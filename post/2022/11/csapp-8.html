<!DOCTYPE html><html lang="zh-CN"><head>
    <meta charset="UTF-8">
<title>CS:APP 第八章学习笔记 - ouuan's blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
CS:APP 第八章 “Exceptional Control Flow” 的学习笔记。
本章的主要内容为 exception、system call、process、signal、longjmp。
">
<meta property="og:url" content="https://ouuan.moe/post/2022/11/csapp-8">
<meta property="og:site_name" content="ouuan's blog">
<meta property="og:title" content="CS:APP 第八章学习笔记 · ouuan's blog">
<meta property="og:description" content="
CS:APP 第八章 “Exceptional Control Flow” 的学习笔记。
本章的主要内容为 exception、system call、process、signal、longjmp。
">
<meta property="twitter:domain" content="ouuan.moe">
<meta property="twitter:title" content="CS:APP 第八章学习笔记 · ouuan's blog">
<meta property="twitter:description" content="
CS:APP 第八章 “Exceptional Control Flow” 的学习笔记。
本章的主要内容为 exception、system call、process、signal、longjmp。
">
<meta property="twitter:url" content="https://ouuan.moe/post/2022/11/csapp-8">
<style>html:not(.dark):not(.light) { visibility: hidden; } body { visibility: hidden; }</style>
<script>(() => { let dark; try { const theme = localStorage && localStorage.getItem('vueuse-color-scheme'); if (theme === 'dark') dark = true; else if (theme === 'light') dark = false; else dark = window.matchMedia('(prefers-color-scheme: dark)').matches; } catch (e) { dark = false; } document.documentElement.classList.add(dark ? 'dark' : 'light'); })()</script>
<noscript><style>@media (prefers-color-scheme: light) { :root:not(.dark):not(.light) { color-scheme: light; --text-color: #232637; --bg-color: #DEE6EE; --card-color: #EFF3F7; --link-color: #1E66B8; --hover-color: #2E80DD; --active-color: #164C89; --bghover-color: #D6E0EA; --popup-color: #F7F9FB; --footer-color: #5F627B; --area-color: #E1E2E8; --nested-color: #F0F0F3; } } @media (prefers-color-scheme: dark) { :root:not(.dark):not(.light) { color-scheme: dark; --text-color: #E6EDF2; --bg-color: #0D0E15; --card-color: #1F2130; --link-color: #8BB8EC; --hover-color: #A2C6F0; --active-color: #74AAE8; --bghover-color: #353853; --popup-color: #2C2F45; --footer-color: #9699AE; --area-color: #2F313D; --nested-color: #3C3E4E; } } html { visibility:visible !important; }</style></noscript>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="canonical" href="https://ouuan.moe/post/2022/11/csapp-8">
<link rel="alternate" type="application/rss+xml" href="/feed.xml" title="RSS Feed - ouuan's blog">
<link rel="alternate" type="application/atom+xml" href="/feed.atom" title="Atom Feed - ouuan's blog">
<link rel="alternate" type="application/json" href="/feed.json" title="JSON Feed - ouuan's blog">
<link rel="dns-prefetch" href="https://plausible.ouuan.moe">
<link rel="preconnect" href="https://blog-visitor-count.ouuan.moe">
<link rel="stylesheet" href="/vendors/katex/katex.css">
<link rel="sitemap" href="https://ouuan.moe/sitemap.xml">
<meta name="author" content="ouuan">
<meta name="twitter:creator" content="@ouuan">
<meta name="twitter:card" content="summary">
<meta property="og:image" content="https://ouuan.moe/images/2022/11/csapp-8.png">
<meta property="generator" content="îles">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-12-17T06:27:26.000Z">
<meta property="article:modified_time" content="2022-12-18T08:09:18.000Z">
<meta property="article:author" content="ouuan">
<meta property="article:tag" content="csapp">
<meta property="article:tag" content="学习笔记">
<link rel="preconnect" href="https://giscus.app">
<link rel="dns-prefetch" href="https://avatars.githubusercontent.com">
    <link rel="stylesheet" href="/assets/style-33d3a633.css">
    
  <link rel="modulepreload" href="/assets/iles.a8cc6c9f.js" crossorigin=""><link rel="modulepreload" href="/assets/vendor-vue.332650a1.js" crossorigin=""><link rel="modulepreload" href="/assets/vite.5ce4fca4.js" crossorigin=""><link rel="modulepreload" href="/assets/SearchBar.4a9cfa9a.js" crossorigin=""><link rel="modulepreload" href="/assets/PostHead.4e2d9266.js" crossorigin=""><link rel="modulepreload" href="/assets/VisitorCount.ccf5cdec.js" crossorigin=""><link rel="modulepreload" href="/assets/site.0440d0dc.js" crossorigin=""><link rel="modulepreload" href="/assets/GiscusCommentsInner.434be06c.js" crossorigin=""><link rel="modulepreload" href="/assets/useTheme.bb94191c.js" crossorigin=""><link rel="modulepreload" href="/assets/TableOfContents.572c62ae.js" crossorigin=""><style>@font-face { font-family: "Noto Serif SC Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Regular.unique.53e7f4b8.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Regular.unique.7f8118af.woff') format('woff'); unicode-range: U+0-ff1f; } @font-face { font-family: "Noto Serif SC Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Regular.common.235c1183.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Regular.common.5026c0c4.woff') format('woff'); unicode-range: U+0-ff1b; } @font-face { font-family: "Noto Serif SC Web Font"; font-weight: 700; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Bold.unique.58170f83.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Bold.unique.4b7e2d35.woff') format('woff'); unicode-range: U+0-952e; } @font-face { font-family: "Noto Serif SC Web Font"; font-weight: 700; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Bold.common.479b05d0.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Bold.common.d38b8f95.woff') format('woff'); unicode-range: U+0-ff0c; }</style><link rel="preload" href="/assets/fonts/NotoSerifSC-Regular.unique.53e7f4b8.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/NotoSerifSC-Regular.common.235c1183.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/NotoSerifSC-Bold.unique.58170f83.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/NotoSerifSC-Bold.common.479b05d0.woff2" as="font" type="font/woff2" crossorigin=""></head>
  <body itemscope="" itemtype="https://schema.org/ItemPage">
    <div id="app"><header class="bg-card shadow print:hidden" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPHeader"><div class="flex flex-wrap justify-center whitespace-nowrap px-4 page-container sm:flex-nowrap"><div class="flex basis-full items-stretch justify-center sm:mr-3 sm:basis-auto"><a class="flex items-center p-3 text-xl font-serif bghover" href="/"><span>ouuan<span class="mojikumi-narrow-left">’</span>s blog</span></a></div><nav class="flex"><ul class="flex"><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/"><span>首页</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/posts"><span>文章</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/tags"><span>标签</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/about"><span>关于</span></a></li></ul></nav><div class="sm:basis-full"></div><ul class="flex"><li class="flex"><ile-root id="ile-1"><div class="flex items-stretch lg:hidden"><a class="flex items-center p-2 bghover" href="/search" title="全站搜索"><span class="i-mdi-magnify text-xl"></span></a></div><form role="search" class="hidden items-stretch justify-center lg:flex"><div class="flex items-center"><input value="" class="w-48 rd-full bg-area px-3 py-1" type="search" placeholder="关键词" aria-label="全站搜索"></div><a class="flex items-center p-2 bghover" href="/search?q=" title="全站搜索"><span class="i-mdi-magnify text-xl"></span></a></form></ile-root><script></script><script type="module" async="">import{h as r,c as a}from"/assets/iles.a8cc6c9f.js";import{_ as m}from"/assets/SearchBar.4a9cfa9a.js";import"/assets/vendor-vue.332650a1.js";import"/assets/vite.5ce4fca4.js";r(a,m,"ile-1",{},{});
</script></li><li class="flex items-stretch"><a class="flex items-center p-2 bghover" href="/feed.xml" title="RSS 订阅"><span class="i-mdi-rss text-xl"></span></a></li><li class="flex"><ile-root id="ile-2"><div class="relative flex items-stretch"><button title="暗色模式设置" class="flex items-center p-2 bghover" aria-haspopup="menu" aria-controls="__theme-switcher" aria-expanded="false"><span class="i-mdi-theme-light-dark text-xl"></span></button><ul style="display:none;" id="__theme-switcher" class="absolute right-0 top-full z-20 whitespace-nowrap rd-1 bg-popup shadow-md" role="menu" aria-label="暗色模式选项"><li class="bghover" role="menuitemradio" aria-checked="true"><button class="flex items-center p-1 text-hover"><span class="i-mdi-cellphone md:i-mdi-tablet lg:i-mdi-monitor mr-1"></span><span>跟随系统</span></button></li><li class="bghover" role="menuitemradio" aria-checked="false"><button class="flex items-center p-1"><span class="i-mdi-white-balance-sunny mr-1"></span><span>总是亮色</span></button></li><li class="bghover" role="menuitemradio" aria-checked="false"><button class="flex items-center p-1"><span class="i-mdi-weather-night mr-1"></span><span>总是暗色</span></button></li></ul></div></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.a8cc6c9f.js";import"/assets/vendor-vue.332650a1.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.a8cc6c9f.js").then(o=>o.v),["assets/iles.a8cc6c9f.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/ThemeSwitcher.8c2c1f90.js"),["assets/ThemeSwitcher.8c2c1f90.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js","assets/useTheme.bb94191c.js"])).default});s(u,v,"ile-2",{},{})});export default E();
</script></li></ul></div></header><main class="min-h-100vh py-6 page-container" itemprop="mainContentOfPage" itemscope="" itemtype="https://schema.org/WebPageElement"><div class="flex justify-center"><div class="grow m-4 standard-card max-w-200"><article itemprop="mainEntity" itemscope="" itemtype="https://schema.org/BlogPosting"><div class="hidden" itemscope="" itemtype="https://schema.org/Person" itemprop="author"><meta itemprop="name" content="ouuan"><meta itemprop="givenName" content="Yufan"><meta itemprop="familyName" content="You"><meta itemprop="url" content="https://github.com/ouuan"><link itemprop="gender" href="https://schema.org/Male"><meta itemprop="image" content="/android-chrome-512x512.png"></div><meta itemprop="mainEntityOfPage" content="https://ouuan.moe/post/2022/11/csapp-8"><meta itemprop="image" content="https://ouuan.moe/images/2022/11/csapp-8.png"><ile-root id="ile-3" class="my-12"><header class="my-12" data-v-e17b8ba7=""><h1 class="mb-3 mt-6 text-center text-8" itemprop="headline" data-v-e17b8ba7=""><span class="inline-block font-serif break-anywhere" data-v-e17b8ba7=""><span data-v-e17b8ba7="" data-v-6544d8e8="">CS:APP 第八章学习笔记</span></span></h1><div class="flex flex-wrap justify-center gap-x-4 gap-y-1 text-footer md:text-sm" data-v-e17b8ba7=""><span class="flex items-center" title="创建于 2022-11-18 10:01:01 GMT+8" data-v-e17b8ba7=""><span class="i-mdi-folder-plus-outline mr-1" data-v-e17b8ba7=""></span><span class="sr-only" data-v-e17b8ba7="">创建于</span><a class="hover:underline" href="https://github.com/ouuan/iles-blog/blob/master/src/pages/post/2022/11/csapp-8.mdx?plain=1" data-v-e17b8ba7=""><time datetime="2022-11-18T10:01:01+08:00" itemprop="dateCreated" data-v-e17b8ba7="">2022-11-18</time></a></span><span class="flex items-center" title="修改于 2022-12-18 16:09:18 GMT+8" data-v-e17b8ba7=""><span class="i-mdi-update mr-1" data-v-e17b8ba7=""></span><span class="sr-only" data-v-e17b8ba7="">修改于</span><a class="hover:underline" href="https://github.com/ouuan/iles-blog/commits/master/src/pages/post/2022/11/csapp-8.mdx" data-v-e17b8ba7=""><time datetime="2022-12-18T16:09:18+08:00" itemprop="dateModified" data-v-e17b8ba7="">2022-12-18</time></a></span><span class="flex items-center" title="访问量" data-v-e17b8ba7=""><span class="i-mdi-eye-outline mr-1" data-v-e17b8ba7=""></span><span class="sr-only" data-v-e17b8ba7="">访问量</span><span data-v-e17b8ba7="">65</span></span><span class="flex flex-wrap justify-center gap-x-2 gap-y-1" data-v-e17b8ba7=""><span title="标签: csapp" class="flex items-center" itemprop="keywords" data-v-e17b8ba7=""><span class="i-mdi-tag-outline mr-1" data-v-e17b8ba7=""></span><span class="sr-only" data-v-e17b8ba7="">标签</span><a href="/tag/csapp" class="hover:underline" data-v-e17b8ba7=""><span data-v-e17b8ba7="" data-v-6544d8e8="">csapp</span></a></span><span title="标签: 学习笔记" class="flex items-center" itemprop="keywords" data-v-e17b8ba7=""><span class="i-mdi-tag-outline mr-1" data-v-e17b8ba7=""></span><span class="sr-only" data-v-e17b8ba7="">标签</span><a href="/tag/学习笔记" class="hover:underline" data-v-e17b8ba7=""><span data-v-e17b8ba7="" data-v-6544d8e8="">学习笔记</span></a></span></span></div></header></ile-root><script></script><script type="module" async="">import{h as e,c as t}from"/assets/iles.a8cc6c9f.js";import{c as a}from"/assets/PostHead.4e2d9266.js";import"/assets/vendor-vue.332650a1.js";import"/assets/vite.5ce4fca4.js";import"/assets/VisitorCount.ccf5cdec.js";import"/assets/site.0440d0dc.js";e(t,a,"ile-3",{class:"my-12",href:"/post/2022/11/csapp-8",filename:"src/pages/post/2022/11/csapp-8.mdx",frontmatter:{title:"CS:APP 第八章学习笔记",date:new Date(1668736861e3),image:"/images/2022/11/csapp-8.png",tags:["csapp","学习笔记"],lastUpdated:new Date(1671350958e3),published:new Date(1671258446e3),visitor:65,description:`
CS:APP 第八章 “Exceptional Control Flow” 的学习笔记。
本章的主要内容为 exception、system call、process、signal、longjmp。
`}},{});
</script><section class="article-style" itemprop="articleBody">
<p><a href="https://csapp.cs.cmu.edu/">CS:APP</a> 第八章 <span class="mojikumi">“</span>Exceptional Control Flow<span class="mojikumi">”</span> 的学习笔记<span class="mojikumi-line-end">。</span></p>
<p>本章的主要内容为 exception<span class="mojikumi-line-end">、</span>system call<span class="mojikumi-line-end">、</span>process<span class="mojikumi-line-end">、</span>signal<span class="mojikumi-line-end">、</span>longjmp<span class="mojikumi-line-end">。</span></p>

<p>在一般情况下<span class="mojikumi-line-end">，</span>PC 会按照指令的顺序以及跳转指令来变化<span class="mojikumi-line-end">。</span>但在很多时候<span class="mojikumi-line-end">，</span>这样的控制流是不能满足需要的<span class="mojikumi-line-end">，</span>需要 <i>exceptional control flow</i> (ECF) 作为跳转指令的补充<span class="mojikumi-line-end">，</span>以处理一些<span class="mojikumi-line-start">“</span>异常<span class="mojikumi-line-end">”</span>的或者来自<span class="mojikumi-line-start">“</span>外部<span class="mojikumi-line-end">”</span>的变化<span class="mojikumi-line-end">。</span></p>
<p>ECF 存在于各个层次<span class="mojikumi-line-end">，</span>例如<span class="mojikumi-line-end">：</span></p>
<ul>
<li>硬件监测到事件发生时调用 exception handler</li>
<li>操作系统在不同进程之间进行 <a href="#context-switch">context switch</a></li>
<li>不同进程间通过发送 <a href="#signals">signal</a> 来调用接收者的 signal handler</li>
<li>程序内部通过 <a href="#nonlocal-jumps">nonlocal jump</a> 来实现错误处理</li>
</ul>
<h2 id="exceptions" class="heading"><a href="#exceptions" class="heading-anchor" aria-label="章节： Exceptions" tabindex="-1"></a><span>Exceptions</span></h2>
<p><i>exception</i> 是由某种<span class="mojikumi-line-start">“</span>状态改变<span class="mojikumi">”</span><wbr><span class="mojikumi-line-start">（</span>可能是某条指令执行的结果<span class="mojikumi-line-end">，</span>或者来自外部 I/O 的变化等等<span class="mojikumi-line-end">）</span>导致的控制流的突变<span class="mojikumi-line-end">。</span></p>
<p>处理器检测到这种状态改变后<span class="mojikumi-line-end">，</span>会调用 <i>exception handler</i><span class="mojikumi-line-end">，</span>然后跳转到触发前的指令或下一条指令<span class="mojikumi-line-end">，</span>或者终止整个程序<span class="mojikumi-line-end">。</span></p>
<h3 id="exception-handling" class="heading"><a href="#exception-handling" class="heading-anchor" aria-label="章节： Exception Handling" tabindex="-1"></a><span>Exception Handling</span></h3>
<p>每种 exception 都会有一个 <i>exception number</i><span class="mojikumi-line-end">，</span>某些 exception 的 number 由硬件决定<span class="mojikumi-line-end">，</span>另一些由操作系统决定<span class="mojikumi-line-end">。</span></p>
<p>内存中会有一个 <i>exception table</i><span class="mojikumi-line-end">，</span>以 exception number 为索引<span class="mojikumi-line-end">，</span>每一项是对应的 exception handler<span class="mojikumi-line-end">。</span>处理器中有一个 <i>exception table base register</i><span class="mojikumi-line-end">，</span>用来存 exception table 的起始地址<span class="mojikumi-line-end">，</span>结合 exception number 就可以对每一项寻址<span class="mojikumi-line-end">。</span></p>
<p>exception 与 procedure call 的主要区别有<span class="mojikumi-line-end">：</span></p>
<ul>
<li>procedure call 返回到栈顶存储的返回地址<span class="mojikumi-line-end">，</span>而 exception 返回到触发时的指令或下一条指令<span class="mojikumi-line-end">，</span>或终止程序<span class="mojikumi-line-end">。</span></li>
<li>调用 exception handler 时<span class="mojikumi-line-end">，</span>会保存包括 condition codes 在内的一些处理器状态<span class="mojikumi-line-end">，</span>在返回时恢复<span class="mojikumi-line-end">。</span></li>
<li>exception handler 在 <a href="#user-kernel-mode">kernel mode</a> 下运行<span class="mojikumi-line-end">，</span>使用的运行栈也是 kernel 的<span class="mojikumi-line-end">。</span></li>
</ul>
<h3 id="classes-of-exceptions" class="heading"><a href="#classes-of-exceptions" class="heading-anchor" aria-label="章节： Classes of Exceptions" tabindex="-1"></a><span>Classes of Exceptions</span></h3>
<p>exception 一般有四种<span class="mojikumi-line-end">：</span></p>
<ul>
<li>interrupt: 异步触发<span class="mojikumi-line-start">（</span>不是某条指令的执行导致了 exception<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>返回到下一条指令<span class="mojikumi-line-end">。</span>一般是由外部 I/O 设备触发<span class="mojikumi-line-start">（</span>设备通过 interrupt pin 告诉处理器有 interrupt<span class="mojikumi-line-end">，</span>通过 system bus 发送 exception number<span class="mojikumi-line-end">，</span>处理器在每执行完一条指令后检查 interrupt pin<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>触发后调用 interrupt handler<span class="mojikumi-line-end">，</span>再回到原来的位置继续执行下一条指令<span class="mojikumi-line-end">。</span></li>
<li>trap: 同步触发<span class="mojikumi-line-end">，</span>返回到下一条指令<span class="mojikumi-line-end">。</span>比如 <a href="#linux-%E4%B8%AD%E7%9A%84-system-call">system call</a> 是一种常见的 trap<span class="mojikumi-line-end">，</span>通过 <code>syscall</code> 指令主动触发 exception<span class="mojikumi-line-end">，</span>看上去和函数调用类似<span class="mojikumi-line-end">，</span>但可以在 kernel mode 下运行<span class="mojikumi-line-end">。</span></li>
<li>fault: 同步触发<span class="mojikumi-line-end">，</span>返回到触发 exception 的指令或退出<span class="mojikumi-line-end">。</span>一般来说<span class="mojikumi-line-end">，</span>fault handler 会尝试解决导致 fault 发生的问题<span class="mojikumi-line-end">，</span>如果成功解决则返回到触发 exception 的指令<span class="mojikumi-line-end">，</span>并且能够不再次触发 exception 而继续执行下去<span class="mojikumi-line-end">；</span>如果没能成功解决<span class="mojikumi-line-end">，</span>则 abort<span class="mojikumi-line-end">。</span></li>
<li>abort: 同步触发<span class="mojikumi-line-end">，</span>一定退出<span class="mojikumi-line-end">。</span>一般代表严重的不可恢复的错误<span class="mojikumi-line-end">。</span></li>
</ul>
<h3 id="exceptions-in-linuxx86-64-systems" class="heading"><a href="#exceptions-in-linuxx86-64-systems" class="heading-anchor" aria-label="章节： Exceptions in Linux/x86-64 Systems" tabindex="-1"></a><span>Exceptions in Linux/x86-64 Systems</span></h3>
<h4 id="x86-64-中的-fault-abort" class="heading"><a href="#x86-64-中的-fault-abort" class="heading-anchor" aria-label="章节： x86-64 中的 fault / abort" tabindex="-1"></a><span>x86-64 中的 fault / abort</span></h4>
<ul>
<li>Divide Error Exception (Interrupt 0): 除以零<span class="mojikumi-line-end">。</span>它是 fault<span class="mojikumi-line-end">，</span>但实际上 Linux 不会尝试从 divide error 中恢复<span class="mojikumi-line-end">，</span>而是会直接 abort<span class="mojikumi-line-end">，</span>一般会显示为 <span class="mojikumi">“</span>floating point exception<span class="mojikumi">”</span><span class="mojikumi-line-end">。</span></li>
<li>General Protection Exception (Interrupt 13): 有多种触发原因<span class="mojikumi-line-end">，</span>例如访问未定义的内存<span class="mojikumi-line-end">，</span>尝试写入只读的内存段<span class="mojikumi-line-end">。</span>Linux 也不会尝试从中恢复<span class="mojikumi-line-end">，</span>而是会直接 abort<span class="mojikumi-line-end">，</span>一般会显示为 <span class="mojikumi">“</span>segmentation fault<span class="mojikumi">”</span><span class="mojikumi-line-end">。</span></li>
<li>Page-Fault Exception (Interrupt 14): page fault 是一个名副其实的 fault<span class="mojikumi-line-end">，</span>会尝试恢复<span class="mojikumi-line-end">，</span>详见<a href="/post/2022/11/csapp-9">第九章</a><span class="mojikumi-line-end">。</span></li>
<li>Machine-Check Exception (Interrupt 18): 严重的硬件错误<span class="mojikumi-line-end">，</span>是 abort<span class="mojikumi-line-end">。</span></li>
</ul>
<p><span class="mojikumi-line-start">（</span>完整列表参见 <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel® 64 and IA-32 Architectures Software Developer Manuals</a> Volume 3A 的 <span class="mojikumi">“</span>6.15 EXCEPTION AND INTERRUPT REFERENCE<span class="mojikumi">”</span> 一节<span class="mojikumi">。</span><span class="mojikumi-line-end">）</span></p>
<h4 id="linux-中的-system-call" class="heading"><a href="#linux-中的-system-call" class="heading-anchor" aria-label="章节： Linux 中的 system call" tabindex="-1"></a><span>Linux 中的 system call</span></h4>
<p>Linux 中常用的一些 system call 如 CS:APP Figure 8.10 所示<span class="mojikumi-line-end">：</span></p>
<p><picture><source type="image/webp" srcset="/assets/csapp-fig8.10.f8581cd0.webp"><img srcset="/assets/csapp-fig8.10.9e132224.png" loading="lazy" src="/assets/csapp-fig8.10.9e132224.png" width="1094" height="320" alt="Linux 中常用的一些 system call"></picture></p>
<p><span class="mojikumi-line-start">（</span>更多 system call 参见 <code>man syscalls</code><span class="mojikumi-line-end">）</span></p>
<p>在 C 语言中<span class="mojikumi-line-end">，</span>可以使用 <code>syscall</code> 函数来调用 system call<span class="mojikumi-line-end">，</span>但一般不这样做<span class="mojikumi-line-end">，</span>而是使用每个 system call 对应的 wrapper function<span class="mojikumi-line-end">。</span><code>syscall</code> 和 wrapper function 统称为 <i>system-level function</i><span class="mojikumi-line-end">。</span></p>
<h2 id="processes" class="heading"><a href="#processes" class="heading-anchor" aria-label="章节： Processes" tabindex="-1"></a><span>Processes</span></h2>
<p>一个系统中会有很多进程同时运行<span class="mojikumi-line-end">，</span>但营造出了每个进程都独占了处理器和内存的假象<span class="mojikumi-line-end">。</span></p>
<p>进程独占内存的假象是通过每个进程的 private address space 实现的<span class="mojikumi-line-end">，</span>详见<a href="/post/2022/11/csapp-9">第九章</a><span class="mojikumi-line-end">。</span></p>
<h3 id="logical-concurrent-flow" class="heading"><a href="#logical-concurrent-flow" class="heading-anchor" aria-label="章节： Logical / Concurrent Flow" tabindex="-1"></a><span>Logical / Concurrent Flow</span></h3>
<p>根据一个程序的指令得到的 control flow 称作 <i>logical (control) flow</i><span class="mojikumi-line-end">。</span>系统会在不同的进程间来回切换<span class="mojikumi-line-end">，</span>从一个进程切换出去称作将这个进程 <i>preempt</i><span class="mojikumi-line-end">。</span></p>
<p>如果两个 control flow 的存活时间有重叠<span class="mojikumi-line-end">，</span>则称它们是 <i>concurrent flow</i> 或它们 <i>run concurrently</i><span class="mojikumi-line-end">。</span>这种现象被称作 <i>concurrency</i><span class="mojikumi-line-end">，</span>也被称作 <i>multitasking</i><span class="mojikumi-line-end">。</span>每次连续执行的同一个 logical flow 中的一段称作一个 <i>time slice</i><span class="mojikumi-line-end">，</span>所以 multitasking 也被称作 <i>time slicing</i><span class="mojikumi-line-end">。</span>如果两个 logical flow 在不同的 processor core 上运行<span class="mojikumi-line-end">，</span>则称它们是 <i>parallel flow</i><span class="mojikumi-line-end">，</span><i>run in parallel</i><span class="mojikumi-line-end">。</span></p>
<h3 id="user-kernel-mode" class="heading"><a href="#user-kernel-mode" class="heading-anchor" aria-label="章节： User / Kernel Mode" tabindex="-1"></a><span>User / Kernel Mode</span></h3>
<p>在处理器中存有一个 <i>mode bit</i><span class="mojikumi-line-end">，</span>表示当前是 user mode 还是 kernel mode<span class="mojikumi-line-end">。</span>只有在 kernel mode 下才能执行某些 <i>privileged instruction</i><span class="mojikumi-line-end">、</span>修改 mode bit<span class="mojikumi-line-end">、</span>访问地址空间中属于 kernel 的区域<span class="mojikumi-line-end">。</span></p>
<p>user mode 的程序只能通过 exception 来进入 kernel mode<span class="mojikumi-line-end">，</span>以执行 privileged instruction 或者访问 kernel 的数据<span class="mojikumi-line-end">。</span>在 Linux 中<span class="mojikumi-line-end">，</span>也可以在 user mode 下访问 <code>/proc</code><span class="mojikumi-line-end">、</span><code>/sys</code> 来获得一些 kernel 的数据<span class="mojikumi-line-end">。</span></p>
<h3 id="context-switch" class="heading"><a href="#context-switch" class="heading-anchor" aria-label="章节： Context Switch" tabindex="-1"></a><span>Context Switch</span></h3>
<p>每个进程都有一个 <i>context</i><span class="mojikumi-line-end">，</span>包括寄存器内容<span class="mojikumi-line-end">、</span>PC<span class="mojikumi-line-end">、</span>user stack<span class="mojikumi-line-end">、</span>kernel stack<span class="mojikumi-line-end">、</span>condition codes<span class="mojikumi-line-end">、</span>page table<span class="mojikumi-line-end">、</span>process table<span class="mojikumi-line-end">、</span>file table 等等<span class="mojikumi-line-end">。</span></p>
<p>操作系统通过 <i>context switch</i> 来在不同进程间切换<span class="mojikumi-line-end">，</span>即保存当前进程的 context<span class="mojikumi-line-end">，</span>恢复要切换到的进程的 context<span class="mojikumi-line-end">，</span>最后切换过去<span class="mojikumi-line-end">。</span>context switch 在 exception 中发生<span class="mojikumi-line-end">，</span>处理 exception 时操作系统中的 <i>scheduler</i> 会决定是否进行 context switch<span class="mojikumi-line-end">，</span>schedule 到哪个进程<span class="mojikumi-line-end">。</span>例如<span class="mojikumi-line-end">：</span></p>
<ul>
<li>在通过 system call 读取文件时进行 context switch<span class="mojikumi-line-end">，</span>以在等待读取文件时先执行其他进程<span class="mojikumi-line-end">；</span>读取到文件后在 interrupt 中再 context switch 回来<span class="mojikumi-line-end">。</span></li>
<li>系统会周期性地<span class="mojikumi-line-start">（</span>例如每 1ms<span class="mojikumi-line-end">）</span>触发 interrupt<span class="mojikumi-line-end">，</span>从而可以在一个进程执行了一段时间后进行 context switch<span class="mojikumi-line-end">。</span></li>
</ul>
<p>因为程序不知道操作系统会如何 schedule<span class="mojikumi-line-end">，</span>一般来说<span class="mojikumi-line-end">，</span>不同进程的执行顺序是没有保证的<span class="mojikumi-line-end">。</span></p>
<h2 id="system-call-error-handling" class="heading"><a href="#system-call-error-handling" class="heading-anchor" aria-label="章节： System Call Error Handling" tabindex="-1"></a><span>System Call Error Handling</span></h2>
<p>system-level function 一般以返回 -1 代表出错<span class="mojikumi-line-end">，</span>而将具体的错误记录在全局整型变量 <code>errno</code> (<code>#include &lt;errno.h&gt;</code>)<span class="mojikumi-line-end">，</span>函数 <code>strerror</code> 可以用来根据 <code>errno</code> 得到文字错误信息<span class="mojikumi-line-end">。</span></p>
<p>调用 system-level function 时应当检查错误<span class="mojikumi-line-end">。</span>为了使错误处理更加简便<span class="mojikumi-line-end">，</span>可以使用类似下面的 wrapper function<span class="mojikumi-line-end">：</span></p>
<section class="code-block relative my-6 shadow" itemprop="hasPart" itemscope="" itemtype="https://schema.org/SoftwareSourceCode" data-v-ad49d235=""><div class="h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex" style="display:none;" data-v-ad49d235=""><h3 class="text-3 text-footer" itemprop="programmingLanguage" aria-label="C 代码块" data-v-ad49d235="">C</h3><ile-root id="ile-4"><button title="复制到剪贴板" class="copy-button b-footer text-footer" data-v-9288569d=""><span class="i-mdi-content-copy" data-v-9288569d=""></span><span class="sr-only" role="status" data-v-9288569d=""></span></button></ile-root><script></script><script type="module" async="">var s=(i,a)=>()=>(a||i((a={exports:{}}).exports,a),a.exports);var r=(i,a,o)=>new Promise((c,n)=>{var f=t=>{try{_(o.next(t))}catch(e){n(e)}},l=t=>{try{_(o.throw(t))}catch(e){n(e)}},_=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);_((o=o.apply(i,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{b as p}from"/assets/iles.a8cc6c9f.js";import"/assets/vendor-vue.332650a1.js";var E=s(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.a8cc6c9f.js").then(i=>i.v),["assets/iles.a8cc6c9f.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/CopyButton.c03e0a7e.js"),["assets/CopyButton.c03e0a7e.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default});p(u,v,"ile-4",{},{})});export default E();
</script></div><div class="light:hidden" itemprop="text" data-v-ad49d235=""><pre class="shiki dark" style="background-color: #011627" tabindex="0"><code><span><span style="color: #C792EA">#include</span><span style="color: #D6DEEB"> </span><span style="color: #D9F5DD">&lt;</span><span style="color: #ECC48D">errno.h</span><span style="color: #D9F5DD">&gt;</span></span>
<span><span style="color: #C792EA">#include</span><span style="color: #D6DEEB"> </span><span style="color: #D9F5DD">&lt;</span><span style="color: #ECC48D">stdio.h</span><span style="color: #D9F5DD">&gt;</span></span>
<span><span style="color: #C792EA">#include</span><span style="color: #D6DEEB"> </span><span style="color: #D9F5DD">&lt;</span><span style="color: #ECC48D">stdlib.h</span><span style="color: #D9F5DD">&gt;</span></span>
<span><span style="color: #C792EA">#include</span><span style="color: #D6DEEB"> </span><span style="color: #D9F5DD">&lt;</span><span style="color: #ECC48D">string.h</span><span style="color: #D9F5DD">&gt;</span></span>
<span><span style="color: #C792EA">#include</span><span style="color: #D6DEEB"> </span><span style="color: #D9F5DD">&lt;</span><span style="color: #ECC48D">unistd.h</span><span style="color: #D9F5DD">&gt;</span></span>
<span></span>
<span><span style="color: #C792EA">void</span><span style="color: #D6DEEB"> </span><span style="color: #82AAFF">unix_error</span><span style="color: #D6DEEB">(</span><span style="color: #C792EA">char</span><span style="color: #D6DEEB"> </span><span style="color: #7FDBCA">*</span><span style="color: #D7DBE0">msg</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">{</span></span>
<span><span style="color: #D6DEEB">    </span><span style="color: #82AAFF">fprintf(stderr, </span><span style="color: #D9F5DD">"</span><span style="color: #82AAFF">%s</span><span style="color: #ECC48D">: </span><span style="color: #82AAFF">%s</span><span style="color: #F78C6C">\n</span><span style="color: #D9F5DD">"</span><span style="color: #82AAFF">, msg, strerror(errno))</span><span style="color: #D6DEEB">;</span></span>
<span><span style="color: #D6DEEB">    </span><span style="color: #82AAFF">exit(errno)</span><span style="color: #D6DEEB">;</span></span>
<span><span style="color: #D6DEEB">}</span></span>
<span></span>
<span><span style="color: #C792EA">pid_t</span><span style="color: #D6DEEB"> </span><span style="color: #82AAFF">Fork</span><span style="color: #D6DEEB">(</span><span style="color: #C792EA">void</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">{</span></span>
<span><span style="color: #D6DEEB">    </span><span style="color: #C792EA">pid_t</span><span style="color: #D6DEEB"> pid </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #82AAFF">fork()</span><span style="color: #D6DEEB">;</span></span>
<span></span>
<span><span style="color: #D6DEEB">    </span><span style="color: #C792EA">if</span><span style="color: #D6DEEB"> (pid </span><span style="color: #C792EA">&lt;</span><span style="color: #D6DEEB"> </span><span style="color: #F78C6C">0</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">        </span><span style="color: #82AAFF">unix_error(</span><span style="color: #D9F5DD">"</span><span style="color: #ECC48D">Fork error</span><span style="color: #D9F5DD">"</span><span style="color: #82AAFF">)</span><span style="color: #D6DEEB">;</span></span>
<span></span>
<span><span style="color: #D6DEEB">    </span><span style="color: #C792EA">return</span><span style="color: #D6DEEB"> pid;</span></span>
<span><span style="color: #D6DEEB">}</span></span></code></pre></div><div class="light:important-block" style="display:none;" data-v-ad49d235=""><pre class="shiki light" style="background-color: #FBFBFB" tabindex="0"><code><span><span style="color: #994CC3">#include</span><span style="color: #403F53"> </span><span style="color: #111111">&lt;</span><span style="color: #C96765">errno.h</span><span style="color: #111111">&gt;</span></span>
<span><span style="color: #994CC3">#include</span><span style="color: #403F53"> </span><span style="color: #111111">&lt;</span><span style="color: #C96765">stdio.h</span><span style="color: #111111">&gt;</span></span>
<span><span style="color: #994CC3">#include</span><span style="color: #403F53"> </span><span style="color: #111111">&lt;</span><span style="color: #C96765">stdlib.h</span><span style="color: #111111">&gt;</span></span>
<span><span style="color: #994CC3">#include</span><span style="color: #403F53"> </span><span style="color: #111111">&lt;</span><span style="color: #C96765">string.h</span><span style="color: #111111">&gt;</span></span>
<span><span style="color: #994CC3">#include</span><span style="color: #403F53"> </span><span style="color: #111111">&lt;</span><span style="color: #C96765">unistd.h</span><span style="color: #111111">&gt;</span></span>
<span></span>
<span><span style="color: #994CC3">void</span><span style="color: #403F53"> </span><span style="color: #4876D6">unix_error</span><span style="color: #403F53">(</span><span style="color: #994CC3">char</span><span style="color: #403F53"> </span><span style="color: #0C969B">*</span><span style="color: #403F53">msg)</span></span>
<span><span style="color: #403F53">{</span></span>
<span><span style="color: #403F53">    </span><span style="color: #4876D6">fprintf(stderr, </span><span style="color: #111111">"</span><span style="color: #4876D6">%s</span><span style="color: #C96765">: </span><span style="color: #4876D6">%s</span><span style="color: #AA0982">\n</span><span style="color: #111111">"</span><span style="color: #4876D6">, msg, strerror(errno))</span><span style="color: #403F53">;</span></span>
<span><span style="color: #403F53">    </span><span style="color: #4876D6">exit(errno)</span><span style="color: #403F53">;</span></span>
<span><span style="color: #403F53">}</span></span>
<span></span>
<span><span style="color: #994CC3">pid_t</span><span style="color: #403F53"> </span><span style="color: #4876D6">Fork</span><span style="color: #403F53">(</span><span style="color: #994CC3">void</span><span style="color: #403F53">)</span></span>
<span><span style="color: #403F53">{</span></span>
<span><span style="color: #403F53">    </span><span style="color: #994CC3">pid_t</span><span style="color: #403F53"> pid </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #4876D6">fork()</span><span style="color: #403F53">;</span></span>
<span></span>
<span><span style="color: #403F53">    </span><span style="color: #994CC3">if</span><span style="color: #403F53"> (pid </span><span style="color: #994CC3">&lt;</span><span style="color: #403F53"> </span><span style="color: #AA0982">0</span><span style="color: #403F53">)</span></span>
<span><span style="color: #403F53">        </span><span style="color: #4876D6">unix_error(</span><span style="color: #111111">"</span><span style="color: #C96765">Fork error</span><span style="color: #111111">"</span><span style="color: #4876D6">)</span><span style="color: #403F53">;</span></span>
<span></span>
<span><span style="color: #403F53">    </span><span style="color: #994CC3">return</span><span style="color: #403F53"> pid;</span></span>
<span><span style="color: #403F53">}</span></span></code></pre></div></section>
<h2 id="process-control" class="heading"><a href="#process-control" class="heading-anchor" aria-label="章节： Process Control" tabindex="-1"></a><span>Process Control</span></h2>
<p>C 语言中有很多用来控制 Unix 进程的函数<span class="mojikumi-line-end">。</span></p>
<h3 id="获取-pid" class="heading"><a href="#获取-pid" class="heading-anchor" aria-label="章节： 获取 PID" tabindex="-1"></a><span>获取 PID</span></h3>
<p>每个进程都有一个 PID<span class="mojikumi-line-end">。</span></p>
<ul>
<li><code>pid_t<wbr> <wbr>getpid<wbr>(<wbr>void<wbr>)</code>: 返回当前进程的 PID</li>
<li><code>pid_t<wbr> <wbr>getppid<wbr>(<wbr>void<wbr>)</code>: 返回当前进程的 parent 的 PID</li>
</ul>
<h3 id="进程的状态" class="heading"><a href="#进程的状态" class="heading-anchor" aria-label="章节： 进程的状态" tabindex="-1"></a><span>进程的状态</span></h3>
<p>每个进程可能处于三种状态之一<span class="mojikumi-line-end">：</span></p>
<ol>
<li>Running: 正在运行中<span class="mojikumi-line-end">，</span>会被 schedule<span class="mojikumi-line-end">。</span></li>
<li>Stopped: 被 suspend 了<span class="mojikumi-line-end">，</span>不会被 schedule<span class="mojikumi-line-end">。</span>Stopped 可能是 SIGSTOP<span class="mojikumi-line-end">、</span>SIGTSTP<span class="mojikumi-line-end">、</span>SIGTTIN<span class="mojikumi-line-end">、</span>SIGTTOU 导致的<span class="mojikumi-line-end">，</span>可以由 SIGCONT 恢复运行<span class="mojikumi-line-end">。</span></li>
<li>Terminated: 进程永久地结束了<span class="mojikumi-line-end">，</span>可能是从 <code>main</code> 函数返回<span class="mojikumi-line-end">、</span>调用了 <code>exit</code> 函数或者收到了某些 signal<span class="mojikumi-line-end">。</span></li>
</ol>
<ul>
<li><code>void exit(int status)</code>: 以某个 exit status 将当前进程 terminate</li>
</ul>
<h3 id="fork" class="heading"><a href="#fork" class="heading-anchor" aria-label="章节： fork" tabindex="-1"></a><span>fork</span></h3>
<ul>
<li><code>pid_t fork(void)</code>: 创建子进程</li>
</ul>
<p>fork 会将当前进程的所有状态复制一份创建一个新的进程<span class="mojikumi-line-end">，</span>新的进程有着和原来相同的代码<span class="mojikumi-line-end">、</span>数据<span class="mojikumi-line-end">、</span>文件<span class="mojikumi-line-start">（</span>例如 <code>stdout</code><span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>但 PID 不同<span class="mojikumi-line-end">，</span>并且后续对数据的修改是和原进程独立的<span class="mojikumi-line-end">。</span></p>
<p>fork 会调用一次<span class="mojikumi-line-end">，</span>返回两次<span class="mojikumi-line-end">，</span>分别在两个进程中返回<span class="mojikumi-line-end">，</span>在 parent 中返回 child 的 PID<span class="mojikumi-line-end">，</span>在 child 中返回 0<span class="mojikumi-line-end">，</span>出错则返回 -1<span class="mojikumi-line-end">。</span></p>
<p>fork 出的进程和原进程在接下来会执行同一份代码<span class="mojikumi-line-end">，</span>所以一般会判断 <code>fork</code> 的返回值是否为 0 来让两个进程执行不同的分支<span class="mojikumi-line-end">。</span></p>
<h3 id="process-group" class="heading"><a href="#process-group" class="heading-anchor" aria-label="章节： process group" tabindex="-1"></a><span>process group</span></h3>
<p>每个进程会属于一个 process group<span class="mojikumi-line-end">，</span>每个 process group 有一个 ID<span class="mojikumi-line-end">。</span></p>
<p>创建子进程时<span class="mojikumi-line-end">，</span>子进程会默认处于 parent 的 process group<span class="mojikumi-line-end">。</span></p>
<ul>
<li><code>pid_t<wbr> <wbr>getpgrp<wbr>(<wbr>void<wbr>)</code>: 返回当前进程的 process group ID</li>
<li><code>int<wbr> <wbr>setpgid<wbr>(<wbr>pid_t<wbr> <wbr>pid<wbr>, <wbr>pid_t<wbr> <wbr>pgid<wbr>)</code>: 将 <code>pid</code> 对应的进程的 progress group ID 修改为 <code>pgid</code><span class="mojikumi-line-end">，</span><code>pid</code> 为 0 表示当前进程<span class="mojikumi-line-end">，</span><code>pgid</code> 为 0 表示修改为 <code>pid</code> 对应的进程的 PID</li>
</ul>
<h3 id="wait" class="heading"><a href="#wait" class="heading-anchor" aria-label="章节： wait" tabindex="-1"></a><span>wait</span></h3>
<ul>
<li><code>pid_t<wbr> <wbr>waitpid<wbr>(<wbr>pid_t<wbr> <wbr>pid<wbr>, <wbr>int<wbr> *<wbr>statusp<wbr>, <wbr>int<wbr> <wbr>options<wbr>)</code>: 等待子进程结束</li>
<li><code>pid_t wait(int *statusp)</code>: <code>waitpid<wbr>(-<wbr>1<wbr>, <wbr>statusp<wbr>, <wbr>0<wbr>)</code></li>
</ul>
<h4 id="waitpid-的-pid-参数" class="heading"><a href="#waitpid-的-pid-参数" class="heading-anchor" aria-label="章节： waitpid 的 pid 参数" tabindex="-1"></a><span>waitpid 的 pid 参数</span></h4>
<p>参数 <code>pid</code> 决定了要等待的是哪些子进程<span class="mojikumi-line-end">：</span></p>
<ul>
<li>-1: 所有子进程</li>
<li>&gt; 0: PID 为 <code>pid</code> 的子进程</li>
<li>0: process group 与当前进程相同的子进程</li>
<li>&lt; -1: process group ID 为 <code>-pid</code> 的子进程</li>
</ul>
<h4 id="waitpid-的行为-options" class="heading"><a href="#waitpid-的行为-options" class="heading-anchor" aria-label="章节： waitpid 的行为 (options)" tabindex="-1"></a><span>waitpid 的行为 (options)</span></h4>
<p>默认情况下<span class="mojikumi-line-end">，</span><code>waitpid</code> 会等待到有某个被等待的子进程 terminate 再返回<span class="mojikumi-line-end">，</span><code>options</code> 可以改变这一行为<span class="mojikumi-line-end">，</span>其值可以包含下列 flag<span class="mojikumi-line-end">：</span></p>
<ul>
<li><code>WNOHANG</code>: 立即返回<span class="mojikumi-line-end">，</span>如果没有符合条件的子进程则返回 0</li>
<li><code>WUNTRACED</code>: 除了 terminate<span class="mojikumi-line-end">，</span>子进程 stop 也可以结束等待</li>
<li><code>WCONTINUED</code>: 除了 terminate<span class="mojikumi-line-end">，</span>子进程从 stopped 中 continue 也可以结束等待</li>
</ul>
<h4 id="reap" class="heading"><a href="#reap" class="heading-anchor" aria-label="章节： reap" tabindex="-1"></a><span>reap</span></h4>
<p>除了等待<span class="mojikumi-line-end">，</span>wait 还会将 terminated 的子进程 <i>reap</i><span class="mojikumi-line-end">，</span>即彻底清除掉<span class="mojikumi-line-end">。</span>没有被 reap 但 terminated 的进程被称作 <i>zombie</i><span class="mojikumi-line-end">，</span>会占用一定的系统资源<span class="mojikumi-line-end">。</span>在 <code>ps</code> 中<span class="mojikumi-line-end">，</span>zombie 显示为 <code>[defunct]</code><span class="mojikumi-line-end">。</span></p>
<p>如果 parent terminate 了<span class="mojikumi-line-end">，</span>没有 terminate 的子进程会被设置为 PID 为 1 的 <code>init</code> 进程的子进程<span class="mojikumi-line-end">，</span>而 zombie 子进程则会被 <code>init</code> reap<span class="mojikumi-line-end">。</span></p>
<h4 id="wait-获取子进程的-status" class="heading"><a href="#wait-获取子进程的-status" class="heading-anchor" aria-label="章节： wait 获取子进程的 status" tabindex="-1"></a><span>wait 获取子进程的 status</span></h4>
<p>如果 <code>statusp</code> 参数不是 <code>NULL</code><span class="mojikumi-line-end">，</span>在 <code>waitpid</code> 返回时 <code>*statusp</code> 内就会存有引起等待结束的那个子进程的信息<span class="mojikumi-line-end">。</span></p>
<p>有一系列 macro 可以用来提取 status 中的信息<span class="mojikumi-line-start">（</span>参数是 <code>*statusp</code><span class="mojikumi-line-end">，</span>不是指针<span class="mojikumi">）</span><span class="mojikumi-line-end">：</span></p>
<ul>
<li><code>WIFEXITED<wbr>(<wbr>status<wbr>)</code>: 是否正常退出 (从 <code>main</code> 函数返回或调用了 <code>exit</code> 函数)</li>
<li><code>WEXITSTATUS<wbr>(<wbr>status<wbr>)</code>: 如果正常退出<span class="mojikumi-line-end">，</span>则返回 exit status (<code>main</code> 函数返回值 / <code>exit</code> 函数参数)</li>
<li><code>WIFSIGNALED<wbr>(<wbr>status<wbr>)</code>: 是否由某个 signal terminate</li>
<li><code>WTERMSIG<wbr>(<wbr>status<wbr>)</code>: 如果是由某个 signal terminate<span class="mojikumi-line-end">，</span>返回这个 signal</li>
<li><code>WIFSTOPPED<wbr>(<wbr>status<wbr>)</code>: 是否被 stop</li>
<li><code>WSTOPSIG<wbr>(<wbr>status<wbr>)</code>: 如果被 stop<span class="mojikumi-line-end">，</span>返回使其 stop 的 signal</li>
<li><code>WIFCONTINUED<wbr>(<wbr>status<wbr>)</code>: 是否被 continue</li>
</ul>
<h4 id="wait-的报错" class="heading"><a href="#wait-的报错" class="heading-anchor" aria-label="章节： wait 的报错" tabindex="-1"></a><span>wait 的报错</span></h4>
<p>出错时 wait 会返回 -1<span class="mojikumi-line-end">，</span><code>errno</code> 可能是 <code>ECHILD</code> 表示被等待的子进程集合为空<span class="mojikumi-line-end">，</span>可能是 <code>EINTR</code> 表示 wait 函数被某个 signal 中断了<span class="mojikumi-line-end">。</span></p>
<p>wait 会在每有一个子进程结束时返回<span class="mojikumi-line-end">，</span>但子进程全部结束时会报错 <code>ECHILD</code><span class="mojikumi-line-end">，</span>可以利用这一点通过 <code>while</code> 循环来等待所有子进程全部结束<span class="mojikumi-line-end">。</span></p>
<h3 id="sleep" class="heading"><a href="#sleep" class="heading-anchor" aria-label="章节： sleep" tabindex="-1"></a><span>sleep</span></h3>
<ul>
<li><code>unsigned<wbr> <wbr>int<wbr> <wbr>sleep<wbr>(<wbr>unsigned<wbr> <wbr>int<wbr> <wbr>secs<wbr>)</code>: sleep 若干秒<span class="mojikumi-line-end">，</span>返回剩余应当 sleep 的秒数<span class="mojikumi-line-start">（</span>正常情况下没被 interrupt 就是 0<span class="mojikumi-line-end">）</span></li>
<li><code>int<wbr> <wbr>pause<wbr>(<wbr>void<wbr>)</code>: 一直 sleep<span class="mojikumi-line-end">，</span>直到被 signal interrupt<span class="mojikumi-line-end">，</span>总是返回 -1</li>
</ul>
<h3 id="execve" class="heading"><a href="#execve" class="heading-anchor" aria-label="章节： execve" tabindex="-1"></a><span>execve</span></h3>
<ul>
<li><code>int<wbr> <wbr>execve<wbr>(<wbr>const<wbr> <wbr>char<wbr> *<wbr>filename<wbr>, <wbr>char<wbr> *<wbr>const<wbr> <wbr>argv<wbr>[], <wbr>char<wbr> *<wbr>const<wbr> <wbr>envp<wbr>[])</code></li>
</ul>
<p><code>execve</code> 会以 <code>argv</code> 作为参数<span class="mojikumi-line-end">、</span><code>envp</code> 作为环境变量<span class="mojikumi-line-end">，</span>在当前进程内执行 executable object file <code>filename</code><span class="mojikumi-line-end">。</span>可以和 <code>fork</code> 配合来在子进程内执行其他程序<span class="mojikumi-line-end">。</span></p>
<p><code>argv</code> 是一个以 <code>NULL</code> 为结尾的字符串数组<span class="mojikumi-line-end">，</span>表示各个参数<span class="mojikumi-line-end">，</span>其中第一个一般是程序的名称<span class="mojikumi-line-end">。</span></p>
<p><code>envp</code> 也是以 <code>NULL</code> 为结尾的字符串数组<span class="mojikumi-line-end">，</span>每个字符串形如 <code>name=value</code><span class="mojikumi-line-end">。</span></p>
<p>有一些函数可以用来获取<span class="mojikumi-line-end">、</span>设置环境变量<span class="mojikumi-line-end">：</span></p>
<ul>
<li><code>char<wbr> *<wbr>getenv<wbr>(<wbr>const<wbr> <wbr>char<wbr> *<wbr>name<wbr>)</code>: 返回 <code>NULL</code> 或环境变量的值</li>
<li><code>int<wbr> <wbr>setenv<wbr>(<wbr>const<wbr> <wbr>char<wbr> *<wbr>name<wbr>, <wbr>const<wbr> <wbr>char<wbr> *<wbr>newvalue<wbr>, <wbr>int<wbr> <wbr>overwrite<wbr>)</code>: 成功则返回 0<span class="mojikumi-line-end">，</span>失败<span class="mojikumi-line-start">（</span><code>overwrite</code> 为 0 而 <code>name</code> 已存在<span class="mojikumi-line-end">）</span>则返回 -1</li>
<li><code>void<wbr> <wbr>unsetenv<wbr>(<wbr>const<wbr> <wbr>char<wbr> *<wbr>name<wbr>)</code></li>
</ul>
<h2 id="signals" class="heading"><a href="#signals" class="heading-anchor" aria-label="章节： Signals" tabindex="-1"></a><span>Signals</span></h2>
<h3 id="signal-的种类" class="heading"><a href="#signal-的种类" class="heading-anchor" aria-label="章节： signal 的种类" tabindex="-1"></a><span>signal 的种类</span></h3>
<p>可以用 <code>man signal.7</code> 查看 signal 的列表<span class="mojikumi-line-start">（</span>名称<span class="mojikumi-line-end">、</span>语义<span class="mojikumi-line-end">、</span>编号<span class="mojikumi-line-end">、</span>默认行为<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<p>特别地<span class="mojikumi-line-end">：</span></p>
<ul>
<li>除以零时会被发送 SIGFPE</li>
<li>执行非法指令时会被发送 SIGILL</li>
<li>非法访问内存时会被发送 SIGSEGV</li>
<li>按 Ctrl+C 时 foreground process group 会被发送 SIGINT</li>
<li>子进程 terminate 时会向 parent 发送 SIGCHLD</li>
<li>可以通过 SIGKILL 来强行 terminate 一个进程</li>
</ul>
<h3 id="signal-的工作流程" class="heading"><a href="#signal-的工作流程" class="heading-anchor" aria-label="章节： signal 的工作流程" tabindex="-1"></a><span>signal 的工作流程</span></h3>
<ul>
<li>每个进程会记录每个 signal 是否 <i>pending</i><span class="mojikumi-line-end">、</span>是否 <i>blocked</i></li>
<li>发送 signal 会使接收者的这个 signal 变为 pending</li>
<li>进程可以改变每个 signal 的 blocked 状态</li>
<li>在切换到 user mode 执行进程时<span class="mojikumi-line-end">，</span>如果一个 signal 处于 pending 状态且没有被 blocked<span class="mojikumi-line-end">，</span>就会接收这个 signal<span class="mojikumi-line-end">，</span>并设为没有在 pending</li>
</ul>
<p>这意味着<span class="mojikumi-line-end">：</span></p>
<ul>
<li>signal 只记录是否 pending<span class="mojikumi-line-end">，</span>不会记录发送了几次<span class="mojikumi-line-end">，</span>在被接收前多次发送只会被接收一次</li>
<li>在 blocked 状态下被发送 signal<span class="mojikumi-line-end">，</span>会在 unblock 时收到</li>
</ul>
<h3 id="发送-signal" class="heading"><a href="#发送-signal" class="heading-anchor" aria-label="章节： 发送 signal" tabindex="-1"></a><span>发送 signal</span></h3>
<h4 id="kill-命令" class="heading"><a href="#kill-命令" class="heading-anchor" aria-label="章节： kill 命令" tabindex="-1"></a><span>kill 命令</span></h4>
<p>可以用 <code>kill</code> 命令在 shell 中向指定的进程发送信号<span class="mojikumi-line-end">。</span>一般 shell 会有 builtin 的 <code>kill</code><span class="mojikumi-line-end">，</span>也有位于 <code>/<wbr>usr<wbr>/<wbr>bin<wbr>/<wbr>kill</code> 的 <code>kill</code><span class="mojikumi-line-end">，</span>可能有一定的区别<span class="mojikumi-line-end">。</span></p>
<p>基础的 <code>kill</code> 命令形如 <code>kill -sig pid</code><span class="mojikumi-line-end">，</span>其中 <code>-sig</code> 可以形如 <code>-INT</code>/<code>-SIGINT</code>/<code>-2</code><span class="mojikumi-line-end">，</span>而 <code>pid</code> 表示要把信号发送给<span class="mojikumi-line-end">：</span></p>
<ul>
<li>&gt; 0: PID 为 <code>pid</code> 的进程</li>
<li>0: process group 和当前进程相同的进程</li>
<li>-1: 除 PID 为 1 的 <code>init</code> 外的所有进程</li>
<li>&lt; 0: process group ID 为 <code>-pid</code> 的进程</li>
</ul>
<p>这与 <a href="#waitpid-%E7%9A%84-pid-%E5%8F%82%E6%95%B0">waitpid 的 pid 参数</a> 是类似的<span class="mojikumi-line-end">。</span></p>
<h4 id="在-shell-中使用键盘发送-sigint-sigtstp" class="heading"><a href="#在-shell-中使用键盘发送-sigint-sigtstp" class="heading-anchor" aria-label="章节： 在 shell 中使用键盘发送 SIGINT / SIGTSTP" tabindex="-1"></a><span>在 shell 中使用键盘发送 SIGINT / SIGTSTP</span></h4>
<p>shell 中会有至多一个 foreground job 和零个或若干个 background job<span class="mojikumi-line-end">。</span>shell 会给每个 job 中的所有进程指定同样的 process group<span class="mojikumi-line-end">。</span></p>
<p>Ctrl+C 会向 foreground group 发送 SIGINT<span class="mojikumi-line-end">，</span>Ctrl+Z 会向 foreground group 发送 SIGTSTP<span class="mojikumi-line-end">。</span></p>
<h4 id="使用函数发送-signal" class="heading"><a href="#使用函数发送-signal" class="heading-anchor" aria-label="章节： 使用函数发送 signal" tabindex="-1"></a><span>使用函数发送 signal</span></h4>
<ul>
<li><code>int kill(pid_t pid, int sig)</code>: 与 <a href="#kill-%E5%91%BD%E4%BB%A4">kill 命令</a>类似</li>
<li><code>unsigned<wbr> <wbr>int<wbr> <wbr>alarm<wbr>(<wbr>unsigned<wbr> <wbr>int<wbr> <wbr>secs<wbr>)</code>: 让 kernel 在 <code>secs</code> 秒后向当前进程发送 SIGALRM<span class="mojikumi-line-end">；</span>如果有尚未发送的 alarm 则取消掉<span class="mojikumi-line-end">，</span>如果 <code>secs</code> 为 0 则取消后不会发送新的 SIGALRM<span class="mojikumi-line-end">；</span>没有尚未发送的 alarm 则返回值是 0<span class="mojikumi-line-end">，</span>否则是被取消的 alarm 还剩的秒数</li>
</ul>
<h3 id="设置-signal-handler" class="heading"><a href="#设置-signal-handler" class="heading-anchor" aria-label="章节： 设置 signal handler" tabindex="-1"></a><span>设置 signal handler</span></h3>
<p>除了 SIGKILL 和 SIGSTOP<span class="mojikumi-line-end">，</span>其他 signal 的行为可以被改变<span class="mojikumi-line-end">。</span></p>
<section class="code-block relative my-6 shadow" itemprop="hasPart" itemscope="" itemtype="https://schema.org/SoftwareSourceCode" data-v-ad49d235=""><div class="h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex" style="display:none;" data-v-ad49d235=""><h4 class="text-3 text-footer" itemprop="programmingLanguage" aria-label="C 代码块" data-v-ad49d235="">C</h4><ile-root id="ile-5"><button title="复制到剪贴板" class="copy-button b-footer text-footer" data-v-9288569d=""><span class="i-mdi-content-copy" data-v-9288569d=""></span><span class="sr-only" role="status" data-v-9288569d=""></span></button></ile-root><script></script><script type="module" async="">var s=(i,a)=>()=>(a||i((a={exports:{}}).exports,a),a.exports);var r=(i,a,o)=>new Promise((c,n)=>{var f=t=>{try{_(o.next(t))}catch(e){n(e)}},l=t=>{try{_(o.throw(t))}catch(e){n(e)}},_=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);_((o=o.apply(i,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{b as p}from"/assets/iles.a8cc6c9f.js";import"/assets/vendor-vue.332650a1.js";var E=s(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.a8cc6c9f.js").then(i=>i.v),["assets/iles.a8cc6c9f.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/CopyButton.c03e0a7e.js"),["assets/CopyButton.c03e0a7e.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default});p(u,v,"ile-5",{},{})});export default E();
</script></div><div class="light:hidden" itemprop="text" data-v-ad49d235=""><pre class="shiki dark" style="background-color: #011627" tabindex="0"><code><span><span style="color: #C792EA">#include</span><span style="color: #D6DEEB"> </span><span style="color: #D9F5DD">&lt;</span><span style="color: #ECC48D">signal.h</span><span style="color: #D9F5DD">&gt;</span></span>
<span><span style="color: #C792EA">typedef</span><span style="color: #D6DEEB"> </span><span style="color: #C792EA">void</span><span style="color: #D6DEEB"> (</span><span style="color: #7FDBCA">*</span><span style="color: #C5E478">sighandler_t</span><span style="color: #D6DEEB">)(</span><span style="color: #C792EA">int</span><span style="color: #D6DEEB">);</span></span>
<span><span style="color: #C5E478">sighandler_t</span><span style="color: #D6DEEB"> </span><span style="color: #82AAFF">signal</span><span style="color: #D6DEEB">(</span><span style="color: #C792EA">int</span><span style="color: #D6DEEB"> </span><span style="color: #D7DBE0">signum</span><span style="color: #D6DEEB">, </span><span style="color: #C5E478">sighandler_t</span><span style="color: #D6DEEB"> </span><span style="color: #D7DBE0">handler</span><span style="color: #D6DEEB">);</span></span></code></pre></div><div class="light:important-block" style="display:none;" data-v-ad49d235=""><pre class="shiki light" style="background-color: #FBFBFB" tabindex="0"><code><span><span style="color: #994CC3">#include</span><span style="color: #403F53"> </span><span style="color: #111111">&lt;</span><span style="color: #C96765">signal.h</span><span style="color: #111111">&gt;</span></span>
<span><span style="color: #994CC3">typedef</span><span style="color: #403F53"> </span><span style="color: #994CC3">void</span><span style="color: #403F53"> (</span><span style="color: #0C969B">*</span><span style="color: #4876D6">sighandler_t</span><span style="color: #403F53">)(</span><span style="color: #994CC3">int</span><span style="color: #403F53">);</span></span>
<span><span style="color: #4876D6">sighandler_t</span><span style="color: #403F53"> </span><span style="color: #4876D6">signal</span><span style="color: #403F53">(</span><span style="color: #994CC3">int</span><span style="color: #403F53"> signum, </span><span style="color: #4876D6">sighandler_t</span><span style="color: #403F53"> handler);</span></span></code></pre></div></section>
<p>函数 <code>signal</code> 用来改变处理 signal <code>signum</code> 的方式<span class="mojikumi-line-end">。</span><code>handler</code> 可以是一个函数指针<span class="mojikumi-line-end">，</span>也可以是 <code>SIG_IGN</code> 表示无视这个 signal<span class="mojikumi-line-end">，</span>或者 <code>SIG_DFL</code> 表示使用这个 signal 的默认行为<span class="mojikumi-line-end">。</span></p>
<p>有 handler 时<span class="mojikumi-line-end">，</span>接收到一个 signal 就会触发 exception 来执行 handler<span class="mojikumi-line-end">，</span>在 handler 结束时一般会返回到原来的指令<span class="mojikumi-line-end">。</span></p>
<p>在执行 handler 的过程中<span class="mojikumi-line-end">，</span>相应的 signal 会被 block<span class="mojikumi-line-end">，</span>但 handler 可以被其他类型的 signal interrupt<span class="mojikumi-line-end">，</span>在处理完这另一个 signal 后返回到一开始的 handler<span class="mojikumi-line-end">。</span></p>
<h3 id="block-unblock-signal" class="heading"><a href="#block-unblock-signal" class="heading-anchor" aria-label="章节： block / unblock signal" tabindex="-1"></a><span>block / unblock signal</span></h3>
<p>进程可以主动 block / unblock 指定的 signal<span class="mojikumi-line-end">：</span></p>
<ul>
<li><code>int<wbr> <wbr>sigprocmask<wbr>(<wbr>int<wbr> <wbr>how<wbr>, <wbr>const<wbr> <wbr>sigset_t<wbr> *<wbr>set<wbr>, <wbr>sigset_t<wbr> *<wbr>oldset<wbr>)</code></li>
</ul>
<p>其中 <code>how</code> 是 <code>SIG_BLOCK</code> / <code>SIG_UNBLOCK</code> / <code>SIG_SETMASK</code><span class="mojikumi-line-end">，</span>分别表示 block <code>set</code> 里的 signal / unblock <code>set</code> 里的 signal / 将 blocked set 设为 <code>set</code><span class="mojikumi-line-end">。</span></p>
<p>若 <code>oldset</code> 不是 <code>NULL</code><span class="mojikumi-line-end">，</span>则会将修改前的 blocked set 存下来<span class="mojikumi-line-end">。</span></p>
<p>还有一些用来设置 <code>sigset_t</code> 的函数<span class="mojikumi-line-end">：</span></p>
<ul>
<li><code>int<wbr> <wbr>sigemptyset<wbr>(<wbr>sigset_t<wbr> *<wbr>set<wbr>)</code>: 将 <code>set</code> 设为空</li>
<li><code>int<wbr> <wbr>sigfillset<wbr>(<wbr>sigset_t<wbr> *<wbr>set<wbr>)</code>: 将 <code>set</code> 设为所有 signal</li>
<li><code>int<wbr> <wbr>sigaddset<wbr>(<wbr>sigset_t<wbr> *<wbr>set<wbr>, <wbr>int<wbr> <wbr>signum<wbr>)</code>: 将 <code>signum</code> 加入 <code>set</code></li>
<li><code>int<wbr> <wbr>sigdelset<wbr>(<wbr>sigset_t<wbr> *<wbr>set<wbr>, <wbr>int<wbr> <wbr>signum<wbr>)</code>: 将 <code>signum</code> 从 <code>set</code> 中删去</li>
<li><code>int<wbr> <wbr>sigismember<wbr>(<wbr>const<wbr> <wbr>sigset_t<wbr> *<wbr>set<wbr>, <wbr>int<wbr> <wbr>signum<wbr>)</code>: 检查 <code>signum</code> 是否在 <code>set</code> 中<span class="mojikumi-line-end">，</span>返回 0/1 或出错返回 -1</li>
</ul>
<h3 id="编写、使用-signal-handler" class="heading"><a href="#编写、使用-signal-handler" class="heading-anchor" aria-label="章节： 编写、使用 signal handler" tabindex="-1"></a><span>编写<span class="mojikumi-line-end">、</span>使用 signal handler</span></h3>
<h4 id="编写安全的-signal-handler" class="heading"><a href="#编写安全的-signal-handler" class="heading-anchor" aria-label="章节： 编写安全的 signal handler" tabindex="-1"></a><span>编写安全的 signal handler</span></h4>
<p>由于 signal handler 和主程序并行运行<span class="mojikumi-line-end">、</span>共享数据<span class="mojikumi-line-end">，</span>并且主程序可能在意想不到的地方接收到 signal 而被 interrupt<span class="mojikumi-line-end">，</span>编写安全的 signal handler 是困难的<span class="mojikumi-line-end">，</span>一般要遵循下面的守则<span class="mojikumi-line-end">：</span></p>
<ol start="0">
<li>handler 应当尽量简单<span class="mojikumi-line-end">，</span>例如可以设置一个 flag 而在主程序中检查 flag 并进行处理<span class="mojikumi-line-end">，</span>而非直接在 handler 中处理</li>
<li>在 handler 中只调用 async-signal-safe 的函数<span class="mojikumi-line-start">（</span>函数列表参见 <code>man<wbr> <wbr>signal<wbr>-<wbr>safety</code><span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>常用的 <code>printf</code><span class="mojikumi-line-end">、</span><code>sprintf</code><span class="mojikumi-line-end">、</span><code>malloc</code><span class="mojikumi-line-end">、</span><code>exit</code> 都不是 async-signal-safe 的</li>
<li>存储并恢复 <code>errno</code><span class="mojikumi-line-end">，</span>保证调用 handler 前后 <code>errno</code> 不变</li>
<li>访问 handler 与主程序共享的数据时<span class="mojikumi-line-end">，</span>block signal 以防止在访问的中途被 interrupt</li>
<li>把在 handler 中修改而在主程序中访问的的全局变量声明为 <code>volatile</code> 的<span class="mojikumi-line-end">，</span>防止编译器误认为变量没有被修改而错误地进行优化</li>
<li>将 flag 声明为 <code>sig_atomic_t</code> 类型<span class="mojikumi-line-end">，</span>它的单次访问是 atomic 的<span class="mojikumi-line-end">，</span>不会被 interrupt<span class="mojikumi-line-start">（</span>但先读后写是两次访问<span class="mojikumi-line-end">，</span>可能被 interrupt<span class="mojikumi-line-end">）</span></li>
</ol>
<a id="为什么函数会不-async-signal-safe" name="为什么函数会不-async-signal-safe" aria-hidden="true"></a>
<aside role="note" data-v-a2ab257f=""><div class="shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue" data-v-a2ab257f=""><div class="p-3 flex justify-between items-center" data-v-a2ab257f=""><h5 class="flex items-center gap-1 font-bold" data-v-a2ab257f=""><span class="text-5 i-mdi-pencil text-blue" data-v-a2ab257f=""></span><span class="sr-only" data-v-a2ab257f="">Note: </span><span data-v-a2ab257f="">为什么函数会不 async-signal-safe</span></h5><!--v-if--></div><div class="overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover" data-v-a2ab257f=""><p>以 <code>printf</code> 为例<span class="mojikumi-line-end">，</span><code>printf</code> 会使用一个 statically allocated buffer<span class="mojikumi-line-end">，</span>如果在中途被 interrupt<span class="mojikumi-line-end">，</span>而在返回到被 interrupt 的位置前的这段时间里<span class="mojikumi-line-end">，</span><code>printf</code> 再次被调用<span class="mojikumi-line-end">，</span>那么这个 buffer 就会处于一个 inconsistent 的中间态<span class="mojikumi-line-end">，</span>导致 UB<span class="mojikumi-line-end">。</span></p><p>也就是说<span class="mojikumi-line-end">，</span>一个函数不 async-signal-safe 一般是因为使用了一些全局变量并且可能在执行过程中被 interrupt<span class="mojikumi-line-end">。</span>要安全地调用这样的函数<span class="mojikumi-line-end">，</span>在其被 interrupt 后<span class="mojikumi-line-end">，</span>下次执行必须要是从被 interrupt 的地方继续<span class="mojikumi-line-end">，</span>而不能从头开始<span class="mojikumi-line-end">。</span></p><p>除了在 handler 中只调用 async-signal-safe 的函数<span class="mojikumi-line-end">，</span>也可以选择在主程序中调用非 async-signal-safe 函数时 block 掉 handler 使用了这一函数的 signal<span class="mojikumi-line-end">，</span>但这很难做到<span class="mojikumi-line-end">。</span></p></div></div></aside>
<h4 id="正确处理多次发送的-signal" class="heading"><a href="#正确处理多次发送的-signal" class="heading-anchor" aria-label="章节： 正确处理多次发送的 signal" tabindex="-1"></a><span>正确处理多次发送的 signal</span></h4>
<p>多次发送 signal 可能只会收到一次<span class="mojikumi-line-end">，</span>所以处理 signal 时不能误以为收到的次数与发送的次数相同<span class="mojikumi-line-end">。</span></p>
<p>例如<span class="mojikumi-line-end">，</span>接收 SIGCHLD 来 reap child 时<span class="mojikumi-line-end">，</span>应当在 handler 中 reap 掉所有已 terminate 的子进程<span class="mojikumi-line-end">，</span>而非只 reap 一个子进程<span class="mojikumi-line-end">。</span></p>
<h4 id="不同系统上-signal-handling-的差异" class="heading"><a href="#不同系统上-signal-handling-的差异" class="heading-anchor" aria-label="章节： 不同系统上 signal handling 的差异" tabindex="-1"></a><span>不同系统上 signal handling 的差异</span></h4>
<p>在一些系统上<span class="mojikumi-line-end">，</span>signal handling 的语义会有区别<span class="mojikumi-line-end">：</span></p>
<ul>
<li>
<p>在一些系统上<span class="mojikumi-line-end">，</span>调用了 handler 后这个 signal 就会恢复默认行为<span class="mojikumi-line-end">，</span>需要在 handler 中重新调用 <code>signal</code> 才能一直使用这个 handler<span class="mojikumi-line-end">。</span></p>
</li>
<li>
<p>在一些系统上<span class="mojikumi-line-end">，</span>需要执行较长时间的 system call 会在被 interrupt 后报错 EINTR<span class="mojikumi-line-end">，</span>而在现代系统上会尽可能地自动重新执行这个 system call<span class="mojikumi-line-end">，</span>详见 <code>man signal.7</code> 的 <span class="mojikumi">“</span>Interruption of system calls and library functions by signal handlers<span class="mojikumi">”</span> 一节<span class="mojikumi-line-end">。</span></p>
<p><span class="mojikumi-line-start">（</span>P.S. 这就是 <a href="https://www.dreamsongs.com/RiseOfWorseIsBetter.html">Rise of Worse Is Better</a> 中用来举例的 <span class="mojikumi">“</span>PC loser-ing problem<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>原本采用 worse-is-better 的 Unix 现在也进化成了 the right thing<span class="mojikumi-line-end">）</span>
<span class="mojikumi-line-start">（</span>P.P.S. 当时读这篇的时候我完全没看懂这一段<span class="mojikumi-line-end">，</span>没想到现在竟然还能记起来<span class="mojikumi-line-end">）</span></p>
</li>
</ul>
<p>可以通过 <code>sigaction</code> 函数来设置想要的 signal handling 语义<span class="mojikumi-line-end">。</span></p>
<h4 id="注意-handler-被调用的时机" class="heading"><a href="#注意-handler-被调用的时机" class="heading-anchor" aria-label="章节： 注意 handler 被调用的时机" tabindex="-1"></a><span>注意 handler 被调用的时机</span></h4>
<p>handler 可能会在意想不到的时机被调用<span class="mojikumi-line-end">，</span>为了避免出错<span class="mojikumi-line-start">（</span>race<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>可能会需要暂时 block signal 来确保 handler 在正确的时机被调用<span class="mojikumi-line-end">。</span>详见 CS:APP 上的例子<span class="mojikumi-line-end">。</span></p>
<h3 id="等待-signal" class="heading"><a href="#等待-signal" class="heading-anchor" aria-label="章节： 等待 signal" tabindex="-1"></a><span>等待 signal</span></h3>
<ul>
<li><code>int<wbr> <wbr>sigsuspend<wbr>(<wbr>const<wbr> <wbr>sigset_t<wbr> *<wbr>mask<wbr>)</code>: 将 blocked set 设为 <code>mask</code><span class="mojikumi-line-end">，</span>在接收到任何 signal 后返回</li>
</ul>
<p>可以在程序的其他部分 block 掉某个 signal<span class="mojikumi-line-end">，</span>然后在 <code>sigsuspend</code> 的参数中将其 unblock<span class="mojikumi-line-end">，</span>以达到等待该 signal 的目的<span class="mojikumi-line-end">。</span>因为 <code>sigsuspend</code> 等待的不是某个特定的 signal<span class="mojikumi-line-end">，</span>可以配合 <code>while</code> 循环来检查由 handler 设置的某个 flag<span class="mojikumi-line-end">。</span></p>
<p><code>sigsuspend</code> 的效果类似于下面的这段代码<span class="mojikumi-line-end">：</span></p>
<section class="code-block relative my-6 shadow" itemprop="hasPart" itemscope="" itemtype="https://schema.org/SoftwareSourceCode" data-v-ad49d235=""><div class="h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex" style="display:none;" data-v-ad49d235=""><h4 class="text-3 text-footer" itemprop="programmingLanguage" aria-label="C 代码块" data-v-ad49d235="">C</h4><ile-root id="ile-6"><button title="复制到剪贴板" class="copy-button b-footer text-footer" data-v-9288569d=""><span class="i-mdi-content-copy" data-v-9288569d=""></span><span class="sr-only" role="status" data-v-9288569d=""></span></button></ile-root><script></script><script type="module" async="">var s=(i,a)=>()=>(a||i((a={exports:{}}).exports,a),a.exports);var r=(i,a,o)=>new Promise((c,n)=>{var f=t=>{try{_(o.next(t))}catch(e){n(e)}},l=t=>{try{_(o.throw(t))}catch(e){n(e)}},_=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);_((o=o.apply(i,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{b as p}from"/assets/iles.a8cc6c9f.js";import"/assets/vendor-vue.332650a1.js";var E=s(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.a8cc6c9f.js").then(i=>i.v),["assets/iles.a8cc6c9f.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/CopyButton.c03e0a7e.js"),["assets/CopyButton.c03e0a7e.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default});p(u,v,"ile-6",{},{})});export default E();
</script></div><div class="light:hidden" itemprop="text" data-v-ad49d235=""><pre class="shiki dark" style="background-color: #011627" tabindex="0"><code><span><span style="color: #82AAFF">sigprocmask</span><span style="color: #D6DEEB">(SIG_SETMASK, </span><span style="color: #7FDBCA">&amp;</span><span style="color: #D7DBE0">mask</span><span style="color: #D6DEEB">, </span><span style="color: #7FDBCA">&amp;</span><span style="color: #D7DBE0">prev</span><span style="color: #D6DEEB">);</span></span>
<span><span style="color: #82AAFF">pause</span><span style="color: #D6DEEB">();</span></span>
<span><span style="color: #82AAFF">sigprocmask</span><span style="color: #D6DEEB">(SIG_SETMASK, </span><span style="color: #7FDBCA">&amp;</span><span style="color: #D7DBE0">prev</span><span style="color: #D6DEEB">, </span><span style="color: #82AAFF">NULL</span><span style="color: #D6DEEB">);</span></span></code></pre></div><div class="light:important-block" style="display:none;" data-v-ad49d235=""><pre class="shiki light" style="background-color: #FBFBFB" tabindex="0"><code><span><span style="color: #4876D6">sigprocmask</span><span style="color: #403F53">(SIG_SETMASK, </span><span style="color: #0C969B">&amp;</span><span style="color: #403F53">mask, </span><span style="color: #0C969B">&amp;</span><span style="color: #403F53">prev);</span></span>
<span><span style="color: #4876D6">pause</span><span style="color: #403F53">();</span></span>
<span><span style="color: #4876D6">sigprocmask</span><span style="color: #403F53">(SIG_SETMASK, </span><span style="color: #0C969B">&amp;</span><span style="color: #403F53">prev, </span><span style="color: #4876D6">NULL</span><span style="color: #403F53">);</span></span></code></pre></div></section>
<p>不同的是<span class="mojikumi-line-end">，</span>上面这段代码有可能会恰好在 <code>sigprocmask</code> 之后<span class="mojikumi-line-end">、</span><code>pause</code> 之前接收到 signal<span class="mojikumi-line-end">，</span>导致这个 signal 没有将 <code>pause</code> interrupt 而一直 sleep 下去<span class="mojikumi-line-end">。</span><code>sigsuspend</code> 是 atomic 的<span class="mojikumi-line-end">，</span>就不存在这样的问题<span class="mojikumi-line-end">。</span></p>
<h2 id="nonlocal-jumps" class="heading"><a href="#nonlocal-jumps" class="heading-anchor" aria-label="章节： Nonlocal Jumps" tabindex="-1"></a><span>Nonlocal Jumps</span></h2>
<ul>
<li><code>int<wbr> <wbr>setjmp<wbr>(<wbr>jmp_buf<wbr> <wbr>env<wbr>)</code></li>
<li><code>void<wbr> <wbr>longjmp<wbr>(<wbr>jmp_buf<wbr> <wbr>env<wbr>, <wbr>int<wbr> <wbr>val<wbr>)</code></li>
</ul>
<p><code>setjmp</code> 会将当前的 PC 和寄存器等信息存在 <code>env</code> 中<span class="mojikumi-line-end">，</span>而 <code>longjmp</code> 会恢复 <code>env</code> 中保存的信息<span class="mojikumi-line-end">，</span>跳转到 <code>setjmp</code> 的位置<span class="mojikumi-line-end">。</span></p>
<p>这意味着 <code>setjmp</code> 可能返回多次<span class="mojikumi-line-end">，</span>而 <code>longjmp</code> 不会返回<span class="mojikumi-line-end">。</span>第一次调用 <code>setjmp</code> 会返回 0<span class="mojikumi-line-end">，</span>而之后调用 <code>longjmp</code> 时会在 <code>setjmp</code> 的位置返回参数 <code>val</code> 的值<span class="mojikumi-line-start">（</span>特别地<span class="mojikumi-line-end">，</span>如果 <code>val</code> 的值是 0<span class="mojikumi-line-end">，</span>会返回 1<span class="mojikumi-line-end">，</span>强制和首次返回区分开<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<p>因为 <code>setjmp</code> / <code>longjmp</code> 只是恢复 PC 和寄存器<span class="mojikumi-line-start">（</span>包括 <code>%rsp</code><span class="mojikumi">）</span><span class="mojikumi-line-end">：</span></p>
<ul>
<li>调用 <code>longjmp</code> 时 <code>setjmp</code> 所在的函数必须还没有返回<span class="mojikumi-line-end">，</span>否则 <code>setjmp</code> 所在的 stack frame 就失效了<span class="mojikumi-line-end">。</span></li>
<li><code>setjmp</code> 的返回值只应出现在<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/setjmp.html">一些简单的表达式中</a><span class="mojikumi-line-end">，</span>否则是 UB<span class="mojikumi-line-end">。</span>特别地<span class="mojikumi-line-end">，</span>不应将 <code>setjmp</code> 的返回值赋给一个变量<span class="mojikumi-line-end">，</span>但可以放在 <code>if</code> 或 <code>switch</code> 里<span class="mojikumi-line-end">。</span>这是考虑到<span class="mojikumi-line-end">，</span>计算一个复杂的表达式可能会有一些中间量以及 dynamic stack allocation<span class="mojikumi-line-end">，</span>而 <code>longjmp</code> 回来时这些中间量<span class="mojikumi-line-end">、</span>dynamic stack allocation 不一定能被正确恢复<span class="mojikumi-line-end">，</span>导致表达式不一定能被正确计算<span class="mojikumi-line-end">。</span></li>
<li>如果修改了存放在内存中的局部变量<span class="mojikumi-line-end">，</span>跳转后会是被修改过的值而不是原来的值<span class="mojikumi-line-end">，</span>而存放在寄存器中的值则会被恢复<span class="mojikumi-line-end">。</span>要确保变量不被存在寄存器中<span class="mojikumi-line-end">，</span>必须使用 <code>volatile</code> 声明变量<span class="mojikumi-line-end">，</span>否则<span class="mojikumi-line-start">（</span>即便使用了 <code>register</code> 或 <code>auto</code> 来声明变量<span class="mojikumi-line-end">）</span>编译器可能任意地把变量放在内存或寄存器中<span class="mojikumi-line-end">，</span>造成跳转后变量的值不确定<span class="mojikumi-line-end">。</span></li>
</ul>
<a id="volatile-vs-取地址" name="volatile-vs-取地址" aria-hidden="true"></a>
<aside role="note" data-v-a2ab257f=""><div class="shadow-md rd-1 b-l-6 my-6 bg-purple-2 dark:bg-purple-9 b-purple-5" data-v-a2ab257f=""><div class="p-3 flex justify-between items-center" data-v-a2ab257f=""><h3 class="flex items-center gap-1 font-bold" data-v-a2ab257f=""><span class="text-5 i-mdi-help-circle-outline text-purple" data-v-a2ab257f=""></span><span class="sr-only" data-v-a2ab257f="">Question: </span><span data-v-a2ab257f="">volatile vs 取地址</span></h3><!--v-if--></div><div class="overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover" data-v-a2ab257f=""><p>C99 rationale 和 <code>man setjmp</code> 都说要用 <code>volatile</code> 才能确保局部变量存在栈上<span class="mojikumi-line-end">，</span>那如果一个局部变量被取了地址<span class="mojikumi-line-end">，</span>还有可能存在寄存器中吗？如果有可能的话<span class="mojikumi-line-end">，</span>是标准允许这样但事实上不会<span class="mojikumi-line-end">，</span>还是真的可以在 gcc 中做到？</p></div></div></aside>
<ul>
<li><code>int<wbr> <wbr>sigsetjmp<wbr>(<wbr>sigjmp_buf<wbr> <wbr>env<wbr>, <wbr>int<wbr> <wbr>savesigs<wbr>)</code></li>
<li><code>void<wbr> <wbr>siglongjmp<wbr>(<wbr>sigjmp_buf<wbr> <wbr>env<wbr>, <wbr>int<wbr> <wbr>val<wbr>)</code></li>
</ul>
<p><code>sigsetjmp</code> / <code>siglongjmp</code> 会额外存储<span class="mojikumi-line-end">、</span>恢复 pending / blocked signal 的信息<span class="mojikumi-line-start">（</span>需要以非 0 <code>savesigs</code> 调用 <code>sigsetjmp</code><span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>可以用于 signal handler<span class="mojikumi-line-end">。</span></p>
<p>nonlocal jump 主要有两种用途<span class="mojikumi-line-end">：</span></p>
<ul>
<li>出错时直接跳转到一个集中的位置来处理错误<span class="mojikumi-line-end">，</span>而不用一层层往上返回</li>
<li>处理 signal 时不返回到被 interrupt 的位置<span class="mojikumi-line-end">，</span>而跳转到指定的位置</li>
</ul>
<p>在 signal handler 中使用 nonlocal jump 时需要注意<span class="mojikumi-line-end">：</span></p>
<ul>
<li>先 <code>sigsetjmp</code> 再 install signal handler<span class="mojikumi-line-end">，</span>否则可能 race</li>
<li><code>siglongjmp</code> 跳转到的后续代码中只能调用 async-signal-safe 的函数</li>
</ul>
<p>nonlocal jump 可能造成可读性的问题<span class="mojikumi-line-end">，</span>也可能因为跳过了中间很多函数的返回<span class="mojikumi-line-end">，</span>造成内存泄露等后果<span class="mojikumi-line-end">，</span>要谨慎使用<span class="mojikumi-line-end">。</span></p>
<h2 id="tools-for-manipulating-processes" class="heading"><a href="#tools-for-manipulating-processes" class="heading-anchor" aria-label="章节： Tools for Manipulating Processes" tabindex="-1"></a><span>Tools for Manipulating Processes</span></h2>
<ul>
<li><code>strace</code>: 显示程序调用的所有 system call<span class="mojikumi-line-end">，</span>可以静态链接来避免看到大量共享库相关的输出</li>
<li><code>ps</code>: 列出进程信息</li>
<li><code>top</code>: 列出进程的资源使用<span class="mojikumi-line-start">（</span>可以用 <code>htop</code><span class="mojikumi-line-end">）</span></li>
<li><code>pmap</code>: 查看进程的 memory map</li>
<li><code>/proc</code>: 查看各种进程相关的信息 (<code>man proc.5</code>)</li>
</ul></section><div class="article-style my-9"><hr></div><footer><div class="my-6 b-l-6 b-gray-4 bg-area p-6 shadow dark:b-gray-11" itemprop="copyrightNotice"><ul class="flex flex-col gap-1"><li class="flex gap-1"><span class="shrink-0">文章作者:</span><a href="https://github.com/ouuan" rel="author">ouuan</a></li><li class="flex gap-1"><span class="shrink-0">原文链接:</span><a href="https://ouuan.moe/post/2022/11/csapp-8" rel="canonical" class="break-all">https://ouuan.moe/post/2022/11/csapp-8</a></li><li class="flex gap-1"><span class="shrink-0">许可协议:</span><span> 本文采用 <span class="article-style"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.zh" class="font-sans" itemprop="license">CC BY-SA 4.0</a></span> 许可协议进行授权，未满足 <span class="underline decoration-dotted" title="简而言之，转载时必须标明出处（本文的链接），标明是转载而非原创，标明作了哪些修改，并使用相同的许可协议，但无需私信征求许可">许可协议要求</span> 不得转载。 </span></li></ul></div></footer></article><div class="my-6 print:hidden" itemprop="comment" itemscope="" itemtype="https://schema.org/Comment"><ile-root id="ile-7"></ile-root><script></script><script type="module" async="">import{h as r,c as m}from"/assets/iles.a8cc6c9f.js";import{_ as o}from"/assets/GiscusCommentsInner.434be06c.js";import"/assets/vendor-vue.332650a1.js";import"/assets/vite.5ce4fca4.js";import"/assets/useTheme.bb94191c.js";import"/assets/site.0440d0dc.js";r(m,o,"ile-7",{term:"CS:APP 第八章学习笔记"},{});
</script></div><nav class="my-6 flex justify-between gap-6 print:hidden lg:text-justify"><div class="flex flex-1"><a class="flex items-center gap-1 hover:text-hover" href="/post/2022/11/pitfalls-of-breaststroke-breathing"><span class="i-mdi-chevron-left"></span><span class="sr-only">上一篇</span><span class="break-anywhere">蛙泳换气踩坑记录</span></a></div><div class="flex flex-1 justify-end"><a class="flex flex-row-reverse items-center gap-1 hover:text-hover" href="/post/2022/11/csapp-9"><span class="i-mdi-chevron-right"></span><span class="sr-only">下一篇</span><span class="break-anywhere">CS:APP 第九章学习笔记</span></a></div></nav></div><ile-root id="ile-8"><div class="flex print:hidden"><aside style="max-height:calc(100vh - 10rem);" id="__toc" class="sticky top-16 m-4 hidden w-72 rd-2 bg-card py-6 shadow xl:block 2xl:w-84 3xl:w-96" aria-label="文章目录" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPSideBar"><div class="mb-3 flex flex-wrap items-center justify-between gap-2 pl-8 pr-4"><div class="flex items-center"><h2 class="text-xl font-bold"> 文章目录 </h2><button id="__toc-close" class="flex items-center px-1 text-xl" title="关闭目录" aria-controls="__toc" aria-expanded="true"><span class="i-mdi-close"></span></button></div><div><label class="ml-auto flex items-center gap-1"><span>展开全部</span><input type="checkbox"></label></div></div><div style="max-height:calc(100% - 2rem);" class="overflow-auto overscroll-contain pl-8 pr-4"><ol data-v-c5806953=""><li id="__toc-item-exceptions" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#exceptions" data-v-c5806953=""><span data-v-c5806953="">Exceptions</span></a></li><li id="__toc-item-processes" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#processes" data-v-c5806953=""><span data-v-c5806953="">Processes</span></a></li><li id="__toc-item-system-call-error-handling" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#system-call-error-handling" data-v-c5806953=""><span data-v-c5806953="">System Call Error Handling</span></a></li><li id="__toc-item-process-control" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#process-control" data-v-c5806953=""><span data-v-c5806953="">Process Control</span></a></li><li id="__toc-item-signals" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#signals" data-v-c5806953=""><span data-v-c5806953="">Signals</span></a></li><li id="__toc-item-nonlocal-jumps" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#nonlocal-jumps" data-v-c5806953=""><span data-v-c5806953="">Nonlocal Jumps</span></a></li><li id="__toc-item-tools-for-manipulating-processes" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#tools-for-manipulating-processes" data-v-c5806953=""><span data-v-c5806953="">Tools for Manipulating Processes</span></a></li></ol></div></aside><button style="display:none;" id="__toc-open" title="显示文章目录" class="bottom-24 text-lg floating-button" aria-haspopup="dialog" aria-controls="__toc" aria-expanded="true"><span class="i-mdi-menu"></span></button></div></ile-root><script></script><script type="module" async="">import{h as r,c as v}from"/assets/iles.a8cc6c9f.js";import{_ as c}from"/assets/TableOfContents.572c62ae.js";import"/assets/vendor-vue.332650a1.js";import"/assets/vite.5ce4fca4.js";r(v,c,"ile-8",function(l,e,s,t,i,n,g,u,o,a){return{headings:[{level:s,title:"Exceptions",slug:"exceptions"},{level:l,title:"Exception Handling",slug:"exception-handling"},{level:l,title:"Classes of Exceptions",slug:"classes-of-exceptions"},{level:l,title:"Exceptions in Linux/x86-64 Systems",slug:"exceptions-in-linuxx86-64-systems"},{level:e,title:"x86-64 中的 fault / abort",slug:"x86-64-中的-fault-abort"},{level:e,title:"Linux 中的 system call",slug:"linux-中的-system-call"},{level:s,title:"Processes",slug:"processes"},{level:l,title:"Logical / Concurrent Flow",slug:"logical-concurrent-flow"},{level:l,title:"User / Kernel Mode",slug:"user-kernel-mode"},{level:l,title:"Context Switch",slug:"context-switch"},{level:s,title:"System Call Error Handling",slug:"system-call-error-handling"},{level:s,title:"Process Control",slug:"process-control"},{level:l,title:"获取 PID",slug:"获取-pid"},{level:l,title:t,slug:t},{level:l,title:i,slug:i},{level:l,title:"process group",slug:"process-group"},{level:l,title:n,slug:n},{level:e,title:"waitpid 的 pid 参数",slug:"waitpid-的-pid-参数"},{level:e,title:"waitpid 的行为 (options)",slug:"waitpid-的行为-options"},{level:e,title:g,slug:g},{level:e,title:"wait 获取子进程的 status",slug:"wait-获取子进程的-status"},{level:e,title:"wait 的报错",slug:"wait-的报错"},{level:l,title:u,slug:u},{level:l,title:o,slug:o},{level:s,title:"Signals",slug:"signals"},{level:l,title:"signal 的种类",slug:"signal-的种类"},{level:l,title:"signal 的工作流程",slug:"signal-的工作流程"},{level:l,title:"发送 signal",slug:"发送-signal"},{level:e,title:"kill 命令",slug:"kill-命令"},{level:e,title:"在 shell 中使用键盘发送 SIGINT / SIGTSTP",slug:"在-shell-中使用键盘发送-sigint-sigtstp"},{level:e,title:"使用函数发送 signal",slug:"使用函数发送-signal"},{level:l,title:"设置 signal handler",slug:"设置-signal-handler"},{level:l,title:"block / unblock signal",slug:"block-unblock-signal"},{level:l,title:"编写、使用 signal handler",slug:"编写、使用-signal-handler"},{level:e,title:"编写安全的 signal handler",slug:"编写安全的-signal-handler"},{level:a,title:"为什么函数会不 async-signal-safe",slug:"为什么函数会不-async-signal-safe"},{level:e,title:"正确处理多次发送的 signal",slug:"正确处理多次发送的-signal"},{level:e,title:"不同系统上 signal handling 的差异",slug:"不同系统上-signal-handling-的差异"},{level:e,title:"注意 handler 被调用的时机",slug:"注意-handler-被调用的时机"},{level:l,title:"等待 signal",slug:"等待-signal"},{level:s,title:"Nonlocal Jumps",slug:"nonlocal-jumps"},{level:a,title:"volatile vs 取地址",slug:"volatile-vs-取地址"},{level:s,title:"Tools for Manipulating Processes",slug:"tools-for-manipulating-processes"}]}}(3,4,2,"进程的状态","fork","wait","reap","sleep","execve",6),{});
</script></div></main><footer class="flex flex-col gap-1 bg-card p-6 text-footer" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPFooter"><div class="flex flex-wrap items-center justify-center gap-x-1"><span>Copyright ©</span><span>2022 - 2024</span><a class="flex items-center" href="/sponsor" title="赞赏支持"><span class="i-mdi-heart text-red dark:text-red-7"></span></a><span>ouuan</span></div><div class="flex flex-wrap items-center justify-center gap-x-1 print:hidden"><span> 当前有 <ile-root id="ile-9"><span><span class="i-mdi-loading motion-safe:animate-spin"></span><span class="sr-only">加载中</span></span></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.a8cc6c9f.js";import"/assets/vendor-vue.332650a1.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.a8cc6c9f.js").then(o=>o.v),["assets/iles.a8cc6c9f.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/VisitorCountRealtime.ba912bd5.js"),["assets/VisitorCountRealtime.ba912bd5.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-9",{},{})});export default E();
</script> 人在线 </span><span class="i-mdi-circle-small"></span><span title="实际上，为了保护用户隐私，同一用户的多次访问只有在同一天内使用同一浏览器在同一ip下才会被算作同一人"> 共有 <ile-root id="ile-10"><span><span class="i-mdi-loading motion-safe:animate-spin"></span><span class="sr-only">加载中</span></span></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.a8cc6c9f.js";import"/assets/vendor-vue.332650a1.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.a8cc6c9f.js").then(o=>o.v),["assets/iles.a8cc6c9f.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/VisitorCount.7a2aee2b.js"),["assets/VisitorCount.7a2aee2b.js","assets/VisitorCount.ccf5cdec.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-10",{},{})});export default E();
</script> 人到访过这里 </span></div><div class="flex flex-wrap items-center justify-center gap-x-1 print:hidden"> 基于 <a class="underline" href="https://github.com/ElMassimo/iles">îles</a><a class="underline" href="https://github.com/ouuan/iles-blog/blob/master/package.json">等项目</a><span class="i-mdi-circle-small"></span><span>由 ouuan 设计/制作</span><span class="i-mdi-circle-small"></span><a class="underline" href="https://github.com/ouuan/iles-blog">源代码</a></div></footer><meta itemprop="copyrightYear" content="2022 - 2024"><div class="hidden" itemscope="" itemtype="https://schema.org/Person" itemprop="copyrightHolder"><meta itemprop="name" content="ouuan"><meta itemprop="givenName" content="Yufan"><meta itemprop="familyName" content="You"><meta itemprop="url" content="https://github.com/ouuan"><link itemprop="gender" href="https://schema.org/Male"><meta itemprop="image" content="/android-chrome-512x512.png"></div><ile-root id="ile-11"><button class="group bottom-10 flex-col floating-button" title="前往底部"><div aria-hidden="true" class="flex justify-center"><span class="i-mdi-chevron-double-up motion-safe:transition-font-size text-0"></span></div><div aria-hidden="true" class="text-0 group-hover:text-3.5 motion-safe:transition-font-size"></div><div aria-hidden="false" class="flex justify-center"><span class="i-mdi-chevron-double-down motion-safe:transition-font-size text-5 group-hover:text-3"></span></div></button></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.a8cc6c9f.js";import"/assets/vendor-vue.332650a1.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.a8cc6c9f.js").then(o=>o.v),["assets/iles.a8cc6c9f.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/BackToTop.6d31ad12.js"),["assets/BackToTop.6d31ad12.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-11",{},{})});export default E();
</script><div class="hidden"></div><ile-root id="ile-12"></ile-root><script></script><script type="module" async="">var p=(t,a)=>()=>(a||t((a={exports:{}}).exports,a),a.exports);var e=(t,a,_)=>new Promise((c,n)=>{var f=o=>{try{i(_.next(o))}catch(r){n(r)}},l=o=>{try{i(_.throw(o))}catch(r){n(r)}},i=o=>o.done?c(o.value):Promise.resolve(o.value).then(f,l);i((_=_.apply(t,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.a8cc6c9f.js";import"/assets/vendor-vue.332650a1.js";var u=p(m=>{const E=()=>e(m,null,function*(){return(yield d(()=>import("/assets/iles.a8cc6c9f.js").then(t=>t.d),["assets/iles.a8cc6c9f.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default}),h=()=>e(m,null,function*(){return(yield d(()=>import("/assets/PlausibleTrigger.cabf89fc.js"),["assets/PlausibleTrigger.cabf89fc.js","assets/plausible.3ac8f9aa.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).onLoad});s(E,h,"ile-12",{},{})});export default u();
</script><div></div><ile-root id="ile-13"></ile-root><script></script><script type="module" async="">var p=(t,a)=>()=>(a||t((a={exports:{}}).exports,a),a.exports);var e=(t,a,_)=>new Promise((c,n)=>{var f=o=>{try{i(_.next(o))}catch(r){n(r)}},l=o=>{try{i(_.throw(o))}catch(r){n(r)}},i=o=>o.done?c(o.value):Promise.resolve(o.value).then(f,l);i((_=_.apply(t,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.a8cc6c9f.js";import"/assets/vendor-vue.332650a1.js";var u=p(m=>{const E=()=>e(m,null,function*(){return(yield d(()=>import("/assets/iles.a8cc6c9f.js").then(t=>t.d),["assets/iles.a8cc6c9f.js","assets/vendor-vue.332650a1.js","assets/vite.5ce4fca4.js"])).default}),h=()=>e(m,null,function*(){return(yield d(()=>import("/assets/TextJustifyFix.4fa5e997.js"),[])).onLoad});s(E,h,"ile-13",{},{})});export default u();
</script><meta itemprop="inLanguage" content="zh-CN"></div>
  
</body></html>