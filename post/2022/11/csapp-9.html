<!DOCTYPE html><html lang="zh-CN"><head>
    <meta charset="UTF-8">
<title>CS:APP 第九章学习笔记 - ouuan's blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="

CS:APP 第九章 “Virtual Memory” 的学习笔记。
本章的主要内容为 page table、address translation、memory mapping、dynamic allocation。
">
<meta property="og:url" content="https://ouuan.moe/post/2022/11/csapp-9">
<meta property="og:site_name" content="ouuan's blog">
<meta property="og:title" content="CS:APP 第九章学习笔记 · ouuan's blog">
<meta property="og:description" content="

CS:APP 第九章 “Virtual Memory” 的学习笔记。
本章的主要内容为 page table、address translation、memory mapping、dynamic allocation。
">
<meta property="twitter:domain" content="ouuan.moe">
<meta property="twitter:title" content="CS:APP 第九章学习笔记 · ouuan's blog">
<meta property="twitter:description" content="

CS:APP 第九章 “Virtual Memory” 的学习笔记。
本章的主要内容为 page table、address translation、memory mapping、dynamic allocation。
">
<meta property="twitter:url" content="https://ouuan.moe/post/2022/11/csapp-9">
<style>html:not(.dark):not(.light) { visibility: hidden; } body { visibility: hidden; }</style>
<script>(() => { let dark; try { const theme = localStorage && localStorage.getItem('vueuse-color-scheme'); if (theme === 'dark') dark = true; else if (theme === 'light') dark = false; else dark = window.matchMedia('(prefers-color-scheme: dark)').matches; } catch (e) { dark = false; } document.documentElement.classList.add(dark ? 'dark' : 'light'); })()</script>
<noscript><style>@media (prefers-color-scheme: light) { :root:not(.dark):not(.light) { color-scheme: light; --text-color: #232637; --bg-color: #DEE6EE; --card-color: #EFF3F7; --link-color: #1E66B8; --hover-color: #2E80DD; --active-color: #164C89; --bghover-color: #D6E0EA; --popup-color: #F7F9FB; --footer-color: #5F627B; --area-color: #E1E2E8; --nested-color: #F0F0F3; } } @media (prefers-color-scheme: dark) { :root:not(.dark):not(.light) { color-scheme: dark; --text-color: #E6EDF2; --bg-color: #0D0E15; --card-color: #1F2130; --link-color: #8BB8EC; --hover-color: #A2C6F0; --active-color: #74AAE8; --bghover-color: #353853; --popup-color: #2C2F45; --footer-color: #9699AE; --area-color: #2F313D; --nested-color: #3C3E4E; } } html { visibility:visible !important; }</style></noscript>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="canonical" href="https://ouuan.moe/post/2022/11/csapp-9">
<link rel="alternate" type="application/rss+xml" href="/feed.xml" title="RSS Feed - ouuan's blog">
<link rel="alternate" type="application/atom+xml" href="/feed.atom" title="Atom Feed - ouuan's blog">
<link rel="alternate" type="application/json" href="/feed.json" title="JSON Feed - ouuan's blog">
<link rel="dns-prefetch" href="https://plausible.ouuan.moe">
<link rel="preconnect" href="https://blog-visitor-count.ouuan.moe">
<link rel="stylesheet" href="/vendors/katex/katex.css">
<link rel="sitemap" href="https://ouuan.moe/sitemap.xml">
<meta name="author" content="ouuan">
<meta name="twitter:creator" content="@ouuan">
<meta name="twitter:card" content="summary">
<meta property="og:image" content="https://ouuan.moe/images/2022/11/csapp-9.png">
<meta property="generator" content="îles">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-12-26T06:44:19.000Z">
<meta property="article:modified_time" content="2023-07-05T14:31:07.000Z">
<meta property="article:author" content="ouuan">
<meta property="article:tag" content="csapp">
<meta property="article:tag" content="学习笔记">
<link rel="preconnect" href="https://giscus.app">
<link rel="dns-prefetch" href="https://avatars.githubusercontent.com">
    <link rel="stylesheet" href="/assets/style-cfd49c27.css">
    
  <link rel="modulepreload" href="/assets/iles.d16725a3.js" crossorigin=""><link rel="modulepreload" href="/assets/vendor-vue.1fb1cc54.js" crossorigin=""><link rel="modulepreload" href="/assets/vite.5ce4fca4.js" crossorigin=""><link rel="modulepreload" href="/assets/SearchBar.9da0cc7a.js" crossorigin=""><link rel="modulepreload" href="/assets/PostHead.fa685758.js" crossorigin=""><link rel="modulepreload" href="/assets/VisitorCount.9aa34bd6.js" crossorigin=""><link rel="modulepreload" href="/assets/site.b21fb919.js" crossorigin=""><link rel="modulepreload" href="/assets/GiscusCommentsInner.4e768edd.js" crossorigin=""><link rel="modulepreload" href="/assets/useTheme.e8b3aa5c.js" crossorigin=""><link rel="modulepreload" href="/assets/TableOfContents.e445cc36.js" crossorigin=""><style>@font-face { font-family: "Noto Serif SC Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Regular.unique.2c67f2d1.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Regular.unique.3e6431fb.woff') format('woff'); unicode-range: U+0-ff1f; } @font-face { font-family: "Noto Serif SC Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Regular.common.6ea6fba7.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Regular.common.a9784cdb.woff') format('woff'); unicode-range: U+0-ff1b; } @font-face { font-family: "Noto Serif SC Web Font"; font-weight: 700; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Bold.unique.262c70c7.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Bold.unique.e7a72cb6.woff') format('woff'); unicode-range: U+0-95f4; } @font-face { font-family: "Noto Serif SC Web Font"; font-weight: 700; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Bold.common.a2128fd5.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Bold.common.f1ef6e4f.woff') format('woff'); unicode-range: U+0-8981; } @font-face { font-family: "LXGW WenKai Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Bold.unique.44f2ba5f.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Bold.unique.b1b09b34.woff') format('woff'); unicode-range: U+0-201d; } @font-face { font-family: "LXGW WenKai Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/LXGWWenKai-Regular.common.7789ccb3.woff2') format('woff2'), url('/assets/fonts/LXGWWenKai-Regular.common.2283d7fc.woff') format('woff'); unicode-range: U+0-ff0c; }</style><link rel="preload" href="/assets/fonts/NotoSerifSC-Regular.unique.2c67f2d1.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/NotoSerifSC-Regular.common.6ea6fba7.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/NotoSerifSC-Bold.unique.262c70c7.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/NotoSerifSC-Bold.common.a2128fd5.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/NotoSerifSC-Bold.unique.44f2ba5f.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/LXGWWenKai-Regular.common.7789ccb3.woff2" as="font" type="font/woff2" crossorigin=""></head>
  <body itemscope="" itemtype="https://schema.org/ItemPage">
    <div id="app"><header class="bg-card shadow print:hidden" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPHeader"><div class="flex flex-wrap justify-center whitespace-nowrap px-4 page-container sm:flex-nowrap"><div class="flex basis-full items-stretch justify-center sm:mr-3 sm:basis-auto"><a class="flex items-center p-3 text-xl font-serif bghover" href="/"><span>ouuan<span class="mojikumi-narrow-left">’</span>s blog</span></a></div><nav class="flex"><ul class="flex"><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/"><span>首页</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/posts"><span>文章</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/tags"><span>标签</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/about"><span>关于</span></a></li></ul></nav><div class="sm:basis-full"></div><ul class="flex"><li class="flex"><ile-root id="ile-1"><div class="flex items-stretch lg:hidden"><a class="flex items-center p-2 bghover" href="/search" title="全站搜索"><span class="i-mdi-magnify text-xl"></span></a></div><form role="search" class="hidden items-stretch justify-center lg:flex"><div class="flex items-center"><input value="" class="w-48 rd-full bg-area px-3 py-1" type="search" placeholder="关键词" aria-label="全站搜索"></div><a class="flex items-center p-2 bghover" href="/search?q=" title="全站搜索"><span class="i-mdi-magnify text-xl"></span></a></form></ile-root><script></script><script type="module" async="">import{h as r,c as a}from"/assets/iles.d16725a3.js";import{_ as m}from"/assets/SearchBar.9da0cc7a.js";import"/assets/vendor-vue.1fb1cc54.js";import"/assets/vite.5ce4fca4.js";r(a,m,"ile-1",{},{});
</script></li><li class="flex items-stretch"><a class="flex items-center p-2 bghover" href="/feed.xml" title="RSS 订阅"><span class="i-mdi-rss text-xl"></span></a></li><li class="flex"><ile-root id="ile-2"><div class="relative flex items-stretch"><button title="暗色模式设置" class="flex items-center p-2 bghover" aria-haspopup="menu" aria-controls="__theme-switcher" aria-expanded="false"><span class="i-mdi-theme-light-dark text-xl"></span></button><ul style="display:none;" id="__theme-switcher" class="absolute right-0 top-full z-20 whitespace-nowrap rd-1 bg-popup shadow-md" role="menu" aria-label="暗色模式选项"><li class="bghover" role="menuitemradio" aria-checked="true"><button class="flex items-center p-1 text-hover"><span class="i-mdi-cellphone md:i-mdi-tablet lg:i-mdi-monitor mr-1"></span><span>跟随系统</span></button></li><li class="bghover" role="menuitemradio" aria-checked="false"><button class="flex items-center p-1"><span class="i-mdi-white-balance-sunny mr-1"></span><span>总是亮色</span></button></li><li class="bghover" role="menuitemradio" aria-checked="false"><button class="flex items-center p-1"><span class="i-mdi-weather-night mr-1"></span><span>总是暗色</span></button></li></ul></div></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.d16725a3.js";import"/assets/vendor-vue.1fb1cc54.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.d16725a3.js").then(o=>o.v),["assets/iles.d16725a3.js","assets/vendor-vue.1fb1cc54.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/ThemeSwitcher.9060b188.js"),["assets/ThemeSwitcher.9060b188.js","assets/vendor-vue.1fb1cc54.js","assets/vite.5ce4fca4.js","assets/useTheme.e8b3aa5c.js"])).default});s(u,v,"ile-2",{},{})});export default E();
</script></li></ul></div></header><main class="min-h-100vh py-6 page-container" itemprop="mainContentOfPage" itemscope="" itemtype="https://schema.org/WebPageElement"><div class="flex justify-center"><div class="grow m-4 standard-card max-w-200"><article itemprop="mainEntity" itemscope="" itemtype="https://schema.org/BlogPosting"><div class="hidden" itemscope="" itemtype="https://schema.org/Person" itemprop="author"><meta itemprop="name" content="ouuan"><meta itemprop="givenName" content="Yufan"><meta itemprop="familyName" content="You"><meta itemprop="url" content="https://github.com/ouuan"><link itemprop="gender" href="https://schema.org/Male"><meta itemprop="image" content="/android-chrome-512x512.png"></div><meta itemprop="mainEntityOfPage" content="https://ouuan.moe/post/2022/11/csapp-9"><meta itemprop="image" content="https://ouuan.moe/images/2022/11/csapp-9.png"><ile-root id="ile-3" class="my-12"><header class="my-12" data-v-4039c18a=""><h1 class="mb-3 mt-6 text-center text-8" itemprop="headline" data-v-4039c18a=""><span class="inline-block font-serif break-anywhere" data-v-4039c18a="">CS:APP 第九章学习笔记</span></h1><div class="flex flex-wrap justify-center gap-x-4 gap-y-1 text-footer md:text-sm" data-v-4039c18a=""><span class="flex items-center" title="创建于 2022-11-23 18:10:42 GMT+8" data-v-4039c18a=""><span class="i-mdi-folder-plus-outline mr-1" data-v-4039c18a=""></span><span class="sr-only" data-v-4039c18a="">创建于</span><a class="hover:underline" href="https://github.com/ouuan/iles-blog/blob/master/src/pages/post/2022/11/csapp-9.mdx?plain=1" data-v-4039c18a=""><time datetime="2022-11-23T18:10:42+08:00" itemprop="dateCreated" data-v-4039c18a="">2022-11-23</time></a></span><span class="flex items-center" title="修改于 2023-07-05 22:31:07 GMT+8" data-v-4039c18a=""><span class="i-mdi-update mr-1" data-v-4039c18a=""></span><span class="sr-only" data-v-4039c18a="">修改于</span><a class="hover:underline" href="https://github.com/ouuan/iles-blog/commits/master/src/pages/post/2022/11/csapp-9.mdx" data-v-4039c18a=""><time datetime="2023-07-05T22:31:07+08:00" itemprop="dateModified" data-v-4039c18a="">2023-07-05</time></a></span><span class="flex items-center" title="访问量" data-v-4039c18a=""><span class="i-mdi-eye-outline mr-1" data-v-4039c18a=""></span><span class="sr-only" data-v-4039c18a="">访问量</span><span data-v-4039c18a="">78</span></span><span class="flex flex-wrap justify-center gap-x-2 gap-y-1" data-v-4039c18a=""><span title="标签: csapp" class="flex items-center" itemprop="keywords" data-v-4039c18a=""><span class="i-mdi-tag-outline mr-1" data-v-4039c18a=""></span><span class="sr-only" data-v-4039c18a="">标签</span><a href="/tag/csapp" class="hover:underline" data-v-4039c18a="">csapp</a></span><span title="标签: 学习笔记" class="flex items-center" itemprop="keywords" data-v-4039c18a=""><span class="i-mdi-tag-outline mr-1" data-v-4039c18a=""></span><span class="sr-only" data-v-4039c18a="">标签</span><a href="/tag/学习笔记" class="hover:underline" data-v-4039c18a="">学习笔记</a></span></span></div></header></ile-root><script></script><script type="module" async="">import{h as a,c as t}from"/assets/iles.d16725a3.js";import e from"/assets/PostHead.fa685758.js";import"/assets/vendor-vue.1fb1cc54.js";import"/assets/vite.5ce4fca4.js";import"/assets/VisitorCount.9aa34bd6.js";import"/assets/site.b21fb919.js";a(t,e,"ile-3",{class:"my-12",href:"/post/2022/11/csapp-9",filename:"src/pages/post/2022/11/csapp-9.mdx",frontmatter:{title:"CS:APP 第九章学习笔记",date:new Date(1669198242e3),image:"/images/2022/11/csapp-9.png",copyrightNotice:"本文包含若干截自 CS:APP 中的图片，本文作者对其不拥有版权。",tags:["csapp","学习笔记"],lastUpdated:new Date(1688567467e3),published:new Date(1672037059e3),visitor:78,description:`

CS:APP 第九章 “Virtual Memory” 的学习笔记。
本章的主要内容为 page table、address translation、memory mapping、dynamic allocation。
`}},{});
</script><section class="article-style" itemprop="articleBody">

<p><a href="https://csapp.cs.cmu.edu/">CS:APP</a> 第九章 <span class="mojikumi">“</span>Virtual Memory<span class="mojikumi">”</span> 的学习笔记<span class="mojikumi-line-end">。</span></p>
<p>本章的主要内容为 page table<span class="mojikumi-line-end">、</span>address translation<span class="mojikumi-line-end">、</span>memory mapping<span class="mojikumi-line-end">、</span>dynamic allocation<span class="mojikumi-line-end">。</span></p>

<p>虚存是对 main memory 的抽象<span class="mojikumi-line-end">，</span>它的主要作用有<span class="mojikumi-line-end">：</span></p>
<ul>
<li>将 main memory 用作 disk 的 cache<span class="mojikumi-line-end">，</span>只将 active 的部分放在 main memory<span class="mojikumi-line-end">，</span>在需要时在 disk 和 memory 之间传递数据</li>
<li>通过给应用程序提供统一的地址空间<span class="mojikumi-line-end">，</span>简化内存管理</li>
<li>通过给不同进程提供独立的地址空间<span class="mojikumi-line-end">，</span>防止一个进程的数据被其他进程破坏</li>
</ul>
<p>虚存在系统中起着非常重要的作用<span class="mojikumi-line-end">，</span>学习虚存一方面可以学会使用它的一些强大功能<span class="mojikumi-line-start">（</span>例如将文件映射到内存中<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>另一方面可以避免一些内存管理相关的错误<span class="mojikumi-line-end">。</span></p>
<h2 id="physical-and-virtual-addressing" class="heading"><a href="#physical-and-virtual-addressing" class="heading-anchor" aria-label="章节： Physical and Virtual Addressing" tabindex="-1"></a><span>Physical and Virtual Addressing</span></h2>
<p>内存有两种寻址方式<span class="mojikumi-line-end">：</span>物理寻址和虚拟寻址<span class="mojikumi-line-end">。</span></p>
<p>main memory 可以看作 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></span> 个 byte 排列在一起<span class="mojikumi-line-end">，</span>地址分别为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \sim M-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span><span class="mojikumi-line-end">，</span>物理寻址就是 CPU 直接将需要的地址传给 main memory<span class="mojikumi-line-end">，</span>获取到数据后传回 CPU<span class="mojikumi-line-end">。</span></p>
<p>虚拟寻址需要硬件和操作系统配合<span class="mojikumi-line-end">，</span>CPU 将虚拟地址传给 <i>memory management unit</i> (MMU)<span class="mojikumi-line-end">，</span>MMU 将虚拟地址翻译成物理地址传给 main memory<span class="mojikumi-line-end">，</span>而这个过程又和操作系统相关<span class="mojikumi-line-end">。</span></p>
<h2 id="address-spaces" class="heading"><a href="#address-spaces" class="heading-anchor" aria-label="章节： Address Spaces" tabindex="-1"></a><span>Address Spaces</span></h2>
<p><span class="mojikumi-line-start">（</span>线性<span class="mojikumi-line-end">）</span>地址空间是连续的非负整数构成的集合<span class="mojikumi-line-end">，</span>一个系统有一个物理地址空间 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>M</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, M-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span><span class="mojikumi-line-end">，</span>还有若干个虚拟地址空间 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, N-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span><span class="mojikumi-line-end">，</span>其中 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">N = 2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="mojikumi-line-end">，</span>称作 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>-bit 地址空间<span class="mojikumi-line-end">，</span>一般是 32-bit 或者 64-bit<span class="mojikumi-line-end">。</span></p>
<p>同一份数据可以在不同的地址空间有不同的地址<span class="mojikumi-line-end">，</span>是虚存的一个基本思想<span class="mojikumi-line-end">。</span></p>
<h2 id="vm-as-a-tool-for-caching" class="heading"><a href="#vm-as-a-tool-for-caching" class="heading-anchor" aria-label="章节： VM as a Tool for Caching" tabindex="-1"></a><span>VM as a Tool for Caching</span></h2>
<p>可以说<span class="mojikumi-line-end">，</span>虚存是存储在磁盘上的<span class="mojikumi-line-end">，</span>而物理内存是虚存的 cache<span class="mojikumi">。</span><wbr><span class="mojikumi-line-start">（</span>但实际上虚存在很多时候会只出现在这个 cache 里而只在必要时被写入到磁盘上<span class="mojikumi">。</span><span class="mojikumi-line-end">）</span></p>
<h3 id="page" class="heading"><a href="#page" class="heading-anchor" aria-label="章节： page" tabindex="-1"></a><span>page</span></h3>
<p>虚存被分成了很多固定大小的块<span class="mojikumi-line-end">，</span>每一块称作一个 <i>virtual page</i><span class="mojikumi-line-end">，</span>而物理内存被分为同样大小的块<span class="mojikumi-line-end">，</span>每一块被称作一个 <i>physical page</i><span class="mojikumi-line-end">。</span>在 cache 中<span class="mojikumi-line-end">，</span>这样的一块一般被称作一个 block<span class="mojikumi-line-end">，</span>但在虚存中被称作一个 page<span class="mojikumi-line-end">。</span></p>
<p>因为 DRAM 比磁盘快很多<span class="mojikumi-line-end">，</span>并且磁盘的连续访问比随机访问快很多<span class="mojikumi-line-end">：</span></p>
<ul>
<li>虚存的一个 page 会比较大<span class="mojikumi-line-end">，</span>一般有 4KB ~ 2MB</li>
<li>虚存是 <a href="/post/2022/12/csapp-6#cache-%E7%9A%84%E5%88%86%E7%B1%BB">fully associative cache</a></li>
<li>操作系统会使用一些比 SRAM cache 更加复杂的算法作为 replacement policy 来管理虚存</li>
</ul>
<p>一个 virtual page 可能处于三种状态之一: unallocated<span class="mojikumi-line-end">、</span>cached<span class="mojikumi-line-end">、</span>uncached<span class="mojikumi-line-end">。</span></p>
<h3 id="page-table" class="heading"><a href="#page-table" class="heading-anchor" aria-label="章节： page table" tabindex="-1"></a><span>page table</span></h3>
<p>在物理内存中存放着一张 <i>page table</i><span class="mojikumi-line-end">，</span>虚拟地址空间中的每个 page 都对应 page table 中的一项 (<i>page table entry</i>, PTE)<span class="mojikumi-line-end">。</span>每一项包含一个 valid bit 和一个地址<span class="mojikumi-line-end">：</span></p>
<ul>
<li>cached: valid bit set<span class="mojikumi-line-end">，</span>地址为该 page 的缓存的物理地址</li>
<li>uncached: valid bit not set<span class="mojikumi-line-end">，</span>地址指向磁盘上的 virtual page</li>
<li>unallocated: valid bit not set<span class="mojikumi-line-end">，</span>地址为 null</li>
</ul>
<h3 id="page-fault" class="heading"><a href="#page-fault" class="heading-anchor" aria-label="章节： page fault" tabindex="-1"></a><span>page fault</span></h3>
<p>在地址翻译时<span class="mojikumi-line-end">，</span>MMU 会查看传入的虚拟地址对应的 PTE<span class="mojikumi-line-end">，</span>若 cached<span class="mojikumi-line-end">，</span>则称作 <i>page hit</i><span class="mojikumi-line-end">，</span>就会将 PTE 存储的物理地址传给 main memory<span class="mojikumi-line-end">；</span>否则<span class="mojikumi-line-end">，</span>就是 cache miss<span class="mojikumi-line-end">，</span>在虚存中被称作 <i>page fault</i><span class="mojikumi-line-end">。</span></p>
<p>page fault 是一个 exception<span class="mojikumi-line-end">，</span>会触发 kernel 中的 page fault handler<span class="mojikumi-line-end">。</span>page fault handler 会在 physical memory 中选择一个 physical page<span class="mojikumi-line-start">（</span>victim page<span class="mojikumi-line-end">）</span>用来存这个触发 page fault 的 page<span class="mojikumi-line-end">，</span>先将 victim page 原有的数据在必要时放回磁盘<span class="mojikumi-line-end">，</span>然后将新的数据存入 victim page<span class="mojikumi-line-end">，</span>再相应地修改 page table 中的这两个 PTE<span class="mojikumi-line-end">，</span>使得 victim page 原来存的那个 virtual page 变为 uncached<span class="mojikumi-line-end">，</span>而新存入的 virtual page 变为 cached 并且地址指向 victim page<span class="mojikumi-line-end">。</span>page fault handler 的最终效果就是<span class="mojikumi-line-end">，</span>一开始想要的 virtual page 已经 cached<span class="mojikumi-line-end">，</span>于是在返回到 exception 触发的位置时就可以 page hit 而正常读取数据了<span class="mojikumi-line-end">。</span></p>
<p>在磁盘和内存间传递数据在虚存中被称作 <i>swapping</i> 或 <i>paging</i><span class="mojikumi-line-end">：</span></p>
<blockquote>
<p>Pages are <i>swapped in</i> (<i>paged in</i>) from disk to DRAM, and <i>swapped out</i> (<i>paged out</i>) from DRAM to disk.</p>
</blockquote>
<p>虚存的 cache miss 是非常昂贵的<span class="mojikumi-line-end">，</span>但由于程序访问内存的 locality<span class="mojikumi-line-end">，</span>一般来说 page fault 很少触发<span class="mojikumi-line-end">，</span>效率就不会太差<span class="mojikumi-line-end">。</span>不断触发 page fault 的情况称作 <i>thrashing</i><span class="mojikumi-line-end">，</span>会大大影响程序的效率<span class="mojikumi-line-end">。</span></p>
<h2 id="vm-as-a-tool-for-memory-management" class="heading"><a href="#vm-as-a-tool-for-memory-management" class="heading-anchor" aria-label="章节： VM as a Tool for Memory Management" tabindex="-1"></a><span>VM as a Tool for Memory Management</span></h2>
<p>实际上<span class="mojikumi-line-end">，</span>page table 在一个系统中并非只有一份<span class="mojikumi-line-end">，</span>而是每个进程都有一份<span class="mojikumi-line-end">，</span>并且可以把同一个 physical page 映射到不同进程中的多个 virtual page<span class="mojikumi-line-end">。</span></p>
<p>虚存为内存管理提供了如下的便利<span class="mojikumi-line-end">：</span></p>
<ul>
<li>简化了 linking<span class="mojikumi-line-end">，</span>使得链接时无需考虑具体的物理地址<span class="mojikumi-line-end">，</span>不同程序可以使用同样的虚拟地址分配方案<span class="mojikumi-line-end">。</span></li>
<li>简化了 loading<span class="mojikumi-line-end">，</span>使得加载程序时只需将可执行文件的段落映射到虚存中<span class="mojikumi-line-end">，</span>不用拷贝数据<span class="mojikumi-line-end">，</span>等访问到某个 page 时才会 page in<span class="mojikumi-line-end">。</span>这样的将文件内容映射到虚存中的操作称作 <a href="#memory-mapping">memory mapping</a><span class="mojikumi-line-end">，</span>Linux 提供了 <code>mmap</code> system call 来进行 memory mapping<span class="mojikumi-line-end">。</span></li>
<li>简化了内存共享<span class="mojikumi-line-end">，</span>操作系统可以将进程私有的数据映射到不同的 physical page<span class="mojikumi-line-end">，</span>而将共享的数据映射到相同的 physical page<span class="mojikumi-line-end">。</span></li>
<li>简化了内存分配<span class="mojikumi-line-end">，</span>因为应用请求一段连续的 virtual pages 时<span class="mojikumi-line-end">，</span>操作系统可以将其映射到不连续的 physical pages<span class="mojikumi-line-end">。</span></li>
</ul>
<h2 id="vm-as-a-tool-for-memory-protection" class="heading"><a href="#vm-as-a-tool-for-memory-protection" class="heading-anchor" aria-label="章节： VM as a Tool for Memory Protection" tabindex="-1"></a><span>VM as a Tool for Memory Protection</span></h2>
<ul>
<li>虚存可以轻松地给不同的进程提供不同的私有内存空间<span class="mojikumi-line-end">。</span></li>
<li>通过给 PTE 添加 permission bit <code>SUP</code><span class="mojikumi-line-end">、</span><code>READ</code><span class="mojikumi-line-end">、</span><code>WRITE</code><span class="mojikumi-line-end">，</span>就可以使某个 page 只读或者只能在 kernel mode 下被访问<span class="mojikumi-line-end">。</span>如果试图访问一个 page 时权限出错<span class="mojikumi-line-end">，</span>则会触发 CPU 的 general protection exception<span class="mojikumi-line-end">，</span>进而由 exception handler 向进程发送 SIGSEGV<span class="mojikumi-line-end">。</span></li>
</ul>
<h2 id="address-translation" class="heading"><a href="#address-translation" class="heading-anchor" aria-label="章节： Address Translation" tabindex="-1"></a><span>Address Translation</span></h2>
<p>一个内存地址可以被分为两部分<span class="mojikumi-line-end">，</span>虚拟地址被分为高位的 <i>virtual page number</i> (VPN) 和低位的 <i>virtual page offset</i> (VPO)<span class="mojikumi-line-end">，</span>物理地址被分为 PPN 和 PPO<span class="mojikumi-line-end">。</span></p>
<p>CPU 中有一个 <i>page table base register</i> (PTBR)<span class="mojikumi-line-end">，</span>指向 page table 的起始地址<span class="mojikumi-line-end">。</span>地址翻译时<span class="mojikumi-line-end">，</span>MMU 通过 PTBR 和 VPN 得到 PTE 的地址<span class="mojikumi-line-end">，</span>从 main memory 获取 PTE<span class="mojikumi-line-end">，</span>根据 valid bit<span class="mojikumi-line-end">，</span>要么触发 page fault<span class="mojikumi-line-end">，</span>要么获取到 PPN<span class="mojikumi-line-end">，</span>而 PPO = VPO<span class="mojikumi-line-end">，</span>就得到了物理地址<span class="mojikumi-line-end">。</span></p>
<p>SRAM cache 一般会以物理地址来 cache main memory<span class="mojikumi-line-end">，</span>也就是说<span class="mojikumi-line-end">，</span>通过 PTE 的地址访问 PTE<span class="mojikumi-line-end">、</span>通过物理地址访问 main memory 时会首先尝试通过 SRAM cache 来访问<span class="mojikumi-line-end">。</span></p>
<p>如果每次都从 main memory 获取 PTE<span class="mojikumi-line-end">，</span>即使在 L1 cache hit 了效率也不够高<span class="mojikumi-line-end">，</span>所以 MMU 中还有一个小的 page table cache<span class="mojikumi-line-end">，</span>叫做 <i>translation lookaside buffer</i> (TLB)<span class="mojikumi-line-end">。</span>VPN 被分为两部分<span class="mojikumi-line-end">：</span>低位的 TLBI (index) 和高位的 TLBT (tag)<span class="mojikumi-line-end">，</span>其中 TLBI 用来选择 cache set<span class="mojikumi-line-end">，</span>TLBT 用来进行 cache line matching<span class="mojikumi-line-end">。</span>在地址翻译时<span class="mojikumi-line-end">，</span>会优先查询 TLB<span class="mojikumi-line-end">，</span>若 miss 再查询 page table<span class="mojikumi-line-end">。</span></p>
<p>地址空间往往很大<span class="mojikumi-line-end">，</span>如果只用一张 page table<span class="mojikumi-line-end">，</span>那么 page table 本身就会占用大量的空间<span class="mojikumi-line-end">，</span>所以可以将 page table 分层<span class="mojikumi-line-end">，</span>每层 page table 指向下一层 page table<span class="mojikumi-line-end">，</span>直到最后一层指向 VP / PP<span class="mojikumi-line-end">。</span></p>
<h2 id="case-study-core-i7-address-translation" class="heading"><a href="#case-study-core-i7-address-translation" class="heading-anchor" aria-label="章节： Case Study: Core i7 Address Translation" tabindex="-1"></a><span>Case Study: Core i7 Address Translation</span></h2>
<p>Core i7 memory system 如 CS:APP Figure 9.21 所示<span class="mojikumi-line-end">：</span></p>
<p><picture><source type="image/webp" srcset="/assets/csapp-fig9.21.282f25d8.webp"><img srcset="/assets/csapp-fig9.21.032f64c1.png" loading="lazy" src="/assets/csapp-fig9.21.032f64c1.png" width="1207" height="934" alt="The Core i7 memory system"></picture></p>
<p>Core i7 使用 48-bit 的虚拟地址空间和 52-bit 的物理地址空间<span class="mojikumi-line-end">，</span>page size 可以设置为 4KB 或 4MB<span class="mojikumi-line-end">，</span>有四级 page table<span class="mojikumi-line-end">。</span></p>
<p>每个 PTE 有以下内容<span class="mojikumi">：</span><wbr><span class="mojikumi-line-start">（</span>还有一些其他内容<span class="mojikumi-line-end">）</span></p>
<ul>
<li>P: valid bit</li>
<li>R/W: 是否只读</li>
<li>U/S: 是否需要在 kernel mode 下访问</li>
<li>XD: 是否可以被读取指令<span class="mojikumi-line-start">（</span>是否可执行<span class="mojikumi-line-end">）</span></li>
<li>A: reference bit<span class="mojikumi-line-end">，</span>访问到时由 MMU 设置<span class="mojikumi-line-end">，</span>而由软件清除<span class="mojikumi-line-start">（</span>可以用于 replacement algorithm<span class="mojikumi-line-end">）</span></li>
<li>Base addr: child page table / physical page 的地址的高位 40 bits<span class="mojikumi-line-start">（</span>剩下 12 bits 即 4KB<span class="mojikumi-line-end">，</span>这要求地址以 4KB 对齐<span class="mojikumi-line-end">，</span>而 page size 一般就是 4KB<span class="mojikumi-line-end">）</span></li>
</ul>
<p>L1 page table 还有一项 PS 用来指定 page size<span class="mojikumi-line-end">。</span></p>
<p>L4 page table 还有 dirty bit D 用来表示 page 被写入过需要被 swap out (write back)<span class="mojikumi-line-end">，</span>以及 G 表示 global page 即切换进程时不从 TLB 中 evict 掉<span class="mojikumi-line-end">。</span></p>
<p>VPN 有 36 bits<span class="mojikumi-line-end">，</span>每 9 bits 用来访问一级 page table<span class="mojikumi-line-end">。</span></p>
<p>因为 L1 cache 是 8-way 32KB 的<span class="mojikumi-line-end">，</span>正好有 12 bits 用来选择 cache set<span class="mojikumi-line-end">，</span>所以在获取 PPN 的同时就可以把 VPO 发送给 L1 cache 来提前选择好 cache set<span class="mojikumi-line-end">。</span></p>
<h2 id="linux-virtual-memory-system" class="heading"><a href="#linux-virtual-memory-system" class="heading-anchor" aria-label="章节： Linux Virtual Memory System" tabindex="-1"></a><span>Linux Virtual Memory System</span></h2>
<p>kernel 的虚存中包含<span class="mojikumi-line-end">：</span></p>
<ul>
<li>
<p>kernel 的代码以及全局的数据结构</p>
</li>
<li>
<p>将整个物理内存连续地映射到虚存中<span class="mojikumi-line-end">，</span>这样就可以方便地访问特定的物理地址</p>
</li>
<li>
<p>和每个进程相关的数据结构<span class="mojikumi-line-end">，</span>例如 page table<span class="mojikumi-line-end">、</span>kernel stack<span class="mojikumi-line-end">、</span><code>task_struct</code> 等</p>
<p><span class="mojikumi-line-start">（</span>P.S. 这部分虽然是和每个进程相关<span class="mojikumi-line-end">，</span>但并不会在每个进程中有所不同<span class="mojikumi-line-end">，</span>CS:APP 中这里写错了<span class="mojikumi-line-end">，</span>在 errata 中指出了<span class="mojikumi-line-end">）</span></p>
</li>
</ul>
<p>Linux 将虚存划分为若干 <i>area</i><span class="mojikumi-line-start">（</span>也称 <i>segment</i><span class="mojikumi-line-end">）</span>来管理<span class="mojikumi-line-end">，</span>例如 code segment<span class="mojikumi-line-end">、</span>data segment<span class="mojikumi-line-end">、</span>heap<span class="mojikumi-line-end">、</span>shared library segment<span class="mojikumi-line-end">，</span>每个 area 是虚存中连续的一段<span class="mojikumi-line-end">。</span></p>
<p>kernel 为每个进程维护了一个 <code>task_struct</code><span class="mojikumi-line-end">，</span>其中的 <code>mm</code> 一项是一个 <code>mm_struct</code><span class="mojikumi-line-end">。</span><code>mm_struct</code> 的 <code>pgd</code> 一项是 L1 page table 的地址<span class="mojikumi-line-end">，</span>而 <code>mmap</code> 指向一个 <code>vm_<wbr>area_<wbr>struct</code><span class="mojikumi-line-end">。</span>每个 <code>vm_<wbr>area_<wbr>struct</code> 表示一个 area<span class="mojikumi-line-end">，</span>有以下几项<span class="mojikumi-line-start">（</span>还有一些其他项<span class="mojikumi">）</span><span class="mojikumi-line-end">：</span></p>
<ul>
<li><code>vm_start</code> / <code>vm_end</code>: 指向 area 的开头 / 结尾</li>
<li><code>vm_page_prot</code>: area 中所有 page 的 access permission</li>
<li><code>vm_flags</code>: 一些 flag<span class="mojikumi-line-end">，</span>例如这个 area 中的 page 是否被所有进程共享</li>
<li><code>vm_prev</code> / <code>vm_next</code>: 指向相邻的 <code>vm_<wbr>area_<wbr>struct</code><span class="mojikumi-line-end">，</span>构成一个链表</li>
</ul>
<p>在处理 page fault 时<span class="mojikumi-line-end">，</span>page fault handler 首先会检查地址是否在某个 area 内<span class="mojikumi-line-start">（</span>不在则触发 segmentation fault<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>然后会检查是否有访问权限<span class="mojikumi-line-start">（</span>没有则触发 protection exception<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>如果一切 ok 就会根据 replacement algorithm 选择 victim page<span class="mojikumi-line-end">，</span>若其 dirty 则将其 swap out<span class="mojikumi-line-end">，</span>然后将新的 page swap in<span class="mojikumi-line-end">，</span>最后更新 page table 并返回<span class="mojikumi-line-end">。</span></p>
<a id="segmentation-fault-vs-protection-exception" name="segmentation-fault-vs-protection-exception" aria-hidden="true"></a>
<aside role="note" data-v-a2ab257f=""><div class="shadow-md rd-1 b-l-6 my-6 bg-purple-2 dark:bg-purple-9 b-purple-5" data-v-a2ab257f=""><div class="p-3 flex justify-between items-center" data-v-a2ab257f=""><h3 class="flex items-center gap-1 font-bold" data-v-a2ab257f=""><span class="text-5 i-mdi-help-circle-outline text-purple" data-v-a2ab257f=""></span><span class="sr-only" data-v-a2ab257f="">Question: </span><span data-v-a2ab257f="">segmentation fault vs protection exception</span></h3><!--v-if--></div><div class="overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover" data-v-a2ab257f=""><p>segmentation fault 和 protection exception 有区别吗？general protection exception 不应该是 CPU 触发的吗<span class="mojikumi-line-end">，</span>怎么是 page fault handler 触发？segmentation fault 和 SIGSEGV 是什么关系？</p><p>我的理解是 kernel 收到 CPU 的 general protection exception 会向进程发送 SIGSEGV<span class="mojikumi-line-end">，</span>但 CS:APP 这里在相邻的两段分别用了 <span class="mojikumi">“</span>segmentation fault<span class="mojikumi">”</span> 和 <span class="mojikumi">“</span>protection exception<span class="mojikumi">”</span><span class="mojikumi-line-end">。</span></p></div></div></aside>
<h2 id="memory-mapping" class="heading"><a href="#memory-mapping" class="heading-anchor" aria-label="章节： Memory Mapping" tabindex="-1"></a><span>Memory Mapping</span></h2>
<p>将一个 <i>object</i> 的内容设为一段虚存的初始值称作 <i>memory mapping</i><span class="mojikumi-line-end">。</span>这个 object 可以是文件系统中一个文件的一段 (<i>file-backed</i>)<span class="mojikumi-line-end">，</span>也可以是一个初始为空的 <i>anonymous file</i> (<i>demand-zero</i>)<span class="mojikumi-line-end">。</span></p>
<p>在 map 时并不会立即将数据放到物理内存中<span class="mojikumi-line-end">，</span>而是等到访问到某个 page 时再 swap in<span class="mojikumi-line-end">，</span>这称作 <i>demand paging</i><span class="mojikumi-line-end">。</span>操作系统会使用 <i>swap file</i> 来进行 swapping<span class="mojikumi-line-end">，</span>但只有进行了修改才会需要 swap out<span class="mojikumi-line-end">，</span>否则可以直接从 map 到的文件 swap in<span class="mojikumi-line-end">。</span></p>
<p>如果不同的进程映射到了同一个文件的同一段<span class="mojikumi-line-end">，</span>在物理内存中会只有一份数据<span class="mojikumi-line-end">。</span></p>
<p>memory mapping 有 shared 和 private 两种<span class="mojikumi-line-end">：</span></p>
<ul>
<li>map as shared objects: 修改对其他进程可见<span class="mojikumi-line-end">，</span>如果是 file-backed 还会将内存修改同步到磁盘上的文件<span class="mojikumi-line-end">。</span></li>
<li>map as private objects: 修改对其他进程不可见<span class="mojikumi-line-end">，</span>也不会同步到磁盘上<span class="mojikumi-line-end">，</span>并且是 copy-on-write 的<span class="mojikumi-line-end">：</span>一开始将 PTE 设为只读<span class="mojikumi-line-end">，</span>在触发 protection exception 后<span class="mojikumi-line-end">，</span>exception handler 发现这个 area 是可以写入但 private 的<span class="mojikumi-line-end">，</span>就创建一个新的 page<span class="mojikumi-line-end">，</span>将原来的 page 复制过去<span class="mojikumi-line-end">，</span>将 PTE 设为可以写入<span class="mojikumi-line-end">。</span></li>
</ul>
<h3 id="fork-的原理" class="heading"><a href="#fork-的原理" class="heading-anchor" aria-label="章节： fork 的原理" tabindex="-1"></a><span>fork 的原理</span></h3>
<p>fork 时会将原来的 <code>mm_struct</code> 以及 page table 复制一份<span class="mojikumi-line-end">，</span>但是将原来的 private area 中的 PTE 可以写入的重新变为只读<span class="mojikumi-line-end">，</span>从而在之后再写入时重新触发 copy-on-write<span class="mojikumi-line-end">，</span>就做到了 parent 和 child 一开始有一样的数据但后续写入独立<span class="mojikumi-line-end">。</span>在 fork 前就创建了的 shared area 会由两个进程共享<span class="mojikumi-line-end">，</span>可以利用这一点在 parent 和 child 之间通信<span class="mojikumi-line-end">。</span></p>
<h3 id="execve-的原理" class="heading"><a href="#execve-的原理" class="heading-anchor" aria-label="章节： execve 的原理" tabindex="-1"></a><span>execve 的原理</span></h3>
<ol>
<li>删除当前进程的所有 area (<code>vm_<wbr>area_<wbr>struct</code>)</li>
<li>根据 program header table 进行 memory mapping<span class="mojikumi-line-end">：</span>
<ul>
<li><code>.init</code><span class="mojikumi-line-end">、</span><code>.text</code><span class="mojikumi-line-end">、</span><code>.rodata</code>: private, file-backed, read-only</li>
<li><code>.data</code>: private, file-backed, read/write</li>
<li><code>.bss</code><span class="mojikumi-line-end">、</span>heap<span class="mojikumi-line-end">、</span>stack: private, demand-zero, read/write</li>
</ul>
</li>
<li>如果有 link 到共享库<span class="mojikumi-line-end">，</span>会进行动态链接<span class="mojikumi-line-end">，</span>将共享库 private, file-backed map</li>
<li>修改 program counter</li>
</ol>
<a id="关于共享库的-map-方式" name="关于共享库的-map-方式" aria-hidden="true"></a>
<aside role="note" data-v-a2ab257f=""><details class="shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue" data-v-a2ab257f=""><summary class="p-3 flex justify-between items-center cursor-pointer" data-v-a2ab257f=""><h4 class="flex items-center gap-1 font-bold" data-v-a2ab257f=""><span class="text-5 i-mdi-info-circle-outline text-blue" data-v-a2ab257f=""></span><span class="sr-only" data-v-a2ab257f="">Info: </span><span data-v-a2ab257f="">关于共享库的 map 方式</span></h4><span class="details-icon text-5" data-v-a2ab257f=""></span></summary><div class="overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover" data-v-a2ab257f=""><p>下面是一封发送于 2022.12.18<span class="mojikumi-line-end">，</span>尚未收到回复的邮件<span class="mojikumi-line-end">：</span></p><blockquote>
<p>Dear Drs. Randy Bryant and Dave O'Hallaron,</p>
<p>I am a student at Tsinghua University and I am writing to ask a question about the book CS:APP3e.</p>
<p>In <span class="mojikumi">“</span>9.8.3 The execve Function Revisited<span class="mojikumi">”</span> on page 837, it is stated that shared libraries are <span class="mojikumi">“</span>mapped into the shared region of the user<span class="mojikumi-narrow-left">’</span>s virtual address space<span class="mojikumi">”</span>. In Figure 9.31, it is stated that <span class="mojikumi">“</span>Memory-mapped region for shared libraries<span class="mojikumi">”</span> are <span class="mojikumi">“</span>Shared, file-backed<span class="mojikumi">”</span>.</p>
<p>However, I believe that shared libraries are actually mapped as private objects rather than shared objects. I have come to this conclusion for the following reasons:</p>
<ol>
<li>If there is data in the shared library, it should be copy-on-write, and should not be shared among different processes.</li>
<li>/proc/self/maps shows that all mappings to shared libraries of my shell are private.</li>
<li>The source code and comments of dl-load indicate that the mapping should be private. (See <a href="https://github.com/bminor/glibc/blob/71e408e45dcacf429a94b2807f75aaadd8d37cb9/elf/dl-load.h#L32-L49" class="break-all">https://github.com/bminor/glibc/blob/71e408e45dcacf429a94b2807f75aaadd8d37cb9/elf/dl-load.h#L32-L49</a> and <a href="https://github.com/bminor/glibc/commit/9b8a44cd18fbf1aedeb03e19f4bcdb06b0ee409b" class="break-all">https://github.com/bminor/glibc/commit/9b8a44cd18fbf1aedeb03e19f4bcdb06b0ee409b</a>.)</li>
</ol>
<p>I have checked the errata but did not find this issue addressed. I am writing to you in the hope that you can provide an explanation of this statement or add it to the errata. Thank you for your attention to this matter.</p>
<p>Sincerely,<br>
Yufan You</p>
</blockquote></div></details></aside>
<h3 id="mmap" class="heading"><a href="#mmap" class="heading-anchor" aria-label="章节： mmap" tabindex="-1"></a><span>mmap</span></h3>
<p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)</code></p>
<ul>
<li><code>addr</code>: area 的起始地址<span class="mojikumi-line-end">，</span>仅作提示作用<span class="mojikumi-line-end">，</span>一般 <code>NULL</code> 就行</li>
<li><code>length</code>: area 的长度</li>
<li><code>prot</code>: <code>PROT_EXEC</code><span class="mojikumi-line-end">、</span><code>PROT_READ</code><span class="mojikumi-line-end">、</span><code>PROT_WRITE</code><span class="mojikumi-line-end">、</span><code>PROT_NONE</code></li>
<li><code>flags</code>: 有很多<span class="mojikumi-line-end">，</span>常用的有 <code>MAP_SHARED</code><span class="mojikumi-line-end">、</span><code>MAP_PRIVATE</code><span class="mojikumi-line-end">、</span><code>MAP_<wbr>ANONYMOUS</code></li>
<li><code>fd</code>: map 到的 file descriptor</li>
<li><code>offset</code>: map 到的文件内容的 offset<span class="mojikumi-line-end">，</span>必须是 page size 的倍数</li>
</ul>
<p>在 <code>MAP_<wbr>ANONYMOUS</code> 时<span class="mojikumi-line-end">，</span>最好将 <code>fd</code> 设为 -1<span class="mojikumi-line-end">、</span><code>offset</code> 设为 0<span class="mojikumi-line-start">（</span>在有的实现中这是必须的<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<p>失败时 <code>mmap</code> 会返回 <code>MAP_FAILED</code><span class="mojikumi-line-end">。</span></p>
<p><code>int<wbr> <wbr>munmap<wbr>(<wbr>void<wbr> *<wbr>addr<wbr>, <wbr>size_t<wbr> <wbr>length<wbr>)</code>: 将自 <code>addr</code> 起 <code>length</code> 长的范围内的 mapping 删除<span class="mojikumi-line-end">，</span>以后再访问就会 segmentation fault<span class="mojikumi-line-end">。</span><code>addr</code> 必须是 page size 的倍数<span class="mojikumi-line-end">。</span></p>
<h2 id="dynamic-memory-allocation" class="heading"><a href="#dynamic-memory-allocation" class="heading-anchor" aria-label="章节： Dynamic Memory Allocation" tabindex="-1"></a><span>Dynamic Memory Allocation</span></h2>
<h3 id="动态分配的相关函数" class="heading"><a href="#动态分配的相关函数" class="heading-anchor" aria-label="章节： 动态分配的相关函数" tabindex="-1"></a><span>动态分配的相关函数</span></h3>
<p>在 C 语言中<span class="mojikumi-line-end">，</span>可以用 <code>malloc</code> 和 <code>free</code> 来获取 / 释放动态分配的内存<span class="mojikumi-line-end">。</span>可以使用 <code>calloc</code> 来初始化分配到的内存并在使用乘法计算内存大小时检测是否发生溢出<span class="mojikumi-line-end">。</span>可以使用 <code>realloc</code> 来给一块动态分配的内存调整大小<span class="mojikumi-line-end">。</span>详见 <code>man malloc</code><span class="mojikumi-line-end">。</span></p>
<p>为了让动态分配得到的内存可以用于任何数据类型<span class="mojikumi-line-end">，</span>地址会以 double word 对齐<span class="mojikumi-line-end">，</span>即 32 位系统对齐到 8 的倍数<span class="mojikumi-line-end">，</span>64 位系统对齐到 16 的倍数<span class="mojikumi-line-end">。</span></p>
<p>操作系统使用 <code>brk</code> 指针来指向 heap 的结尾<span class="mojikumi-line-end">，</span>可以通过 <code>sbrk</code> 函数来增大 heap<span class="mojikumi-line-end">。</span></p>
<h3 id="allocator-的要求和目标" class="heading"><a href="#allocator-的要求和目标" class="heading-anchor" aria-label="章节： allocator 的要求和目标" tabindex="-1"></a><span>allocator 的要求和目标</span></h3>
<p>Dynamic memory allocator 会将 heap 划分为若干大小不等的 block<span class="mojikumi-line-end">，</span>每个 block 要么 allocated 要么 free<span class="mojikumi-line-end">。</span></p>
<p>allocator 需要做到<span class="mojikumi-line-end">：</span></p>
<ul>
<li>能够处理以任意顺序发送的 allocate 和 free 请求<span class="mojikumi-line-start">（</span>不能对顺序做任何假定<span class="mojikumi-line-end">）</span></li>
<li>立即对请求做出响应<span class="mojikumi-line-start">（</span>不能离线<span class="mojikumi-line-end">）</span></li>
<li>只使用 heap 存储数据<span class="mojikumi-line-start">（</span>不能将数据存储在虚存的其他位置<span class="mojikumi-line-end">）</span></li>
<li>满足对齐要求<span class="mojikumi-line-start">（</span>能够存储任何类型的数据<span class="mojikumi-line-end">）</span></li>
<li>不能修改或移动 allocated block<span class="mojikumi-line-start">（</span>可以修改 free block 或者 heap 中不是 block 的区域<span class="mojikumi-line-end">）</span></li>
</ul>
<p>而 allocator 有两个性能方面的目标<span class="mojikumi-line-end">：</span></p>
<ol>
<li>更快地响应请求<span class="mojikumi-line-start">（</span>更大的吞吐量<span class="mojikumi-line-end">）</span></li>
<li>更高效地利用内存</li>
</ol>
<p>其中<span class="mojikumi-line-end">，</span>导致内存利用率低的主要原因是 <i>fragmentation</i><span class="mojikumi-line-end">：</span></p>
<ul>
<li>internal fragmentation: 实际分配的 allocated block 比 alloc 请求中申请的大</li>
<li>external fragmentation: 所有 free block 加起来大小足够<span class="mojikumi-line-end">，</span>但每单个 free block 都不够大<span class="mojikumi-line-end">，</span>导致需要使用更多 heap 空间</li>
</ul>
<h3 id="一种简单的-allocator-实现方式" class="heading"><a href="#一种简单的-allocator-实现方式" class="heading-anchor" aria-label="章节： 一种简单的 allocator 实现方式" tabindex="-1"></a><span>一种简单的 allocator 实现方式</span></h3>
<h4 id="block-header" class="heading"><a href="#block-header" class="heading-anchor" aria-label="章节： block header" tabindex="-1"></a><span>block header</span></h4>
<p>allocator 需要记录 block 的信息<span class="mojikumi-line-end">，</span>而只能使用 heap 空间<span class="mojikumi-line-end">，</span>所以直接在 block 的开头记录 block header<span class="mojikumi-line-end">，</span>即 block size 以及是否 allocated<span class="mojikumi-line-end">。</span></p>
<p>因为地址有对齐要求<span class="mojikumi-line-end">，</span>block size 的最低几位一定是 0<span class="mojikumi-line-end">，</span>就可以用最低位来存 allocated bit<span class="mojikumi-line-end">。</span></p>
<p>block size 充当了单向链表的作用<span class="mojikumi-line-end">。</span>如果想访问 free block<span class="mojikumi-line-end">，</span>就得访问每个 block 再看是否 free<span class="mojikumi-line-end">，</span>所以这样的结构被称作 <i>implicit free list</i><span class="mojikumi-line-end">。</span></p>
<h4 id="placement-policy" class="heading"><a href="#placement-policy" class="heading-anchor" aria-label="章节： placement policy" tabindex="-1"></a><span>placement policy</span></h4>
<p>allocate 时需要找到一个足够大的 free block<span class="mojikumi-line-end">，</span>allocator 进行这样的搜索的方式称作 <i>placement policy</i><span class="mojikumi-line-end">：</span></p>
<ul>
<li>first fit<span class="mojikumi-line-end">：</span>从头开始找<span class="mojikumi-line-end">，</span>直到找到足够大的 free block</li>
<li>next fit<span class="mojikumi-line-end">：</span>从上次搜索结束的地方开始找<span class="mojikumi-line-end">，</span>直到找到足够大的 free block</li>
<li>best fit<span class="mojikumi-line-end">：</span>遍历所有 free block<span class="mojikumi-line-end">，</span>使用足够大的 free block 中最小的</li>
</ul>
<p>使用 implicit free list 时<span class="mojikumi-line-end">，</span>next fit 比 first fit 吞吐量更大但内存利用率更低<span class="mojikumi-line-end">，</span>best fit 内存利用率最好但吞吐量最差<span class="mojikumi-line-end">。</span></p>
<h4 id="分割-free-block" class="heading"><a href="#分割-free-block" class="heading-anchor" aria-label="章节： 分割 free block" tabindex="-1"></a><span>分割 free block</span></h4>
<p>如果 allocate 时 free block 的剩余空间比需要的空间大<span class="mojikumi-line-end">，</span>且大的超过一个 block 的 minimum size (double word)<span class="mojikumi-line-end">，</span>就可以将这个 block 分为两半<span class="mojikumi-line-end">，</span>一半用作 allocated block<span class="mojikumi-line-end">，</span>另一半为 free block<span class="mojikumi-line-end">。</span></p>
<h4 id="获取更多的-heap-空间" class="heading"><a href="#获取更多的-heap-空间" class="heading-anchor" aria-label="章节： 获取更多的 heap 空间" tabindex="-1"></a><span>获取更多的 heap 空间</span></h4>
<p>如果已有的 heap 空间无法满足 allocate 请求<span class="mojikumi-line-end">，</span>可以使用 <code>sbrk</code> 来获取更多的 heap 空间<span class="mojikumi-line-end">，</span>并将新得到的空间设为 free block<span class="mojikumi-line-end">。</span></p>
<h4 id="合并-free-block" class="heading"><a href="#合并-free-block" class="heading-anchor" aria-label="章节： 合并 free block" tabindex="-1"></a><span>合并 free block</span></h4>
<p>如果很多 free block 相邻地放在一起<span class="mojikumi-line-end">，</span>可能会造成 <i>false fragmentation</i><span class="mojikumi-line-end">，</span>即合并后能放下但每个单独无法放下<span class="mojikumi-line-end">，</span>所以需要对相邻的 free block 进行合并 (coalesce)<span class="mojikumi-line-end">。</span></p>
<p>合并有两种策略<span class="mojikumi-line-end">：</span></p>
<ul>
<li>immediate coalescing<span class="mojikumi-line-end">：</span>每次 free 时都将新得到的 free block 与相邻的 free block 合并<span class="mojikumi-line-end">，</span>这样的话每时每刻都不会有相邻的 free block</li>
<li>deferred coalescing<span class="mojikumi-line-end">：</span>等到某个时候再合并<span class="mojikumi-line-end">，</span>例如在未能找到足够大的 free block 时</li>
</ul>
<p>immediate coalescing 的实现较为简单<span class="mojikumi-line-end">，</span>可以在常数时间内完成<span class="mojikumi-line-end">，</span>但可能会导致反复的合并和分割<span class="mojikumi-line-end">，</span>带来不必要的性能损失<span class="mojikumi-line-end">。</span></p>
<p>合并时需要知道上一个 block 的信息<span class="mojikumi-line-end">，</span>这可以通过在 block 尾部添加一个与 header 内容相同的 footer 来实现<span class="mojikumi-line-end">，</span>这被称作使用 <i>boundary tags</i><span class="mojikumi-line-end">。</span>由于只有 free block 需要 footer<span class="mojikumi-line-end">，</span>可以省去 allocated block 的 footer<span class="mojikumi-line-end">，</span>而在 header 中存储上一块的 allocated bit<span class="mojikumi-line-end">，</span>来节省空间<span class="mojikumi-line-end">。</span></p>
<h3 id="explicit-free-list" class="heading"><a href="#explicit-free-list" class="heading-anchor" aria-label="章节： explicit free list" tabindex="-1"></a><span>explicit free list</span></h3>
<p>可以在 free block 中存储指向前驱后继的指针来维护一个 free block 的链表<span class="mojikumi-line-end">，</span>称作 <i>explicit free list</i><span class="mojikumi-line-end">。</span></p>
<p>这个 list 可以是 LIFO 的或者按地址顺序的<span class="mojikumi-line-end">。</span>LIFO 的 list 可以在常数时间内完成 free 操作<span class="mojikumi-line-end">，</span>而按地址顺序的 list 需要使用线性时间来找到一个 block 在 list 中的位置<span class="mojikumi-line-end">，</span>但内存利用率更高<span class="mojikumi-line-end">。</span></p>
<p>由于需要足够大的空间来存储前驱后继的指针<span class="mojikumi-line-end">，</span>explicit free list 的 minimum block size 更大<span class="mojikumi-line-end">，</span>可能会出现更严重的 internal fragmentation 导致内存利用率下降<span class="mojikumi-line-end">。</span></p>
<h3 id="segregated-free-lists" class="heading"><a href="#segregated-free-lists" class="heading-anchor" aria-label="章节： segregated free lists" tabindex="-1"></a><span>segregated free lists</span></h3>
<p>可以将 block 按 size 分类<span class="mojikumi-line-end">，</span>例如按 2 的次幂分类<span class="mojikumi-line-end">，</span>每一类维护一个 list<span class="mojikumi-line-end">。</span>具体实现方式有很多<span class="mojikumi-line-end">，</span>例如 simple segregated storage 和 segregated fits<span class="mojikumi-line-end">。</span></p>
<h4 id="simple-segregated-storage" class="heading"><a href="#simple-segregated-storage" class="heading-anchor" aria-label="章节： simple segregated storage" tabindex="-1"></a><span>simple segregated storage</span></h4>
<p>每一类的所有 block 都是这一类的最大 size<span class="mojikumi-line-end">，</span>如果一类 block 用光了就申请新的 heap 空间<span class="mojikumi-line-end">，</span>free 时直接放回相应的 list<span class="mojikumi-line-end">，</span>不合并也不分割<span class="mojikumi-line-end">。</span></p>
<p>这样的话<span class="mojikumi-line-end">，</span>header 和 footer 都不需要了<span class="mojikumi-line-end">，</span>只需在 free block 里存放一个后继指针即可<span class="mojikumi-line-end">，</span>但 internal fragmentation 和 external fragmentation 都很严重<span class="mojikumi-line-end">。</span></p>
<h4 id="segregated-fit" class="heading"><a href="#segregated-fit" class="heading-anchor" aria-label="章节： segregated fit" tabindex="-1"></a><span>segregated fit</span></h4>
<p>每一类中有不同大小的 block<span class="mojikumi-line-end">，</span>有分割和合并<span class="mojikumi-line-end">。</span>allocate 时从相应的类别开始找<span class="mojikumi-line-end">，</span>在一类中找不到就继续找下一类<span class="mojikumi-line-end">，</span>这样近似于 best-fit search<span class="mojikumi-line-end">，</span>但速度很快<span class="mojikumi-line-end">。</span></p>
<p>segregated fit 的综合性能较好<span class="mojikumi-line-end">，</span>所以包括 libc 中的 <code>malloc</code> 函数在内的 allocator 往往选择使用 segregated fit<span class="mojikumi-line-end">。</span></p>
<h4 id="buddy-system" class="heading"><a href="#buddy-system" class="heading-anchor" aria-label="章节： buddy system" tabindex="-1"></a><span>buddy system</span></h4>
<p>所有 block size 都是 2 的次幂<span class="mojikumi-line-end">，</span>分割时每次分成两半直到大小合适<span class="mojikumi-line-end">，</span>合并时只和 <span class="mojikumi">“</span>buddy<span class="mojikumi">”</span> 合并<span class="mojikumi-line-end">。</span></p>
<p>这里描述清楚可能比较复杂<span class="mojikumi-line-end">，</span>就感性理解一下<span class="mojikumi-line-end">，</span>所有的 block 会形成一个如下图所示树状的样子<span class="mojikumi-line-start">（</span>有点树状数组的感觉<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>parent 相同的 block 就是 buddy<span class="mojikumi-line-end">。</span></p>
<p><picture><source type="image/webp" srcset="/assets/buddy-system.955de85d.webp"><img srcset="/assets/buddy-system.2fd53174.png" loading="lazy" src="/assets/buddy-system.2fd53174.png" width="321" height="158" alt="buddy system"></picture></p>
<p>这样的话<span class="mojikumi-line-end">，</span>搜索和合并会比较快速<span class="mojikumi-line-end">，</span>但由于 block size 都是 2 的次幂<span class="mojikumi-line-end">，</span>可能出现严重的 internal fragmentation<span class="mojikumi-line-end">。</span></p>
<h3 id="平衡树维护-free-block" class="heading"><a href="#平衡树维护-free-block" class="heading-anchor" aria-label="章节： 平衡树维护 free block" tabindex="-1"></a><span>平衡树维护 free block</span></h3>
<p>CS:APP 中没有提到这种方式<span class="mojikumi-line-end">，</span>但只要理解了上面这几种 free list<span class="mojikumi-line-end">，</span>就很好理解<span class="mojikumi-line-end">，</span>free block 不一定要用链表维护<span class="mojikumi-line-end">，</span>也可以用平衡树维护<span class="mojikumi-line-end">：</span>在 free block 中存放树的节点所需的 children<span class="mojikumi-line-end">、</span>parent 等信息<span class="mojikumi-line-end">，</span>就可以高效实现严格的 best fit<span class="mojikumi-line-end">，</span>复杂度也不会像 segregated fit 一样在极端情况下发生退化<span class="mojikumi-line-end">。</span>但是树的节点需要的信息往往比链表多<span class="mojikumi-line-end">，</span>可能会让 minimum block size 增大到 6 个 word<span class="mojikumi-line-end">。</span></p>
<p>我自己写 malloc lab 的时候试着写了个 Splay<span class="mojikumi-line-end">，</span>发现一般情况下还是比 segregated fit 慢不少<span class="mojikumi-line-end">，</span>内存利用率也不一定有明显提升<span class="mojikumi-line-end">，</span>不知道其他平衡树 / 特殊场景下性能如何<span class="mojikumi-line-end">。</span>倒是在网上看到有说红黑树可以在 malloc lab 拿高分<span class="mojikumi-line-start">（</span><s>谁用好的算法拿高分啊<span class="mojikumi-line-end">，</span>不是考验对着数据调参的能力吗<span class="mojikumi-line-end">，</span>我觉得我对数据过拟合的 segregated fit 分已经够高了</s><span class="mojikumi">）</span><wbr><span class="mojikumi-line-start">（</span><s>虚假的 segregated fit<span class="mojikumi-line-end">：</span>按 block size segregate 来寻找 fit<span class="mojikumi-line-end">；</span>真正的 segregated fit<span class="mojikumi-line-end">：</span>按测试数据 segregate 分别进行 fit</s><span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<h3 id="malloc-lab" class="heading"><a href="#malloc-lab" class="heading-anchor" aria-label="章节： malloc lab" tabindex="-1"></a><span>malloc lab</span></h3>
<p>CS:APP 经典 lab 的代码似乎是可以公开的<span class="mojikumi-line-start">（</span></p>
<p><a href="https://github.com/ouuan/course-assignments/tree/master/csapp/malloc-lab">https<wbr>://<wbr>github<wbr>.<wbr>com<wbr>/<wbr>ouuan<wbr>/<wbr>course<wbr>-<wbr>assignments<wbr>/<wbr>tree<wbr>/<wbr>master<wbr>/<wbr>csapp<wbr>/<wbr>malloc<wbr>-<wbr>lab</a></p>
<h2 id="garbage-collection" class="heading"><a href="#garbage-collection" class="heading-anchor" aria-label="章节： Garbage Collection" tabindex="-1"></a><span>Garbage Collection</span></h2>
<p>可以通过 block 之间以及 stack<span class="mojikumi-line-end">、</span>register<span class="mojikumi-line-end">、</span>global 变量对 block 的引用关系找到不可达的 block 而进行 garbage collection<span class="mojikumi-line-end">。</span></p>
<p>在 C 中<span class="mojikumi-line-end">，</span>由于没有类型信息<span class="mojikumi-line-end">，</span>可能会将非指针类型的数据视作对 block 的引用<span class="mojikumi-line-end">，</span>导致不可达的 block 被视作可达<span class="mojikumi-line-end">，</span>所以 C 语言的 garbage collection 只能是 conservative 的<span class="mojikumi-line-end">。</span></p></section><div class="article-style my-9"><hr></div><footer><div class="my-6 b-l-6 b-gray-4 bg-area p-6 shadow dark:b-gray-11" itemprop="copyrightNotice"><ul class="flex flex-col gap-1"><li class="flex gap-1"><span class="shrink-0">文章作者:</span><a href="https://github.com/ouuan" rel="author">ouuan</a></li><li class="flex gap-1"><span class="shrink-0">原文链接:</span><a href="https://ouuan.moe/post/2022/11/csapp-9" rel="canonical" class="break-all">https://ouuan.moe/post/2022/11/csapp-9</a></li><li class="flex gap-1"><span class="shrink-0">许可协议:</span><span> 本文采用 <span class="article-style"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.zh" class="font-sans" itemprop="license">CC BY-SA 4.0</a></span> 许可协议进行授权，未满足 <span class="underline decoration-dotted" title="简而言之，转载时必须标明出处（本文的链接），标明是转载而非原创，标明作了哪些修改，并使用相同的许可协议，但无需私信征求许可">许可协议要求</span> 不得转载。 </span></li><li class="flex gap-1"><span class="shrink-0">额外说明:</span><span>本文包含若干截自 CS:APP 中的图片，本文作者对其不拥有版权。</span></li></ul></div></footer></article><div class="my-6 print:hidden" itemprop="comment" itemscope="" itemtype="https://schema.org/Comment"><ile-root id="ile-4"></ile-root><script></script><script type="module" async="">import{h as r,c as m}from"/assets/iles.d16725a3.js";import{_ as o}from"/assets/GiscusCommentsInner.4e768edd.js";import"/assets/vendor-vue.1fb1cc54.js";import"/assets/vite.5ce4fca4.js";import"/assets/useTheme.e8b3aa5c.js";import"/assets/site.b21fb919.js";r(m,o,"ile-4",{term:"CS:APP 第九章学习笔记"},{});
</script></div><nav class="my-6 flex justify-between gap-6 print:hidden lg:text-justify"><div class="flex flex-1"><a class="flex items-center gap-1 hover:text-hover" href="/post/2022/11/csapp-8"><span class="i-mdi-chevron-left"></span><span class="sr-only">上一篇</span><span class="break-anywhere">CS:APP 第八章学习笔记</span></a></div><div class="flex flex-1 justify-end"><a class="flex flex-row-reverse items-center gap-1 hover:text-hover" href="/post/2022/12/csapp-6"><span class="i-mdi-chevron-right"></span><span class="sr-only">下一篇</span><span class="break-anywhere">CS:APP 第六章学习笔记</span></a></div></nav></div><ile-root id="ile-5"><div class="flex print:hidden"><aside style="max-height:calc(100vh - 10rem);" id="__toc" class="sticky top-16 m-4 hidden w-72 rd-2 bg-card py-6 shadow xl:block 2xl:w-84 3xl:w-96" aria-label="文章目录" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPSideBar"><div class="mb-3 flex flex-wrap items-center justify-between gap-2 pl-8 pr-4"><div class="flex items-center"><h2 class="text-xl font-bold"> 文章目录 </h2><button id="__toc-close" class="flex items-center px-1 text-xl" title="关闭目录" aria-controls="__toc" aria-expanded="true"><span class="i-mdi-close"></span></button></div><div><label class="ml-auto flex items-center gap-1"><span>展开全部</span><input type="checkbox"></label></div></div><div style="max-height:calc(100% - 2rem);" class="overflow-auto overscroll-contain pl-8 pr-4"><ol data-v-c5806953=""><li id="__toc-item-physical-and-virtual-addressing" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#physical-and-virtual-addressing" data-v-c5806953=""><span data-v-c5806953="">Physical and Virtual Addressing</span></a></li><li id="__toc-item-address-spaces" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#address-spaces" data-v-c5806953=""><span data-v-c5806953="">Address Spaces</span></a></li><li id="__toc-item-vm-as-a-tool-for-caching" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#vm-as-a-tool-for-caching" data-v-c5806953=""><span data-v-c5806953="">VM as a Tool for Caching</span></a></li><li id="__toc-item-vm-as-a-tool-for-memory-management" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#vm-as-a-tool-for-memory-management" data-v-c5806953=""><span data-v-c5806953="">VM as a Tool for Memory Management</span></a></li><li id="__toc-item-vm-as-a-tool-for-memory-protection" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#vm-as-a-tool-for-memory-protection" data-v-c5806953=""><span data-v-c5806953="">VM as a Tool for Memory Protection</span></a></li><li id="__toc-item-address-translation" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#address-translation" data-v-c5806953=""><span data-v-c5806953="">Address Translation</span></a></li><li id="__toc-item-case-study-core-i7-address-translation" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#case-study-core-i7-address-translation" data-v-c5806953=""><span data-v-c5806953="">Case Study: Core i7 Address Translation</span></a></li><li id="__toc-item-linux-virtual-memory-system" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#linux-virtual-memory-system" data-v-c5806953=""><span data-v-c5806953="">Linux Virtual Memory System</span></a></li><li id="__toc-item-memory-mapping" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#memory-mapping" data-v-c5806953=""><span data-v-c5806953="">Memory Mapping</span></a></li><li id="__toc-item-dynamic-memory-allocation" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#dynamic-memory-allocation" data-v-c5806953=""><span data-v-c5806953="">Dynamic Memory Allocation</span></a></li><li id="__toc-item-garbage-collection" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#garbage-collection" data-v-c5806953=""><span data-v-c5806953="">Garbage Collection</span></a></li></ol></div></aside><button style="display:none;" id="__toc-open" title="显示文章目录" class="bottom-24 text-lg floating-button" aria-haspopup="dialog" aria-controls="__toc" aria-expanded="true"><span class="i-mdi-menu"></span></button></div></ile-root><script></script><script type="module" async="">import{h as r,c as g}from"/assets/iles.d16725a3.js";import{_ as u}from"/assets/TableOfContents.e445cc36.js";import"/assets/vendor-vue.1fb1cc54.js";import"/assets/vite.5ce4fca4.js";r(g,u,"ile-5",function(e,l,t,s,a,i,o){return{headings:[{level:l,title:"Physical and Virtual Addressing",slug:"physical-and-virtual-addressing"},{level:l,title:"Address Spaces",slug:"address-spaces"},{level:l,title:"VM as a Tool for Caching",slug:"vm-as-a-tool-for-caching"},{level:e,title:s,slug:s},{level:e,title:"page table",slug:"page-table"},{level:e,title:"page fault",slug:"page-fault"},{level:l,title:"VM as a Tool for Memory Management",slug:"vm-as-a-tool-for-memory-management"},{level:l,title:"VM as a Tool for Memory Protection",slug:"vm-as-a-tool-for-memory-protection"},{level:l,title:"Address Translation",slug:"address-translation"},{level:l,title:"Case Study: Core i7 Address Translation",slug:"case-study-core-i7-address-translation"},{level:l,title:"Linux Virtual Memory System",slug:"linux-virtual-memory-system"},{level:a,title:"segmentation fault vs protection exception",slug:"segmentation-fault-vs-protection-exception"},{level:l,title:"Memory Mapping",slug:"memory-mapping"},{level:e,title:"fork 的原理",slug:"fork-的原理"},{level:e,title:"execve 的原理",slug:"execve-的原理"},{level:a,title:"关于共享库的 map 方式",slug:"关于共享库的-map-方式"},{level:e,title:i,slug:i},{level:l,title:"Dynamic Memory Allocation",slug:"dynamic-memory-allocation"},{level:e,title:o,slug:o},{level:e,title:"allocator 的要求和目标",slug:"allocator-的要求和目标"},{level:e,title:"一种简单的 allocator 实现方式",slug:"一种简单的-allocator-实现方式"},{level:t,title:"block header",slug:"block-header"},{level:t,title:"placement policy",slug:"placement-policy"},{level:t,title:"分割 free block",slug:"分割-free-block"},{level:t,title:"获取更多的 heap 空间",slug:"获取更多的-heap-空间"},{level:t,title:"合并 free block",slug:"合并-free-block"},{level:e,title:"explicit free list",slug:"explicit-free-list"},{level:e,title:"segregated free lists",slug:"segregated-free-lists"},{level:t,title:"simple segregated storage",slug:"simple-segregated-storage"},{level:t,title:"segregated fit",slug:"segregated-fit"},{level:t,title:"buddy system",slug:"buddy-system"},{level:e,title:"平衡树维护 free block",slug:"平衡树维护-free-block"},{level:e,title:"malloc lab",slug:"malloc-lab"},{level:l,title:"Garbage Collection",slug:"garbage-collection"}]}}(3,2,4,"page",6,"mmap","动态分配的相关函数"),{});
</script></div></main><footer class="flex flex-col gap-1 bg-card p-6 text-footer" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPFooter"><div class="flex flex-wrap items-center justify-center gap-x-1"><span>Copyright ©</span><span>2022 - 2023</span><a class="flex items-center" href="/sponsor" title="赞赏支持"><span class="i-mdi-heart text-red dark:text-red-7"></span></a><span>ouuan</span><span class="i-mdi-circle-small"></span><span title="实际上，为了保护用户隐私，同一用户的多次访问只有在同一天内使用同一浏览器在同一ip下才会被算作同一人"> 共有 <ile-root id="ile-6"><span><span class="i-mdi-loading motion-safe:animate-spin"></span><span class="sr-only">加载中</span></span></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.d16725a3.js";import"/assets/vendor-vue.1fb1cc54.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.d16725a3.js").then(o=>o.v),["assets/iles.d16725a3.js","assets/vendor-vue.1fb1cc54.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/VisitorCount.ff1168a7.js"),["assets/VisitorCount.ff1168a7.js","assets/VisitorCount.9aa34bd6.js","assets/vendor-vue.1fb1cc54.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-6",{},{})});export default E();
</script> 人到访过这里 </span></div><div class="flex flex-wrap items-center justify-center gap-x-1"> 基于 <a class="underline" href="https://github.com/ElMassimo/iles">îles</a> 及 <a class="underline" href="https://github.com/ouuan/iles-blog/blob/master/package.json">很多其他项目</a><span class="i-mdi-circle-small"></span><span>由 ouuan 设计/制作</span><span class="i-mdi-circle-small"></span><a class="underline" href="https://github.com/ouuan/iles-blog">源代码</a><span class="i-mdi-circle-small"></span><a class="underline" href="https://github.com/ouuan/iles-blog/discussions">Discussions</a></div></footer><meta itemprop="copyrightYear" content="2022 - 2023"><div class="hidden" itemscope="" itemtype="https://schema.org/Person" itemprop="copyrightHolder"><meta itemprop="name" content="ouuan"><meta itemprop="givenName" content="Yufan"><meta itemprop="familyName" content="You"><meta itemprop="url" content="https://github.com/ouuan"><link itemprop="gender" href="https://schema.org/Male"><meta itemprop="image" content="/android-chrome-512x512.png"></div><ile-root id="ile-7"><button class="group bottom-10 flex-col floating-button" title="前往底部"><div aria-hidden="true" class="flex justify-center"><span class="i-mdi-chevron-double-up motion-safe:transition-font-size text-0"></span></div><div aria-hidden="true" class="text-0 group-hover:text-3.5 motion-safe:transition-font-size"></div><div aria-hidden="false" class="flex justify-center"><span class="i-mdi-chevron-double-down motion-safe:transition-font-size text-5 group-hover:text-3"></span></div></button></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.d16725a3.js";import"/assets/vendor-vue.1fb1cc54.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.d16725a3.js").then(o=>o.v),["assets/iles.d16725a3.js","assets/vendor-vue.1fb1cc54.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/BackToTop.f8640a7b.js"),["assets/BackToTop.f8640a7b.js","assets/vendor-vue.1fb1cc54.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-7",{},{})});export default E();
</script><div class="hidden"></div><ile-root id="ile-8"></ile-root><script></script><script type="module" async="">var p=(t,a)=>()=>(a||t((a={exports:{}}).exports,a),a.exports);var e=(t,a,_)=>new Promise((c,n)=>{var f=o=>{try{i(_.next(o))}catch(r){n(r)}},l=o=>{try{i(_.throw(o))}catch(r){n(r)}},i=o=>o.done?c(o.value):Promise.resolve(o.value).then(f,l);i((_=_.apply(t,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.d16725a3.js";import"/assets/vendor-vue.1fb1cc54.js";var u=p(m=>{const E=()=>e(m,null,function*(){return(yield d(()=>import("/assets/iles.d16725a3.js").then(t=>t.d),["assets/iles.d16725a3.js","assets/vendor-vue.1fb1cc54.js","assets/vite.5ce4fca4.js"])).default}),h=()=>e(m,null,function*(){return(yield d(()=>import("/assets/PlausibleTrigger.bd4fd35f.js"),["assets/PlausibleTrigger.bd4fd35f.js","assets/plausible.7ba80cbe.js","assets/vendor-vue.1fb1cc54.js","assets/vite.5ce4fca4.js"])).onLoad});s(E,h,"ile-8",{},{})});export default u();
</script><div></div><ile-root id="ile-9"></ile-root><script></script><script type="module" async="">var p=(t,a)=>()=>(a||t((a={exports:{}}).exports,a),a.exports);var e=(t,a,_)=>new Promise((c,n)=>{var f=o=>{try{i(_.next(o))}catch(r){n(r)}},l=o=>{try{i(_.throw(o))}catch(r){n(r)}},i=o=>o.done?c(o.value):Promise.resolve(o.value).then(f,l);i((_=_.apply(t,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.d16725a3.js";import"/assets/vendor-vue.1fb1cc54.js";var u=p(m=>{const E=()=>e(m,null,function*(){return(yield d(()=>import("/assets/iles.d16725a3.js").then(t=>t.d),["assets/iles.d16725a3.js","assets/vendor-vue.1fb1cc54.js","assets/vite.5ce4fca4.js"])).default}),h=()=>e(m,null,function*(){return(yield d(()=>import("/assets/TextJustifyFix.4fa5e997.js"),[])).onLoad});s(E,h,"ile-9",{},{})});export default u();
</script><meta itemprop="inLanguage" content="zh-CN"></div>
  
</body></html>