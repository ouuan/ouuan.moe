<!DOCTYPE html><html lang="zh-CN"><head>
    <meta charset="UTF-8">
<title>CNATDA 第三章学习笔记 - ouuan's blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="



《Computer Networking: A Top-Down Approach (8th Edition)》第三章 “Transport Layer” 的学习笔记。
">
<meta property="og:url" content="https://ouuan.moe/post/2023/06/cnatda-3">
<meta property="og:site_name" content="ouuan's blog">
<meta property="og:title" content="CNATDA 第三章学习笔记 · ouuan's blog">
<meta property="og:description" content="



《Computer Networking: A Top-Down Approach (8th Edition)》第三章 “Transport Layer” 的学习笔记。
">
<meta property="twitter:domain" content="ouuan.moe">
<meta property="twitter:title" content="CNATDA 第三章学习笔记 · ouuan's blog">
<meta property="twitter:description" content="



《Computer Networking: A Top-Down Approach (8th Edition)》第三章 “Transport Layer” 的学习笔记。
">
<meta property="twitter:url" content="https://ouuan.moe/post/2023/06/cnatda-3">
<style>html:not(.dark):not(.light) { visibility: hidden; } body { visibility: hidden; }</style>
<script>(() => { let dark; try { const theme = localStorage && localStorage.getItem('vueuse-color-scheme'); if (theme === 'dark') dark = true; else if (theme === 'light') dark = false; else dark = window.matchMedia('(prefers-color-scheme: dark)').matches; } catch (e) { dark = false; } document.documentElement.classList.add(dark ? 'dark' : 'light'); })()</script>
<noscript><style>@media (prefers-color-scheme: light) { :root:not(.dark):not(.light) { color-scheme: light; --text-color: #232637; --bg-color: #DEE6EE; --card-color: #EFF3F7; --link-color: #1E66B8; --hover-color: #2E80DD; --active-color: #164C89; --bghover-color: #D6E0EA; --popup-color: #F7F9FB; --footer-color: #5F627B; --area-color: #E1E2E8; --nested-color: #F0F0F3; } } @media (prefers-color-scheme: dark) { :root:not(.dark):not(.light) { color-scheme: dark; --text-color: #E6EDF2; --bg-color: #0D0E15; --card-color: #1F2130; --link-color: #8BB8EC; --hover-color: #A2C6F0; --active-color: #74AAE8; --bghover-color: #353853; --popup-color: #2C2F45; --footer-color: #9699AE; --area-color: #2F313D; --nested-color: #3C3E4E; } } html { visibility:visible !important; }</style></noscript>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="canonical" href="https://ouuan.moe/post/2023/06/cnatda-3">
<link rel="alternate" type="application/rss+xml" href="/feed.xml" title="RSS Feed - ouuan's blog">
<link rel="alternate" type="application/atom+xml" href="/feed.atom" title="Atom Feed - ouuan's blog">
<link rel="alternate" type="application/json" href="/feed.json" title="JSON Feed - ouuan's blog">
<link rel="dns-prefetch" href="https://plausible.ouuan.moe">
<link rel="preconnect" href="https://blog-visitor-count.ouuan.moe">
<link rel="stylesheet" href="/vendors/katex/katex.css">
<link rel="sitemap" href="https://ouuan.moe/sitemap.xml">
<meta name="author" content="ouuan">
<meta name="twitter:creator" content="@ouuan">
<meta name="twitter:card" content="summary">
<meta property="og:image" content="https://ouuan.moe/images/2023/06/cnatda-3.png">
<meta property="generator" content="îles">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-06-24T11:29:55.000Z">
<meta property="article:modified_time" content="2023-07-05T14:29:05.000Z">
<meta property="article:author" content="ouuan">
<meta property="article:tag" content="cnatda">
<meta property="article:tag" content="学习笔记">
<link rel="preconnect" href="https://giscus.app">
<link rel="dns-prefetch" href="https://avatars.githubusercontent.com">
    <link rel="stylesheet" href="/assets/style-cfd49c27.css">
    
  <link rel="modulepreload" href="/assets/iles.e381640b.js" crossorigin=""><link rel="modulepreload" href="/assets/vendor-vue.bda4d3d4.js" crossorigin=""><link rel="modulepreload" href="/assets/vite.5ce4fca4.js" crossorigin=""><link rel="modulepreload" href="/assets/SearchBar.a9e18075.js" crossorigin=""><link rel="modulepreload" href="/assets/PostHead.26f9e680.js" crossorigin=""><link rel="modulepreload" href="/assets/VisitorCount.065e72b2.js" crossorigin=""><link rel="modulepreload" href="/assets/site.b21fb919.js" crossorigin=""><link rel="modulepreload" href="/assets/GiscusCommentsInner.b6b2a6ec.js" crossorigin=""><link rel="modulepreload" href="/assets/useTheme.546d36da.js" crossorigin=""><link rel="modulepreload" href="/assets/TableOfContents.ee0e2b18.js" crossorigin=""><style>@font-face { font-family: "Noto Serif SC Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Regular.unique.47909eed.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Regular.unique.52c7117e.woff') format('woff'); unicode-range: U+0-9f7f; } @font-face { font-family: "Noto Serif SC Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Regular.common.79ca374e.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Regular.common.2a06c596.woff') format('woff'); unicode-range: U+0-ff1b; } @font-face { font-family: "Noto Serif SC Web Font"; font-weight: 700; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Bold.unique.f9d370e7.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Bold.unique.6068567a.woff') format('woff'); unicode-range: U+0-90e8; } @font-face { font-family: "Noto Serif SC Web Font"; font-weight: 700; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Bold.common.8d2c4ede.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Bold.common.7f011ba7.woff') format('woff'); unicode-range: U+0-7684; }</style><link rel="preload" href="/assets/fonts/NotoSerifSC-Regular.unique.47909eed.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/NotoSerifSC-Regular.common.79ca374e.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/NotoSerifSC-Bold.unique.f9d370e7.woff2" as="font" type="font/woff2" crossorigin=""><link rel="preload" href="/assets/fonts/NotoSerifSC-Bold.common.8d2c4ede.woff2" as="font" type="font/woff2" crossorigin=""></head>
  <body itemscope="" itemtype="https://schema.org/ItemPage">
    <div id="app"><header class="bg-card shadow print:hidden" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPHeader"><div class="flex flex-wrap justify-center whitespace-nowrap px-4 page-container sm:flex-nowrap"><div class="flex basis-full items-stretch justify-center sm:mr-3 sm:basis-auto"><a class="flex items-center p-3 text-xl font-serif bghover" href="/"><span>ouuan<span class="mojikumi-narrow-left">’</span>s blog</span></a></div><nav class="flex"><ul class="flex"><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/"><span>首页</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/posts"><span>文章</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/tags"><span>标签</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/about"><span>关于</span></a></li></ul></nav><div class="sm:basis-full"></div><ul class="flex"><li class="flex"><ile-root id="ile-1"><div class="flex items-stretch lg:hidden"><a class="flex items-center p-2 bghover" href="/search" title="全站搜索"><span class="i-mdi-magnify text-xl"></span></a></div><form role="search" class="hidden items-stretch justify-center lg:flex"><div class="flex items-center"><input value="" class="w-48 rd-full bg-area px-3 py-1" type="search" placeholder="关键词" aria-label="全站搜索"></div><a class="flex items-center p-2 bghover" href="/search?q=" title="全站搜索"><span class="i-mdi-magnify text-xl"></span></a></form></ile-root><script></script><script type="module" async="">import{h as r,c as a}from"/assets/iles.e381640b.js";import{_ as m}from"/assets/SearchBar.a9e18075.js";import"/assets/vendor-vue.bda4d3d4.js";import"/assets/vite.5ce4fca4.js";r(a,m,"ile-1",{},{});
</script></li><li class="flex items-stretch"><a class="flex items-center p-2 bghover" href="/feed.xml" title="RSS 订阅"><span class="i-mdi-rss text-xl"></span></a></li><li class="flex"><ile-root id="ile-2"><div class="relative flex items-stretch"><button title="暗色模式设置" class="flex items-center p-2 bghover" aria-haspopup="menu" aria-controls="__theme-switcher" aria-expanded="false"><span class="i-mdi-theme-light-dark text-xl"></span></button><ul style="display:none;" id="__theme-switcher" class="absolute right-0 top-full z-20 whitespace-nowrap rd-1 bg-popup shadow-md" role="menu" aria-label="暗色模式选项"><li class="bghover" role="menuitemradio" aria-checked="true"><button class="flex items-center p-1 text-hover"><span class="i-mdi-cellphone md:i-mdi-tablet lg:i-mdi-monitor mr-1"></span><span>跟随系统</span></button></li><li class="bghover" role="menuitemradio" aria-checked="false"><button class="flex items-center p-1"><span class="i-mdi-white-balance-sunny mr-1"></span><span>总是亮色</span></button></li><li class="bghover" role="menuitemradio" aria-checked="false"><button class="flex items-center p-1"><span class="i-mdi-weather-night mr-1"></span><span>总是暗色</span></button></li></ul></div></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(o=>o.v),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/ThemeSwitcher.9b91f8bf.js"),["assets/ThemeSwitcher.9b91f8bf.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js","assets/useTheme.546d36da.js"])).default});s(u,v,"ile-2",{},{})});export default E();
</script></li></ul></div></header><main class="min-h-100vh py-6 page-container" itemprop="mainContentOfPage" itemscope="" itemtype="https://schema.org/WebPageElement"><div class="flex justify-center"><div class="grow m-4 standard-card max-w-200"><article itemprop="mainEntity" itemscope="" itemtype="https://schema.org/BlogPosting"><div class="hidden" itemscope="" itemtype="https://schema.org/Person" itemprop="author"><meta itemprop="name" content="ouuan"><meta itemprop="givenName" content="Yufan"><meta itemprop="familyName" content="You"><meta itemprop="url" content="https://github.com/ouuan"><link itemprop="gender" href="https://schema.org/Male"><meta itemprop="image" content="/android-chrome-512x512.png"></div><meta itemprop="mainEntityOfPage" content="https://ouuan.moe/post/2023/06/cnatda-3"><meta itemprop="image" content="https://ouuan.moe/images/2023/06/cnatda-3.png"><ile-root id="ile-3" class="my-12"><header class="my-12" data-v-4039c18a=""><h1 class="mb-3 mt-6 text-center text-8" itemprop="headline" data-v-4039c18a=""><span class="inline-block font-serif break-anywhere" data-v-4039c18a="">CNATDA 第三章学习笔记</span></h1><div class="flex flex-wrap justify-center gap-x-4 gap-y-1 text-footer md:text-sm" data-v-4039c18a=""><span class="flex items-center" title="创建于 2023-06-20 20:50:58 GMT+8" data-v-4039c18a=""><span class="i-mdi-folder-plus-outline mr-1" data-v-4039c18a=""></span><span class="sr-only" data-v-4039c18a="">创建于</span><a class="hover:underline" href="https://github.com/ouuan/iles-blog/blob/master/src/pages/post/2023/06/cnatda-3.mdx?plain=1" data-v-4039c18a=""><time datetime="2023-06-20T20:50:58+08:00" itemprop="dateCreated" data-v-4039c18a="">2023-06-20</time></a></span><span class="flex items-center" title="修改于 2023-07-05 22:29:05 GMT+8" data-v-4039c18a=""><span class="i-mdi-update mr-1" data-v-4039c18a=""></span><span class="sr-only" data-v-4039c18a="">修改于</span><a class="hover:underline" href="https://github.com/ouuan/iles-blog/commits/master/src/pages/post/2023/06/cnatda-3.mdx" data-v-4039c18a=""><time datetime="2023-07-05T22:29:05+08:00" itemprop="dateModified" data-v-4039c18a="">2023-07-05</time></a></span><span class="flex items-center" title="访问量" data-v-4039c18a=""><span class="i-mdi-eye-outline mr-1" data-v-4039c18a=""></span><span class="sr-only" data-v-4039c18a="">访问量</span><span data-v-4039c18a="">40</span></span><span class="flex flex-wrap justify-center gap-x-2 gap-y-1" data-v-4039c18a=""><span title="标签: cnatda" class="flex items-center" itemprop="keywords" data-v-4039c18a=""><span class="i-mdi-tag-outline mr-1" data-v-4039c18a=""></span><span class="sr-only" data-v-4039c18a="">标签</span><a href="/tag/cnatda" class="hover:underline" data-v-4039c18a="">cnatda</a></span><span title="标签: 学习笔记" class="flex items-center" itemprop="keywords" data-v-4039c18a=""><span class="i-mdi-tag-outline mr-1" data-v-4039c18a=""></span><span class="sr-only" data-v-4039c18a="">标签</span><a href="/tag/学习笔记" class="hover:underline" data-v-4039c18a="">学习笔记</a></span></span></div></header></ile-root><script></script><script type="module" async="">import{h as t,c as a}from"/assets/iles.e381640b.js";import e from"/assets/PostHead.26f9e680.js";import"/assets/vendor-vue.bda4d3d4.js";import"/assets/vite.5ce4fca4.js";import"/assets/VisitorCount.065e72b2.js";import"/assets/site.b21fb919.js";t(a,e,"ile-3",{class:"my-12",href:"/post/2023/06/cnatda-3",filename:"src/pages/post/2023/06/cnatda-3.mdx",frontmatter:{title:"CNATDA 第三章学习笔记",date:new Date(1687265458e3),image:"/images/2023/06/cnatda-3.png",tags:["cnatda","学习笔记"],lastUpdated:new Date(1688567345e3),published:new Date(1687606195e3),visitor:40,description:`



《Computer Networking: A Top-Down Approach (8th Edition)》第三章 “Transport Layer” 的学习笔记。
`}},{});
</script><section class="article-style" itemprop="articleBody">



<p><span class="mojikumi-line-start">《</span>Computer Networking: A Top-Down Approach (8th Edition)<span class="mojikumi-line-end">》</span>第三章 <span class="mojikumi">“</span>Transport Layer<span class="mojikumi">”</span> 的学习笔记<span class="mojikumi-line-end">。</span></p>

<h2 id="introduction-and-transport-layer-services" class="heading"><a href="#introduction-and-transport-layer-services" class="heading-anchor" aria-label="章节： Introduction and Transport-Layer Services" tabindex="-1"></a><span>Introduction and Transport-Layer Services</span></h2>
<p>transport layer 将 application-layer message 封装于 transport-layer segment<span class="mojikumi-line-end">，</span>然后交给 network layer 进行传输<span class="mojikumi-line-end">，</span>将 network layer 提供的 host-to-host logical communication 扩展为了 process-to-process (application-to-application) logical communication<span class="mojikumi-line-end">。</span></p>
<p>Internet 的 network-layer protocol 是 Internet Protocol (IP)<span class="mojikumi-line-end">，</span>IP 提供的是 <span class="mojikumi">“</span>best-effort delivery service<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>就是说它会尽力但并不保证 datagram 能成功传输<span class="mojikumi-line-end">，</span>也不保证传输到的顺序以及数据的完整性<span class="mojikumi-line-end">、</span>正确性<span class="mojikumi-line-end">。</span></p>
<p>UDP 仅提供 process-to-process delivery 和 error checking<span class="mojikumi-line-end">，</span>同样是一个 unreliable service<span class="mojikumi-line-end">。</span>TCP 在 UDP 的基础上还提供 reliable data transfer 和 congestion control<span class="mojikumi-line-end">。</span></p>
<a id="segment-or-datagram" name="segment-or-datagram" aria-hidden="true"></a>
<aside role="note" data-v-a2ab257f=""><div class="shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue" data-v-a2ab257f=""><div class="p-3 flex justify-between items-center" data-v-a2ab257f=""><h3 class="flex items-center gap-1 font-bold" data-v-a2ab257f=""><span class="text-5 i-mdi-pencil text-blue" data-v-a2ab257f=""></span><span class="sr-only" data-v-a2ab257f="">Note: </span><span data-v-a2ab257f="">segment or datagram?</span></h3><!--v-if--></div><div class="overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover" data-v-a2ab257f=""><p>在 CNATDA 中<span class="mojikumi-line-end">，</span>network layer packet 被统称为 <span class="mojikumi">“</span>segment<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>但一般应当是 TCP 的 packet 被称作 <span class="mojikumi">“</span>segment<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>而 UDP 的 packet 被称作 <span class="mojikumi">“</span>datagram<span class="mojikumi">”</span><wbr><span class="mojikumi-line-start">（</span>UDP 名字中的 <span class="mojikumi">“</span>D<span class="mojikumi">”</span> 就是 <span class="mojikumi">“</span>datagram<span class="mojikumi">”</span><span class="mojikumi">）</span><span class="mojikumi-line-end">。</span>为了方便<span class="mojikumi-line-end">，</span>我也将 network layer packet 统称为 <span class="mojikumi">“</span>segment<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>但在特指时<span class="mojikumi-line-end">，</span>称作 <span class="mojikumi">“</span>TCP segment<span class="mojikumi">”</span><span class="mojikumi">、</span><wbr><span class="mojikumi-line-start">“</span>UDP datagram<span class="mojikumi">”</span> 和 <span class="mojikumi">“</span>IP datagram<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>语境明确时也可能略去协议名<span class="mojikumi-line-end">。</span></p></div></div></aside>
<h2 id="multiplexing-and-demultiplexing" class="heading"><a href="#multiplexing-and-demultiplexing" class="heading-anchor" aria-label="章节： Multiplexing and Demultiplexing" tabindex="-1"></a><span>Multiplexing and Demultiplexing</span></h2>
<p><dfn>multiplexing</dfn> 指的是将多个信道的信息合并到一个信道进行传输<span class="mojikumi-line-end">，</span>而 <dfn>demultiplexing</dfn> 指的是将这个合并后的信息再拆分到多个信道去<span class="mojikumi-line-end">。</span></p>
<p>一般来说<span class="mojikumi-line-end">，</span>一个 host 会有很多 application 从而有很多 socket<span class="mojikumi-line-end">，</span>但只有一个 transport layer 以及一个 network layer<span class="mojikumi-line-end">。</span></p>
<ul>
<li>在发送方<span class="mojikumi-line-end">，</span>transport layer 从多个 socket 收集 message 并发送给 network layer 的过程被称作 multiplexing<span class="mojikumi-line-end">；</span></li>
<li>在接收方<span class="mojikumi-line-end">，</span>transport layer 从 network layer 接收到 message 后传递给正确的 socket 的过程被称作 demultiplexing<span class="mojikumi-line-end">。</span></li>
</ul>
<p>multiplexing 以及 demultiplexing 需要每个 socket 有 unique identifier<span class="mojikumi-line-end">：</span></p>
<ul>
<li>在 UDP 中<span class="mojikumi-line-end">，</span>只以 port 作为 socket identifier</li>
<li>在 TCP 中<span class="mojikumi-line-end">，</span>以 destination port 和 source IP 作为 socket identifier</li>
</ul>
<h2 id="connectionless-transport-udp" class="heading"><a href="#connectionless-transport-udp" class="heading-anchor" aria-label="章节： Connectionless Transport: UDP" tabindex="-1"></a><span>Connectionless Transport: UDP</span></h2>
<p>UDP 仅提供 multiplexing and demultiplexing 以及 error checking<span class="mojikumi-line-end">，</span>但在一些 application 中它比 TCP 更加适合<span class="mojikumi-line-end">，</span>主要因为下列原因<span class="mojikumi-line-end">：</span></p>
<ul>
<li>更好地控制何时发送数据<span class="mojikumi-line-end">、</span>发送什么数据<span class="mojikumi-line-end">：</span>TCP 有 congestion control<span class="mojikumi-line-end">，</span>可能会延迟发送的时间<span class="mojikumi-line-end">；</span>在传输失败时会重新发送<span class="mojikumi-line-end">，</span>可能耗时很久才传输成功<span class="mojikumi-line-end">。</span></li>
<li>无需建立连接<span class="mojikumi-line-end">：</span>建立 TCP connection 会产生 delay<span class="mojikumi-line-end">。</span></li>
<li>无连接状态<span class="mojikumi-line-end">：</span>保存 TCP connection state 需要占用系统资源<span class="mojikumi-line-end">。</span></li>
<li>small header overhead<span class="mojikumi-line-end">：</span>TCP segment header 有 20 byte 的 overhead<span class="mojikumi-line-end">，</span>UDP 只有 8 byte<span class="mojikumi-line-end">。</span></li>
</ul>
<p>一些使用 UDP 的例子<span class="mojikumi-line-end">：</span></p>
<ul>
<li>DNS 使用 UDP 来避免建立 TCP 连接的 delay<span class="mojikumi-line-end">。</span></li>
<li>在 HTTP/3 中<span class="mojikumi-line-end">，</span>使用基于 UDP 的 application-layer protocol QUIC 来提供 reliable data transfer 并避免建立 TCP 连接的 delay<span class="mojikumi-line-end">。</span></li>
<li>在 network management (SNMP) 中<span class="mojikumi-line-end">，</span>使用 UDP 以在网络非常拥堵时发送消息<span class="mojikumi-line-end">。</span></li>
<li>在 multimedia application 尤其是即时通话中经常会使用 UDP<span class="mojikumi-line-end">，</span>因为对延时敏感而 loss-tolerant<span class="mojikumi-line-end">。</span></li>
</ul>
<p>但是<span class="mojikumi-line-end">，</span>尤其是传输 multimedia 时<span class="mojikumi-line-end">，</span>在没有 congestion control 的情况下传输大量数据可能导致网络拥堵<span class="mojikumi-line-end">，</span>进而导致 UDP 大量丢包而 TCP 传输缓慢<span class="mojikumi-line-end">。</span></p>
<p>UDP datagram 的结构为<span class="mojikumi-line-end">：</span></p>
<ul>
<li>source port (16 bits)</li>
<li>destination port (16 bits)</li>
<li>length (16 bits): 整个 datagram<span class="mojikumi-line-start">（</span>包含 header 和 data<span class="mojikumi-line-end">）</span>的 byte 数</li>
<li>checksum (16 bits)<span class="mojikumi-line-end">：</span>将 UDP datagram 以及 IP header 的一些 field 以 16 bits 为单位视作 ones<span class="mojikumi-narrow-left">’</span> complement integer 加在一起<span class="mojikumi-line-start">（</span>即在进位时加 1<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>最后取反<span class="mojikumi-line-start">（</span>即按位取反<span class="mojikumi">）</span><span class="mojikumi-line-end">；</span>校验时只需检查 sum 是否全 1</li>
<li>application data (message)</li>
</ul>
<p>UDP 的 checksum 只能用来进行 error detecting<span class="mojikumi-line-end">，</span>不能用来进行 error correcting<span class="mojikumi-line-end">，</span>错误时可以直接扔掉或者通知 application<span class="mojikumi-line-end">。</span></p>
<p>虽然在很多 link-layer protocol 中也有 error checking<span class="mojikumi-line-end">，</span>但并不能保证一路上所有 link 都有 error checking<span class="mojikumi-line-end">；</span>并且<span class="mojikumi-line-end">，</span>error 可能不是在 link-to-link 的传输过程中产生的<span class="mojikumi-line-end">，</span>例如可能是存储在 router 中时产生的<span class="mojikumi-line-end">。</span>所以<span class="mojikumi-line-end">，</span>UDP 要提供 checksum<span class="mojikumi-line-end">，</span>这也是体现了 end-to-end principle 的一个例子<span class="mojikumi-line-end">。</span></p>
<h2 id="principles-of-reliable-data-transfer" class="heading"><a href="#principles-of-reliable-data-transfer" class="heading-anchor" aria-label="章节： Principles of Reliable Data Transfer" tabindex="-1"></a><span>Principles of Reliable Data Transfer</span></h2>
<a id="关于这部分的详细程度" name="关于这部分的详细程度" aria-hidden="true"></a>
<aside role="note" data-v-a2ab257f=""><div class="shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue" data-v-a2ab257f=""><div class="p-3 flex justify-between items-center" data-v-a2ab257f=""><h3 class="flex items-center gap-1 font-bold" data-v-a2ab257f=""><span class="text-5 i-mdi-info-circle-outline text-blue" data-v-a2ab257f=""></span><span class="sr-only" data-v-a2ab257f="">Info: </span><span data-v-a2ab257f="">关于这部分的详细程度</span></h3><!--v-if--></div><div class="overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover" data-v-a2ab257f=""><p>这部分我写的比较简略<span class="mojikumi-line-end">，</span>仅作为摘要<span class="mojikumi-line-end">，</span>更循序渐进的讲解以及实现细节等需要看书<span class="mojikumi-line-end">。</span></p></div></div></aside>
<h3 id="stop-and-wait" class="heading"><a href="#stop-and-wait" class="heading-anchor" aria-label="章节： Stop-And-Wait" tabindex="-1"></a><span>Stop-And-Wait</span></h3>
<p>在 stop-and-wait protocol 中<span class="mojikumi-line-end">，</span>sender 每次确认 receiver 收到了 packet 才会发下一个 packet<span class="mojikumi-line-end">。</span></p>
<ol>
<li>checksum: 传输过程中可能出错<span class="mojikumi-line-end">，</span>需要进行 error detection</li>
<li>acknowledgment (ACK):
<ul>
<li>需要告诉 sender 没有丢包</li>
<li>收到 packet 时需要告诉 sender 是否出错</li>
</ul>
</li>
<li>retransmission: 未收到 ACK 或收到 negative acknowledgment (NAK) 时需要重新传输</li>
<li>sequence number: retransmission 可能是因为 ACK 的传输出了问题<span class="mojikumi-line-end">，</span>这会导致 duplicate packet<span class="mojikumi-line-end">，</span>sequence number 的作用之一是识别 duplicate packet<span class="mojikumi-line-end">；</span>在 stop-and-wait protocol 中<span class="mojikumi-line-end">，</span>用 0/1 作为 sequence number 即可<span class="mojikumi-line-end">，</span>这也被称作 <i>alternating-bit protocol</i></li>
<li>timeout: 丢包需要通过超时来检测<span class="mojikumi-line-end">，</span>超时了就 retransmit<span class="mojikumi-line-end">；</span>如果等待太久性能会受影响<span class="mojikumi-line-end">，</span>所以 timeout 一般被设为较有可能是丢包的值而非几乎能确定是丢包的值</li>
<li>ACK with sequence number: 通过超时检测丢包可能带来 duplicate packet<span class="mojikumi-line-start">（</span>ACK 传输出错或用时过长<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>需要通过在 ACK 中加入 sequence number 来标识 acknowledge 的是哪个 packet<span class="mojikumi-line-end">，</span>以此也可以通过上一个 packet 的 ACK 代替表示当前 packet 出错的 NAK</li>
</ol>
<h3 id="pipelined-reliable-data-transfer" class="heading"><a href="#pipelined-reliable-data-transfer" class="heading-anchor" aria-label="章节： Pipelined Reliable Data Transfer" tabindex="-1"></a><span>Pipelined Reliable Data Transfer</span></h3>
<p>stop-and-wait 虽然 work<span class="mojikumi-line-end">，</span>但每次都要等上一个 packet 成功传输才能传下一个<span class="mojikumi-line-end">，</span>性能太差<span class="mojikumi-line-end">。</span></p>
<p>同时传输多个 packet 被称作 <i>pipelining</i><span class="mojikumi-line-end">，</span>这意味着<span class="mojikumi-line-end">：</span></p>
<ul>
<li>sequence number 需要更大的值域<span class="mojikumi-line-start">（</span>不止是 1 bit 的 0/1<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>至少正在传输的这些 packet 需要互不相同的 sequence number</li>
<li>sender 需要 buffer 以支持多个 packet 的 retransmission<span class="mojikumi-line-end">，</span>receiver 也可能需要 buffer</li>
</ul>
<p>有两种基础的实现方法<span class="mojikumi-line-end">：</span>go-back-n (GBN) 和 selective repeat (SR)<span class="mojikumi-line-end">。</span></p>
<h3 id="go-back-n" class="heading"><a href="#go-back-n" class="heading-anchor" aria-label="章节： Go-Back-N" tabindex="-1"></a><span>Go-Back-N</span></h3>
<p>receiver: 只接受按正确顺序依次收到的 packet<span class="mojikumi-line-end">，</span>顺序错误的 packet 直接扔掉<span class="mojikumi-line-start">（</span>顺序正确但有 error 的 packet 通过发送上一个 packet 的 ACK 进行 negative acknowledgment<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<p>sender:</p>
<ul>
<li>有一个 sliding window 表示当前有效的 sequence number 范围</li>
<li>window 内前一半已发送尚未收到 ACK<span class="mojikumi-line-end">，</span>后一半 sequence number 尚未使用</li>
<li>如果 window 内所有 sequence number 均已被使用<span class="mojikumi-line-end">，</span>将不能发送新的 packet</li>
<li>收到的 ACK 被视作 <i>cumulative acknowledgment</i><span class="mojikumi-line-end">，</span>即在这个 ACK 的 sequence number 之前的 packet 也被视作已 ACK</li>
<li>收到 ACK 时将 window 滑动到这个 ACK 之后</li>
<li>所有未 ACK 的 packet 共用一个 timer</li>
<li>retransmit 时发送 window 内所有尚未 ACK 的 packet</li>
</ul>
<p>GBN 的好处是 receiver 不需要 buffer<span class="mojikumi-line-end">，</span>坏处是一个 packet 出错就要把整个 window 内的 packet 重新发送<span class="mojikumi-line-end">。</span></p>
<h3 id="selective-repeat" class="heading"><a href="#selective-repeat" class="heading-anchor" aria-label="章节： Selective Repeat" tabindex="-1"></a><span>Selective Repeat</span></h3>
<p>sender:</p>
<ul>
<li>sliding window 与 GBN 类似<span class="mojikumi-line-end">，</span>但前一半中除了开头<span class="mojikumi-line-start">（</span>如果有<span class="mojikumi-line-end">）</span>一定未 ACK<span class="mojikumi-line-end">，</span>后面的可能已 ACK 也可能没有</li>
<li>ACK<span class="mojikumi-line-end">、</span>timer<span class="mojikumi-line-end">、</span>retransmission 都是每个 packet 独立的</li>
<li>收到 window 开头的 ACK 时滑动到首个未 ACK 处<span class="mojikumi-line-start">（</span>如果均已 ACK 则是未使用处<span class="mojikumi-line-end">）</span></li>
</ul>
<p>receiver:</p>
<ul>
<li>也需要维护一个 sliding window<span class="mojikumi-line-end">，</span>但这个 window 和 sender 的不保证一致<span class="mojikumi-line-end">，</span>其开头是尚未收到的最小的 sequence number</li>
<li>收到非 window 开头的 packet 时需要 buffer 下来</li>
<li>收到 window 开头的 packet 时将已 buffer 的 packet 连续段按顺序传给 application<span class="mojikumi-line-end">，</span>并滑动 window</li>
<li>收到 window 开头减去 window 大小到 window 开头减一这个范围内的 packet 时<span class="mojikumi-line-start">（</span>这表示之前对这个 packet 的 ACK 的传输出了问题或者耗时过长<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>也需要 ACK</li>
<li>无论收到的是哪个 packet<span class="mojikumi-line-end">，</span>如果有 error 则直接不管<span class="mojikumi-line-start">（</span>因为 ACK 对每个 packet 独立<span class="mojikumi-line-end">，</span>不能通过设置 ACK 的 sequence number 来表示 negative acknowledgment<span class="mojikumi-line-end">；</span>也可以选择引入 NAK<span class="mojikumi-line-end">，</span>若不引入则只能不管<span class="mojikumi-line-end">）</span></li>
</ul>
<p>需要注意的是<span class="mojikumi-line-end">，</span>由于 sender 和 receiver 的 window 可能不同<span class="mojikumi-line-end">，</span>window 大小不能超过 sequence number 值域的一半<span class="mojikumi-line-end">。</span></p>
<p>最后<span class="mojikumi">，</span><wbr><span class="mojikumi-line-start">（</span>无论是 GBN 还是 SR<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>因为 sequence number 的值域有限<span class="mojikumi-line-start">（</span>循环使用<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>如果一个 duplicate packet (duplicate ACK) 的传输耗时太久<span class="mojikumi-line-end">，</span>可能会占用重复的 sequence number<span class="mojikumi-line-end">，</span>在实践中采取的解决方法一般是在一个 packet 传输了几分钟后便认为它已经没了<span class="mojikumi-line-end">。</span></p>
<h2 id="connection-oriented-transport-tcp" class="heading"><a href="#connection-oriented-transport-tcp" class="heading-anchor" aria-label="章节： Connection-Oriented Transport: TCP" tabindex="-1"></a><span>Connection-Oriented Transport: TCP</span></h2>
<h3 id="the-tcp-connection" class="heading"><a href="#the-tcp-connection" class="heading-anchor" aria-label="章节： The TCP Connection" tabindex="-1"></a><span>The TCP Connection</span></h3>
<p>TCP connection 在两个 end system 中都建立了一些 state variable<span class="mojikumi-line-end">，</span>但它只是 logical connection<span class="mojikumi-line-end">，</span>并没有在 network core 中建立 circuit<span class="mojikumi-line-start">（</span>与 circuit-switched network 不同<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<p>TCP connection 是 full-duplex 的<span class="mojikumi-line-end">，</span>即建立连接后双方都可以向对方发送信息<span class="mojikumi-line-end">；</span>是 point-to-point 的<span class="mojikumi-line-end">，</span>即不能 multicasting<span class="mojikumi-line-end">。</span></p>
<p>TCP connection 是通过 <i>three-way handshake</i> 建立的<span class="mojikumi-line-end">。</span>通过 TCP 发送 message 时会先放入 send buffer<span class="mojikumi-line-end">，</span>接收到 message 时会先放入 receive buffer<span class="mojikumi-line-end">。</span></p>
<p>TCP 会根据 maximum transmission unit (MTU<span class="mojikumi-line-end">，</span>link-layer frame 的最大 size) 计算出合适的 maximum segment size (MSS<span class="mojikumi-line-end">，</span>segment 包含的 data (application message) 的最大 size) 使得 data 加上 TCP header 和 IP header 后不超过 MTU<span class="mojikumi-line-end">。</span></p>
<h3 id="tcp-segment-structure" class="heading"><a href="#tcp-segment-structure" class="heading-anchor" aria-label="章节： TCP Segment Structure" tabindex="-1"></a><span>TCP Segment Structure</span></h3>
<p>TCP segment 的结构如下图所示<span class="mojikumi-line-end">：</span><sup><a href="#user-content-fn-fig-3.29" id="user-content-fnref-fig-3.29" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></p>
<p><picture><source type="image/webp" srcset="/assets/cnatda-fig-3.29.c8a13933.webp"><img srcset="/assets/cnatda-fig-3.29.2ff11b60.png" loading="lazy" src="/assets/cnatda-fig-3.29.2ff11b60.png" width="812" height="652" alt="TCP segment structure"></picture></p>
<p>其中 <span class="mojikumi">“</span>options<span class="mojikumi">”</span> 是可选且可变长的<span class="mojikumi-line-end">，</span>所以 TCP header 是可变长的<span class="mojikumi-line-end">，</span>但一般是 20 byte<span class="mojikumi-line-end">。</span></p>
<p>各项的含义<span class="mojikumi-line-start">（</span>部分<span class="mojikumi-line-end">）</span>见下文<span class="mojikumi-line-end">。</span></p>
<h3 id="sequence-numbers-and-acknowledgment-numbers" class="heading"><a href="#sequence-numbers-and-acknowledgment-numbers" class="heading-anchor" aria-label="章节： Sequence Numbers and Acknowledgment Numbers" tabindex="-1"></a><span>Sequence Numbers and Acknowledgment Numbers</span></h3>
<p>TCP 将发送的所有 message 连在一起视作一个无结构但有序的 byte stream<span class="mojikumi-line-end">，</span>segment 的 sequence number 表示的是 message 的第一个 byte 在 byte stream 中的位置<span class="mojikumi-line-end">。</span>双方<span class="mojikumi-line-start">（</span>client 和 server<span class="mojikumi-line-end">）</span>的 sequence number 是分别计算的<span class="mojikumi-line-end">。</span></p>
<p>为了尽量避免 sequence number 与留存在网络中的其他 segment 发生冲突<span class="mojikumi-line-end">，</span>以及其他安全原因<span class="mojikumi-line-end">，</span>一次连接中的首个 byte 的 sequence number 一般不是 0<span class="mojikumi-line-end">，</span>而是随机选择<span class="mojikumi-line-end">。</span></p>
<p>acknowledgment number 是期待收到的下个<span class="mojikumi-line-start">（</span>尚未收到的首个<span class="mojikumi-line-end">）</span>byte 的 sequence number<span class="mojikumi-line-end">，</span>是 cumulative acknowledgment<span class="mojikumi-line-end">。</span></p>
<p>收到顺序错误的 segment 时<span class="mojikumi-line-end">，</span>TCP 没有规定如何处理<span class="mojikumi-line-end">，</span>但一般都会 buffer 下来<span class="mojikumi-line-end">。</span></p>
<p>一个 segment 中可以同时包含 acknowledgment 和 data<span class="mojikumi-line-end">，</span>这时 acknowledgment 被称作 <span class="mojikumi">“</span>piggybacked on the data segment<span class="mojikumi">”</span><span class="mojikumi-line-end">。</span>也可以只有 acknowledgment 没有 data<span class="mojikumi-line-end">，</span>此时 segment 仍有 sequence number<span class="mojikumi-line-end">，</span>设为下一个 byte 的 sequence number<span class="mojikumi-line-end">。</span></p>
<h3 id="round-trip-time-estimation-and-timeout" class="heading"><a href="#round-trip-time-estimation-and-timeout" class="heading-anchor" aria-label="章节： Round-Trip Time Estimation and Timeout" tabindex="-1"></a><span>Round-Trip Time Estimation and Timeout</span></h3>
<p>一个 segment 的 sample RTT (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></span>) 指的是 segment 进入 network layer 直到 acknowledgment 被接收的用时<span class="mojikumi-line-end">。</span></p>
<p>在多数 TCP implementation 中<span class="mojikumi-line-end">，</span>在计算一个 segment 的 sample RTT 时不会再去计算正在同时传输的其他 segment 的 sample RTT<span class="mojikumi-line-end">，</span>并且只会计算一次就传输成功的 segment 的 sample RTT<span class="mojikumi-line-end">，</span>不会计算 retransmission 的 sample RTT<span class="mojikumi-line-end">。</span></p>
<p>estimated RTT (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span></span>) 是计算出的这些 sample RTT 的 exponential weighted moving average (EWMA)<span class="mojikumi-line-end">，</span>用来平缓 RTT 的波动<span class="mojikumi-line-end">：</span><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>←</mo><mfrac><mn>7</mn><mn>8</mn></mfrac><mi>e</mi><mo>+</mo><mfrac><mn>1</mn><mn>8</mn></mfrac><mi>s</mi></mrow><annotation encoding="application/x-tex">e \gets \frac 78 e + \frac 18 s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">s</span></span></span></span></span></p>
<p>dev RTT (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></span>) 用来衡量 RTT 波动的大小<span class="mojikumi-line-end">：</span><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>←</mo><mfrac><mn>3</mn><mn>4</mn></mfrac><mi>d</mi><mo>+</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mi mathvariant="normal">∣</mi><mi>s</mi><mo>−</mo><mi>e</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">d \gets \frac 34 d + \frac 14 |s - e|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∣</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mord">∣</span></span></span></span></span></p>
<p>timeout interval (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span></span>) 在 estimated RTT 的基础上根据 dev RTT 提供了一定的冗余<span class="mojikumi-line-end">：</span><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>e</mi><mo>+</mo><mn>4</mn><mi>d</mi></mrow><annotation encoding="application/x-tex">t = e + 4d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">4</span><span class="mord mathnormal">d</span></span></span></span></span></p>
<p>timeout interval 的初始值一般是 1 秒<span class="mojikumi-line-end">。</span>在发生 retransmission 时<span class="mojikumi-line-end">，</span>timeout interval 会翻倍<span class="mojikumi-line-end">，</span>而在得到新的 sample RTT 后<span class="mojikumi-line-start">（</span>即某个 segment 一次就传输成功后<span class="mojikumi-line-end">）</span>又会回到正常的计算方式<span class="mojikumi-line-end">。</span></p>
<h3 id="reliable-data-transfer" class="heading"><a href="#reliable-data-transfer" class="heading-anchor" aria-label="章节： Reliable Data Transfer" tabindex="-1"></a><span>Reliable Data Transfer</span></h3>
<p>TCP 一般只使用一个 retransmission timer<span class="mojikumi-line-end">，</span>用来给 oldest segment 计时<span class="mojikumi-line-end">。</span></p>
<p>虽然 TCP 和 GBN 有些类似<span class="mojikumi-line-end">，</span>但 TCP 在 retransmit 时一次只传一个 segment<span class="mojikumi-line-end">，</span>而 receiver 往往也会 buffer 顺序错误的 segment<span class="mojikumi-line-end">。</span></p>
<p>retransmission 在两种情况下发生<span class="mojikumi-line-end">：</span>timeout 或者收到三个 duplicate ACK<span class="mojikumi-line-start">（</span>即相同 sequence number 的第四个 ACK<span class="mojikumi-line-end">；</span>这被称作 <i>fast retransmit</i><span class="mojikumi">）</span><span class="mojikumi-line-end">。</span>这意味着只收到一个或两个 duplicate ACK 的时候还是会等到 timeout 才 retransmit<span class="mojikumi-line-end">，</span>因为这往往意味着只是顺序错误而不是丢包<span class="mojikumi-line-end">。</span><sup><a href="#user-content-fn-fast-retransmit" id="user-content-fnref-fast-retransmit" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup></p>
<p>一般还会实现 delayed ACK<span class="mojikumi-line-end">，</span>即只 ACK 一个 segment 时会尝试等到下一个 segment 一起 ACK<span class="mojikumi-line-start">（</span>但不会等超过 500ms<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span>这样可以减少通信量<span class="mojikumi-line-end">，</span>尤其是经过等待后 ACK 可以被 piggyback 时<span class="mojikumi-line-end">。</span><sup><a href="#user-content-fn-delayed-ack" id="user-content-fnref-delayed-ack" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup>但是 cumulative ACK 以及 duplicate ACK 都会立即发送不会等待<span class="mojikumi-line-end">。</span></p>
<h3 id="flow-control" class="heading"><a href="#flow-control" class="heading-anchor" aria-label="章节： Flow Control" tabindex="-1"></a><span>Flow Control</span></h3>
<p>receiver 有一个 buffer<span class="mojikumi-line-end">，</span>但 application 不一定会立刻从 buffer 中读取<span class="mojikumi-line-end">，</span>如果 application 读得太慢<span class="mojikumi-line-end">，</span>就需要 sender 不要发太快来避免 buffer overflow<span class="mojikumi-line-end">。</span></p>
<p>TCP header 中包含 receive window (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{rwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">rwnd</span></span></span></span></span></span>) 表示 buffer 的剩余空间<span class="mojikumi-line-end">，</span>而 sender 需要保证已发送未被 ACK 的数据总量不超过 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{rwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">rwnd</span></span></span></span></span></span><span class="mojikumi-line-end">。</span></p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{rwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">rwnd</span></span></span></span></span></span> 为 0 会阻断 sender 发送更多 segment<span class="mojikumi-line-end">，</span>而为了让 receiver 有机会告诉 sender 更新后的 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{rwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">rwnd</span></span></span></span></span></span><span class="mojikumi-line-end">，</span>防止通信被一直阻断下去<span class="mojikumi-line-end">，</span>sender 需要发送 probing of zero window<span class="mojikumi-line-end">，</span>即 1 byte 的 data<span class="mojikumi-line-end">，</span>可以以以指数上升的间隔发送<span class="mojikumi-line-end">。</span><sup><a href="#user-content-fn-zero-window-probing-793" id="user-content-fnref-zero-window-probing-793" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup> <sup><a href="#user-content-fn-zero-window-probing-1122" id="user-content-fnref-zero-window-probing-1122" data-footnote-ref="" aria-describedby="footnote-label">5</a></sup><span class="mojikumi-line-start">（</span><s>好多以</s><span class="mojikumi-line-end">）</span></p>
<h3 id="tcp-connection-management" class="heading"><a href="#tcp-connection-management" class="heading-anchor" aria-label="章节： TCP Connection Management" tabindex="-1"></a><span>TCP Connection Management</span></h3>
<p>书上只讲了最基本的情况<span class="mojikumi-line-end">，</span>没有讲各种 corner case<span class="mojikumi-line-end">，</span>说是可以去看<span class="mojikumi-line-start">《</span>TCP/IP Illustrated<span class="mojikumi">》</span><wbr><span class="mojikumi-line-start">（</span></p>
<p>建立 TCP connection<span class="mojikumi-line-end">：</span></p>
<ol>
<li>client 向 server 发 SYN segment: SYN flag set<span class="mojikumi-line-end">，</span>sequence number 是 client ISN<span class="mojikumi-line-start">（</span>initial sequence number<span class="mojikumi-line-end">，</span>第一个 byte 的 sequence number 是 client ISN + 1<span class="mojikumi-line-end">）</span></li>
<li>server 收到 SYN segment<span class="mojikumi-line-end">，</span>建立 buffer 和 state<span class="mojikumi-line-end">，</span>向 client 发 SYNACK segment: SYN flag set<span class="mojikumi-line-end">，</span>ACK 了 SYN segment<span class="mojikumi-line-end">，</span>sequence number 是 server ISN</li>
<li>client 收到 SYNACK segment<span class="mojikumi-line-end">，</span>建立 buffer 和 state<span class="mojikumi-line-end">，</span>向 server 发 SYNACK 的 ACK<span class="mojikumi-line-end">，</span>可以携带 application data</li>
</ol>
<p>或者也可以拆开看<span class="mojikumi-line-end">：</span></p>
<ul>
<li>client 和 server 互发 SYN<span class="mojikumi-line-end">，</span>client 先发<span class="mojikumi-line-end">，</span>SYN 不携带 application data<span class="mojikumi-line-end">，</span>sequence number 用来表示 ISN</li>
<li>收到 SYN 要 ACK<span class="mojikumi-line-end">，</span>ACK 可以 piggyback 到 SYN 或者 application data 上</li>
<li>收到 SYN 时会建立 buffer 以及 state variable</li>
</ul>
<p>在断开连接时<span class="mojikumi-line-end">，</span>双方会互相发送 FIN package (FIN flag set)<span class="mojikumi-line-end">，</span>以及相应的 ACK<span class="mojikumi-line-end">。</span>首先提出断开连接的一方在发送最后一个 ACK 后会等待一段时间<span class="mojikumi-line-start">（</span>一般是 30s<span class="mojikumi-line-end">）</span>再真的断开连接<span class="mojikumi-line-end">，</span>以给对方机会 retransmit FIN segment<span class="mojikumi-line-end">，</span>防止这最后一个 ACK 丢包导致对方一直等着<span class="mojikumi-line-end">。</span></p>
<p>如果尝试连接到一个不接受 TCP 连接的端口<span class="mojikumi-line-end">，</span>会返回 RST flag set 的 segment<span class="mojikumi-line-end">。</span></p>
<a id="syn-flood-attack" name="syn-flood-attack" aria-hidden="true"></a>
<aside role="note" data-v-a2ab257f=""><div class="shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue" data-v-a2ab257f=""><div class="p-3 flex justify-between items-center" data-v-a2ab257f=""><h4 class="flex items-center gap-1 font-bold" data-v-a2ab257f=""><span class="text-5 i-mdi-pencil text-blue" data-v-a2ab257f=""></span><span class="sr-only" data-v-a2ab257f="">Note: </span><span data-v-a2ab257f="">SYN flood attack</span></h4><!--v-if--></div><div class="overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover" data-v-a2ab257f=""><p>如果 server 在收到 SYN 时就建立 buffer 以及 state 会带来遭受 SYN flood attack 的可能<span class="mojikumi-line-end">，</span>即向 server 发送大量 SYN segment 而不发送后续的 ACK<span class="mojikumi-line-end">，</span>从而占用 server 的大量资源<span class="mojikumi-line-end">。</span></p><p>SYN flood attack 的一个防范方式是使用 SYN cookie<span class="mojikumi-line-end">：</span>在收到 SYN segment 时不建立 buffer 以及 state variable 等<span class="mojikumi-line-end">，</span>而是计算 low resolution timestamp + 双方 IP + 双方 port + server secret 的 hash<span class="mojikumi-line-end">，</span>将 timestamp (5 bits) + MSS (encoded to 3 bits) + hash (24 bits) 作为 server ISN<span class="mojikumi-line-end">，</span>在收到 SYN segment 时不建立 buffer 和 state<span class="mojikumi-line-end">，</span>而在收到 ACK 时根据 ACK number 得到 server ISN<span class="mojikumi-line-end">，</span>检查 hash 是否正确并得到 MSS 然后再建立 buffer 和 state<span class="mojikumi-line-end">。</span></p></div></div></aside>
<h2 id="principles-of-congestion-control" class="heading"><a href="#principles-of-congestion-control" class="heading-anchor" aria-label="章节： Principles of Congestion Control" tabindex="-1"></a><span>Principles of Congestion Control</span></h2>
<p>congestion 会导致<span class="mojikumi-line-end">：</span></p>
<ul>
<li>large queue delay</li>
<li>router buffer overflow 会导致丢包以及 retransmission</li>
<li>large delay 会导致 premature timeout 以及 unneeded retransmission</li>
<li>在传输路径上如果在一个 router 处发生了丢包<span class="mojikumi-line-end">，</span>在此之前的 router 的 work 都浪费了</li>
</ul>
<p>congestion control 分为两大类<span class="mojikumi-line-end">：</span></p>
<ul>
<li>end-to-end: 不依赖于 network layer<span class="mojikumi-line-end">，</span>依靠 retransmission 或 delay 增大等现象推断出 congestion<span class="mojikumi-line-end">。</span></li>
<li>network-assisted: router 提供 congestion feedback<span class="mojikumi-line-start">（</span>一个 bit 表示 link 是否 congested<span class="mojikumi-line-end">，</span>或者更复杂的信息<span class="mojikumi-line-end">，</span>例如 available bit rate<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>可以是由 router 发一个新的 packet<span class="mojikumi-line-end">，</span>或者修改正在传输的其他 packet<span class="mojikumi-line-end">，</span>一方收到 feedback 后再发给另一方<span class="mojikumi-line-end">。</span></li>
</ul>
<h2 id="tcp-congestion-control" class="heading"><a href="#tcp-congestion-control" class="heading-anchor" aria-label="章节： TCP Congestion Control" tabindex="-1"></a><span>TCP Congestion Control</span></h2>
<h3 id="classic-tcp-congestion-control" class="heading"><a href="#classic-tcp-congestion-control" class="heading-anchor" aria-label="章节： Classic TCP Congestion Control" tabindex="-1"></a><span>Classic TCP Congestion Control</span></h3>
<p>classic TCP congestion control 是 end-to-end 的<span class="mojikumi-line-end">。</span></p>
<p>TCP 使用 congestion window (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span>) 来限制发送速率<span class="mojikumi-line-end">。</span><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span> 的效果与 receive window (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{rwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">rwnd</span></span></span></span></span></span>) 类似<span class="mojikumi-line-end">，</span>会将 unacknowledged 的数据总量限制在 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mo separator="true">,</mo><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min(\mathrm{cwnd}, \mathrm{rwnd})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">cwnd</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">rwnd</span></span><span class="mclose">)</span></span></span></span></span> 之内<span class="mojikumi-line-end">，</span>从而将发送速率限制在约 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mi mathvariant="normal">/</mi><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">T</mi><mi mathvariant="normal">T</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cwnd} / \mathrm{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span><span class="mord">/</span><span class="mord"><span class="mord mathrm">RTT</span></span></span></span></span></span><span class="mojikumi-line-end">。</span></p>
<p>classic TCP congestion control 的基本原则<span class="mojikumi-line-end">：</span></p>
<ul>
<li>retransmission 是 congestion 的征兆<span class="mojikumi-line-end">，</span>需要减小 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span></li>
<li>segment 被 acknowledge 是没有 congestion 的征兆<span class="mojikumi-line-end">，</span>可以增大 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span></li>
<li>增大 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span> 相当于是在进行试探<span class="mojikumi-line-end">，</span>即不断增大发送速率来试探增大到多大会发生 congestion</li>
</ul>
<p>具体分为三种模式<span class="mojikumi-line-end">：</span></p>
<ul>
<li>slow start: 初始状态以及 timeout 后转移到的状态<span class="mojikumi-line-end">，</span>从 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mo>=</mo><mn>1</mn><mtext>&nbsp;</mtext><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">S</mi><mi mathvariant="normal">S</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cwnd} = 1\ \mathrm{MSS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mspace">&nbsp;</span><span class="mord"><span class="mord mathrm">MSS</span></span></span></span></span></span> 开始<span class="mojikumi-line-end">，</span>每个 RTT <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span> 翻倍<span class="mojikumi-line-end">，</span>直到 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mo>⩾</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">h</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cwnd \geqslant \mathrm{ssthresh}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8311em;vertical-align:-0.1367em;"></span><span class="mord"><span class="mord mathrm">cwnd</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathrm">ssthresh</span></span></span></span></span></span></span><span class="mojikumi-line-end">，</span>转移到 congestion avoidance<span class="mojikumi-line-end">。</span></li>
<li>congestion avoidance: 每个 RTT 内 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span> 增大 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>&nbsp;</mtext><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">S</mi><mi mathvariant="normal">S</mi></mrow></mrow><annotation encoding="application/x-tex">1\ \mathrm{MSS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mspace">&nbsp;</span><span class="mord"><span class="mord mathrm">MSS</span></span></span></span></span></span><span class="mojikumi-line-end">。</span></li>
<li>fast recovery: fast retransmit 后转移到的状态<span class="mojikumi-line-end">，</span>从 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mo>=</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">h</mi></mrow><mo>+</mo><mn>3</mn><mtext>&nbsp;</mtext><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">S</mi><mi mathvariant="normal">S</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cwnd} = \mathrm{ssthresh} + 3\ \mathrm{MSS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathrm">ssthresh</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3</span><span class="mspace">&nbsp;</span><span class="mord"><span class="mord mathrm">MSS</span></span></span></span></span></span> 开始<span class="mojikumi-line-end">，</span>每个 duplicate ACK 都让 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span> 增大 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>&nbsp;</mtext><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">S</mi><mi mathvariant="normal">S</mi></mrow></mrow><annotation encoding="application/x-tex">1\ \mathrm{MSS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mspace">&nbsp;</span><span class="mord"><span class="mord mathrm">MSS</span></span></span></span></span></span><span class="mojikumi-line-end">，</span>直到收到非 duplicate 的新的 ACK<span class="mojikumi-line-end">，</span>转移到 congestion avoidance<span class="mojikumi-line-end">。</span></li>
</ul>
<p>具体细节如下图所示<span class="mojikumi-line-end">：</span><sup><a href="#user-content-fn-fig-3.51" id="user-content-fnref-fig-3.51" data-footnote-ref="" aria-describedby="footnote-label">6</a></sup></p>
<p><picture><source type="image/webp" srcset="/assets/cnatda-fig-3.51.5c10e88c.webp"><img srcset="/assets/cnatda-fig-3.51.26a2bfa1.png" loading="lazy" src="/assets/cnatda-fig-3.51.26a2bfa1.png" width="1315" height="996" alt="FSM description of TCP congestion control"></picture></p>
<p>正常情况下会在 congestion avoidance 和 fast recovery 之间反复切换<span class="mojikumi-line-end">，</span>此时 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span> 的增长是线性的<span class="mojikumi-line-end">，</span>降低是减半<span class="mojikumi-line-end">，</span>称其是 <i>additive-increase, multiplicative-decrease</i> (AIMD) 的<span class="mojikumi-line-end">。</span>AIMD congestion control 会导致 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span> 呈锯齿状变化<span class="mojikumi-line-end">。</span></p>
<p>TCP congestion control 有多个版本<span class="mojikumi-line-end">，</span>上文描述的是 TCP Reno<span class="mojikumi-line-end">，</span>如果用 slow start 来代替 fast recovery 则是更古老的 TCP Tahoe<span class="mojikumi-line-end">。</span></p>
<p>TCP Reno 的锯齿状 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span></span></span></span></span> 变化曲线实际上没能快速恢复到导致 congestion 的临界值<span class="mojikumi-line-end">，</span>会产生较大的浪费<span class="mojikumi-line-end">。</span>一个优化后的版本是 TCP CUBIC<span class="mojikumi-line-end">，</span>它修改了 congestion avoidance 阶段的上升曲线<span class="mojikumi-line-end">，</span>使其是一个三次函数曲线<span class="mojikumi-line-end">，</span>如下图所示<span class="mojikumi-line-end">：</span><sup><a href="#user-content-fn-fig-3.54" id="user-content-fnref-fig-3.54" data-footnote-ref="" aria-describedby="footnote-label">7</a></sup></p>
<p><picture><source type="image/webp" srcset="/assets/cnatda-fig-3.54.bd38af1d.webp"><img srcset="/assets/cnatda-fig-3.54.1d92cc88.png" loading="lazy" src="/assets/cnatda-fig-3.54.1d92cc88.png" width="934" height="632" alt="TCP congestion avoidance sending rates: TCP Reno and TCP CUBIC"></picture></p>
<a id="tcp-splitting" name="tcp-splitting" aria-hidden="true"></a>
<aside role="note" data-v-a2ab257f=""><div class="shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue" data-v-a2ab257f=""><div class="p-3 flex justify-between items-center" data-v-a2ab257f=""><h4 class="flex items-center gap-1 font-bold" data-v-a2ab257f=""><span class="text-5 i-mdi-pencil text-blue" data-v-a2ab257f=""></span><span class="sr-only" data-v-a2ab257f="">Note: </span><span data-v-a2ab257f="">TCP splitting</span></h4><!--v-if--></div><div class="overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover" data-v-a2ab257f=""><p>如果 RTT 过大<span class="mojikumi-line-end">，</span>slow start 可能导致初次连接时 response time 较大<span class="mojikumi-line-start">（</span>一般会有 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>⋅</mo><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">T</mi><mi mathvariant="normal">T</mi></mrow></mrow><annotation encoding="application/x-tex">4 \cdot \mathrm{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">RTT</span></span></span></span></span></span> 左右<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span>TCP splitting 在 client 和 data center 之间增设了一个 frontend server 作为代理<span class="mojikumi-line-end">，</span>frontend server 与 data center 之间建立了 persistent TCP connection 来避免 slow start<span class="mojikumi-line-end">，</span>而 client 和 frontend server 之间的 RTT 较小<span class="mojikumi-line-end">，</span>slow start 的影响就较小<span class="mojikumi-line-end">。</span></p></div></div></aside>
<h3 id="network-assisted-explicit-congestion-notification" class="heading"><a href="#network-assisted-explicit-congestion-notification" class="heading-anchor" aria-label="章节： Network-Assisted Explicit Congestion Notification" tabindex="-1"></a><span>Network-Assisted Explicit Congestion Notification</span></h3>
<p><a href="https://datatracker.ietf.org/doc/html/rfc3168">Explicit Congestion Notification (ECN)</a> 是 network-assisted congestion control 的一种手段<span class="mojikumi-line-end">，</span>它对 TCP 和 IP 都进行了扩展<span class="mojikumi-line-end">。</span></p>
<p>ECN 使用了 IP datagram header 的两个 bit<span class="mojikumi-line-end">，</span>一个用来告诉 router 通信双方是 ECN-capable 的<span class="mojikumi-line-end">，</span>另一个由 router 设置<span class="mojikumi-line-end">，</span>表示自己处于 congestion<span class="mojikumi-line-start">（</span>一般会在丢包实际发生前就设置<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<p>在一方收到 router 的 congestion 信息后<span class="mojikumi-line-end">，</span>会在发给另一方的 ACK segment 里设置 ECE (explicit congestion notification echo) flag<span class="mojikumi-line-end">，</span>另一方收到 ECE 后会将 congestion window 减半<span class="mojikumi-line-end">，</span>并在下一个 segment 里设置 CWR (congestion window reduced) flag<span class="mojikumi-line-end">。</span></p>
<p>除了 TCP<span class="mojikumi-line-end">，</span>还有其他 transport-layer protocol 利用了 ECN<span class="mojikumi-line-end">，</span>例如与 UDP 类似但提供了 congestion control 的 DCCP<span class="mojikumi-line-end">，</span>为 data center 设计的 DCTCP<span class="mojikumi-line-end">、</span>DCQCN 等<span class="mojikumi-line-end">。</span></p>
<h3 id="delayed-based-congestion-control" class="heading"><a href="#delayed-based-congestion-control" class="heading-anchor" aria-label="章节： Delayed-based Congestion Control" tabindex="-1"></a><span>Delayed-based Congestion Control</span></h3>
<p>delay-based congestion control 也能在丢包发生前就检测到 congestion<span class="mojikumi-line-end">。</span></p>
<p>TCP Vegas 会检测历史最大的 throughput<span class="mojikumi-line-start">（</span><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi></mrow><mi mathvariant="normal">/</mi><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">T</mi><mi mathvariant="normal">T</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cwnd} / \mathrm{RTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">cwnd</span></span><span class="mord">/</span><span class="mord"><span class="mord mathrm">RTT</span></span></span></span></span></span><span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>若当前的 throughput 明显小于历史最大值<span class="mojikumi-line-end">，</span>则说明发生了 congestion<span class="mojikumi-line-end">。</span></p>
<p>BBR 的思路类似<span class="mojikumi-line-end">，</span>并采用了一些机制使其在与非 delay-based 的 congestion control 竞争时保持 fair<span class="mojikumi-line-end">。</span>Google 在 2016 年已经在内部的 B4 网络中采用 BBR 替换了 TCP CUBIC<span class="mojikumi-line-end">。</span></p>
<p>此外<span class="mojikumi-line-end">，</span>还有 TIMELY<span class="mojikumi-line-end">、</span>Compound TCP<span class="mojikumi-line-end">、</span>FAST 等 delay-based congestion control protocol<span class="mojikumi-line-end">。</span></p>
<h3 id="fairness" class="heading"><a href="#fairness" class="heading-anchor" aria-label="章节： Fairness" tabindex="-1"></a><span>Fairness</span></h3>
<p>假设有 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span> 个 TCP 连接共用一个 transmission rate 为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></span> 的 bottleneck link<span class="mojikumi-line-end">，</span>并且这个 link 上没有其他数据传输<span class="mojikumi-line-end">。</span>如果每个连接的 throughput 都大约是 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">R/K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="mojikumi-line-end">，</span>则称所使用的 congestion control mechanism 是 fair 的<span class="mojikumi-line-end">。</span></p>
<p>在各方的 RTT 相同且只有 TCP 连接时<span class="mojikumi-line-end">，</span>AIMD congestion control 是 fair 的<span class="mojikumi-line-end">，</span>如下图所示<sup><a href="#user-content-fn-fig-3.57" id="user-content-fnref-fig-3.57" data-footnote-ref="" aria-describedby="footnote-label">8</a></sup><span class="mojikumi-line-end">，</span>addictive increase 是沿 45 度方向的<span class="mojikumi-line-end">，</span>multiplicative decrease 是朝着原点的<span class="mojikumi-line-end">，</span>所以会趋向 fair<span class="mojikumi-line-end">。</span></p>
<p>但是<span class="mojikumi-line-end">，</span>在各方 RTT 不同时<span class="mojikumi-line-end">，</span>RTT 小的往往能获得更大的 throughput<span class="mojikumi-line-end">。</span></p>
<p><picture><source type="image/webp" srcset="/assets/cnatda-fig-3.57.18b0e5dd.webp"><img srcset="/assets/cnatda-fig-3.57.35ca77c5.png" loading="lazy" src="/assets/cnatda-fig-3.57.35ca77c5.png" width="813" height="792" alt="Throughput realized by two TCP connections"></picture></p>
<p>在有 UDP 连接参与时<span class="mojikumi-line-end">，</span>由于 UDP 没有 congestion control<span class="mojikumi-line-end">，</span>可能会导致 unfair<span class="mojikumi-line-end">。</span></p>
<p>上面讨论的 fairness 是对于 connection 而言的<span class="mojikumi-line-end">，</span>而对于 application / host 就不一定 fair 了<span class="mojikumi-line-end">，</span>因为可以建立多个 parallel TCP connection<span class="mojikumi-line-end">，</span>例如浏览器一般就会这样做<span class="mojikumi-line-end">。</span></p>
<h2 id="evolution-of-transport-layer-functionality" class="heading"><a href="#evolution-of-transport-layer-functionality" class="heading-anchor" aria-label="章节： Evolution of Transport-Layer Functionality" tabindex="-1"></a><span>Evolution of Transport-Layer Functionality</span></h2>
<p>虽然 Internet 只有 TCP 和 UDP 两个 transport-layer protocol<span class="mojikumi-line-end">，</span>但 transport-layer functionality 依然在不断演化<span class="mojikumi-line-end">。</span></p>
<p>现在有非常多不同版本的 TCP 实现<span class="mojikumi-line-start">（</span>例如上文提到的 TCP CUBIC<span class="mojikumi-line-end">、</span>BBR 等<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>或是解决了旧版实现中的一些问题<span class="mojikumi-line-end">，</span>或是更适配于特定的应用场景<span class="mojikumi-line-start">（</span>网络环境<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<p>QUIC 是一个基于 UDP 的 application-layer protocol<span class="mojikumi-line-end">，</span>有下列 feature<span class="mojikumi-line-end">：</span></p>
<ul>
<li>需要 handshake 建立连接<span class="mojikumi-line-end">，</span>且所有数据都是加密的<span class="mojikumi-line-end">。</span>connection-establishment handshake 和 authentication and encryption handshake 被合并在了一起<span class="mojikumi-line-end">，</span>从而比 TLS 更快<span class="mojikumi-line-end">。</span></li>
<li>以 stream 为单位传输 application data<span class="mojikumi-line-end">，</span>而多个 stream 可以放在单个 packet 中传输<span class="mojikumi-line-end">。</span></li>
<li>reliable data transfer<span class="mojikumi-line-end">，</span>其中 in-order delivery 是对每个 stream 分别保序<span class="mojikumi-line-end">，</span>所以不同 stream 之间不会带来阻塞 (HOL blocking)<span class="mojikumi-line-end">。</span></li>
<li>与 TCP 类似的 congestion control<span class="mojikumi-line-end">。</span></li>
</ul>
<p>作为一个 application-level protocol<span class="mojikumi-line-end">，</span>QUIC 可以比 transport-layer protocol 更频繁地更新<span class="mojikumi-line-end">。</span></p>
<section data-footnotes="" class="footnotes"><h2 class="sr-only" id="footnote-label">Footnotes</h2>
<ol>
<li id="user-content-fn-fig-3.29">
<p>p231, Figure 3.29: TCP segment structure <a href="#user-content-fnref-fig-3.29" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-fast-retransmit">
<p><a href="https://datatracker.ietf.org/doc/html/rfc2001#section-3">3 Fast Retransmit - RFC2001</a> <a href="#user-content-fnref-fast-retransmit" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-delayed-ack">
<p><a href="https://datatracker.ietf.org/doc/html/rfc1122#page-97">4.2.3.2  When to Send an ACK Segment - RFC1122</a> <a href="#user-content-fnref-delayed-ack" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-zero-window-probing-793">
<p><a href="https://datatracker.ietf.org/doc/html/rfc793#page-42">Managing the Window - RFC793</a> <a href="#user-content-fnref-zero-window-probing-793" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-zero-window-probing-1122">
<p><a href="https://datatracker.ietf.org/doc/html/rfc1122#page-92">4.2.2.17 Probing Zero Windows - RFC1122</a> <a href="#user-content-fnref-zero-window-probing-1122" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-fig-3.51">
<p>p268, Figure 3.51: FSM description of TCP congestion control <a href="#user-content-fnref-fig-3.51" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-fig-3.54">
<p>p272, Figure 3.54: TCP congestion avoidance sending rates: TCP Reno and TCP CUBIC <a href="#user-content-fnref-fig-3.54" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-fig-3.57">
<p>p278, Figure 3.57: Throughput realized by TCP connections 1 and 2 <a href="#user-content-fnref-fig-3.57" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
</ol>
</section></section><div class="article-style my-9"><hr></div><footer><div class="my-6 b-l-6 b-gray-4 bg-area p-6 shadow dark:b-gray-11" itemprop="copyrightNotice"><ul class="flex flex-col gap-1"><li class="flex gap-1"><span class="shrink-0">文章作者:</span><a href="https://github.com/ouuan" rel="author">ouuan</a></li><li class="flex gap-1"><span class="shrink-0">原文链接:</span><a href="https://ouuan.moe/post/2023/06/cnatda-3" rel="canonical" class="break-all">https://ouuan.moe/post/2023/06/cnatda-3</a></li><li class="flex gap-1"><span class="shrink-0">许可协议:</span><span> 本文采用 <span class="article-style"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.zh" class="font-sans" itemprop="license">CC BY-SA 4.0</a></span> 许可协议进行授权，未满足 <span class="underline decoration-dotted" title="简而言之，转载时必须标明出处（本文的链接），标明是转载而非原创，标明作了哪些修改，并使用相同的许可协议，但无需私信征求许可">许可协议要求</span> 不得转载。 </span></li></ul></div></footer></article><div class="my-6 print:hidden" itemprop="comment" itemscope="" itemtype="https://schema.org/Comment"><ile-root id="ile-4"></ile-root><script></script><script type="module" async="">import{h as r,c as m}from"/assets/iles.e381640b.js";import{_ as o}from"/assets/GiscusCommentsInner.b6b2a6ec.js";import"/assets/vendor-vue.bda4d3d4.js";import"/assets/vite.5ce4fca4.js";import"/assets/useTheme.546d36da.js";import"/assets/site.b21fb919.js";r(m,o,"ile-4",{term:"CNATDA 第三章学习笔记"},{});
</script></div><nav class="my-6 flex justify-between gap-6 print:hidden lg:text-justify"><div class="flex flex-1"><a class="flex items-center gap-1 hover:text-hover" href="/post/2023/06/cnatda-2"><span class="i-mdi-chevron-left"></span><span class="sr-only">上一篇</span><span class="break-anywhere">CNATDA 第二章学习笔记</span></a></div><div class="flex flex-1 justify-end"><a class="flex flex-row-reverse items-center gap-1 hover:text-hover" href="/post/2023/06/cnatda-4"><span class="i-mdi-chevron-right"></span><span class="sr-only">下一篇</span><span class="break-anywhere">CNATDA 第四章学习笔记</span></a></div></nav></div><ile-root id="ile-5"><div class="flex print:hidden"><aside style="max-height:calc(100vh - 10rem);" id="__toc" class="sticky top-16 m-4 hidden w-72 rd-2 bg-card py-6 shadow xl:block 2xl:w-84 3xl:w-96" aria-label="文章目录" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPSideBar"><div class="mb-3 flex flex-wrap items-center justify-between gap-2 pl-8 pr-4"><div class="flex items-center"><h2 class="text-xl font-bold"> 文章目录 </h2><button id="__toc-close" class="flex items-center px-1 text-xl" title="关闭目录" aria-controls="__toc" aria-expanded="true"><span class="i-mdi-close"></span></button></div><div><label class="ml-auto flex items-center gap-1"><span>展开全部</span><input type="checkbox"></label></div></div><div style="max-height:calc(100% - 2rem);" class="overflow-auto overscroll-contain pl-8 pr-4"><ol data-v-c5806953=""><li id="__toc-item-introduction-and-transport-layer-services" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#introduction-and-transport-layer-services" data-v-c5806953=""><span data-v-c5806953="">Introduction and Transport-Layer Services</span></a></li><li id="__toc-item-multiplexing-and-demultiplexing" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#multiplexing-and-demultiplexing" data-v-c5806953=""><span data-v-c5806953="">Multiplexing and Demultiplexing</span></a></li><li id="__toc-item-connectionless-transport-udp" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#connectionless-transport-udp" data-v-c5806953=""><span data-v-c5806953="">Connectionless Transport: UDP</span></a></li><li id="__toc-item-principles-of-reliable-data-transfer" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#principles-of-reliable-data-transfer" data-v-c5806953=""><span data-v-c5806953="">Principles of Reliable Data Transfer</span></a></li><li id="__toc-item-connection-oriented-transport-tcp" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#connection-oriented-transport-tcp" data-v-c5806953=""><span data-v-c5806953="">Connection-Oriented Transport: TCP</span></a></li><li id="__toc-item-principles-of-congestion-control" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#principles-of-congestion-control" data-v-c5806953=""><span data-v-c5806953="">Principles of Congestion Control</span></a></li><li id="__toc-item-tcp-congestion-control" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-chevron-right" data-v-c5806953=""></span><span class="sr-only" data-v-c5806953="">已折叠</span><a class="transition-color ease-out" href="#tcp-congestion-control" data-v-c5806953=""><span data-v-c5806953="">TCP Congestion Control</span></a></li><li id="__toc-item-evolution-of-transport-layer-functionality" class="relative my-1" data-v-c5806953=""><span class="absolute top-1.2 left--4
                   motion-safe:transition-transform ease-out i-mdi-circle-medium" data-v-c5806953=""></span><a class="transition-color ease-out" href="#evolution-of-transport-layer-functionality" data-v-c5806953=""><span data-v-c5806953="">Evolution of Transport-Layer Functionality</span></a></li></ol></div></aside><button style="display:none;" id="__toc-open" title="显示文章目录" class="bottom-24 text-lg floating-button" aria-haspopup="dialog" aria-controls="__toc" aria-expanded="true"><span class="i-mdi-menu"></span></button></div></ile-root><script></script><script type="module" async="">import{h as i,c as o}from"/assets/iles.e381640b.js";import{_ as s}from"/assets/TableOfContents.ee0e2b18.js";import"/assets/vendor-vue.bda4d3d4.js";import"/assets/vite.5ce4fca4.js";i(o,s,"ile-5",function(e,t,l,n){return{headings:[{level:t,title:"Introduction and Transport-Layer Services",slug:"introduction-and-transport-layer-services"},{level:l,title:"segment or datagram?",slug:"segment-or-datagram"},{level:t,title:"Multiplexing and Demultiplexing",slug:"multiplexing-and-demultiplexing"},{level:t,title:"Connectionless Transport: UDP",slug:"connectionless-transport-udp"},{level:t,title:"Principles of Reliable Data Transfer",slug:"principles-of-reliable-data-transfer"},{level:l,title:n,slug:n},{level:e,title:"Stop-And-Wait",slug:"stop-and-wait"},{level:e,title:"Pipelined Reliable Data Transfer",slug:"pipelined-reliable-data-transfer"},{level:e,title:"Go-Back-N",slug:"go-back-n"},{level:e,title:"Selective Repeat",slug:"selective-repeat"},{level:t,title:"Connection-Oriented Transport: TCP",slug:"connection-oriented-transport-tcp"},{level:e,title:"The TCP Connection",slug:"the-tcp-connection"},{level:e,title:"TCP Segment Structure",slug:"tcp-segment-structure"},{level:e,title:"Sequence Numbers and Acknowledgment Numbers",slug:"sequence-numbers-and-acknowledgment-numbers"},{level:e,title:"Round-Trip Time Estimation and Timeout",slug:"round-trip-time-estimation-and-timeout"},{level:e,title:"Reliable Data Transfer",slug:"reliable-data-transfer"},{level:e,title:"Flow Control",slug:"flow-control"},{level:e,title:"TCP Connection Management",slug:"tcp-connection-management"},{level:l,title:"SYN flood attack",slug:"syn-flood-attack"},{level:t,title:"Principles of Congestion Control",slug:"principles-of-congestion-control"},{level:t,title:"TCP Congestion Control",slug:"tcp-congestion-control"},{level:e,title:"Classic TCP Congestion Control",slug:"classic-tcp-congestion-control"},{level:l,title:"TCP splitting",slug:"tcp-splitting"},{level:e,title:"Network-Assisted Explicit Congestion Notification",slug:"network-assisted-explicit-congestion-notification"},{level:e,title:"Delayed-based Congestion Control",slug:"delayed-based-congestion-control"},{level:e,title:"Fairness",slug:"fairness"},{level:t,title:"Evolution of Transport-Layer Functionality",slug:"evolution-of-transport-layer-functionality"}]}}(3,2,6,"关于这部分的详细程度"),{});
</script></div></main><footer class="flex flex-col gap-1 bg-card p-6 text-footer" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPFooter"><div class="flex flex-wrap items-center justify-center gap-x-1"><span>Copyright ©</span><span>2022 - 2023</span><a class="flex items-center" href="/sponsor" title="赞赏支持"><span class="i-mdi-heart text-red dark:text-red-7"></span></a><span>ouuan</span></div><div class="flex flex-wrap items-center justify-center gap-x-1"><span> 当前有 <ile-root id="ile-6"><span><span class="i-mdi-loading motion-safe:animate-spin"></span><span class="sr-only">加载中</span></span></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(o=>o.v),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/VisitorCountRealtime.4d85595f.js"),["assets/VisitorCountRealtime.4d85595f.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-6",{},{})});export default E();
</script> 人在线 </span><span class="i-mdi-circle-small"></span><span title="实际上，为了保护用户隐私，同一用户的多次访问只有在同一天内使用同一浏览器在同一ip下才会被算作同一人"> 共有 <ile-root id="ile-7"><span><span class="i-mdi-loading motion-safe:animate-spin"></span><span class="sr-only">加载中</span></span></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(o=>o.v),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/VisitorCount.11a0e95f.js"),["assets/VisitorCount.11a0e95f.js","assets/VisitorCount.065e72b2.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-7",{},{})});export default E();
</script> 人到访过这里 </span></div><div class="flex flex-wrap items-center justify-center gap-x-1"> 基于 <a class="underline" href="https://github.com/ElMassimo/iles">îles</a><a class="underline" href="https://github.com/ouuan/iles-blog/blob/master/package.json">等项目</a><span class="i-mdi-circle-small"></span><span>由 ouuan 设计/制作</span><span class="i-mdi-circle-small"></span><a class="underline" href="https://github.com/ouuan/iles-blog">源代码</a></div></footer><meta itemprop="copyrightYear" content="2022 - 2023"><div class="hidden" itemscope="" itemtype="https://schema.org/Person" itemprop="copyrightHolder"><meta itemprop="name" content="ouuan"><meta itemprop="givenName" content="Yufan"><meta itemprop="familyName" content="You"><meta itemprop="url" content="https://github.com/ouuan"><link itemprop="gender" href="https://schema.org/Male"><meta itemprop="image" content="/android-chrome-512x512.png"></div><ile-root id="ile-8"><button class="group bottom-10 flex-col floating-button" title="前往底部"><div aria-hidden="true" class="flex justify-center"><span class="i-mdi-chevron-double-up motion-safe:transition-font-size text-0"></span></div><div aria-hidden="true" class="text-0 group-hover:text-3.5 motion-safe:transition-font-size"></div><div aria-hidden="false" class="flex justify-center"><span class="i-mdi-chevron-double-down motion-safe:transition-font-size text-5 group-hover:text-3"></span></div></button></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(o=>o.v),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/BackToTop.b700b311.js"),["assets/BackToTop.b700b311.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-8",{},{})});export default E();
</script><div class="hidden"></div><ile-root id="ile-9"></ile-root><script></script><script type="module" async="">var p=(t,a)=>()=>(a||t((a={exports:{}}).exports,a),a.exports);var e=(t,a,_)=>new Promise((c,n)=>{var f=o=>{try{i(_.next(o))}catch(r){n(r)}},l=o=>{try{i(_.throw(o))}catch(r){n(r)}},i=o=>o.done?c(o.value):Promise.resolve(o.value).then(f,l);i((_=_.apply(t,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var u=p(m=>{const E=()=>e(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(t=>t.d),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),h=()=>e(m,null,function*(){return(yield d(()=>import("/assets/PlausibleTrigger.097a6894.js"),["assets/PlausibleTrigger.097a6894.js","assets/plausible.72e01c7c.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).onLoad});s(E,h,"ile-9",{},{})});export default u();
</script><div></div><ile-root id="ile-10"></ile-root><script></script><script type="module" async="">var p=(t,a)=>()=>(a||t((a={exports:{}}).exports,a),a.exports);var e=(t,a,_)=>new Promise((c,n)=>{var f=o=>{try{i(_.next(o))}catch(r){n(r)}},l=o=>{try{i(_.throw(o))}catch(r){n(r)}},i=o=>o.done?c(o.value):Promise.resolve(o.value).then(f,l);i((_=_.apply(t,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var u=p(m=>{const E=()=>e(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(t=>t.d),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),h=()=>e(m,null,function*(){return(yield d(()=>import("/assets/TextJustifyFix.4fa5e997.js"),[])).onLoad});s(E,h,"ile-10",{},{})});export default u();
</script><meta itemprop="inLanguage" content="zh-CN"></div>
  
</body></html>