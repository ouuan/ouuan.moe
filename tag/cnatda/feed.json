{
    "version": "https://jsonfeed.org/version/1",
    "title": "ouuan's blog: 标签: cnatda",
    "home_page_url": "https://ouuan.moe/tag/cnatda",
    "feed_url": "https://ouuan.moe/tag/cnatda/feed.json",
    "description": "标签: cnatda - ouuan 写东西的地方，涵盖了 Web 开发、计算机系统、Linux 使用、大学学习生活等多个主题。",
    "author": {
        "name": "ouuan",
        "url": "https://github.com/ouuan"
    },
    "items": [
        {
            "id": "https://ouuan.moe/post/2023/06/cnatda-3",
            "content_html": "\n\n\n\n<p><span class=\"mojikumi-line-start\">《</span>Computer Networking: A Top-Down Approach (8th Edition)<span class=\"mojikumi-line-end\">》</span>第三章 <span class=\"mojikumi\">“</span>Transport Layer<span class=\"mojikumi\">”</span> 的学习笔记<span class=\"mojikumi-line-end\">。</span></p>\n\n<h2 id=\"introduction-and-transport-layer-services\" class=\"heading\"><a href=\"#introduction-and-transport-layer-services\" class=\"heading-anchor\" aria-label=\"章节： Introduction and Transport-Layer Services\" tabindex=\"-1\"></a><span>Introduction and Transport-Layer Services</span></h2>\n<p>transport layer 将 application-layer message 封装于 transport-layer segment<span class=\"mojikumi-line-end\">，</span>然后交给 network layer 进行传输<span class=\"mojikumi-line-end\">，</span>将 network layer 提供的 host-to-host logical communication 扩展为了 process-to-process (application-to-application) logical communication<span class=\"mojikumi-line-end\">。</span></p>\n<p>Internet 的 network layer protocol 是 Internet Protocol (IP)<span class=\"mojikumi-line-end\">，</span>IP 提供的是 <span class=\"mojikumi\">“</span>best-effort delivery service<span class=\"mojikumi\">”</span><span class=\"mojikumi-line-end\">，</span>就是说它会尽力但并不保证 datagram 能成功传输<span class=\"mojikumi-line-end\">，</span>也不保证传输到的顺序以及数据的完整性<span class=\"mojikumi-line-end\">、</span>正确性<span class=\"mojikumi-line-end\">。</span></p>\n<p>UDP 仅提供 process-to-process delivery 和 error checking<span class=\"mojikumi-line-end\">，</span>同样是一个 unreliable service<span class=\"mojikumi-line-end\">。</span>TCP 在 UDP 的基础上还提供 reliable data transfer 和 congestion control<span class=\"mojikumi-line-end\">。</span></p>\n<a id=\"segment-or-datagram\" name=\"segment-or-datagram\" aria-hidden=\"true\"></a>\n<aside role=\"note\" data-v-a2ab257f><div class=\"shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue\" data-v-a2ab257f><div class=\"p-3 flex justify-between items-center\" data-v-a2ab257f><h3 class=\"flex items-center gap-1 font-bold\" data-v-a2ab257f><span class=\"text-5 i-mdi-pencil text-blue\" data-v-a2ab257f></span><span class=\"sr-only\" data-v-a2ab257f>Note: </span><span data-v-a2ab257f>segment or datagram?</span></h3><!--v-if--></div><div class=\"overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover\" data-v-a2ab257f><p>在 CNATDA 中<span class=\"mojikumi-line-end\">，</span>network layer packet 被统称为 <span class=\"mojikumi\">“</span>segment<span class=\"mojikumi\">”</span><span class=\"mojikumi-line-end\">，</span>但一般应当是 TCP 的 packet 被称作 <span class=\"mojikumi\">“</span>segment<span class=\"mojikumi\">”</span><span class=\"mojikumi-line-end\">，</span>而 UDP 的 packet 被称作 <span class=\"mojikumi\">“</span>datagram<span class=\"mojikumi\">”</span><wbr><span class=\"mojikumi-line-start\">（</span>UDP 名字中的 <span class=\"mojikumi\">“</span>D<span class=\"mojikumi\">”</span> 就是 <span class=\"mojikumi\">“</span>datagram<span class=\"mojikumi\">”</span><span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span>为了方便<span class=\"mojikumi-line-end\">，</span>我也将 network layer packet 统称为 <span class=\"mojikumi\">“</span>segment<span class=\"mojikumi\">”</span><span class=\"mojikumi-line-end\">，</span>但在特指时<span class=\"mojikumi-line-end\">，</span>称作 <span class=\"mojikumi\">“</span>TCP segment<span class=\"mojikumi\">”</span><span class=\"mojikumi\">、</span><wbr><span class=\"mojikumi-line-start\">“</span>UDP datagram<span class=\"mojikumi\">”</span> 和 <span class=\"mojikumi\">“</span>IP datagram<span class=\"mojikumi\">”</span><span class=\"mojikumi-line-end\">，</span>语境明确时也可能略去协议名<span class=\"mojikumi-line-end\">。</span></p></div></div></aside>\n<h2 id=\"multiplexing-and-demultiplexing\" class=\"heading\"><a href=\"#multiplexing-and-demultiplexing\" class=\"heading-anchor\" aria-label=\"章节： Multiplexing and Demultiplexing\" tabindex=\"-1\"></a><span>Multiplexing and Demultiplexing</span></h2>\n<p><dfn>multiplexing</dfn> 指的是将多个信道的信息合并到一个信道进行传输<span class=\"mojikumi-line-end\">，</span>而 <dfn>demultiplexing</dfn> 指的是将这个合并后的信息再拆分到多个信道去<span class=\"mojikumi-line-end\">。</span></p>\n<p>一般来说<span class=\"mojikumi-line-end\">，</span>一个 host 会有很多 application 从而有很多 socket<span class=\"mojikumi-line-end\">，</span>但只有一个 transport layer 以及一个 network layer<span class=\"mojikumi-line-end\">。</span></p>\n<ul>\n<li>在发送方<span class=\"mojikumi-line-end\">，</span>transport layer 从多个 socket 收集 message 并发送给 network layer 的过程被称作 multiplexing<span class=\"mojikumi-line-end\">；</span></li>\n<li>在接收方<span class=\"mojikumi-line-end\">，</span>transport layer 从 network layer 接收到 message 后传递给正确的 socket 的过程被称作 demultiplexing<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<p>multiplexing 以及 demultiplexing 需要每个 socket 有 unique identifier<span class=\"mojikumi-line-end\">，</span>并且 segment 中需要包含这个 socket identifier<span class=\"mojikumi-line-end\">。</span></p>\n<ul>\n<li>在 UDP 中<span class=\"mojikumi-line-end\">，</span>只以 port 作为 socket identifier<span class=\"mojikumi-line-end\">，</span>UDP datagram 中包含 source port 和 destination port<span class=\"mojikumi-line-end\">；</span></li>\n<li>在 TCP 中<span class=\"mojikumi-line-end\">，</span>以 destination port 和 source IP 作为 socket identifier<span class=\"mojikumi-line-end\">，</span>TCP segment 中包含双方的 IP 和 port 以及表示是否是 connection-establishment 的 flag<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<h2 id=\"connectionless-transport-udp\" class=\"heading\"><a href=\"#connectionless-transport-udp\" class=\"heading-anchor\" aria-label=\"章节： Connectionless Transport: UDP\" tabindex=\"-1\"></a><span>Connectionless Transport: UDP</span></h2>\n<p>UDP 仅提供 multiplexing and demultiplexing 以及 error checking<span class=\"mojikumi-line-end\">，</span>但在一些 application 中它比 TCP 更加适合<span class=\"mojikumi-line-end\">，</span>主要因为下列原因<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>更好地控制何时发送数据<span class=\"mojikumi-line-end\">、</span>发送什么数据<span class=\"mojikumi-line-end\">：</span>TCP 有 congestion control<span class=\"mojikumi-line-end\">，</span>可能会延迟发送的时间<span class=\"mojikumi-line-end\">；</span>在传输失败时会重新发送<span class=\"mojikumi-line-end\">，</span>可能耗时很久才传输成功<span class=\"mojikumi-line-end\">。</span></li>\n<li>无需建立连接<span class=\"mojikumi-line-end\">：</span>建立 TCP connection 会产生 delay<span class=\"mojikumi-line-end\">。</span></li>\n<li>无连接状态<span class=\"mojikumi-line-end\">：</span>保存 TCP connection state 需要占用系统资源<span class=\"mojikumi-line-end\">。</span></li>\n<li>small header overhead<span class=\"mojikumi-line-end\">：</span>TCP segment header 有 20 byte 的 overhead<span class=\"mojikumi-line-end\">，</span>UDP 只有 8 byte<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<p>一些使用 UDP 的例子<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>DNS 使用 UDP 来避免建立 TCP 连接的 delay<span class=\"mojikumi-line-end\">。</span></li>\n<li>在 HTTP/3 中<span class=\"mojikumi-line-end\">，</span>使用基于 UDP 的 application layer protocol QUIC 来提供 reliable data transfer 并避免建立 TCP 连接的 delay<span class=\"mojikumi-line-end\">。</span></li>\n<li>在 network management (SNMP) 中<span class=\"mojikumi-line-end\">，</span>使用 UDP 以在网络非常拥堵时发送消息<span class=\"mojikumi-line-end\">。</span></li>\n<li>在 multimedia application 尤其是即时通话中经常会使用 UDP<span class=\"mojikumi-line-end\">，</span>因为对延时敏感而 loss-tolerant<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<p>但是<span class=\"mojikumi-line-end\">，</span>尤其是传输 multimedia 时<span class=\"mojikumi-line-end\">，</span>在没有 congestion control 的情况下传输大量数据可能导致网络拥堵<span class=\"mojikumi-line-end\">，</span>进而导致 UDP 大量丢包而 TCP 传输缓慢<span class=\"mojikumi-line-end\">。</span></p>\n<p>UDP datagram 的结构为<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>source port (16 bits)</li>\n<li>destination port (16 bits)</li>\n<li>length (16 bits): 整个 datagram<span class=\"mojikumi-line-start\">（</span>包含 header 和 data<span class=\"mojikumi-line-end\">）</span>的 byte 数</li>\n<li>checksum (16 bits)<span class=\"mojikumi-line-end\">：</span>将 UDP datagram 以及 IP header 的一些 field 以 16 bits 为单位视作 ones<span class=\"mojikumi-narrow-left\">’</span> complement integer 加在一起<span class=\"mojikumi-line-start\">（</span>即在进位时加 1<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>最后取反<span class=\"mojikumi-line-start\">（</span>即按位取反<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">；</span>校验时只需检查 sum 是否全 1</li>\n<li>application data (message)</li>\n</ul>\n<p>UDP 的 checksum 只能用来进行 error detecting<span class=\"mojikumi-line-end\">，</span>不能用来进行 error correcting<span class=\"mojikumi-line-end\">，</span>错误时可以直接扔掉或者通知 application<span class=\"mojikumi-line-end\">。</span></p>\n<p>虽然在很多 link layer protocol 中也有 error checking<span class=\"mojikumi-line-end\">，</span>但并不能保证一路上所有 link 都有 error checking<span class=\"mojikumi-line-end\">；</span>并且<span class=\"mojikumi-line-end\">，</span>error 可能不是在 link-to-link 的传输过程中产生的<span class=\"mojikumi-line-end\">，</span>例如可能是存储在 router 中时产生的<span class=\"mojikumi-line-end\">。</span>所以<span class=\"mojikumi-line-end\">，</span>UDP 要提供 checksum<span class=\"mojikumi-line-end\">，</span>这也是体现了 end-to-end principle 的一个例子<span class=\"mojikumi-line-end\">。</span></p>\n<h2 id=\"principles-of-reliable-data-transfer\" class=\"heading\"><a href=\"#principles-of-reliable-data-transfer\" class=\"heading-anchor\" aria-label=\"章节： Principles of Reliable Data Transfer\" tabindex=\"-1\"></a><span>Principles of Reliable Data Transfer</span></h2>\n<a id=\"关于这部分的详细程度\" name=\"关于这部分的详细程度\" aria-hidden=\"true\"></a>\n<aside role=\"note\" data-v-a2ab257f><div class=\"shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue\" data-v-a2ab257f><div class=\"p-3 flex justify-between items-center\" data-v-a2ab257f><h3 class=\"flex items-center gap-1 font-bold\" data-v-a2ab257f><span class=\"text-5 i-mdi-info-circle-outline text-blue\" data-v-a2ab257f></span><span class=\"sr-only\" data-v-a2ab257f>Info: </span><span data-v-a2ab257f>关于这部分的详细程度</span></h3><!--v-if--></div><div class=\"overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover\" data-v-a2ab257f><p>这部分我写的比较简略<span class=\"mojikumi-line-end\">，</span>仅作为摘要<span class=\"mojikumi-line-end\">，</span>更循序渐进的讲解以及实现细节等需要看书<span class=\"mojikumi-line-end\">。</span></p></div></div></aside>\n<h3 id=\"stop-and-wait\" class=\"heading\"><a href=\"#stop-and-wait\" class=\"heading-anchor\" aria-label=\"章节： Stop-And-Wait\" tabindex=\"-1\"></a><span>Stop-And-Wait</span></h3>\n<p>在 stop-and-wait protocol 中<span class=\"mojikumi-line-end\">，</span>sender 每次确认 receiver 收到了 packet 才会发下一个 packet<span class=\"mojikumi-line-end\">。</span></p>\n<ol>\n<li>checksum: 传输过程中可能出错<span class=\"mojikumi-line-end\">，</span>需要进行 error detection</li>\n<li>acknowledgment (ACK):\n<ul>\n<li>需要告诉 sender 没有丢包</li>\n<li>收到 packet 时需要告诉 sender 是否出错</li>\n</ul>\n</li>\n<li>retransmission: 未收到 ACK 或收到 negative acknowledgment (NAK) 时需要重新传输</li>\n<li>sequence number: retransmission 可能是因为 ACK 的传输出了问题<span class=\"mojikumi-line-end\">，</span>这会导致 duplicate packet<span class=\"mojikumi-line-end\">，</span>sequence number 的作用之一是识别 duplicate packet<span class=\"mojikumi-line-end\">；</span>在 stop-and-wait protocol 中<span class=\"mojikumi-line-end\">，</span>用 0/1 作为 sequence number 即可<span class=\"mojikumi-line-end\">，</span>这也被称作 <i>alternating-bit protocol</i></li>\n<li>timeout: 丢包需要通过超时来检测<span class=\"mojikumi-line-end\">，</span>超时了就 retransmit<span class=\"mojikumi-line-end\">；</span>如果等待太久性能会受影响<span class=\"mojikumi-line-end\">，</span>所以 timeout 一般被设为较有可能是丢包的值而非几乎能确定是丢包的值</li>\n<li>ACK with sequence number: 通过超时检测丢包可能带来 duplicate packet<span class=\"mojikumi-line-start\">（</span>ACK 传输出错或用时过长<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>需要通过在 ACK 中加入 sequence number 来标识 acknowledge 的是哪个 packet<span class=\"mojikumi-line-end\">，</span>以此也可以通过上一个 packet 的 ACK 代替表示当前 packet 出错的 NAK</li>\n</ol>\n<h3 id=\"pipelined-reliable-data-transfer\" class=\"heading\"><a href=\"#pipelined-reliable-data-transfer\" class=\"heading-anchor\" aria-label=\"章节： Pipelined Reliable Data Transfer\" tabindex=\"-1\"></a><span>Pipelined Reliable Data Transfer</span></h3>\n<p>stop-and-wait 虽然 work<span class=\"mojikumi-line-end\">，</span>但每次都要等上一个 packet 成功传输才能传下一个<span class=\"mojikumi-line-end\">，</span>性能太差<span class=\"mojikumi-line-end\">。</span></p>\n<p>同时传输多个 packet 被称作 <i>pipelining</i><span class=\"mojikumi-line-end\">，</span>这意味着<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>sequence number 需要更大的值域<span class=\"mojikumi-line-start\">（</span>不止是 1 bit 的 0/1<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>至少正在传输的这些 packet 需要互不相同的 sequence number</li>\n<li>sender 需要 buffer 以支持多个 packet 的 retransmission<span class=\"mojikumi-line-end\">，</span>receiver 也可能需要 buffer</li>\n</ul>\n<p>有两种基础的实现方法<span class=\"mojikumi-line-end\">：</span>go-back-n (GBN) 和 selective repeat (SR)<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"go-back-n\" class=\"heading\"><a href=\"#go-back-n\" class=\"heading-anchor\" aria-label=\"章节： Go-Back-N\" tabindex=\"-1\"></a><span>Go-Back-N</span></h3>\n<p>receiver: 只接受按正确顺序依次收到的 packet<span class=\"mojikumi-line-end\">，</span>顺序错误的 packet 直接扔掉<span class=\"mojikumi-line-start\">（</span>顺序正确但有 error 的 packet 通过发送上一个 packet 的 ACK 进行 negative acknowledgment<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span></p>\n<p>sender:</p>\n<ul>\n<li>有一个 sliding window 表示当前有效的 sequence number 范围</li>\n<li>window 内前一半已发送尚未收到 ACK<span class=\"mojikumi-line-end\">，</span>后一半 sequence number 尚未使用</li>\n<li>如果 window 内所有 sequence number 均已被使用<span class=\"mojikumi-line-end\">，</span>将不能发送新的 packet</li>\n<li>收到的 ACK 被视作 <i>cumulative acknowledgment</i><span class=\"mojikumi-line-end\">，</span>即在这个 ACK 的 sequence number 之前的 packet 也被视作已 ACK</li>\n<li>收到 ACK 时将 window 滑动到这个 ACK 之后</li>\n<li>所有未 ACK 的 packet 共用一个 timer</li>\n<li>retransmit 时发送 window 内所有尚未 ACK 的 packet</li>\n</ul>\n<p>GBN 的好处是 receiver 不需要 buffer<span class=\"mojikumi-line-end\">，</span>坏处是一个 packet 出错就要把整个 window 内的 packet 重新发送<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"selective-repeat\" class=\"heading\"><a href=\"#selective-repeat\" class=\"heading-anchor\" aria-label=\"章节： Selective Repeat\" tabindex=\"-1\"></a><span>Selective Repeat</span></h3>\n<p>sender:</p>\n<ul>\n<li>sliding window 与 GBN 类似<span class=\"mojikumi-line-end\">，</span>但前一半中除了开头<span class=\"mojikumi-line-start\">（</span>如果有<span class=\"mojikumi-line-end\">）</span>一定未 ACK<span class=\"mojikumi-line-end\">，</span>后面的可能已 ACK 也可能没有</li>\n<li>ACK<span class=\"mojikumi-line-end\">、</span>timer<span class=\"mojikumi-line-end\">、</span>retransmission 都是每个 packet 独立的</li>\n<li>收到 window 开头的 ACK 时滑动到首个未 ACK 处<span class=\"mojikumi-line-start\">（</span>如果均已 ACK 则是未使用处<span class=\"mojikumi-line-end\">）</span></li>\n</ul>\n<p>receiver:</p>\n<ul>\n<li>也需要维护一个 sliding window<span class=\"mojikumi-line-end\">，</span>但这个 window 和 sender 的不保证一致<span class=\"mojikumi-line-end\">，</span>其开头是尚未收到的最小的 sequence number</li>\n<li>收到非 window 开头的 packet 时需要 buffer 下来</li>\n<li>收到 window 开头的 packet 时将已 buffer 的 packet 连续段按顺序传给 application<span class=\"mojikumi-line-end\">，</span>并滑动 window</li>\n<li>收到 window 开头减去 window 大小到 window 开头减一这个范围内的 packet 时<span class=\"mojikumi-line-start\">（</span>这表示之前对这个 packet 的 ACK 的传输出了问题或者耗时过长<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>也需要 ACK</li>\n<li>无论收到的是哪个 packet<span class=\"mojikumi-line-end\">，</span>如果有 error 则直接不管<span class=\"mojikumi-line-start\">（</span>因为 ACK 对每个 packet 独立<span class=\"mojikumi-line-end\">，</span>不能通过设置 ACK 的 sequence number 来表示 negative acknowledgment<span class=\"mojikumi-line-end\">；</span>也可以选择引入 NAK<span class=\"mojikumi-line-end\">，</span>若不引入则只能不管<span class=\"mojikumi-line-end\">）</span></li>\n</ul>\n<p>需要注意的是<span class=\"mojikumi-line-end\">，</span>由于 sender 和 receiver 的 window 可能不同<span class=\"mojikumi-line-end\">，</span>window 大小不能超过 sequence number 值域的一半<span class=\"mojikumi-line-end\">。</span></p>\n<p>最后<span class=\"mojikumi\">，</span><wbr><span class=\"mojikumi-line-start\">（</span>无论是 GBN 还是 SR<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>因为 sequence number 的值域有限<span class=\"mojikumi-line-start\">（</span>循环使用<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>如果一个 duplicate packet (duplicate ACK) 的传输耗时太久<span class=\"mojikumi-line-end\">，</span>可能会占用重复的 sequence number<span class=\"mojikumi-line-end\">，</span>在实践中采取的解决方法一般是在一个 packet 传输了几分钟后便认为它已经没了<span class=\"mojikumi-line-end\">。</span></p>\n<h2 id=\"connection-oriented-transport-tcp\" class=\"heading\"><a href=\"#connection-oriented-transport-tcp\" class=\"heading-anchor\" aria-label=\"章节： Connection-Oriented Transport: TCP\" tabindex=\"-1\"></a><span>Connection-Oriented Transport: TCP</span></h2>\n<h3 id=\"the-tcp-connection\" class=\"heading\"><a href=\"#the-tcp-connection\" class=\"heading-anchor\" aria-label=\"章节： The TCP Connection\" tabindex=\"-1\"></a><span>The TCP Connection</span></h3>\n<p>TCP connection 在两个 end system 中都建立了一些 state variable<span class=\"mojikumi-line-end\">，</span>但它只是 logical connection<span class=\"mojikumi-line-end\">，</span>并没有在 network core 中建立 circuit<span class=\"mojikumi-line-start\">（</span>与 circuit-switched network 不同<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span></p>\n<p>TCP connection 是 full-duplex 的<span class=\"mojikumi-line-end\">，</span>即建立连接后双方都可以向对方发送信息<span class=\"mojikumi-line-end\">；</span>是 point-to-point 的<span class=\"mojikumi-line-end\">，</span>即不能 multicasting<span class=\"mojikumi-line-end\">。</span></p>\n<p>TCP connection 是通过 <i>three-way handshake</i> 建立的<span class=\"mojikumi-line-end\">。</span>通过 TCP 发送 message 时会先放入 send buffer<span class=\"mojikumi-line-end\">，</span>接收到 message 时会先放入 receive buffer<span class=\"mojikumi-line-end\">。</span></p>\n<p>TCP 会根据 maximum transmission unit (MTU<span class=\"mojikumi-line-end\">，</span>link-layer frame 的最大 size) 计算出合适的 maximum segment size (MSS<span class=\"mojikumi-line-end\">，</span>segment 包含的 data (application message) 的最大 size) 使得 data 加上 TCP header 和 IP header 后不超过 MTU<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"tcp-segment-structure\" class=\"heading\"><a href=\"#tcp-segment-structure\" class=\"heading-anchor\" aria-label=\"章节： TCP Segment Structure\" tabindex=\"-1\"></a><span>TCP Segment Structure</span></h3>\n<p>TCP segment 的结构如下图所示<span class=\"mojikumi-line-end\">：</span><sup><a href=\"#user-content-fn-fig-3.29\" id=\"user-content-fnref-fig-3.29\" data-footnote-ref aria-describedby=\"footnote-label\">1</a></sup></p>\n<p><picture><source type=\"image/webp\" srcset=\"/assets/cnatda-fig-3.29.c8a13933.webp\"><img srcset=\"/assets/cnatda-fig-3.29.2ff11b60.png\" loading=\"lazy\" src=\"/assets/cnatda-fig-3.29.2ff11b60.png\" width=\"812\" height=\"652\" alt=\"TCP segment structure\"></picture></p>\n<p>其中 <span class=\"mojikumi\">“</span>options<span class=\"mojikumi\">”</span> 是可选且可变长的<span class=\"mojikumi-line-end\">，</span>所以 TCP header 是可变长的<span class=\"mojikumi-line-end\">，</span>但一般是 20 byte<span class=\"mojikumi-line-end\">。</span></p>\n<p>各项的含义<span class=\"mojikumi-line-start\">（</span>部分<span class=\"mojikumi-line-end\">）</span>见下文<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"sequence-numbers-and-acknowledgment-numbers\" class=\"heading\"><a href=\"#sequence-numbers-and-acknowledgment-numbers\" class=\"heading-anchor\" aria-label=\"章节： Sequence Numbers and Acknowledgment Numbers\" tabindex=\"-1\"></a><span>Sequence Numbers and Acknowledgment Numbers</span></h3>\n<p>TCP 将发送的所有 message 连在一起视作一个无结构但有序的 byte stream<span class=\"mojikumi-line-end\">，</span>segment 的 sequence number 表示的是 message 的第一个 byte 在 byte stream 中的位置<span class=\"mojikumi-line-end\">。</span>双方<span class=\"mojikumi-line-start\">（</span>client 和 server<span class=\"mojikumi-line-end\">）</span>的 sequence number 是分别计算的<span class=\"mojikumi-line-end\">。</span></p>\n<p>为了尽量避免 sequence number 与留存在网络中的其他 segment 发生冲突<span class=\"mojikumi-line-end\">，</span>以及其他安全原因<span class=\"mojikumi-line-end\">，</span>一次连接中的首个 byte 的 sequence number 一般不是 0<span class=\"mojikumi-line-end\">，</span>而是随机选择<span class=\"mojikumi-line-end\">。</span></p>\n<p>acknowledgment number 是期待收到的下个<span class=\"mojikumi-line-start\">（</span>尚未收到的首个<span class=\"mojikumi-line-end\">）</span>byte 的 sequence number<span class=\"mojikumi-line-end\">，</span>是 cumulative acknowledgment<span class=\"mojikumi-line-end\">。</span></p>\n<p>收到顺序错误的 segment 时<span class=\"mojikumi-line-end\">，</span>TCP 没有规定如何处理<span class=\"mojikumi-line-end\">，</span>但一般都会 buffer 下来<span class=\"mojikumi-line-end\">。</span></p>\n<p>一个 segment 中可以同时包含 acknowledgment 和 data<span class=\"mojikumi-line-end\">，</span>这时 acknowledgment 被称作 <span class=\"mojikumi\">“</span>piggybacked on the data segment<span class=\"mojikumi\">”</span><span class=\"mojikumi-line-end\">。</span>也可以只有 acknowledgment 没有 data<span class=\"mojikumi-line-end\">，</span>此时 segment 仍有 sequence number<span class=\"mojikumi-line-end\">，</span>设为下一个 byte 的 sequence number<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"round-trip-time-estimation-and-timeout\" class=\"heading\"><a href=\"#round-trip-time-estimation-and-timeout\" class=\"heading-anchor\" aria-label=\"章节： Round-Trip Time Estimation and Timeout\" tabindex=\"-1\"></a><span>Round-Trip Time Estimation and Timeout</span></h3>\n<p>一个 segment 的 sample RTT (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span></span>) 指的是 segment 进入 network layer 直到 acknowledgment 被接收的用时<span class=\"mojikumi-line-end\">。</span></p>\n<p>在多数 TCP implementation 中<span class=\"mojikumi-line-end\">，</span>在计算一个 segment 的 sample RTT 时不会再去计算正在同时传输的其他 segment 的 sample RTT<span class=\"mojikumi-line-end\">，</span>并且只会计算一次就传输成功的 segment 的 sample RTT<span class=\"mojikumi-line-end\">，</span>不会计算 retransmission 的 sample RTT<span class=\"mojikumi-line-end\">。</span></p>\n<p>estimated RTT (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span></span>) 是计算出的这些 sample RTT 的 exponential weighted moving average (EWMA)<span class=\"mojikumi-line-end\">，</span>用来平缓 RTT 的波动<span class=\"mojikumi-line-end\">：</span><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>←</mo><mfrac><mn>7</mn><mn>8</mn></mfrac><mi>e</mi><mo>+</mo><mfrac><mn>1</mn><mn>8</mn></mfrac><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">e \\gets \\frac 78 e + \\frac 18 s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">7</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\">s</span></span></span></span></span></p>\n<p>dev RTT (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span></span>) 用来衡量 RTT 波动的大小<span class=\"mojikumi-line-end\">：</span><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo>←</mo><mfrac><mn>3</mn><mn>4</mn></mfrac><mi>d</mi><mo>+</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mi mathvariant=\"normal\">∣</mi><mi>s</mi><mo>−</mo><mi>e</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">d \\gets \\frac 34 d + \\frac 14 |s - e|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord\">∣</span></span></span></span></span></p>\n<p>timeout interval (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span></span>) 在 estimated RTT 的基础上根据 dev RTT 提供了一定的冗余<span class=\"mojikumi-line-end\">：</span><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>=</mo><mi>e</mi><mo>+</mo><mn>4</mn><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">t = e + 4d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\">d</span></span></span></span></span></p>\n<p>timeout interval 的初始值一般是 1 秒<span class=\"mojikumi-line-end\">。</span>在发生 retransmission 时<span class=\"mojikumi-line-end\">，</span>timeout interval 会翻倍<span class=\"mojikumi-line-end\">，</span>而在得到新的 sample RTT 后<span class=\"mojikumi-line-start\">（</span>即某个 segment 一次就传输成功后<span class=\"mojikumi-line-end\">）</span>又会回到正常的计算方式<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"reliable-data-transfer\" class=\"heading\"><a href=\"#reliable-data-transfer\" class=\"heading-anchor\" aria-label=\"章节： Reliable Data Transfer\" tabindex=\"-1\"></a><span>Reliable Data Transfer</span></h3>\n<p>TCP 一般只使用一个 retransmission timer<span class=\"mojikumi-line-end\">，</span>用来给 oldest segment 计时<span class=\"mojikumi-line-end\">。</span></p>\n<p>虽然 TCP 和 GBN 有些类似<span class=\"mojikumi-line-end\">，</span>但 TCP 在 retransmit 时一次只传一个 segment<span class=\"mojikumi-line-end\">，</span>而 receiver 往往也会 buffer 顺序错误的 segment<span class=\"mojikumi-line-end\">。</span></p>\n<p>retransmission 在两种情况下发生<span class=\"mojikumi-line-end\">：</span>timeout 或者收到三个 duplicate ACK<span class=\"mojikumi-line-start\">（</span>即相同 sequence number 的第四个 ACK<span class=\"mojikumi-line-end\">；</span>这被称作 <i>fast retransmit</i><span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span>这意味着只收到一个或两个 duplicate ACK 的时候还是会等到 timeout 才 retransmit<span class=\"mojikumi-line-end\">，</span>因为这往往意味着只是顺序错误而不是丢包<span class=\"mojikumi-line-end\">。</span><sup><a href=\"#user-content-fn-fast-retransmit\" id=\"user-content-fnref-fast-retransmit\" data-footnote-ref aria-describedby=\"footnote-label\">2</a></sup></p>\n<p>一般还会实现 delayed ACK<span class=\"mojikumi-line-end\">，</span>即只 ACK 一个 segment 时会尝试等到下一个 segment 一起 ACK<span class=\"mojikumi-line-start\">（</span>但不会等超过 500ms<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span>这样可以减少通信量<span class=\"mojikumi-line-end\">，</span>尤其是经过等待后 ACK 可以被 piggyback 时<span class=\"mojikumi-line-end\">。</span><sup><a href=\"#user-content-fn-delayed-ack\" id=\"user-content-fnref-delayed-ack\" data-footnote-ref aria-describedby=\"footnote-label\">3</a></sup>但是 cumulative ACK 以及 duplicate ACK 都会立即发送不会等待<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"flow-control\" class=\"heading\"><a href=\"#flow-control\" class=\"heading-anchor\" aria-label=\"章节： Flow Control\" tabindex=\"-1\"></a><span>Flow Control</span></h3>\n<p>receiver 有一个 buffer<span class=\"mojikumi-line-end\">，</span>但 application 不一定会立刻从 buffer 中读取<span class=\"mojikumi-line-end\">，</span>如果 application 读得太慢<span class=\"mojikumi-line-end\">，</span>就需要 sender 不要发太快来避免 buffer overflow<span class=\"mojikumi-line-end\">。</span></p>\n<p>TCP header 中包含 receive window (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{rwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">rwnd</span></span></span></span></span></span>) 表示 buffer 的剩余空间<span class=\"mojikumi-line-end\">，</span>而 sender 需要保证已发送未被 ACK 的数据总量不超过 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{rwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">rwnd</span></span></span></span></span></span><span class=\"mojikumi-line-end\">。</span></p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{rwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">rwnd</span></span></span></span></span></span> 为 0 会阻断 sender 发送更多 segment<span class=\"mojikumi-line-end\">，</span>而为了让 receiver 有机会告诉 sender 更新后的 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{rwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">rwnd</span></span></span></span></span></span><span class=\"mojikumi-line-end\">，</span>防止通信被一直阻断下去<span class=\"mojikumi-line-end\">，</span>sender 需要发送 probing of zero window<span class=\"mojikumi-line-end\">，</span>即 1 byte 的 data<span class=\"mojikumi-line-end\">，</span>可以以指数上升的间隔发送<span class=\"mojikumi-line-end\">。</span><sup><a href=\"#user-content-fn-zero-window-probing-793\" id=\"user-content-fnref-zero-window-probing-793\" data-footnote-ref aria-describedby=\"footnote-label\">4</a></sup> <sup><a href=\"#user-content-fn-zero-window-probing-1122\" id=\"user-content-fnref-zero-window-probing-1122\" data-footnote-ref aria-describedby=\"footnote-label\">5</a></sup></p>\n<h3 id=\"tcp-connection-management\" class=\"heading\"><a href=\"#tcp-connection-management\" class=\"heading-anchor\" aria-label=\"章节： TCP Connection Management\" tabindex=\"-1\"></a><span>TCP Connection Management</span></h3>\n<p>书上只讲了最基本的情况<span class=\"mojikumi-line-end\">，</span>没有讲各种 corner case<span class=\"mojikumi-line-end\">，</span>说是可以去看<span class=\"mojikumi-line-start\">《</span>TCP/IP Illustrated<span class=\"mojikumi\">》</span><wbr><span class=\"mojikumi-line-start\">（</span></p>\n<p>建立 TCP connection<span class=\"mojikumi-line-end\">：</span></p>\n<ol>\n<li>client 向 server 发 SYN segment: SYN flag set<span class=\"mojikumi-line-end\">，</span>sequence number 是 client ISN<span class=\"mojikumi-line-start\">（</span>initial sequence number<span class=\"mojikumi-line-end\">，</span>第一个 byte 的 sequence number 是 client ISN + 1<span class=\"mojikumi-line-end\">）</span></li>\n<li>server 收到 SYN segment<span class=\"mojikumi-line-end\">，</span>建立 buffer 和 state<span class=\"mojikumi-line-end\">，</span>向 client 发 SYNACK segment: SYN flag set<span class=\"mojikumi-line-end\">，</span>ACK 了 SYN segment<span class=\"mojikumi-line-end\">，</span>sequence number 是 server ISN</li>\n<li>client 收到 SYNACK segment<span class=\"mojikumi-line-end\">，</span>建立 buffer 和 state<span class=\"mojikumi-line-end\">，</span>向 server 发 SYNACK 的 ACK<span class=\"mojikumi-line-end\">，</span>可以携带 application data</li>\n</ol>\n<p>或者也可以拆开看<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>client 和 server 互发 SYN<span class=\"mojikumi-line-end\">，</span>client 先发<span class=\"mojikumi-line-end\">，</span>SYN 不携带 application data<span class=\"mojikumi-line-end\">，</span>sequence number 用来表示 ISN</li>\n<li>收到 SYN 要 ACK<span class=\"mojikumi-line-end\">，</span>ACK 可以 piggyback 到 SYN 或者 application data 上</li>\n<li>收到 SYN 时会建立 buffer 以及 state variable</li>\n</ul>\n<p>在断开连接时<span class=\"mojikumi-line-end\">，</span>双方会互相发送 FIN package (FIN flag set)<span class=\"mojikumi-line-end\">，</span>以及相应的 ACK<span class=\"mojikumi-line-end\">。</span>首先提出断开连接的一方在发送最后一个 ACK 后会等待一段时间<span class=\"mojikumi-line-start\">（</span>一般是 30s<span class=\"mojikumi-line-end\">）</span>再真的断开连接<span class=\"mojikumi-line-end\">，</span>以给对方机会 retransmit FIN segment<span class=\"mojikumi-line-end\">，</span>防止这最后一个 ACK 丢包导致对方一直等着<span class=\"mojikumi-line-end\">。</span></p>\n<p>如果尝试连接到一个不接受 TCP 连接的端口<span class=\"mojikumi-line-end\">，</span>会返回 RST flag set 的 segment<span class=\"mojikumi-line-end\">。</span></p>\n<a id=\"syn-flood-attack\" name=\"syn-flood-attack\" aria-hidden=\"true\"></a>\n<aside role=\"note\" data-v-a2ab257f><div class=\"shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue\" data-v-a2ab257f><div class=\"p-3 flex justify-between items-center\" data-v-a2ab257f><h4 class=\"flex items-center gap-1 font-bold\" data-v-a2ab257f><span class=\"text-5 i-mdi-pencil text-blue\" data-v-a2ab257f></span><span class=\"sr-only\" data-v-a2ab257f>Note: </span><span data-v-a2ab257f>SYN flood attack</span></h4><!--v-if--></div><div class=\"overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover\" data-v-a2ab257f><p>如果 server 在收到 SYN 时就建立 buffer 以及 state 会带来遭受 SYN flood attack 的可能<span class=\"mojikumi-line-end\">，</span>即向 server 发送大量 SYN segment 而不发送后续的 ACK<span class=\"mojikumi-line-end\">，</span>从而占用 server 的大量资源<span class=\"mojikumi-line-end\">。</span></p><p>SYN flood attack 的一个防范方式是使用 SYN cookie<span class=\"mojikumi-line-end\">：</span>在收到 SYN segment 时不建立 buffer 以及 state variable 等<span class=\"mojikumi-line-end\">，</span>而是计算 low resolution timestamp + 双方 IP + 双方 port + server secret 的 hash<span class=\"mojikumi-line-end\">，</span>将 timestamp (5 bits) + MSS (encoded to 3 bits) + hash (24 bits) 作为 server ISN<span class=\"mojikumi-line-end\">，</span>在收到 SYN segment 时不建立 buffer 和 state<span class=\"mojikumi-line-end\">，</span>而在收到 ACK 时根据 ACK number 得到 server ISN<span class=\"mojikumi-line-end\">，</span>检查 hash 是否正确并得到 MSS 然后再建立 buffer 和 state<span class=\"mojikumi-line-end\">。</span></p></div></div></aside>\n<h2 id=\"principles-of-congestion-control\" class=\"heading\"><a href=\"#principles-of-congestion-control\" class=\"heading-anchor\" aria-label=\"章节： Principles of Congestion Control\" tabindex=\"-1\"></a><span>Principles of Congestion Control</span></h2>\n<p>congestion 会导致<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>large queue delay</li>\n<li>router buffer overflow 会导致丢包以及 retransmission</li>\n<li>large delay 会导致 premature timeout 以及 unneeded retransmission</li>\n<li>在传输路径上如果在一个 router 处发生了丢包<span class=\"mojikumi-line-end\">，</span>在此之前的 router 的 work 都浪费了</li>\n</ul>\n<p>congestion control 分为两大类<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>end-to-end: 不依赖于 network layer<span class=\"mojikumi-line-end\">，</span>依靠 retransmission 或 delay 增大等现象推断出 congestion<span class=\"mojikumi-line-end\">。</span></li>\n<li>network-assisted: router 提供 congestion feedback<span class=\"mojikumi-line-start\">（</span>一个 bit 表示 link 是否 congested<span class=\"mojikumi-line-end\">，</span>或者更复杂的信息<span class=\"mojikumi-line-end\">，</span>例如 available bit rate<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>可以是由 router 发一个新的 packet<span class=\"mojikumi-line-end\">，</span>或者修改正在传输的其他 packet<span class=\"mojikumi-line-end\">，</span>一方收到 feedback 后再发给另一方<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<h2 id=\"tcp-congestion-control\" class=\"heading\"><a href=\"#tcp-congestion-control\" class=\"heading-anchor\" aria-label=\"章节： TCP Congestion Control\" tabindex=\"-1\"></a><span>TCP Congestion Control</span></h2>\n<h3 id=\"classic-tcp-congestion-control\" class=\"heading\"><a href=\"#classic-tcp-congestion-control\" class=\"heading-anchor\" aria-label=\"章节： Classic TCP Congestion Control\" tabindex=\"-1\"></a><span>Classic TCP Congestion Control</span></h3>\n<p>classic TCP congestion control 是 end-to-end 的<span class=\"mojikumi-line-end\">。</span></p>\n<p>TCP 使用 congestion window (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span>) 来限制发送速率<span class=\"mojikumi-line-end\">。</span><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span> 的效果与 receive window (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{rwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">rwnd</span></span></span></span></span></span>) 类似<span class=\"mojikumi-line-end\">，</span>会将 unacknowledged 的数据总量限制在 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>min</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\min(\\mathrm{cwnd}, \\mathrm{rwnd})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">min</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">rwnd</span></span><span class=\"mclose\">)</span></span></span></span></span> 之内<span class=\"mojikumi-line-end\">，</span>从而将发送速率限制在约 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><mi mathvariant=\"normal\">/</mi><mrow><mi mathvariant=\"normal\">R</mi><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">T</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd} / \\mathrm{RTT}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathrm\">RTT</span></span></span></span></span></span><span class=\"mojikumi-line-end\">。</span></p>\n<p>classic TCP congestion control 的基本原则<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>retransmission 是 congestion 的征兆<span class=\"mojikumi-line-end\">，</span>需要减小 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span></li>\n<li>segment 被 acknowledge 是没有 congestion 的征兆<span class=\"mojikumi-line-end\">，</span>可以增大 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span></li>\n<li>增大 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span> 相当于是在进行试探<span class=\"mojikumi-line-end\">，</span>即不断增大发送速率来试探增大到多大会发生 congestion</li>\n</ul>\n<p>具体分为三种模式<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>slow start: 初始状态以及 timeout 后转移到的状态<span class=\"mojikumi-line-end\">，</span>从 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><mo>=</mo><mn>1</mn><mtext> </mtext><mrow><mi mathvariant=\"normal\">M</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">S</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd} = 1\\ \\mathrm{MSS}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\"> </span><span class=\"mord\"><span class=\"mord mathrm\">MSS</span></span></span></span></span></span> 开始<span class=\"mojikumi-line-end\">，</span>每个 RTT <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span> 翻倍<span class=\"mojikumi-line-end\">，</span>直到 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi><mo>⩾</mo><mrow><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">h</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">h</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd \\geqslant \\mathrm{ssthresh}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8311em;vertical-align:-0.1367em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⩾</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">ssthresh</span></span></span></span></span></span></span><span class=\"mojikumi-line-end\">，</span>转移到 congestion avoidance<span class=\"mojikumi-line-end\">。</span></li>\n<li>congestion avoidance: 每个 RTT 内 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span> 增大 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mtext> </mtext><mrow><mi mathvariant=\"normal\">M</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">S</mi></mrow></mrow><annotation encoding=\"application/x-tex\">1\\ \\mathrm{MSS}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\"> </span><span class=\"mord\"><span class=\"mord mathrm\">MSS</span></span></span></span></span></span><span class=\"mojikumi-line-end\">。</span></li>\n<li>fast recovery: fast retransmit 后转移到的状态<span class=\"mojikumi-line-end\">，</span>从 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><mo>=</mo><mrow><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">h</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">h</mi></mrow><mo>+</mo><mn>3</mn><mtext> </mtext><mrow><mi mathvariant=\"normal\">M</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">S</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd} = \\mathrm{ssthresh} + 3\\ \\mathrm{MSS}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">ssthresh</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">3</span><span class=\"mspace\"> </span><span class=\"mord\"><span class=\"mord mathrm\">MSS</span></span></span></span></span></span> 开始<span class=\"mojikumi-line-end\">，</span>每个 duplicate ACK 都让 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span> 增大 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mtext> </mtext><mrow><mi mathvariant=\"normal\">M</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">S</mi></mrow></mrow><annotation encoding=\"application/x-tex\">1\\ \\mathrm{MSS}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\"> </span><span class=\"mord\"><span class=\"mord mathrm\">MSS</span></span></span></span></span></span><span class=\"mojikumi-line-end\">，</span>直到收到非 duplicate 的新的 ACK<span class=\"mojikumi-line-end\">，</span>转移到 congestion avoidance<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<p>具体细节如下图所示<span class=\"mojikumi-line-end\">：</span><sup><a href=\"#user-content-fn-fig-3.51\" id=\"user-content-fnref-fig-3.51\" data-footnote-ref aria-describedby=\"footnote-label\">6</a></sup></p>\n<p><picture><source type=\"image/webp\" srcset=\"/assets/cnatda-fig-3.51.5c10e88c.webp\"><img srcset=\"/assets/cnatda-fig-3.51.26a2bfa1.png\" loading=\"lazy\" src=\"/assets/cnatda-fig-3.51.26a2bfa1.png\" width=\"1315\" height=\"996\" alt=\"FSM description of TCP congestion control\"></picture></p>\n<p>正常情况下会在 congestion avoidance 和 fast recovery 之间反复切换<span class=\"mojikumi-line-end\">，</span>此时 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span> 的增长是线性的<span class=\"mojikumi-line-end\">，</span>降低是减半<span class=\"mojikumi-line-end\">，</span>称其是 <i>additive-increase, multiplicative-decrease</i> (AIMD) 的<span class=\"mojikumi-line-end\">。</span>AIMD congestion control 会导致 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span> 呈锯齿状变化<span class=\"mojikumi-line-end\">。</span></p>\n<p>TCP congestion control 有多个版本<span class=\"mojikumi-line-end\">，</span>上文描述的是 TCP Reno<span class=\"mojikumi-line-end\">，</span>如果用 slow start 来代替 fast recovery 则是更古老的 TCP Tahoe<span class=\"mojikumi-line-end\">。</span></p>\n<p>TCP Reno 的锯齿状 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span></span></span></span></span> 变化曲线实际上没能快速恢复到导致 congestion 的临界值<span class=\"mojikumi-line-end\">，</span>会产生较大的浪费<span class=\"mojikumi-line-end\">。</span>一个优化后的版本是 TCP CUBIC<span class=\"mojikumi-line-end\">，</span>它修改了 congestion avoidance 阶段的上升曲线<span class=\"mojikumi-line-end\">，</span>使其是一个三次函数曲线<span class=\"mojikumi-line-end\">，</span>如下图所示<span class=\"mojikumi-line-end\">：</span><sup><a href=\"#user-content-fn-fig-3.54\" id=\"user-content-fnref-fig-3.54\" data-footnote-ref aria-describedby=\"footnote-label\">7</a></sup></p>\n<p><picture><source type=\"image/webp\" srcset=\"/assets/cnatda-fig-3.54.bd38af1d.webp\"><img srcset=\"/assets/cnatda-fig-3.54.1d92cc88.png\" loading=\"lazy\" src=\"/assets/cnatda-fig-3.54.1d92cc88.png\" width=\"934\" height=\"632\" alt=\"TCP congestion avoidance sending rates: TCP Reno and TCP CUBIC\"></picture></p>\n<h3 id=\"network-assisted-explicit-congestion-notification\" class=\"heading\"><a href=\"#network-assisted-explicit-congestion-notification\" class=\"heading-anchor\" aria-label=\"章节： Network-Assisted Explicit Congestion Notification\" tabindex=\"-1\"></a><span>Network-Assisted Explicit Congestion Notification</span></h3>\n<p><a href=\"https://datatracker.ietf.org/doc/html/rfc3168\">Explicit Congestion Notification (ECN)</a> 是 network-assisted congestion control 的一种手段<span class=\"mojikumi-line-end\">，</span>它对 TCP 和 IP 都进行了扩展<span class=\"mojikumi-line-end\">。</span></p>\n<p>ECN 使用了 IP datagram header 的两个 bit<span class=\"mojikumi-line-end\">，</span>一个用来告诉 router 通信双方是 ECN-capable 的<span class=\"mojikumi-line-end\">，</span>另一个由 router 设置<span class=\"mojikumi-line-end\">，</span>表示自己处于 congestion<span class=\"mojikumi-line-start\">（</span>一般会在丢包实际发生前就设置<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span></p>\n<p>在一方收到 router 的 congestion 信息后<span class=\"mojikumi-line-end\">，</span>会在发给另一方的 ACK segment 里设置 ECE (explicit congestion notification echo) flag<span class=\"mojikumi-line-end\">，</span>另一方收到 ECE 后会将 congestion window 减半<span class=\"mojikumi-line-end\">，</span>并在下一个 segment 里设置 CWR (congestion window reduced) flag<span class=\"mojikumi-line-end\">。</span></p>\n<p>除了 TCP<span class=\"mojikumi-line-end\">，</span>还有其他 transport-layer protocol 利用了 ECN<span class=\"mojikumi-line-end\">，</span>例如与 UDP 类似但提供了 congestion control 的 DCCP<span class=\"mojikumi-line-end\">，</span>为 data center 设计的 DCTCP<span class=\"mojikumi-line-end\">、</span>DCQCN 等<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"delayed-based-congestion-control\" class=\"heading\"><a href=\"#delayed-based-congestion-control\" class=\"heading-anchor\" aria-label=\"章节： Delayed-based Congestion Control\" tabindex=\"-1\"></a><span>Delayed-based Congestion Control</span></h3>\n<p>delay-based congestion control 也能在丢包发生前就检测到 congestion<span class=\"mojikumi-line-end\">。</span></p>\n<p>TCP Vegas 会检测历史最大的 throughput<span class=\"mojikumi-line-start\">（</span><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">w</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">d</mi></mrow><mi mathvariant=\"normal\">/</mi><mrow><mi mathvariant=\"normal\">R</mi><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">T</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{cwnd} / \\mathrm{RTT}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">cwnd</span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathrm\">RTT</span></span></span></span></span></span><span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>若当前的 throughput 明显小于历史最大值<span class=\"mojikumi-line-end\">，</span>则说明发生了 congestion<span class=\"mojikumi-line-end\">。</span></p>\n<p>BBR 的思路类似<span class=\"mojikumi-line-end\">，</span>并采用了一些机制使其在与非 delay-based 的 congestion control 竞争时保持 fair<span class=\"mojikumi-line-end\">。</span>Google 在 2016 年已经在内部的 B4 网络中采用 BBR 替换了 TCP CUBIC<span class=\"mojikumi-line-end\">。</span></p>\n<p>此外<span class=\"mojikumi-line-end\">，</span>还有 TIMELY<span class=\"mojikumi-line-end\">、</span>Compound TCP<span class=\"mojikumi-line-end\">、</span>FAST 等 delay-based congestion control protocol<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"fairness\" class=\"heading\"><a href=\"#fairness\" class=\"heading-anchor\" aria-label=\"章节： Fairness\" tabindex=\"-1\"></a><span>Fairness</span></h3>\n<p>假设有 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span></span> 个 TCP 连接共用一个 transmission rate 为 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span></span> 的 bottleneck link<span class=\"mojikumi-line-end\">，</span>并且这个 link 上没有其他数据传输<span class=\"mojikumi-line-end\">。</span>如果每个连接的 throughput 都大约是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">R/K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span></span><span class=\"mojikumi-line-end\">，</span>则称所使用的 congestion control mechanism 是 fair 的<span class=\"mojikumi-line-end\">。</span></p>\n<p>在各方的 RTT 相同且只有 TCP 连接时<span class=\"mojikumi-line-end\">，</span>AIMD congestion control 是 fair 的<span class=\"mojikumi-line-end\">，</span>如下图所示<sup><a href=\"#user-content-fn-fig-3.57\" id=\"user-content-fnref-fig-3.57\" data-footnote-ref aria-describedby=\"footnote-label\">8</a></sup><span class=\"mojikumi-line-end\">，</span>addictive increase 是沿 45 度方向的<span class=\"mojikumi-line-end\">，</span>multiplicative decrease 是朝着原点的<span class=\"mojikumi-line-end\">，</span>所以会趋向 fair<span class=\"mojikumi-line-end\">。</span></p>\n<p>但是<span class=\"mojikumi-line-end\">，</span>在各方 RTT 不同时<span class=\"mojikumi-line-end\">，</span>RTT 小的往往能获得更大的 throughput<span class=\"mojikumi-line-end\">。</span></p>\n<p><picture><source type=\"image/webp\" srcset=\"/assets/cnatda-fig-3.57.18b0e5dd.webp\"><img srcset=\"/assets/cnatda-fig-3.57.35ca77c5.png\" loading=\"lazy\" src=\"/assets/cnatda-fig-3.57.35ca77c5.png\" width=\"813\" height=\"792\" alt=\"Throughput realized by two TCP connections\"></picture></p>\n<p>在有 UDP 连接参与时<span class=\"mojikumi-line-end\">，</span>由于 UDP 没有 congestion control<span class=\"mojikumi-line-end\">，</span>可能会导致 unfair<span class=\"mojikumi-line-end\">。</span></p>\n<p>上面讨论的 fairness 是对于 connection 而言的<span class=\"mojikumi-line-end\">，</span>而对于 application / host 就不一定 fair 了<span class=\"mojikumi-line-end\">，</span>因为可以建立多个 parallel TCP connection<span class=\"mojikumi-line-end\">，</span>例如浏览器一般就会这样做<span class=\"mojikumi-line-end\">。</span></p>\n<h2 id=\"evolution-of-transport-layer-functionality\" class=\"heading\"><a href=\"#evolution-of-transport-layer-functionality\" class=\"heading-anchor\" aria-label=\"章节： Evolution of Transport-Layer Functionality\" tabindex=\"-1\"></a><span>Evolution of Transport-Layer Functionality</span></h2>\n<p>虽然 Internet 只有 TCP 和 UDP 两个 transport-layer protocol<span class=\"mojikumi-line-end\">，</span>但 transport-layer functionality 依然在不断演化<span class=\"mojikumi-line-end\">。</span></p>\n<p>现在有非常多不同版本的 TCP 实现<span class=\"mojikumi-line-start\">（</span>例如上文提到的 TCP CUBIC<span class=\"mojikumi-line-end\">、</span>BBR 等<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>或是解决了旧版实现中的一些问题<span class=\"mojikumi-line-end\">，</span>或是更适配于特定的应用场景<span class=\"mojikumi-line-start\">（</span>网络环境<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span></p>\n<p>QUIC 是一个基于 UDP 的 application-layer protocol<span class=\"mojikumi-line-end\">，</span>有下列 feature<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>需要 handshake 建立连接<span class=\"mojikumi-line-end\">，</span>且所有数据都是加密的<span class=\"mojikumi-line-end\">。</span>connection-establishment handshake 和 authentication and encryption handshake 被合并在了一起<span class=\"mojikumi-line-end\">，</span>从而比 TLS 更快<span class=\"mojikumi-line-end\">。</span></li>\n<li>以 stream 为单位传输 application data<span class=\"mojikumi-line-end\">，</span>而多个 stream 可以放在单个 packet 中传输<span class=\"mojikumi-line-end\">。</span></li>\n<li>reliable data transfer<span class=\"mojikumi-line-end\">，</span>其中 in-order delivery 是对每个 stream 分别保序<span class=\"mojikumi-line-end\">，</span>所以不同 stream 之间不会带来阻塞 (HOL blocking)<span class=\"mojikumi-line-end\">。</span></li>\n<li>与 TCP 类似的 congestion control<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<p>作为一个 application-level protocol<span class=\"mojikumi-line-end\">，</span>QUIC 可以比 transport-layer protocol 更频繁地更新<span class=\"mojikumi-line-end\">。</span></p>\n<section data-footnotes class=\"footnotes\"><h2 class=\"sr-only\" id=\"footnote-label\">Footnotes</h2>\n<ol>\n<li id=\"user-content-fn-fig-3.29\">\n<p>p231, Figure 3.29: TCP segment structure <a href=\"#user-content-fnref-fig-3.29\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-fast-retransmit\">\n<p><a href=\"https://datatracker.ietf.org/doc/html/rfc2001#section-3\">3 Fast Retransmit - RFC2001</a> <a href=\"#user-content-fnref-fast-retransmit\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-delayed-ack\">\n<p><a href=\"https://datatracker.ietf.org/doc/html/rfc1122#page-97\">4.2.3.2  When to Send an ACK Segment - RFC1122</a> <a href=\"#user-content-fnref-delayed-ack\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-zero-window-probing-793\">\n<p><a href=\"https://datatracker.ietf.org/doc/html/rfc793#page-42\">Managing the Window - RFC793</a> <a href=\"#user-content-fnref-zero-window-probing-793\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-zero-window-probing-1122\">\n<p><a href=\"https://datatracker.ietf.org/doc/html/rfc1122#page-92\">4.2.2.17 Probing Zero Windows - RFC1122</a> <a href=\"#user-content-fnref-zero-window-probing-1122\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-fig-3.51\">\n<p>p268, Figure 3.51: FSM description of TCP congestion control <a href=\"#user-content-fnref-fig-3.51\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-fig-3.54\">\n<p>p272, Figure 3.54: TCP congestion avoidance sending rates: TCP Reno and TCP CUBIC <a href=\"#user-content-fnref-fig-3.54\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-fig-3.57\">\n<p>p278, Figure 3.57: Throughput realized by TCP connections 1 and 2 <a href=\"#user-content-fnref-fig-3.57\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n</ol>\n</section>",
            "url": "https://ouuan.moe/post/2023/06/cnatda-3",
            "title": "CNATDA 第三章学习笔记",
            "summary": "\n\n\n\n<p><span class=\"mojikumi-line-start\">《</span>Computer Networking: A Top-Down Approach (8th Edition)<span class=\"mojikumi-line-end\">》</span>第三章 <span class=\"mojikumi\">“</span>Transport Layer<span class=\"mojikumi\">”</span> 的学习笔记<span class=\"mojikumi-line-end\">。</span></p>\n",
            "date_modified": "2023-06-24T11:29:55.000Z",
            "tags": [
                "cnatda",
                "学习笔记"
            ]
        },
        {
            "id": "https://ouuan.moe/post/2023/06/cnatda-2",
            "content_html": "\n\n\n<p><span class=\"mojikumi-line-start\">《</span>Computer Networking: A Top-Down Approach (8th Edition)<span class=\"mojikumi-line-end\">》</span>第二章 <span class=\"mojikumi\">“</span>Application Layer<span class=\"mojikumi\">”</span> 的学习笔记<span class=\"mojikumi-line-end\">。</span></p>\n\n<h2 id=\"principles-of-network-applications\" class=\"heading\"><a href=\"#principles-of-network-applications\" class=\"heading-anchor\" aria-label=\"章节： Principles of Network Applications\" tabindex=\"-1\"></a><span>Principles of Network Applications</span></h2>\n<p>application architecture 主要分为 client-server 和 P2P 两种<span class=\"mojikumi-line-end\">。</span></p>\n<p><i>process</i> 即在某个 end system 上运行的程序<span class=\"mojikumi-line-start\">（</span>进程<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>不同 end system 上的 process 在网络上互相发送 message 以进行通信<span class=\"mojikumi-line-start\">（</span>注<span class=\"mojikumi-line-end\">：</span>message 即 application-layer packet<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span></p>\n<p>在一次通信中<span class=\"mojikumi-line-end\">，</span>发起通信的一方被称作 <i>client</i><span class=\"mojikumi-line-end\">，</span>等待接收消息的一方被称作 <i>server</i><span class=\"mojikumi\">。</span><wbr><span class=\"mojikumi-line-start\">（</span>注<span class=\"mojikumi-line-end\">：</span>在 P2P 中<span class=\"mojikumi-line-end\">，</span>client 和 server 的身份不是固定的<span class=\"mojikumi\">。</span><span class=\"mojikumi-line-end\">）</span></p>\n<p>process 和网络<span class=\"mojikumi-line-end\">，</span>或者说和 transport layer 之间以 <i>socket</i> 作为 API<span class=\"mojikumi-line-end\">。</span></p>\n<p>host 由 IP 地址识别<span class=\"mojikumi-line-end\">，</span>而 process 由 IP 地址 + 端口识别<span class=\"mojikumi-line-end\">。</span></p>\n<p>一个 application 可以选择 TCP 或者 UDP 来提供 transport service<span class=\"mojikumi-line-end\">。</span>TCP 提供 connection-oriented service<span class=\"mojikumi-line-start\">（</span>需要通过 handshaking 建立 TCP connection<span class=\"mojikumi-line-end\">）</span>和 reliable data transfer service<span class=\"mojikumi-line-start\">（</span>保证接收到 &#x26; 保序<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>以及 congestion control<span class=\"mojikumi-line-end\">。</span>UDP 则这些都不提供<span class=\"mojikumi-line-end\">。</span>一般会根据是否 loss-tolerant<span class=\"mojikumi-line-start\">（</span>是否允许丢失部分数据<span class=\"mojikumi-line-end\">）</span>以及对延时的敏感度来进行选择<span class=\"mojikumi-line-end\">。</span></p>\n<p>TLS (Transport Layer Security) 可以在 TCP 的基础上提供 encryption<span class=\"mojikumi-line-end\">、</span>data integrity<span class=\"mojikumi-line-end\">、</span>end-point authentication<span class=\"mojikumi-line-end\">。</span>它自身位于 application layer<span class=\"mojikumi-line-start\">（</span>或者可以说是 application 与 transport layer 之间 🤔<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>不与 TCP<span class=\"mojikumi-line-end\">、</span>UDP 并列<span class=\"mojikumi-line-end\">。</span></p>\n<p>application-layer protocol 决定了 message 的结构以及相应的行为<span class=\"mojikumi-line-end\">。</span>常见的 application-layer protocol 包括 HTTP<span class=\"mojikumi-line-end\">、</span>SMTP<span class=\"mojikumi-line-end\">、</span>Telnet<span class=\"mojikumi-line-end\">、</span>FTP<span class=\"mojikumi-line-end\">、</span>SIP<span class=\"mojikumi-line-end\">、</span>RTP<span class=\"mojikumi-line-end\">、</span>DASH 等<span class=\"mojikumi-line-end\">。</span>有的 application 会使用专有而非 public domain 的 application-layer protocol<span class=\"mojikumi-line-end\">。</span></p>\n<h2 id=\"the-web-and-http\" class=\"heading\"><a href=\"#the-web-and-http\" class=\"heading-anchor\" aria-label=\"章节： The Web and HTTP\" tabindex=\"-1\"></a><span>The Web and HTTP</span></h2>\n<p>HTTP (HyperText Transfer Protocol) 是 Web 的 application-layer protocol<span class=\"mojikumi-line-end\">，</span>定义了 client (browser) 如何向 server 请求文件<span class=\"mojikumi-line-start\">（</span>web page<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">、</span>server 如何将文件传输给 client<span class=\"mojikumi-line-end\">。</span></p>\n<p>HTTP 的默认端口是 80<span class=\"mojikumi-line-end\">。</span></p>\n<p>HTTP 不存储 client 的信息<span class=\"mojikumi-line-end\">，</span>是一个 <i>stateless protocol</i><span class=\"mojikumi-line-end\">。</span></p>\n<p>HTTP<span class=\"mojikumi-line-start\">（</span>1.0<span class=\"mojikumi-line-end\">、</span>1.1<span class=\"mojikumi-line-end\">、</span>2<span class=\"mojikumi-line-end\">）</span>基于 TCP<span class=\"mojikumi-line-end\">，</span>有 persistent connection 和 non-persistent connection 两种工作方式<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>non-persistent connection<span class=\"mojikumi-line-end\">：</span>每次 request-response 都会建立一个新的 TCP connection<span class=\"mojikumi-line-end\">，</span>收到 response 后立刻关闭 TCP connection<span class=\"mojikumi-line-end\">。</span></li>\n<li>persistent connection<span class=\"mojikumi-line-end\">：</span>同一对 client-server 的多次 request-response<span class=\"mojikumi-line-start\">（</span>例如一个页面引用的多个资源<span class=\"mojikumi-line-end\">）</span>可以共用同一个 TCP connection<span class=\"mojikumi-line-start\">（</span>在闲置一段时间后自动关闭<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>并且无需等待 response 就可以连续发送多个 request<span class=\"mojikumi-line-start\">（</span>被称作 <i>pipelining</i><span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>从而省下每次建立 TCP connection 耗费的 RTT (round-trip time)<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<p>HTTP message 是纯文本<span class=\"mojikumi-line-end\">，</span>格式如下<span class=\"mojikumi-line-end\">。</span></p>\n<p>HTTP request:<sup><a href=\"#user-content-fn-fig2.8\" id=\"user-content-fnref-fig2.8\" data-footnote-ref aria-describedby=\"footnote-label\">1</a></sup></p>\n<p><picture><source type=\"image/webp\" srcset=\"/assets/cnatda-fig-2.8.6bb26d3f.webp\"><img srcset=\"/assets/cnatda-fig-2.8.de34594f.png\" loading=\"lazy\" src=\"/assets/cnatda-fig-2.8.de34594f.png\" width=\"793\" height=\"439\" alt=\"General format of an HTTP request message\"></picture></p>\n<section class=\"code-block relative my-6 shadow\" itemprop=\"hasPart\" itemscope itemtype=\"https://schema.org/SoftwareSourceCode\" data-v-ad49d235><div class=\"h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex\" style=\"display:none;\" data-v-ad49d235><h3 class=\"text-3 text-footer\" itemprop=\"programmingLanguage\" aria-label=\"http 代码块\" data-v-ad49d235>http</h3><ile-root id=\"ile-1\"><button title=\"复制到剪贴板\" class=\"copy-button b-footer text-footer\" data-v-9288569d><span class=\"i-mdi-content-copy\" data-v-9288569d></span><span class=\"sr-only\" role=\"status\" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-1--></div><div class=\"light:hidden\" itemprop=\"text\" data-v-ad49d235><pre class=\"shiki dark\" style=\"background-color: #011627\" tabindex=\"0\"><code><span><span style=\"color: #C792EA\">GET</span><span style=\"color: #D6DEEB\"> /wireshark-labs/INTRO-wireshark-file1.html </span><span style=\"color: #C792EA\">HTTP</span><span style=\"color: #D6DEEB\">/</span><span style=\"color: #F78C6C\">1.1</span></span>\n<span><span style=\"color: #CAECE6\">Host</span><span style=\"color: #C792EA\">:</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #ECC48D\">gaia.cs.umass.edu</span></span>\n<span><span style=\"color: #CAECE6\">User-Agent</span><span style=\"color: #C792EA\">:</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #ECC48D\">curl/8.1.2</span></span>\n<span><span style=\"color: #CAECE6\">Accept</span><span style=\"color: #C792EA\">:</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #ECC48D\">*/*</span></span></code></pre></div><div class=\"light:important-block\" style=\"display:none;\" data-v-ad49d235><pre class=\"shiki light\" style=\"background-color: #FBFBFB\" tabindex=\"0\"><code><span><span style=\"color: #994CC3\">GET</span><span style=\"color: #403F53\"> /wireshark-labs/INTRO-wireshark-file1.html </span><span style=\"color: #994CC3\">HTTP</span><span style=\"color: #403F53\">/</span><span style=\"color: #AA0982\">1.1</span></span>\n<span><span style=\"color: #994CC3\">Host:</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">gaia.cs.umass.edu</span></span>\n<span><span style=\"color: #994CC3\">User-Agent:</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">curl/8.1.2</span></span>\n<span><span style=\"color: #994CC3\">Accept:</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">*/*</span></span></code></pre></div></section>\n<p>HTTP response:<sup><a href=\"#user-content-fn-fig2.9\" id=\"user-content-fnref-fig2.9\" data-footnote-ref aria-describedby=\"footnote-label\">2</a></sup></p>\n<p><picture><source type=\"image/webp\" srcset=\"/assets/cnatda-fig-2.9.d6740f57.webp\"><img srcset=\"/assets/cnatda-fig-2.9.c01ee471.png\" loading=\"lazy\" src=\"/assets/cnatda-fig-2.9.c01ee471.png\" width=\"792\" height=\"443\" alt=\"General format of an HTTP response message\"></picture></p>\n<section class=\"code-block relative my-6 shadow\" itemprop=\"hasPart\" itemscope itemtype=\"https://schema.org/SoftwareSourceCode\" data-v-ad49d235><div class=\"h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex\" style=\"display:none;\" data-v-ad49d235><h3 class=\"text-3 text-footer\" itemprop=\"programmingLanguage\" aria-label=\"http 代码块\" data-v-ad49d235>http</h3><ile-root id=\"ile-2\"><button title=\"复制到剪贴板\" class=\"copy-button b-footer text-footer\" data-v-9288569d><span class=\"i-mdi-content-copy\" data-v-9288569d></span><span class=\"sr-only\" role=\"status\" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-2--></div><div class=\"light:hidden\" itemprop=\"text\" data-v-ad49d235><pre class=\"shiki dark\" style=\"background-color: #011627\" tabindex=\"0\"><code><span><span style=\"color: #D6DEEB\">HTTP/1.1 200 OK</span></span>\n<span><span style=\"color: #CAECE6\">Date</span><span style=\"color: #C792EA\">:</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #ECC48D\">Tue, 13 Jun 2023 11:14:57 GMT</span></span>\n<span><span style=\"color: #CAECE6\">Server</span><span style=\"color: #C792EA\">:</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #ECC48D\">Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.33 mod_perl/2.0.11 Perl/v5.16.3</span></span>\n<span><span style=\"color: #CAECE6\">Last-Modified</span><span style=\"color: #C792EA\">:</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #ECC48D\">Tue, 13 Jun 2023 05:59:01 GMT</span></span>\n<span><span style=\"color: #CAECE6\">ETag</span><span style=\"color: #C792EA\">:</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #ECC48D\">&quot;51-5fdfc882a3e6f&quot;</span></span>\n<span><span style=\"color: #CAECE6\">Accept-Ranges</span><span style=\"color: #C792EA\">:</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #ECC48D\">bytes</span></span>\n<span><span style=\"color: #CAECE6\">Content-Length</span><span style=\"color: #C792EA\">:</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #ECC48D\">81</span></span>\n<span><span style=\"color: #CAECE6\">Content-Type</span><span style=\"color: #C792EA\">:</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #ECC48D\">text/html; charset=UTF-8</span></span>\n<span></span>\n<span><span style=\"color: #D6DEEB\">&lt;html&gt;</span></span>\n<span><span style=\"color: #D6DEEB\">Congratulations!  You&#39;ve downloaded the first Wireshark lab file!</span></span>\n<span><span style=\"color: #D6DEEB\">&lt;/html&gt;</span></span></code></pre></div><div class=\"light:important-block\" style=\"display:none;\" data-v-ad49d235><pre class=\"shiki light\" style=\"background-color: #FBFBFB\" tabindex=\"0\"><code><span><span style=\"color: #403F53\">HTTP/1.1 200 OK</span></span>\n<span><span style=\"color: #994CC3\">Date:</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">Tue, 13 Jun 2023 11:14:57 GMT</span></span>\n<span><span style=\"color: #994CC3\">Server:</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.33 mod_perl/2.0.11 Perl/v5.16.3</span></span>\n<span><span style=\"color: #994CC3\">Last-Modified:</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">Tue, 13 Jun 2023 05:59:01 GMT</span></span>\n<span><span style=\"color: #994CC3\">ETag:</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">&quot;51-5fdfc882a3e6f&quot;</span></span>\n<span><span style=\"color: #994CC3\">Accept-Ranges:</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">bytes</span></span>\n<span><span style=\"color: #994CC3\">Content-Length:</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">81</span></span>\n<span><span style=\"color: #994CC3\">Content-Type:</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">text/html; charset=UTF-8</span></span>\n<span></span>\n<span><span style=\"color: #403F53\">&lt;html&gt;</span></span>\n<span><span style=\"color: #403F53\">Congratulations!  You&#39;ve downloaded the first Wireshark lab file!</span></span>\n<span><span style=\"color: #403F53\">&lt;/html&gt;</span></span></code></pre></div></section>\n<p>server 可以通过 Cookie 识别用户<span class=\"mojikumi-line-end\">，</span>cookie 通过 response 中的 <code>Set-Cookie</code> header 设置<span class=\"mojikumi-line-end\">，</span>在之后的每次 request 中通过 <code>Cookie</code> header 发给 server<span class=\"mojikumi-line-end\">。</span></p>\n<p>机构可以设置 Web cache<span class=\"mojikumi-line-end\">，</span>使用户先向 Web cache 发送请求<span class=\"mojikumi-line-end\">，</span>若 cache hit 则直接由 Web cache 发给用户<span class=\"mojikumi-line-end\">，</span>若 cache miss 则 Web cache 向 origin server 发送请求再返回给用户<span class=\"mojikumi-line-end\">。</span>Web cache 可以减小延迟<span class=\"mojikumi-line-end\">，</span>降低带宽压力<span class=\"mojikumi\">。</span><wbr><span class=\"mojikumi-line-start\">（</span>与之类似的 CDN 则在<a href=\"#content-distribution-networks\">后文</a>有详细讲解<span class=\"mojikumi\">。</span><span class=\"mojikumi-line-end\">）</span></p>\n<p>可以通过 <code>If<wbr>-<wbr>Modified<wbr>-<wbr>Since</code> header 进行 <i>conditional GET</i><span class=\"mojikumi-line-end\">，</span>若没有修改则会返回 body 为空的 304 Not Modified<span class=\"mojikumi-line-end\">。</span></p>\n<p>HTTP/2 提供了 request and response multiplexing<span class=\"mojikumi-line-end\">、</span>prioritization<span class=\"mojikumi-line-end\">、</span>server push 来优化性能<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>multiplexing<span class=\"mojikumi-line-end\">：</span>persistent connection 减少了建立 TCP connection 带来的 RTT<span class=\"mojikumi-line-end\">，</span>但又引入了 Head of Line (HOL) blocking<span class=\"mojikumi-line-end\">，</span>即共用一个 TCP connection 时较小的资源需要等待较大的资源加载完毕<span class=\"mojikumi-line-end\">，</span>所以在 HTTP/1.1 中浏览器经常还是会建立多个 TCP 连接<span class=\"mojikumi-line-end\">，</span>除了解决 HOL blocking<span class=\"mojikumi-line-end\">，</span>也可以在 TCP 的 congestion control 中取得更多带宽<span class=\"mojikumi-line-end\">。</span>HTTP/2 则将每个 message 划分成了多个小的 frame<span class=\"mojikumi-line-end\">，</span>并交替发送不同 message 的 frame<span class=\"mojikumi-line-start\">（</span>frame interleaving<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>从而小的资源无需等待大的资源发送完毕<span class=\"mojikumi-line-end\">。</span></li>\n<li>prioritization<span class=\"mojikumi-line-end\">：</span>同时发送多个请求时<span class=\"mojikumi-line-end\">，</span>可以为每个 response 设置优先级<span class=\"mojikumi-line-end\">，</span>让 server 优先发送高优先级的 response<span class=\"mojikumi-line-end\">。</span>除此之外<span class=\"mojikumi-line-end\">，</span>还可以设置 response 之间的依赖关系<span class=\"mojikumi-line-end\">。</span></li>\n<li>server push<span class=\"mojikumi-line-end\">：</span>一个 request 可以有多个 response<span class=\"mojikumi-line-end\">，</span>即除了对应于 request 的 response<span class=\"mojikumi-line-end\">，</span>server 还可以额外 <i>push</i><span class=\"mojikumi-line-end\">，</span>例如在返回一个 HTML 页面时可以 push 这个页面引用的其他资源<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<p>HTTP/3 使用基于 UDP 的 QUIC 代替了 TCP<span class=\"mojikumi-line-end\">。</span></p>\n<h2 id=\"electronic-mail-in-the-internet\" class=\"heading\"><a href=\"#electronic-mail-in-the-internet\" class=\"heading-anchor\" aria-label=\"章节： Electronic Mail in the Internet\" tabindex=\"-1\"></a><span>Electronic Mail in the Internet</span></h2>\n<p>e-mail 系统有三个主要组件<span class=\"mojikumi-line-end\">：</span>user agent<span class=\"mojikumi-line-end\">、</span>mail server 和 SMTP (Simple Mail Transfer Protocol)<span class=\"mojikumi-line-end\">。</span></p>\n<p>发送邮件时<span class=\"mojikumi-line-end\">，</span>Alice 写完邮件后由她的 user agent 发送到她的 mail server<span class=\"mojikumi-line-end\">，</span>她的 mail server 再发到 Bob 的 mail server 中属于 Bob 的 mailbox<span class=\"mojikumi-line-end\">，</span>之后 Bob 再通过他的 user agent 从他的 mail server 获取他的 mailbox 中的邮件并阅读<span class=\"mojikumi-line-end\">。</span></p>\n<p>发送方的 mail server 会维护一个待发送邮件列表<span class=\"mojikumi-line-end\">，</span>如果接收方的 mail server 在当时不可用<span class=\"mojikumi-line-end\">，</span>则会等待一段时间后再次尝试<span class=\"mojikumi-line-end\">，</span>多次失败则会退回<span class=\"mojikumi-line-end\">。</span></p>\n<p>mail server 使用 SMTP 向其他 mail server 发送邮件<span class=\"mojikumi-line-end\">，</span>发送方作为 SMTP client<span class=\"mojikumi-line-end\">，</span>接收方作为 SMTP server<span class=\"mojikumi-line-end\">。</span></p>\n<p>SMTP 的默认端口是 25<span class=\"mojikumi-line-end\">。</span></p>\n<p>SMTP 是一个比 HTTP 还古老的协议<span class=\"mojikumi-line-end\">，</span>带来的后果之一是它整个 message 都只能包含 ASCII<span class=\"mojikumi-line-end\">。</span></p>\n<p>一次 SMTP 通信如下所示<span class=\"mojikumi-line-end\">：</span><sup><a href=\"#user-content-fn-smtp-example\" id=\"user-content-fnref-smtp-example\" data-footnote-ref aria-describedby=\"footnote-label\">3</a></sup></p>\n<section class=\"code-block relative my-6 shadow\" itemprop=\"hasPart\" itemscope itemtype=\"https://schema.org/SoftwareSourceCode\" data-v-ad49d235><div class=\"h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex\" style=\"display:none;\" data-v-ad49d235><h3 class=\"text-3 text-footer\" itemprop=\"programmingLanguage\" aria-label=\"plain 代码块\" data-v-ad49d235>plain</h3><ile-root id=\"ile-3\"><button title=\"复制到剪贴板\" class=\"copy-button b-footer text-footer\" data-v-9288569d><span class=\"i-mdi-content-copy\" data-v-9288569d></span><span class=\"sr-only\" role=\"status\" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-3--></div><div class=\"light:hidden\" itemprop=\"text\" data-v-ad49d235><pre class=\"shiki dark\" style=\"background-color: #011627\" tabindex=\"0\"><samp><span><span style=\"color: #d6deeb\">S: 220 smtp.example.com ESMTP Postfix</span></span>\n<span><span style=\"color: #d6deeb\">C: HELO relay.example.org</span></span>\n<span><span style=\"color: #d6deeb\">S: 250 Hello relay.example.org, I am glad to meet you</span></span>\n<span><span style=\"color: #d6deeb\">C: MAIL FROM:&lt;bob@example.org&gt;</span></span>\n<span><span style=\"color: #d6deeb\">S: 250 Ok</span></span>\n<span><span style=\"color: #d6deeb\">C: RCPT TO:&lt;alice@example.com&gt;</span></span>\n<span><span style=\"color: #d6deeb\">S: 250 Ok</span></span>\n<span><span style=\"color: #d6deeb\">C: RCPT TO:&lt;theboss@example.com&gt;</span></span>\n<span><span style=\"color: #d6deeb\">S: 250 Ok</span></span>\n<span><span style=\"color: #d6deeb\">C: DATA</span></span>\n<span><span style=\"color: #d6deeb\">S: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span></span>\n<span><span style=\"color: #d6deeb\">C: From: &quot;Bob Example&quot; &lt;bob@example.org&gt;</span></span>\n<span><span style=\"color: #d6deeb\">C: To: &quot;Alice Example&quot; &lt;alice@example.com&gt;</span></span>\n<span><span style=\"color: #d6deeb\">C: Cc: theboss@example.com</span></span>\n<span><span style=\"color: #d6deeb\">C: Date: Tue, 15 Jan 2008 16:02:43 -0500</span></span>\n<span><span style=\"color: #d6deeb\">C: Subject: Test message</span></span>\n<span><span style=\"color: #d6deeb\">C:</span></span>\n<span><span style=\"color: #d6deeb\">C: Hello Alice.</span></span>\n<span><span style=\"color: #d6deeb\">C: This is a test message with 5 header fields and 4 lines in the message body.</span></span>\n<span><span style=\"color: #d6deeb\">C: Your friend,</span></span>\n<span><span style=\"color: #d6deeb\">C: Bob</span></span>\n<span><span style=\"color: #d6deeb\">C: .</span></span>\n<span><span style=\"color: #d6deeb\">S: 250 Ok: queued as 12345</span></span>\n<span><span style=\"color: #d6deeb\">C: QUIT</span></span>\n<span><span style=\"color: #d6deeb\">S: 221 Bye</span></span></samp></pre></div><div class=\"light:important-block\" style=\"display:none;\" data-v-ad49d235><pre class=\"shiki light\" style=\"background-color: #FBFBFB\" tabindex=\"0\"><samp><span><span style=\"color: #403f53\">S: 220 smtp.example.com ESMTP Postfix</span></span>\n<span><span style=\"color: #403f53\">C: HELO relay.example.org</span></span>\n<span><span style=\"color: #403f53\">S: 250 Hello relay.example.org, I am glad to meet you</span></span>\n<span><span style=\"color: #403f53\">C: MAIL FROM:&lt;bob@example.org&gt;</span></span>\n<span><span style=\"color: #403f53\">S: 250 Ok</span></span>\n<span><span style=\"color: #403f53\">C: RCPT TO:&lt;alice@example.com&gt;</span></span>\n<span><span style=\"color: #403f53\">S: 250 Ok</span></span>\n<span><span style=\"color: #403f53\">C: RCPT TO:&lt;theboss@example.com&gt;</span></span>\n<span><span style=\"color: #403f53\">S: 250 Ok</span></span>\n<span><span style=\"color: #403f53\">C: DATA</span></span>\n<span><span style=\"color: #403f53\">S: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span></span>\n<span><span style=\"color: #403f53\">C: From: &quot;Bob Example&quot; &lt;bob@example.org&gt;</span></span>\n<span><span style=\"color: #403f53\">C: To: &quot;Alice Example&quot; &lt;alice@example.com&gt;</span></span>\n<span><span style=\"color: #403f53\">C: Cc: theboss@example.com</span></span>\n<span><span style=\"color: #403f53\">C: Date: Tue, 15 Jan 2008 16:02:43 -0500</span></span>\n<span><span style=\"color: #403f53\">C: Subject: Test message</span></span>\n<span><span style=\"color: #403f53\">C:</span></span>\n<span><span style=\"color: #403f53\">C: Hello Alice.</span></span>\n<span><span style=\"color: #403f53\">C: This is a test message with 5 header fields and 4 lines in the message body.</span></span>\n<span><span style=\"color: #403f53\">C: Your friend,</span></span>\n<span><span style=\"color: #403f53\">C: Bob</span></span>\n<span><span style=\"color: #403f53\">C: .</span></span>\n<span><span style=\"color: #403f53\">S: 250 Ok: queued as 12345</span></span>\n<span><span style=\"color: #403f53\">C: QUIT</span></span>\n<span><span style=\"color: #403f53\">S: 221 Bye</span></span></samp></pre></div></section>\n<p>其中 <code>HELO</code><span class=\"mojikumi-line-end\">、</span><code>MAIL FROM</code><span class=\"mojikumi-line-end\">、</span><code>RCPT TO</code><span class=\"mojikumi-line-end\">、</span><code>DATA</code><span class=\"mojikumi-line-end\">、</span><code>QUIT</code> 等是 <i>command</i><span class=\"mojikumi-line-end\">，</span>用来进行 handshake 等操作<span class=\"mojikumi-line-end\">。</span>如果要向同一个 mail server 连续发送多封邮件<span class=\"mojikumi-line-end\">，</span>可以只 <code>HELO</code><span class=\"mojikumi-line-end\">、</span><code>QUIT</code> 一次<span class=\"mojikumi-line-start\">（</span>但要 <code>MAIL FROM</code><span class=\"mojikumi-line-end\">、</span><code>RCPT TO</code> 多次<span class=\"mojikumi-line-end\">）</span>从而共用一个 TCP 连接<span class=\"mojikumi-line-end\">。</span><code>DATA</code> 后是邮件的内容<span class=\"mojikumi-line-end\">，</span>这一内容的开头是邮件的 header<span class=\"mojikumi-line-end\">，</span>结尾是仅包含 <code>.</code> 的一行<span class=\"mojikumi-line-end\">。</span></p>\n<p>email 是 user agent → mail server → mail server → user agent 而非 user agent → user agent<span class=\"mojikumi-line-end\">，</span>一大原因是如果 user agent 经常不在线则直接发很可能收不到邮件<span class=\"mojikumi-line-end\">，</span>需要用 mail server 来提高在线率以及提供对方不在线时重试的机制<span class=\"mojikumi-line-end\">。</span></p>\n<p>从 user agent 发到 mail server 时可以使用 SMTP 或 HTTP<span class=\"mojikumi-line-end\">，</span>从 mail server 拉取到 user agent 时可以使用 HTTP 或 IMAP (Internet Mail Access Protocol)<span class=\"mojikumi-line-start\">（</span>不能用 SMTP<span class=\"mojikumi-line-end\">，</span>因为 SMTP 是 push protocol<span class=\"mojikumi-line-end\">，</span>不能用来 pull<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span></p>\n<h2 id=\"dns--the-internet’s-directory-service\" class=\"heading\"><a href=\"#dns--the-internet’s-directory-service\" class=\"heading-anchor\" aria-label=\"章节： DNS—The Internet’s Directory Service\" tabindex=\"-1\"></a><span>DNS—The Internet<span class=\"mojikumi-narrow-left\">’</span>s Directory Service</span></h2>\n<h3 id=\"services-provided-by-dns\" class=\"heading\"><a href=\"#services-provided-by-dns\" class=\"heading-anchor\" aria-label=\"章节： Services Provided by DNS\" tabindex=\"-1\"></a><span>Services Provided by DNS</span></h3>\n<p>host 由 hostname 或 IP 地址识别<span class=\"mojikumi-line-end\">，</span>hostname 对人类更友好<span class=\"mojikumi-line-end\">，</span>而 IP 地址对路由器更友好<span class=\"mojikumi-line-end\">。</span></p>\n<p>将 hostname 翻译为 IP 地址是 DNS 的主要任务<span class=\"mojikumi-line-end\">。</span>DNS 是由多个层级的 DNS server 共同构成的 distributed database<span class=\"mojikumi-line-end\">，</span>也是使得 application 能够查询这个 distributed database 的 application-layer protocol<span class=\"mojikumi-line-end\">。</span></p>\n<p>DNS 被很多其他 application-layer protocol 所使用<span class=\"mojikumi-line-end\">，</span>例如在 HTTP/SMTP 中<span class=\"mojikumi-line-end\">，</span>可以使用 hostname 来访问网站 / mail server<span class=\"mojikumi-line-end\">，</span>这时就会调用 DNS<span class=\"mojikumi-line-end\">。</span></p>\n<p>DNS 在提供 hostname 到 IP 地址的翻译的同时<span class=\"mojikumi-line-end\">，</span>还提供了下列功能<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>host aliasing: 可以让一个 host 在有 canonical hostname 的同时还有其他 alias<span class=\"mojikumi-line-end\">。</span></li>\n<li>mail server aliasing: 可以让同一个 hostname 在作为 Web server 和作为 mail server 时指向不同的 host<span class=\"mojikumi-line-end\">。</span></li>\n<li>load distribution: 可以让同一个 hostname 指向多个 host<span class=\"mojikumi-line-end\">，</span>在返回查询结果时进行 rotate<span class=\"mojikumi-line-start\">（</span>即改变位于首位的 IP 地址<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<h3 id=\"overview-of-how-dns-works\" class=\"heading\"><a href=\"#overview-of-how-dns-works\" class=\"heading-anchor\" aria-label=\"章节： Overview of How DNS Works\" tabindex=\"-1\"></a><span>Overview of How DNS Works</span></h3>\n<p>由于下列原因<span class=\"mojikumi-line-end\">，</span>DNS 必须是分布式的<span class=\"mojikumi-line-end\">，</span>单点式的 DNS 无法 scale<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>single point of failure</li>\n<li>traffic volume 过大</li>\n<li>离部分用户距离过远<span class=\"mojikumi-line-end\">，</span>带来较大的延时</li>\n<li>难以维护<span class=\"mojikumi-line-start\">（</span>数据总量大<span class=\"mojikumi-line-end\">，</span>更新频繁<span class=\"mojikumi-line-end\">）</span></li>\n</ul>\n<p>一般来说<span class=\"mojikumi-line-end\">，</span>DNS 分为以下几层<span class=\"mojikumi-line-end\">：</span></p>\n<ol>\n<li>root DNS server: 分散在世界各地的 13 个不同 root server 各自的共上千个 copy<span class=\"mojikumi-line-end\">，</span>用来查询 TLD server</li>\n<li>top-level domain (TLD) server: 每个 TLD 有自己的 TLD server (or server cluster)<span class=\"mojikumi-line-end\">，</span>用来查询 authoritative DNS server</li>\n<li>authoritative DNS server: 每个 subdomain 有自己的 authoritative DNS server<span class=\"mojikumi-line-end\">，</span>可以是组织自己维护的或者由服务商提供的<span class=\"mojikumi-line-end\">，</span>用来查询 hostname 到 IP 地址的映射</li>\n</ol>\n<p>除此之外<span class=\"mojikumi-line-end\">，</span>TLD server 和 authoritative DNS server 之间还可能有 intermediate DNS server<span class=\"mojikumi-line-end\">。</span></p>\n<p>在上述 DNS server 的 hierarchy 之外<span class=\"mojikumi-line-end\">，</span>还有 local DNS server<span class=\"mojikumi-line-start\">（</span>就是电脑的网络设置里设的 DNS 服务器<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>作为 proxy 来代替 requesting host 向 DNS server 进行查询<span class=\"mojikumi-line-end\">。</span></p>\n<p>从逻辑上来说<span class=\"mojikumi-line-end\">，</span>向一个 DNS server 进行查询时<span class=\"mojikumi-line-end\">，</span>如果它自己不知道最终的 answer (IP 地址)<span class=\"mojikumi-line-end\">，</span>它可以让你换一个 DNS server 继续查 (iterative query)<span class=\"mojikumi-line-end\">，</span>或者帮你向其他 DNS server 发送查询 (recursive query) 然后返回最终的结果<span class=\"mojikumi-line-end\">。</span>而在实际中<span class=\"mojikumi-line-end\">，</span>如上文所述<span class=\"mojikumi-line-end\">，</span>一般是向 local DNS server 查询时会进行 recursive query<span class=\"mojikumi-line-end\">，</span>而 local DNS server 再从 root DNS server 向下直到 authoritative DNS server 进行 iterative query<span class=\"mojikumi-line-end\">。</span></p>\n<p>为了减少查询的数量<span class=\"mojikumi-line-end\">，</span>DNS 设有 caching<span class=\"mojikumi-line-end\">。</span>每个查询的发起者<span class=\"mojikumi-line-start\">（</span>requesting host 或者 local DNS server<span class=\"mojikumi-line-end\">）</span>会将收到的查询结果保存一段时间<span class=\"mojikumi-line-end\">，</span>cache miss 才会向其他 DNS server 发起查询<span class=\"mojikumi-line-end\">。</span>例如<span class=\"mojikumi-line-end\">，</span>常用的 TLD server 的 IP 地址往往都在 cache 中<span class=\"mojikumi-line-end\">，</span>大大减少了 root DNS server 收到的请求数量<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"dns-records\" class=\"heading\"><a href=\"#dns-records\" class=\"heading-anchor\" aria-label=\"章节： DNS Records\" tabindex=\"-1\"></a><span>DNS Records</span></h3>\n<p>DNS distributed database 存储的信息单元是 <i>resource record</i> (RR)<span class=\"mojikumi-line-end\">。</span></p>\n<p>每个 RR 包含 type<span class=\"mojikumi-line-end\">、</span>name<span class=\"mojikumi-line-end\">、</span>value<span class=\"mojikumi-line-end\">、</span>TTL 四项信息<span class=\"mojikumi-line-end\">，</span>其中 TTL 表示 cache 多久过期<span class=\"mojikumi-line-end\">。</span>常见的 type 包括以下几个<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>A: name 是 hostname<span class=\"mojikumi-line-end\">，</span>value 是 IP 地址<span class=\"mojikumi-line-end\">，</span>表示一个 hostname 到 IP 地址的映射<span class=\"mojikumi-line-end\">。</span></li>\n<li>NS: name 是 domain<span class=\"mojikumi-line-end\">，</span>value 是其 name server 的 hostname<span class=\"mojikumi-line-end\">，</span>表示可以在这个 name server 进行这个 domain 的进一步查询<span class=\"mojikumi-line-end\">。</span></li>\n<li>CNAME: name 是 alias hostname<span class=\"mojikumi-line-end\">，</span>value 是 canonical hostname<span class=\"mojikumi-line-end\">，</span>用来提供 host aliasing<span class=\"mojikumi-line-end\">。</span></li>\n<li>MX: name 是 alias hostname<span class=\"mojikumi-line-end\">，</span>value 是 canonical hostname<span class=\"mojikumi-line-end\">，</span>用来提供 mail server aliasing<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<p>对一个 hostname 来说 authoritative 的 DNS server 会包含被查询的 host 的 A record<span class=\"mojikumi-line-end\">。</span>不 authoritative 的 DNS server 则会包含相应的 NS record<span class=\"mojikumi-line-end\">，</span>以及这个 name server 的 A record<span class=\"mojikumi-line-end\">。</span></p>\n<p>下面是一个例子<span class=\"mojikumi-line-end\">：</span></p>\n<div class=\"overflow-auto my-6\"><table>\n<thead>\n<tr>\n<th align=\"center\">type</th>\n<th align=\"center\">name</th>\n<th align=\"center\">value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">NS</td>\n<td align=\"center\"><code>.</code></td>\n<td align=\"center\"><code>a<wbr>.<wbr>root<wbr>-<wbr>servers<wbr>.<wbr>net<wbr>.</code></td>\n</tr>\n<tr>\n<td align=\"center\">A</td>\n<td align=\"center\"><code>a<wbr>.<wbr>root<wbr>-<wbr>servers<wbr>.<wbr>net<wbr>.</code></td>\n<td align=\"center\"><code>198.41.0.4</code></td>\n</tr>\n<tr>\n<td align=\"center\">NS</td>\n<td align=\"center\"><code>moe.</code></td>\n<td align=\"center\"><code>ns1<wbr>.<wbr>dns<wbr>.<wbr>nic<wbr>.<wbr>moe<wbr>.</code></td>\n</tr>\n<tr>\n<td align=\"center\">A</td>\n<td align=\"center\"><code>ns1<wbr>.<wbr>dns<wbr>.<wbr>nic<wbr>.<wbr>moe<wbr>.</code></td>\n<td align=\"center\"><code>156<wbr>.<wbr>154<wbr>.<wbr>144<wbr>.<wbr>114</code></td>\n</tr>\n<tr>\n<td align=\"center\">NS</td>\n<td align=\"center\"><code>ouuan.moe.</code></td>\n<td align=\"center\"><code>amos<wbr>.<wbr>ns<wbr>.<wbr>cloudflare<wbr>.<wbr>com<wbr>.</code></td>\n</tr>\n<tr>\n<td align=\"center\">A</td>\n<td align=\"center\"><code>amos<wbr>.<wbr>ns<wbr>.<wbr>cloudflare<wbr>.<wbr>com<wbr>.</code></td>\n<td align=\"center\"><code>172<wbr>.<wbr>64<wbr>.<wbr>35<wbr>.<wbr>120</code></td>\n</tr>\n<tr>\n<td align=\"center\">A</td>\n<td align=\"center\"><code>ouuan.moe.</code></td>\n<td align=\"center\"><code>172<wbr>.<wbr>67<wbr>.<wbr>181<wbr>.<wbr>123</code></td>\n</tr>\n</tbody>\n</table></div>\n<p>在 registar 购买域名时可以填写 name server 的信息<span class=\"mojikumi-line-end\">，</span>由 registar 负责将相应的 NS 以及 A record 添加到 TLD server<span class=\"mojikumi-line-end\">。</span>可以使用域名商的 DNS server<span class=\"mojikumi-line-end\">、</span>其他服务商<span class=\"mojikumi-line-start\">（</span>例如 Cloudflare<span class=\"mojikumi-line-end\">）</span>的 DNS server 或者自己搭建的 DNS server 作为 authoritative DNS server<span class=\"mojikumi-line-end\">。</span></p>\n<p>DNS 最初只能静态更新<span class=\"mojikumi-line-start\">（</span>通过配置文件等方式<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>后来有了 DDNS 来通过 DNS message 动态更新<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"dns-messages\" class=\"heading\"><a href=\"#dns-messages\" class=\"heading-anchor\" aria-label=\"章节： DNS Messages\" tabindex=\"-1\"></a><span>DNS Messages</span></h3>\n<p>DNS message 通过 UDP 发送到 port 53<span class=\"mojikumi-line-end\">。</span></p>\n<p>DNS message 的结构如下图所示<span class=\"mojikumi-line-end\">：</span><sup><a href=\"#user-content-fn-fig-2.21\" id=\"user-content-fnref-fig-2.21\" data-footnote-ref aria-describedby=\"footnote-label\">4</a></sup></p>\n<p><picture><source type=\"image/webp\" srcset=\"/assets/cnatda-fig-2.21.b9121041.webp\"><img srcset=\"/assets/cnatda-fig-2.21.8f9be477.png\" loading=\"lazy\" src=\"/assets/cnatda-fig-2.21.8f9be477.png\" width=\"1349\" height=\"804\" alt=\"DNS message format\"></picture></p>\n<p>identification 由 client 设置<span class=\"mojikumi-line-end\">，</span>即用来识别 query 和 reply 对应关系的 ID<span class=\"mojikumi-line-end\">。</span></p>\n<p>flags 包括以下几个<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>query or reply: 这条 message 是 query 还是 reply</li>\n<li>authoritative or not: 返回的结果是否是最终的答案</li>\n<li>recursion desired: client 是否希望 server 进行 recursive query</li>\n<li>recursion available: server 是否可以进行 recursive query</li>\n</ul>\n<p>4 个 section 中都包含若干 RR<span class=\"mojikumi-line-end\">。</span></p>\n<p>在 query 中<span class=\"mojikumi-line-end\">，</span>question section 里会包含 name 和 type<span class=\"mojikumi-line-end\">。</span></p>\n<p>对于 type A 的查询<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>如果 reply 是 authoritative 的<span class=\"mojikumi-line-start\">（</span>向 authoritative DNS server 查询<span class=\"mojikumi-line-end\">，</span>或者进行了 recursive query<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>则会在 answer section 中列出所查询的 A record<span class=\"mojikumi-line-end\">。</span></li>\n<li>如果不是 authoritative 的<span class=\"mojikumi-line-end\">，</span>则会在 authority section 中列出 NS record<span class=\"mojikumi-line-end\">，</span>在 additional section 中列出这些 name server 的 A record<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<p>在 additional section 中<span class=\"mojikumi-line-end\">，</span>还可能列出 canonical hostname 的 A record 之类的<span class=\"mojikumi-line-end\">。</span></p>\n<h2 id=\"peer-to-peer-file-distribution\" class=\"heading\"><a href=\"#peer-to-peer-file-distribution\" class=\"heading-anchor\" aria-label=\"章节： Peer-to-Peer File Distribution\" tabindex=\"-1\"></a><span>Peer-to-Peer File Distribution</span></h2>\n<p>在传输大文件时<span class=\"mojikumi-line-end\">，</span>client-server 的架构在用户数量增多时需要更大的 server bandwidth 才能保证用户的下载速度<span class=\"mojikumi-line-end\">，</span>而 P2P 的架构则是 self-scalable 的<span class=\"mojikumi\">。</span><wbr><span class=\"mojikumi-line-start\">（</span>书中有简化模型的定量计算<span class=\"mojikumi\">。</span><span class=\"mojikumi-line-end\">）</span></p>\n<p>BitTorrent 是较为流行的 P2P file distribution protocol<span class=\"mojikumi-line-end\">。</span>在 BitTorrent 中<span class=\"mojikumi-line-end\">，</span>以 chunk 为下载文件的基本单位<span class=\"mojikumi-line-end\">。</span>一个 peer 刚加入 torrent 时没有 trunk 所以只能下载<span class=\"mojikumi-line-end\">，</span>在获取到一些 trunk 后就会开始上传给其他 peer<span class=\"mojikumi-line-end\">，</span>下载完成后可以自私地离开或者无私地保种<span class=\"mojikumi-line-end\">。</span></p>\n<p>每个 torrent 会有<span class=\"mojikumi-line-start\">（</span>至少<span class=\"mojikumi-line-end\">）</span>一个 tracker<span class=\"mojikumi-line-end\">，</span>peer 在加入/离开时会通知 tracker<span class=\"mojikumi-line-end\">，</span>并在过程中定期告知 tracker 自己仍在活动<span class=\"mojikumi-line-end\">。</span>tracker 会给每个 peer 提供一些其他 peer 的 IP 地址和端口<span class=\"mojikumi-line-end\">。</span></p>\n<p>在下载过程中<span class=\"mojikumi-line-end\">，</span>每个 peer 拥有一部分 chunk<span class=\"mojikumi-line-end\">，</span>并向其他 peer 请求 chunk<span class=\"mojikumi-line-end\">。</span>每个 peer 需要决定优先下载哪个 trunk 以及上传给谁<span class=\"mojikumi-line-end\">。</span></p>\n<p>优先下载的 trunk 可以采用 <i>rarest first</i> 的策略<span class=\"mojikumi-line-end\">，</span>即优先下载已知的 peer 中拥有人数最少的 chunk<span class=\"mojikumi-line-end\">，</span>这样的话就能使得各个 trunk 较为均匀地在 peer 间分布<span class=\"mojikumi-line-end\">。</span></p>\n<p>在下载过程中<span class=\"mojikumi-line-end\">，</span>会采用被称作<span class=\"mojikumi-line-start\">“</span>tit-for-tat<span class=\"mojikumi-line-end\">”</span>的策略决定上传给谁<span class=\"mojikumi-line-end\">：</span>上传给自己<span class=\"mojikumi-line-start\">（</span>即从他那下载<span class=\"mojikumi-line-end\">）</span>的速度最快的几个 peer 被称作<span class=\"mojikumi-line-start\">“</span>unchoked<span class=\"mojikumi\">”</span><span class=\"mojikumi-line-end\">，</span>除此之外还会每隔一段时间随机选择一个 peer 被称作<span class=\"mojikumi-line-start\">“</span>optimistically unchoked<span class=\"mojikumi\">”</span><span class=\"mojikumi-line-end\">，</span>最后做出的选择就是上传给<span class=\"mojikumi-line-start\">“</span>unchoked<span class=\"mojikumi-line-end\">”</span>和<span class=\"mojikumi-line-start\">“</span>optimistically unchoked<span class=\"mojikumi-line-end\">”</span>的这些 peer<span class=\"mojikumi-line-end\">。</span>这个策略实际上可以被绕过<span class=\"mojikumi-line-end\">，</span>但不被绕过时它提供了一个激励大家上传的机制<span class=\"mojikumi\">。</span><wbr><span class=\"mojikumi-line-start\">（</span>注<span class=\"mojikumi-line-end\">：</span>在下载完毕后保种时<span class=\"mojikumi-line-end\">，</span>会使用另外的策略<span class=\"mojikumi-line-end\">。</span><sup><a href=\"#user-content-fn-seed-choking\" id=\"user-content-fnref-seed-choking\" data-footnote-ref aria-describedby=\"footnote-label\">5</a></sup><span class=\"mojikumi-line-end\">）</span></p>\n<p>除了通过 tracker<span class=\"mojikumi-line-end\">，</span>还可以通过 Distributed Hash Table (DHT<span class=\"mojikumi-line-end\">，</span>一种 P2P 架构的 distributed database) 来获取 peer<span class=\"mojikumi-line-end\">。</span></p>\n<h2 id=\"video-streaming-and-content-distribution-networks\" class=\"heading\"><a href=\"#video-streaming-and-content-distribution-networks\" class=\"heading-anchor\" aria-label=\"章节： Video Streaming and Content Distribution Networks\" tabindex=\"-1\"></a><span>Video Streaming and Content Distribution Networks</span></h2>\n<h3 id=\"http-streaming-and-dash\" class=\"heading\"><a href=\"#http-streaming-and-dash\" class=\"heading-anchor\" aria-label=\"章节： HTTP Streaming and DASH\" tabindex=\"-1\"></a><span>HTTP Streaming and DASH</span></h3>\n<p>视频需要耗费大量的流量<span class=\"mojikumi-line-start\">（</span>以及存储空间<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>而 streaming 时需要保证至少有视频 bitrate 这么多的带宽才能避免卡顿<span class=\"mojikumi-line-end\">，</span>所以一般会根据可用的带宽选择不同质量的视频版本<span class=\"mojikumi-line-end\">。</span></p>\n<p>最基础的 streaming 方式是 HTTP streaming<span class=\"mojikumi-line-end\">，</span>即通过 HTTP GET 获取视频文件至缓冲区并播放<span class=\"mojikumi-line-end\">，</span>但这样无法适应不同用户的不同带宽<span class=\"mojikumi-line-end\">，</span>更无法适应同一个用户随时间变化的带宽<span class=\"mojikumi-line-end\">。</span></p>\n<p>在 Dynamic Adaptive Streaming over HTTP (DASH) 中<span class=\"mojikumi-line-end\">，</span>视频被编码为多个不同质量的版本<span class=\"mojikumi-line-end\">，</span>client 每次获取一个几秒的视频片段<span class=\"mojikumi-line-end\">，</span>并根据可用带宽动态调整选择的版本<span class=\"mojikumi-line-end\">。</span></p>\n<p>在开始播放之前<span class=\"mojikumi-line-end\">，</span>client 首先会获取 manifest file 来得到各个视频版本的 URL 以及 bitrate<span class=\"mojikumi-line-end\">。</span>在播放过程中<span class=\"mojikumi-line-end\">，</span>通过 HTTP GET 请求以及 byte range header 获取视频片段<span class=\"mojikumi-line-end\">，</span>同时计算可用带宽<span class=\"mojikumi-line-end\">，</span>决定接下来选择的视频版本<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"content-distribution-networks\" class=\"heading\"><a href=\"#content-distribution-networks\" class=\"heading-anchor\" aria-label=\"章节： Content Distribution Networks\" tabindex=\"-1\"></a><span>Content Distribution Networks</span></h3>\n<p>和 DNS 类似<span class=\"mojikumi-line-end\">，</span>video streaming 往往也不能仅通过单个 data center 实现<span class=\"mojikumi-line-end\">，</span>因为<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>离部分用户过远<span class=\"mojikumi-line-end\">，</span>虽然 streaming 对延时要求不高<span class=\"mojikumi-line-end\">，</span>但更多的 communication link 很可能意味着更低的 bottleneck bandwidth<span class=\"mojikumi-line-end\">。</span></li>\n<li>同一个视频会在同一个 communication link 上被传输多次<span class=\"mojikumi-line-end\">，</span>造成网络资源以及资费的浪费<span class=\"mojikumi-line-end\">。</span></li>\n<li>single point of failure</li>\n</ul>\n<p>为了解决这些问题<span class=\"mojikumi-line-end\">，</span>video-streaming company 往往会使用 Content Distribution Networks (CDN) 来分发视频<span class=\"mojikumi-line-end\">。</span></p>\n<p>CDN 会在全球各地放置 server (cluster)<span class=\"mojikumi-line-end\">，</span>在每个节点存放一份 content 的 copy<span class=\"mojikumi-line-end\">，</span>在处理 user request 时尽量由最好<span class=\"mojikumi-line-start\">（</span>最近<span class=\"mojikumi-line-end\">）</span>的节点负责响应<span class=\"mojikumi-line-end\">。</span></p>\n<p>CDN 可以是 private CDN<span class=\"mojikumi-line-start\">（</span>例如 Google 的 CDN<span class=\"mojikumi-line-end\">）</span>或者 third-party CDN<span class=\"mojikumi-line-start\">（</span>例如 Akamai<span class=\"mojikumi-line-end\">、</span>Limelight<span class=\"mojikumi-line-end\">、</span>Level-3<span class=\"mojikumi-line-end\">，</span><s>书中竟然没提到 Cloudflare</s><span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span></p>\n<p>CDN 通常有两种放置策略<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>Enter Deep: 放在 access ISP<span class=\"mojikumi-line-end\">，</span>cluster 数量多<span class=\"mojikumi-line-end\">，</span>性能更好<span class=\"mojikumi-line-end\">，</span>维护成本更高<span class=\"mojikumi-line-end\">。</span></li>\n<li>Bring Home: 放在 IXP<span class=\"mojikumi-line-end\">，</span>cluster 数量少<span class=\"mojikumi-line-end\">，</span>维护成本更低<span class=\"mojikumi-line-end\">，</span>性能相对差<span class=\"mojikumi-line-end\">。</span></li>\n</ul>\n<p>CDN 的更新有 push 和 pull 两种方式<span class=\"mojikumi-line-end\">，</span>push 就是内容更新时 push 到各个 cluster<span class=\"mojikumi-line-end\">，</span>pull 则与 cache 类似<span class=\"mojikumi-line-end\">，</span>在 cache miss 时再从上游获取并<span class=\"mojikumi-line-start\">（</span>在 stream 给用户的同时<span class=\"mojikumi-line-end\">）</span>保存下来<span class=\"mojikumi-line-end\">。</span></p>\n<p>将用户重定向到 CDN 节点的一种方式是通过 DNS<span class=\"mojikumi-line-end\">：</span>authoritative DNS server 返回 CDN 的 DNS server 的 NS record<span class=\"mojikumi-line-end\">，</span>然后再由 CDN 的 DNS server 进行节点选择并返回节点的 IP 地址<span class=\"mojikumi-line-end\">。</span></p>\n<p><span class=\"mojikumi-line-start\">（</span>基于 DNS 进行 CDN 重定向时<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>选择节点的两种方式是<span class=\"mojikumi-line-end\">：</span></p>\n<ul>\n<li>\n<p>geographically closest: 由 local DNS server 的 IP 确定地理位置<span class=\"mojikumi-line-end\">，</span>然后选择最近的节点<span class=\"mojikumi-line-end\">。</span>这样做的主要问题在于<span class=\"mojikumi-line-end\">，</span>地理位置近不一定意味着网络距离近/带宽高<span class=\"mojikumi-line-end\">，</span>并且 local DNS server 有可能离用户很远<span class=\"mojikumi-line-end\">。</span></p>\n</li>\n<li>\n<p>real-time measurements: 可以每隔一段时间向各个 local DNS server 发送探测信号来检测网络性能<span class=\"mojikumi-line-end\">，</span>这样做的主要问题在于 DNS server 可能会拒绝响应这样的探测<span class=\"mojikumi-line-end\">。</span></p>\n</li>\n</ul>\n<h3 id=\"case-studies-netflix-and-youtube\" class=\"heading\"><a href=\"#case-studies-netflix-and-youtube\" class=\"heading-anchor\" aria-label=\"章节： Case Studies: Netflix and YouTube\" tabindex=\"-1\"></a><span>Case Studies: Netflix and YouTube</span></h3>\n<p>Netflix 和 YouTube 都是大型 video streaming 服务商<span class=\"mojikumi-line-end\">，</span>但它们的架构有很大不同<span class=\"mojikumi-line-end\">，</span>这很大程度上是由于它们视频类型的不同<span class=\"mojikumi-line-start\">（</span>剧 vs UGC<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">。</span></p>\n<h4 id=\"netflix\" class=\"heading\"><a href=\"#netflix\" class=\"heading-anchor\" aria-label=\"章节： Netflix\" tabindex=\"-1\"></a><span>Netflix</span></h4>\n<p>Netflix 使用 Amazon cloud 运行 Web server 以及视频处理<span class=\"mojikumi-line-end\">，</span>而使用私有的 CDN 分发视频<span class=\"mojikumi-line-end\">。</span></p>\n<p>Netflix 的私有 CDN cluster 安装在 ISP 和 IXP 中<span class=\"mojikumi-line-end\">，</span>其中 IXP 的 cluster 往往容量较大<span class=\"mojikumi-line-end\">，</span>可以装下整个 Netflix 的所有视频的各个版本<span class=\"mojikumi-line-end\">，</span>而 ISP 的 cluster 往往容量较小<span class=\"mojikumi-line-end\">，</span>只存放最热门的视频<span class=\"mojikumi-line-end\">。</span></p>\n<p>Netflix 不使用 pull-caching<span class=\"mojikumi-line-end\">，</span>而是在每天的低峰期采用 push 进行更新<span class=\"mojikumi-line-end\">。</span></p>\n<p>因为 Netflix 的私有 CDN 只负责分发视频<span class=\"mojikumi-line-end\">，</span>它不需要使用 DNS redirect<span class=\"mojikumi-line-end\">，</span>直接由 Web server 告诉 client IP 地址即可<span class=\"mojikumi-line-end\">。</span></p>\n<h4 id=\"youtube\" class=\"heading\"><a href=\"#youtube\" class=\"heading-anchor\" aria-label=\"章节： YouTube\" tabindex=\"-1\"></a><span>YouTube</span></h4>\n<a id=\"google-的-network-infrastructure\" name=\"google-的-network-infrastructure\" aria-hidden=\"true\"></a>\n<aside role=\"note\" data-v-a2ab257f><div class=\"shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue\" data-v-a2ab257f><div class=\"p-3 flex justify-between items-center\" data-v-a2ab257f><h5 class=\"flex items-center gap-1 font-bold\" data-v-a2ab257f><span class=\"text-5 i-mdi-pencil text-blue\" data-v-a2ab257f></span><span class=\"sr-only\" data-v-a2ab257f>Note: </span><span data-v-a2ab257f>Google 的 network infrastructure</span></h5><!--v-if--></div><div class=\"overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover\" data-v-a2ab257f><p>Google 部署了一个庞大的 private network and CDN infrastructure<span class=\"mojikumi-line-end\">，</span>包含以下三级 server clusters<span class=\"mojikumi-line-end\">：</span></p><ol>\n<li>约 20 个<span class=\"mojikumi-line-start\">“</span>mega data center<span class=\"mojikumi\">”</span><span class=\"mojikumi-line-end\">，</span>分布在北美<span class=\"mojikumi-line-end\">、</span>欧洲和亚洲<span class=\"mojikumi-line-end\">，</span>每个 cluster 有数十万服务器<span class=\"mojikumi-line-end\">，</span>用来 serve dynamic content<span class=\"mojikumi-line-end\">。</span></li>\n<li>约 90 个部署在 IXP 的 cluster<span class=\"mojikumi-line-end\">，</span>每个 cluster 有数百个服务器<span class=\"mojikumi-line-end\">，</span>用来 serve 包括 YouTube 视频在内的 static content<span class=\"mojikumi-line-end\">。</span></li>\n<li>数百个部署在 access ISP 的 cluster<span class=\"mojikumi-line-end\">，</span>每个 cluster 有数十个服务器<span class=\"mojikumi-line-end\">，</span>用来进行 TCP splitting 以及 server static content<span class=\"mojikumi-line-end\">，</span>例如网页上的静态资源<span class=\"mojikumi-line-end\">。</span></li>\n</ol><p>在访问 Google 的服务时<span class=\"mojikumi-line-end\">，</span>不同内容往往会来自不同层级的 cluster<span class=\"mojikumi-line-end\">。</span></p><p>这些 cluster 通过 Google 的 private network 连接<span class=\"mojikumi-line-end\">，</span>使得它们之间的很多通信都不依赖于 public Internet<span class=\"mojikumi-line-end\">，</span>与用户的通信也往往只涉及到 access ISP 这一层<span class=\"mojikumi-line-end\">。</span></p></div></div></aside>\n<p>YouTube 使用 Google 的私有 CDN 分发视频<span class=\"mojikumi-line-end\">，</span>并且使用 pull-caching 和 DNS redirect<span class=\"mojikumi-line-end\">。</span>在选择节点时<span class=\"mojikumi-line-end\">，</span>会综合考虑 client 到 cluster 的 RTT 以及负载均衡<span class=\"mojikumi-line-end\">。</span></p>\n<p>在用户上传视频时<span class=\"mojikumi-line-end\">，</span>会在 Google 的 data center 进行处理<span class=\"mojikumi-line-end\">。</span></p>\n<h2 id=\"socket-programming-creating-network-applications\" class=\"heading\"><a href=\"#socket-programming-creating-network-applications\" class=\"heading-anchor\" aria-label=\"章节： Socket Programming: Creating Network Applications\" tabindex=\"-1\"></a><span>Socket Programming: Creating Network Applications</span></h2>\n<p>一般来说<span class=\"mojikumi-line-end\">，</span>编写 network application 需要编写 client program 和 server program<span class=\"mojikumi-line-end\">。</span></p>\n<h3 id=\"socket-programming-with-udp\" class=\"heading\"><a href=\"#socket-programming-with-udp\" class=\"heading-anchor\" aria-label=\"章节： Socket Programming with UDP\" tabindex=\"-1\"></a><span>Socket Programming with UDP</span></h3>\n<p>使用 UDP 时<span class=\"mojikumi-line-end\">，</span>每次发送 datagram 都需要指定 address<span class=\"mojikumi-line-start\">（</span>IP 地址 &#x26; 端口<span class=\"mojikumi\">）</span><span class=\"mojikumi-line-end\">，</span>接收 datagram 时也会收到对方的 address<span class=\"mojikumi-line-end\">。</span></p>\n<p><s>一看就懂但书上解释了半天的</s> 例子<span class=\"mojikumi-line-end\">：</span></p>\n<section class=\"code-block relative my-6 shadow\" itemprop=\"hasPart\" itemscope itemtype=\"https://schema.org/SoftwareSourceCode\" data-v-ad49d235><div class=\"h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex\" style=\"display:none;\" data-v-ad49d235><h4 class=\"text-3 text-footer\" itemprop=\"programmingLanguage\" aria-label=\"python 代码块\" data-v-ad49d235>python</h4><ile-root id=\"ile-4\"><button title=\"复制到剪贴板\" class=\"copy-button b-footer text-footer\" data-v-9288569d><span class=\"i-mdi-content-copy\" data-v-9288569d></span><span class=\"sr-only\" role=\"status\" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-4--></div><div class=\"light:hidden\" itemprop=\"text\" data-v-ad49d235><pre class=\"shiki dark\" style=\"background-color: #011627\" tabindex=\"0\"><code><span><span style=\"color: #C792EA\">from</span><span style=\"color: #D6DEEB\"> socket </span><span style=\"color: #C792EA\">import</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #C792EA\">*</span></span>\n<span><span style=\"color: #D6DEEB\">serverName </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #ECC48D\">hostname</span><span style=\"color: #D9F5DD\">&#39;</span></span>\n<span><span style=\"color: #D6DEEB\">serverPort </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #F78C6C\">12000</span></span>\n<span><span style=\"color: #D6DEEB\">clientSocket </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #B2CCD6\">socket</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">AF_INET</span><span style=\"color: #D9F5DD\">,</span><span style=\"color: #82AAFF\"> SOCK_DGRAM</span><span style=\"color: #D6DEEB\">) </span><span style=\"color: #637777\"># AF_INET 表示 IPv4 地址，SOCK_DGRAM 表示 UDP</span></span>\n<span><span style=\"color: #D6DEEB\">message </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #C5E478\">input</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #ECC48D\">Input lowercase sentence:</span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #D6DEEB\">clientSocket.</span><span style=\"color: #B2CCD6\">sendto</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">message.</span><span style=\"color: #B2CCD6\">encode</span><span style=\"color: #D6DEEB\">()</span><span style=\"color: #D9F5DD\">,</span><span style=\"color: #82AAFF\"> (serverName, serverPort)</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #D6DEEB\">modifiedMessage, serverAddress </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> clientSocket.</span><span style=\"color: #B2CCD6\">recvfrom</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #F78C6C\">2048</span><span style=\"color: #D6DEEB\">) </span><span style=\"color: #637777\"># 2048 是 buffer size</span></span>\n<span><span style=\"color: #C5E478\">print</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">modifiedMessage.</span><span style=\"color: #B2CCD6\">decode</span><span style=\"color: #D6DEEB\">())</span></span>\n<span><span style=\"color: #D6DEEB\">clientSocket.</span><span style=\"color: #B2CCD6\">close</span><span style=\"color: #D6DEEB\">()</span></span></code></pre></div><div class=\"light:important-block\" style=\"display:none;\" data-v-ad49d235><pre class=\"shiki light\" style=\"background-color: #FBFBFB\" tabindex=\"0\"><code><span><span style=\"color: #994CC3\">from</span><span style=\"color: #403F53\"> socket </span><span style=\"color: #994CC3\">import</span><span style=\"color: #403F53\"> </span><span style=\"color: #994CC3\">*</span></span>\n<span><span style=\"color: #403F53\">serverName </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #111111\">&#39;</span><span style=\"color: #C96765\">hostname</span><span style=\"color: #111111\">&#39;</span></span>\n<span><span style=\"color: #403F53\">serverPort </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #AA0982\">12000</span></span>\n<span><span style=\"color: #403F53\">clientSocket </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #0C969B\">socket</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">AF_INET</span><span style=\"color: #111111\">,</span><span style=\"color: #4876D6\"> SOCK_DGRAM</span><span style=\"color: #403F53\">) </span><span style=\"color: #989FB1\"># AF_INET 表示 IPv4 地址，SOCK_DGRAM 表示 UDP</span></span>\n<span><span style=\"color: #403F53\">message </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">input</span><span style=\"color: #403F53\">(</span><span style=\"color: #111111\">&#39;</span><span style=\"color: #C96765\">Input lowercase sentence:</span><span style=\"color: #111111\">&#39;</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #403F53\">clientSocket.</span><span style=\"color: #0C969B\">sendto</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">message.</span><span style=\"color: #0C969B\">encode</span><span style=\"color: #403F53\">()</span><span style=\"color: #111111\">,</span><span style=\"color: #4876D6\"> (serverName, serverPort)</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #403F53\">modifiedMessage, serverAddress </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> clientSocket.</span><span style=\"color: #0C969B\">recvfrom</span><span style=\"color: #403F53\">(</span><span style=\"color: #AA0982\">2048</span><span style=\"color: #403F53\">) </span><span style=\"color: #989FB1\"># 2048 是 buffer size</span></span>\n<span><span style=\"color: #4876D6\">print</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">modifiedMessage.</span><span style=\"color: #0C969B\">decode</span><span style=\"color: #403F53\">())</span></span>\n<span><span style=\"color: #403F53\">clientSocket.</span><span style=\"color: #0C969B\">close</span><span style=\"color: #403F53\">()</span></span></code></pre></div></section>\n<section class=\"code-block relative my-6 shadow\" itemprop=\"hasPart\" itemscope itemtype=\"https://schema.org/SoftwareSourceCode\" data-v-ad49d235><div class=\"h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex\" style=\"display:none;\" data-v-ad49d235><h4 class=\"text-3 text-footer\" itemprop=\"programmingLanguage\" aria-label=\"python 代码块\" data-v-ad49d235>python</h4><ile-root id=\"ile-5\"><button title=\"复制到剪贴板\" class=\"copy-button b-footer text-footer\" data-v-9288569d><span class=\"i-mdi-content-copy\" data-v-9288569d></span><span class=\"sr-only\" role=\"status\" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-5--></div><div class=\"light:hidden\" itemprop=\"text\" data-v-ad49d235><pre class=\"shiki dark\" style=\"background-color: #011627\" tabindex=\"0\"><code><span><span style=\"color: #C792EA\">from</span><span style=\"color: #D6DEEB\"> socket </span><span style=\"color: #C792EA\">import</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #C792EA\">*</span></span>\n<span><span style=\"color: #D6DEEB\">serverPort </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #F78C6C\">12000</span></span>\n<span><span style=\"color: #D6DEEB\">serverSocket </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #B2CCD6\">socket</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">AF_INET</span><span style=\"color: #D9F5DD\">,</span><span style=\"color: #82AAFF\"> SOCK_DGRAM</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #D6DEEB\">serverSocket.</span><span style=\"color: #B2CCD6\">bind</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">(</span><span style=\"color: #D9F5DD\">&#39;&#39;</span><span style=\"color: #82AAFF\">, serverPort)</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #C5E478\">print</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #ECC48D\">The server is ready to receive</span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #C792EA\">while</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #FF5874\">True</span><span style=\"color: #D6DEEB\">:</span></span>\n<span><span style=\"color: #D6DEEB\">    message, clientAddress </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> serverSocket.</span><span style=\"color: #B2CCD6\">recvfrom</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #F78C6C\">2048</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #D6DEEB\">    modifiedMessage </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> message.</span><span style=\"color: #B2CCD6\">decode</span><span style=\"color: #D6DEEB\">().</span><span style=\"color: #B2CCD6\">upper</span><span style=\"color: #D6DEEB\">()</span></span>\n<span><span style=\"color: #D6DEEB\">    serverSocket.</span><span style=\"color: #B2CCD6\">sendto</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">modifiedMessage.</span><span style=\"color: #B2CCD6\">encode</span><span style=\"color: #D6DEEB\">()</span><span style=\"color: #D9F5DD\">,</span><span style=\"color: #82AAFF\"> clientAddress</span><span style=\"color: #D6DEEB\">)</span></span></code></pre></div><div class=\"light:important-block\" style=\"display:none;\" data-v-ad49d235><pre class=\"shiki light\" style=\"background-color: #FBFBFB\" tabindex=\"0\"><code><span><span style=\"color: #994CC3\">from</span><span style=\"color: #403F53\"> socket </span><span style=\"color: #994CC3\">import</span><span style=\"color: #403F53\"> </span><span style=\"color: #994CC3\">*</span></span>\n<span><span style=\"color: #403F53\">serverPort </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #AA0982\">12000</span></span>\n<span><span style=\"color: #403F53\">serverSocket </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #0C969B\">socket</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">AF_INET</span><span style=\"color: #111111\">,</span><span style=\"color: #4876D6\"> SOCK_DGRAM</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #403F53\">serverSocket.</span><span style=\"color: #0C969B\">bind</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">(</span><span style=\"color: #111111\">&#39;&#39;</span><span style=\"color: #4876D6\">, serverPort)</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #4876D6\">print</span><span style=\"color: #403F53\">(</span><span style=\"color: #111111\">&#39;</span><span style=\"color: #C96765\">The server is ready to receive</span><span style=\"color: #111111\">&#39;</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #994CC3\">while</span><span style=\"color: #403F53\"> </span><span style=\"color: #BC5454\">True</span><span style=\"color: #403F53\">:</span></span>\n<span><span style=\"color: #403F53\">    message, clientAddress </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> serverSocket.</span><span style=\"color: #0C969B\">recvfrom</span><span style=\"color: #403F53\">(</span><span style=\"color: #AA0982\">2048</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #403F53\">    modifiedMessage </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> message.</span><span style=\"color: #0C969B\">decode</span><span style=\"color: #403F53\">().</span><span style=\"color: #0C969B\">upper</span><span style=\"color: #403F53\">()</span></span>\n<span><span style=\"color: #403F53\">    serverSocket.</span><span style=\"color: #0C969B\">sendto</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">modifiedMessage.</span><span style=\"color: #0C969B\">encode</span><span style=\"color: #403F53\">()</span><span style=\"color: #111111\">,</span><span style=\"color: #4876D6\"> clientAddress</span><span style=\"color: #403F53\">)</span></span></code></pre></div></section>\n<h3 id=\"socket-programming-with-tcp\" class=\"heading\"><a href=\"#socket-programming-with-tcp\" class=\"heading-anchor\" aria-label=\"章节： Socket Programming with TCP\" tabindex=\"-1\"></a><span>Socket Programming with TCP</span></h3>\n<p>TCP 是一个 connection-oriented protocol<span class=\"mojikumi-line-end\">，</span>在 server 上分为 welcoming socket 和 connection socket<span class=\"mojikumi-line-end\">，</span>一开始需要通过 welcoming socket 建立 connection 并得到 connection socket<span class=\"mojikumi-line-end\">，</span>而在建立了 connection 之后就无需再指定对方的 address<span class=\"mojikumi-line-end\">。</span></p>\n<p><span class=\"mojikumi-line-start\">（</span>下面的代码除了换成 TCP 还对上面的 UDP 代码有若干没有本质区别的修改<span class=\"mojikumi-line-end\">，</span>要是我写肯定会避免<span class=\"mojikumi-line-end\">，</span>但是从书上复制就懒得改了<span class=\"mojikumi\">。</span><span class=\"mojikumi-line-end\">）</span></p>\n<section class=\"code-block relative my-6 shadow\" itemprop=\"hasPart\" itemscope itemtype=\"https://schema.org/SoftwareSourceCode\" data-v-ad49d235><div class=\"h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex\" style=\"display:none;\" data-v-ad49d235><h4 class=\"text-3 text-footer\" itemprop=\"programmingLanguage\" aria-label=\"python 代码块\" data-v-ad49d235>python</h4><ile-root id=\"ile-6\"><button title=\"复制到剪贴板\" class=\"copy-button b-footer text-footer\" data-v-9288569d><span class=\"i-mdi-content-copy\" data-v-9288569d></span><span class=\"sr-only\" role=\"status\" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-6--></div><div class=\"light:hidden\" itemprop=\"text\" data-v-ad49d235><pre class=\"shiki dark\" style=\"background-color: #011627\" tabindex=\"0\"><code><span><span style=\"color: #C792EA\">from</span><span style=\"color: #D6DEEB\"> socket </span><span style=\"color: #C792EA\">import</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #C792EA\">*</span></span>\n<span><span style=\"color: #D6DEEB\">serverName </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #ECC48D\">servername</span><span style=\"color: #D9F5DD\">&#39;</span></span>\n<span><span style=\"color: #D6DEEB\">serverPort </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #F78C6C\">12000</span></span>\n<span><span style=\"color: #D6DEEB\">clientSocket </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #B2CCD6\">socket</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">AF_INET</span><span style=\"color: #D9F5DD\">,</span><span style=\"color: #82AAFF\"> SOCK_STREAM</span><span style=\"color: #D6DEEB\">) </span><span style=\"color: #637777\"># SOCK_STREAM 是 TCP</span></span>\n<span><span style=\"color: #D6DEEB\">clientSocket.</span><span style=\"color: #B2CCD6\">connect</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">(serverName, serverPort)</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #D6DEEB\">sentence </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #C5E478\">input</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #ECC48D\">Input lowercase sentence:</span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #D6DEEB\">clientSocket.</span><span style=\"color: #B2CCD6\">send</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">sentence.</span><span style=\"color: #B2CCD6\">encode</span><span style=\"color: #D6DEEB\">())</span></span>\n<span><span style=\"color: #D6DEEB\">modifiedSentence </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> clientSocket.</span><span style=\"color: #B2CCD6\">recv</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #F78C6C\">1024</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #C5E478\">print</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #ECC48D\">From Server: </span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #D9F5DD\">,</span><span style=\"color: #82AAFF\"> modifiedSentence.</span><span style=\"color: #B2CCD6\">decode</span><span style=\"color: #D6DEEB\">())</span></span>\n<span><span style=\"color: #D6DEEB\">clientSocket.</span><span style=\"color: #B2CCD6\">close</span><span style=\"color: #D6DEEB\">()</span></span></code></pre></div><div class=\"light:important-block\" style=\"display:none;\" data-v-ad49d235><pre class=\"shiki light\" style=\"background-color: #FBFBFB\" tabindex=\"0\"><code><span><span style=\"color: #994CC3\">from</span><span style=\"color: #403F53\"> socket </span><span style=\"color: #994CC3\">import</span><span style=\"color: #403F53\"> </span><span style=\"color: #994CC3\">*</span></span>\n<span><span style=\"color: #403F53\">serverName </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #111111\">&#39;</span><span style=\"color: #C96765\">servername</span><span style=\"color: #111111\">&#39;</span></span>\n<span><span style=\"color: #403F53\">serverPort </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #AA0982\">12000</span></span>\n<span><span style=\"color: #403F53\">clientSocket </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #0C969B\">socket</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">AF_INET</span><span style=\"color: #111111\">,</span><span style=\"color: #4876D6\"> SOCK_STREAM</span><span style=\"color: #403F53\">) </span><span style=\"color: #989FB1\"># SOCK_STREAM 是 TCP</span></span>\n<span><span style=\"color: #403F53\">clientSocket.</span><span style=\"color: #0C969B\">connect</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">(serverName, serverPort)</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #403F53\">sentence </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #4876D6\">input</span><span style=\"color: #403F53\">(</span><span style=\"color: #111111\">&#39;</span><span style=\"color: #C96765\">Input lowercase sentence:</span><span style=\"color: #111111\">&#39;</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #403F53\">clientSocket.</span><span style=\"color: #0C969B\">send</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">sentence.</span><span style=\"color: #0C969B\">encode</span><span style=\"color: #403F53\">())</span></span>\n<span><span style=\"color: #403F53\">modifiedSentence </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> clientSocket.</span><span style=\"color: #0C969B\">recv</span><span style=\"color: #403F53\">(</span><span style=\"color: #AA0982\">1024</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #4876D6\">print</span><span style=\"color: #403F53\">(</span><span style=\"color: #111111\">&#39;</span><span style=\"color: #C96765\">From Server: </span><span style=\"color: #111111\">&#39;</span><span style=\"color: #111111\">,</span><span style=\"color: #4876D6\"> modifiedSentence.</span><span style=\"color: #0C969B\">decode</span><span style=\"color: #403F53\">())</span></span>\n<span><span style=\"color: #403F53\">clientSocket.</span><span style=\"color: #0C969B\">close</span><span style=\"color: #403F53\">()</span></span></code></pre></div></section>\n<section class=\"code-block relative my-6 shadow\" itemprop=\"hasPart\" itemscope itemtype=\"https://schema.org/SoftwareSourceCode\" data-v-ad49d235><div class=\"h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex\" style=\"display:none;\" data-v-ad49d235><h4 class=\"text-3 text-footer\" itemprop=\"programmingLanguage\" aria-label=\"python 代码块\" data-v-ad49d235>python</h4><ile-root id=\"ile-7\"><button title=\"复制到剪贴板\" class=\"copy-button b-footer text-footer\" data-v-9288569d><span class=\"i-mdi-content-copy\" data-v-9288569d></span><span class=\"sr-only\" role=\"status\" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-7--></div><div class=\"light:hidden\" itemprop=\"text\" data-v-ad49d235><pre class=\"shiki dark\" style=\"background-color: #011627\" tabindex=\"0\"><code><span><span style=\"color: #C792EA\">from</span><span style=\"color: #D6DEEB\"> socket </span><span style=\"color: #C792EA\">import</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #C792EA\">*</span></span>\n<span><span style=\"color: #D6DEEB\">serverPort </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #F78C6C\">12000</span></span>\n<span><span style=\"color: #D6DEEB\">serverSocket </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #B2CCD6\">socket</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">AF_INET</span><span style=\"color: #D9F5DD\">,</span><span style=\"color: #82AAFF\"> SOCK_STREAM</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #D6DEEB\">serverSocket.</span><span style=\"color: #B2CCD6\">bind</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">(</span><span style=\"color: #D9F5DD\">&#39;&#39;</span><span style=\"color: #82AAFF\">, serverPort)</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #D6DEEB\">serverSocket.</span><span style=\"color: #B2CCD6\">listen</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #F78C6C\">1</span><span style=\"color: #D6DEEB\">) </span><span style=\"color: #637777\"># 1 是 connection queue 的最大长度</span></span>\n<span><span style=\"color: #C5E478\">print</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #ECC48D\">The server is ready to receive</span><span style=\"color: #D9F5DD\">&#39;</span><span style=\"color: #D6DEEB\">)</span></span>\n<span><span style=\"color: #C792EA\">while</span><span style=\"color: #D6DEEB\"> </span><span style=\"color: #FF5874\">True</span><span style=\"color: #D6DEEB\">:</span></span>\n<span><span style=\"color: #D6DEEB\">    connectionSocket, addr </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> serverSocket.</span><span style=\"color: #B2CCD6\">accept</span><span style=\"color: #D6DEEB\">()</span></span>\n<span><span style=\"color: #D6DEEB\">    sentence </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> connectionSocket.</span><span style=\"color: #B2CCD6\">recv</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #F78C6C\">1024</span><span style=\"color: #D6DEEB\">).</span><span style=\"color: #B2CCD6\">decode</span><span style=\"color: #D6DEEB\">()</span></span>\n<span><span style=\"color: #D6DEEB\">    capitalizedSentence </span><span style=\"color: #C792EA\">=</span><span style=\"color: #D6DEEB\"> sentence.</span><span style=\"color: #B2CCD6\">upper</span><span style=\"color: #D6DEEB\">()</span></span>\n<span><span style=\"color: #D6DEEB\">    connectionSocket.</span><span style=\"color: #B2CCD6\">send</span><span style=\"color: #D6DEEB\">(</span><span style=\"color: #82AAFF\">capitalizedSentence.</span><span style=\"color: #B2CCD6\">encode</span><span style=\"color: #D6DEEB\">())</span></span>\n<span><span style=\"color: #D6DEEB\">    connectionSocket.</span><span style=\"color: #B2CCD6\">close</span><span style=\"color: #D6DEEB\">()</span></span></code></pre></div><div class=\"light:important-block\" style=\"display:none;\" data-v-ad49d235><pre class=\"shiki light\" style=\"background-color: #FBFBFB\" tabindex=\"0\"><code><span><span style=\"color: #994CC3\">from</span><span style=\"color: #403F53\"> socket </span><span style=\"color: #994CC3\">import</span><span style=\"color: #403F53\"> </span><span style=\"color: #994CC3\">*</span></span>\n<span><span style=\"color: #403F53\">serverPort </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #AA0982\">12000</span></span>\n<span><span style=\"color: #403F53\">serverSocket </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> </span><span style=\"color: #0C969B\">socket</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">AF_INET</span><span style=\"color: #111111\">,</span><span style=\"color: #4876D6\"> SOCK_STREAM</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #403F53\">serverSocket.</span><span style=\"color: #0C969B\">bind</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">(</span><span style=\"color: #111111\">&#39;&#39;</span><span style=\"color: #4876D6\">, serverPort)</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #403F53\">serverSocket.</span><span style=\"color: #0C969B\">listen</span><span style=\"color: #403F53\">(</span><span style=\"color: #AA0982\">1</span><span style=\"color: #403F53\">) </span><span style=\"color: #989FB1\"># 1 是 connection queue 的最大长度</span></span>\n<span><span style=\"color: #4876D6\">print</span><span style=\"color: #403F53\">(</span><span style=\"color: #111111\">&#39;</span><span style=\"color: #C96765\">The server is ready to receive</span><span style=\"color: #111111\">&#39;</span><span style=\"color: #403F53\">)</span></span>\n<span><span style=\"color: #994CC3\">while</span><span style=\"color: #403F53\"> </span><span style=\"color: #BC5454\">True</span><span style=\"color: #403F53\">:</span></span>\n<span><span style=\"color: #403F53\">    connectionSocket, addr </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> serverSocket.</span><span style=\"color: #0C969B\">accept</span><span style=\"color: #403F53\">()</span></span>\n<span><span style=\"color: #403F53\">    sentence </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> connectionSocket.</span><span style=\"color: #0C969B\">recv</span><span style=\"color: #403F53\">(</span><span style=\"color: #AA0982\">1024</span><span style=\"color: #403F53\">).</span><span style=\"color: #0C969B\">decode</span><span style=\"color: #403F53\">()</span></span>\n<span><span style=\"color: #403F53\">    capitalizedSentence </span><span style=\"color: #994CC3\">=</span><span style=\"color: #403F53\"> sentence.</span><span style=\"color: #0C969B\">upper</span><span style=\"color: #403F53\">()</span></span>\n<span><span style=\"color: #403F53\">    connectionSocket.</span><span style=\"color: #0C969B\">send</span><span style=\"color: #403F53\">(</span><span style=\"color: #4876D6\">capitalizedSentence.</span><span style=\"color: #0C969B\">encode</span><span style=\"color: #403F53\">())</span></span>\n<span><span style=\"color: #403F53\">    connectionSocket.</span><span style=\"color: #0C969B\">close</span><span style=\"color: #403F53\">()</span></span></code></pre></div></section>\n<section data-footnotes class=\"footnotes\"><h2 class=\"sr-only\" id=\"footnote-label\">Footnotes</h2>\n<ol>\n<li id=\"user-content-fn-fig2.8\">\n<p>p103, Figure 2.8: General format of an HTTP request message <a href=\"#user-content-fnref-fig2.8\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-fig2.9\">\n<p>p104, Figure 2.9: General format of an HTTP response message <a href=\"#user-content-fnref-fig2.9\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-smtp-example\">\n<p><a href=\"https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol#SMTP_transport_example\">SMTP transport example - Simple Mail Transfer Protocol - Wikipedia</a> <a href=\"#user-content-fnref-smtp-example\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-fig-2.21\">\n<p>p133, Figure 2.21: DNS message format <a href=\"#user-content-fnref-fig-2.21\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-seed-choking\">\n<p><a href=\"https://www.libtorrent.org/reference-Settings.html#seed_choking_algorithm_t\">seed_choking_algorithm - libtorrent</a> <a href=\"#user-content-fnref-seed-choking\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n</ol>\n</section>",
            "url": "https://ouuan.moe/post/2023/06/cnatda-2",
            "title": "CNATDA 第二章学习笔记",
            "summary": "\n\n\n<p><span class=\"mojikumi-line-start\">《</span>Computer Networking: A Top-Down Approach (8th Edition)<span class=\"mojikumi-line-end\">》</span>第二章 <span class=\"mojikumi\">“</span>Application Layer<span class=\"mojikumi\">”</span> 的学习笔记<span class=\"mojikumi-line-end\">。</span></p>\n",
            "date_modified": "2023-06-16T15:24:34.000Z",
            "tags": [
                "cnatda",
                "学习笔记"
            ]
        }
    ]
}