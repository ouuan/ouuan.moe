<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>ouuan's blog: 标签: cnatda</title>
        <link>https://ouuan.moe/tag/cnatda</link>
        <description>标签: cnatda - ouuan 写东西的地方，涵盖了 Web 开发、计算机系统、Linux 使用、大学学习生活等多个主题。</description>
        <lastBuildDate>Fri, 16 Jun 2023 15:24:34 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-CN</language>
        <copyright>Copyright © 2022 - 2023 ouuan
Licensed under CC BY-SA 4.0</copyright>
        <atom:link href="https://ouuan.moe/tag/cnatda/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[CNATDA 第二章学习笔记]]></title>
            <link>https://ouuan.moe/post/2023/06/cnatda-2</link>
            <guid>https://ouuan.moe/post/2023/06/cnatda-2</guid>
            <pubDate>Fri, 16 Jun 2023 15:24:34 GMT</pubDate>
            <description><![CDATA[


<p><span class="mojikumi-line-start">《</span>Computer Networking A Top-Down Approach (8th Edition)<span class="mojikumi-line-end">》</span>第二章 <span class="mojikumi">“</span>Application Layer<span class="mojikumi">”</span> 的学习笔记<span class="mojikumi-line-end">。</span></p>
]]></description>
            <content:encoded><![CDATA[


<p><span class="mojikumi-line-start">《</span>Computer Networking A Top-Down Approach (8th Edition)<span class="mojikumi-line-end">》</span>第二章 <span class="mojikumi">“</span>Application Layer<span class="mojikumi">”</span> 的学习笔记<span class="mojikumi-line-end">。</span></p>

<h2 id="principles-of-network-applications" class="heading"><a href="#principles-of-network-applications" class="heading-anchor" aria-label="章节： Principles of Network Applications" tabindex="-1"></a><span>Principles of Network Applications</span></h2>
<p>application architecture 主要分为 client-server 和 P2P 两种<span class="mojikumi-line-end">。</span></p>
<p><i>process</i> 即在某个 end system 上运行的程序<span class="mojikumi-line-start">（</span>进程<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>不同 end system 上的 process 在网络上互相发送 message 以进行通信<span class="mojikumi-line-start">（</span>注<span class="mojikumi-line-end">：</span>message 即 application-layer packet<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<p>在一次通信中<span class="mojikumi-line-end">，</span>发起通信的一方被称作 <i>client</i><span class="mojikumi-line-end">，</span>等待接收消息的一方被称作 <i>server</i><span class="mojikumi">。</span><wbr><span class="mojikumi-line-start">（</span>注<span class="mojikumi-line-end">：</span>在 P2P 中<span class="mojikumi-line-end">，</span>client 和 server 的身份不是固定的<span class="mojikumi">。</span><span class="mojikumi-line-end">）</span></p>
<p>process 和网络<span class="mojikumi-line-end">，</span>或者说和 transport layer 之间以 <i>socket</i> 作为 API<span class="mojikumi-line-end">。</span></p>
<p>host 由 IP 地址识别<span class="mojikumi-line-end">，</span>而 process 由 IP 地址 + 端口识别<span class="mojikumi-line-end">。</span></p>
<p>一个 application 可以选择 TCP 或者 UDP 来提供 transport service<span class="mojikumi-line-end">。</span>TCP 提供 connection-oriented service<span class="mojikumi-line-start">（</span>需要通过 handshaking 建立 TCP connection<span class="mojikumi-line-end">）</span>和 reliable data transfer service<span class="mojikumi-line-start">（</span>保证接收到 &#x26; 保序<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>以及 congestion control<span class="mojikumi-line-end">。</span>UDP 则这些都不提供<span class="mojikumi-line-end">。</span>一般会根据是否 loss-tolerant<span class="mojikumi-line-start">（</span>是否允许丢失部分数据<span class="mojikumi-line-end">）</span>以及对延时的敏感度来进行选择<span class="mojikumi-line-end">。</span></p>
<p>TLS (Transport Layer Security) 可以在 TCP 的基础上提供 encryption<span class="mojikumi-line-end">、</span>data integrity<span class="mojikumi-line-end">、</span>end-point authentication<span class="mojikumi-line-end">。</span>它自身位于 application layer<span class="mojikumi-line-start">（</span>或者可以说是 application 与 transport layer 之间 🤔<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>不与 TCP<span class="mojikumi-line-end">、</span>UDP 并列<span class="mojikumi-line-end">。</span></p>
<p>application-layer protocol 决定了 message 的结构以及相应的行为<span class="mojikumi-line-end">。</span>常见的 application-layer protocol 包括 HTTP<span class="mojikumi-line-end">、</span>SMTP<span class="mojikumi-line-end">、</span>Telnet<span class="mojikumi-line-end">、</span>FTP<span class="mojikumi-line-end">、</span>SIP<span class="mojikumi-line-end">、</span>RTP<span class="mojikumi-line-end">、</span>DASH 等<span class="mojikumi-line-end">。</span>有的 application 会使用专有而非 public domain 的 application-layer protocol<span class="mojikumi-line-end">。</span></p>
<h2 id="the-web-and-http" class="heading"><a href="#the-web-and-http" class="heading-anchor" aria-label="章节： The Web and HTTP" tabindex="-1"></a><span>The Web and HTTP</span></h2>
<p>HTTP (HyperText Transfer Protocol) 是 Web 的 application-layer protocol<span class="mojikumi-line-end">，</span>定义了 client (browser) 如何向 server 请求文件<span class="mojikumi-line-start">（</span>web page<span class="mojikumi">）</span><span class="mojikumi-line-end">、</span>server 如何将文件传输给 client<span class="mojikumi-line-end">。</span></p>
<p>HTTP 的默认端口是 80<span class="mojikumi-line-end">。</span></p>
<p>HTTP 不存储 client 的信息<span class="mojikumi-line-end">，</span>是一个 <i>stateless protocol</i><span class="mojikumi-line-end">。</span></p>
<p>HTTP<span class="mojikumi-line-start">（</span>1.0<span class="mojikumi-line-end">、</span>1.1<span class="mojikumi-line-end">、</span>2<span class="mojikumi-line-end">）</span>基于 TCP<span class="mojikumi-line-end">，</span>有 persistent connection 和 non-persistent connection 两种工作方式<span class="mojikumi-line-end">：</span></p>
<ul>
<li>non-persistent connection<span class="mojikumi-line-end">：</span>每次 request-response 都会建立一个新的 TCP connection<span class="mojikumi-line-end">，</span>收到 response 后立刻关闭 TCP connection<span class="mojikumi-line-end">。</span></li>
<li>persistent connection<span class="mojikumi-line-end">：</span>同一对 client-server 的多次 request-response<span class="mojikumi-line-start">（</span>例如一个页面引用的多个资源<span class="mojikumi-line-end">）</span>可以共用同一个 TCP connection<span class="mojikumi-line-start">（</span>在闲置一段时间后自动关闭<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>并且无需等待 response 就可以连续发送多个 request<span class="mojikumi-line-start">（</span>被称作 <i>pipelining</i><span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>从而省下每次建立 TCP connection 耗费的 RTT (round-trip time)<span class="mojikumi-line-end">。</span></li>
</ul>
<p>HTTP message 是纯文本<span class="mojikumi-line-end">，</span>格式如下<span class="mojikumi-line-end">。</span></p>
<p>HTTP request:<sup><a href="#user-content-fn-fig2.8" id="user-content-fnref-fig2.8" data-footnote-ref aria-describedby="footnote-label">1</a></sup></p>
<p><picture><source type="image/webp" srcset="/assets/cnatda-fig-2.8.6bb26d3f.webp"><img srcset="/assets/cnatda-fig-2.8.de34594f.png" loading="lazy" src="/assets/cnatda-fig-2.8.de34594f.png" width="793" height="439" alt="General format of an HTTP request message"></picture></p>
<section class="code-block relative my-6 shadow" itemprop="hasPart" itemscope itemtype="https://schema.org/SoftwareSourceCode" data-v-ad49d235><div class="h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex" style="display:none;" data-v-ad49d235><h3 class="text-3 text-footer" itemprop="programmingLanguage" aria-label="http 代码块" data-v-ad49d235>http</h3><ile-root id="ile-1"><button title="复制到剪贴板" class="copy-button b-footer text-footer" data-v-9288569d><span class="i-mdi-content-copy" data-v-9288569d></span><span class="sr-only" role="status" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-1--></div><div class="light:hidden" itemprop="text" data-v-ad49d235><pre class="shiki dark" style="background-color: #011627" tabindex="0"><code><span><span style="color: #C792EA">GET</span><span style="color: #D6DEEB"> /wireshark-labs/INTRO-wireshark-file1.html </span><span style="color: #C792EA">HTTP</span><span style="color: #D6DEEB">/</span><span style="color: #F78C6C">1.1</span></span>
<span><span style="color: #CAECE6">Host</span><span style="color: #C792EA">:</span><span style="color: #D6DEEB"> </span><span style="color: #ECC48D">gaia.cs.umass.edu</span></span>
<span><span style="color: #CAECE6">User-Agent</span><span style="color: #C792EA">:</span><span style="color: #D6DEEB"> </span><span style="color: #ECC48D">curl/8.1.2</span></span>
<span><span style="color: #CAECE6">Accept</span><span style="color: #C792EA">:</span><span style="color: #D6DEEB"> </span><span style="color: #ECC48D">*/*</span></span></code></pre></div><div class="light:important-block" style="display:none;" data-v-ad49d235><pre class="shiki light" style="background-color: #FBFBFB" tabindex="0"><code><span><span style="color: #994CC3">GET</span><span style="color: #403F53"> /wireshark-labs/INTRO-wireshark-file1.html </span><span style="color: #994CC3">HTTP</span><span style="color: #403F53">/</span><span style="color: #AA0982">1.1</span></span>
<span><span style="color: #994CC3">Host:</span><span style="color: #403F53"> </span><span style="color: #4876D6">gaia.cs.umass.edu</span></span>
<span><span style="color: #994CC3">User-Agent:</span><span style="color: #403F53"> </span><span style="color: #4876D6">curl/8.1.2</span></span>
<span><span style="color: #994CC3">Accept:</span><span style="color: #403F53"> </span><span style="color: #4876D6">*/*</span></span></code></pre></div></section>
<p>HTTP response:<sup><a href="#user-content-fn-fig2.9" id="user-content-fnref-fig2.9" data-footnote-ref aria-describedby="footnote-label">2</a></sup></p>
<p><picture><source type="image/webp" srcset="/assets/cnatda-fig-2.9.d6740f57.webp"><img srcset="/assets/cnatda-fig-2.9.c01ee471.png" loading="lazy" src="/assets/cnatda-fig-2.9.c01ee471.png" width="792" height="443" alt="General format of an HTTP response message"></picture></p>
<section class="code-block relative my-6 shadow" itemprop="hasPart" itemscope itemtype="https://schema.org/SoftwareSourceCode" data-v-ad49d235><div class="h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex" style="display:none;" data-v-ad49d235><h3 class="text-3 text-footer" itemprop="programmingLanguage" aria-label="http 代码块" data-v-ad49d235>http</h3><ile-root id="ile-2"><button title="复制到剪贴板" class="copy-button b-footer text-footer" data-v-9288569d><span class="i-mdi-content-copy" data-v-9288569d></span><span class="sr-only" role="status" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-2--></div><div class="light:hidden" itemprop="text" data-v-ad49d235><pre class="shiki dark" style="background-color: #011627" tabindex="0"><code><span><span style="color: #D6DEEB">HTTP/1.1 200 OK</span></span>
<span><span style="color: #CAECE6">Date</span><span style="color: #C792EA">:</span><span style="color: #D6DEEB"> </span><span style="color: #ECC48D">Tue, 13 Jun 2023 11:14:57 GMT</span></span>
<span><span style="color: #CAECE6">Server</span><span style="color: #C792EA">:</span><span style="color: #D6DEEB"> </span><span style="color: #ECC48D">Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.33 mod_perl/2.0.11 Perl/v5.16.3</span></span>
<span><span style="color: #CAECE6">Last-Modified</span><span style="color: #C792EA">:</span><span style="color: #D6DEEB"> </span><span style="color: #ECC48D">Tue, 13 Jun 2023 05:59:01 GMT</span></span>
<span><span style="color: #CAECE6">ETag</span><span style="color: #C792EA">:</span><span style="color: #D6DEEB"> </span><span style="color: #ECC48D">&quot;51-5fdfc882a3e6f&quot;</span></span>
<span><span style="color: #CAECE6">Accept-Ranges</span><span style="color: #C792EA">:</span><span style="color: #D6DEEB"> </span><span style="color: #ECC48D">bytes</span></span>
<span><span style="color: #CAECE6">Content-Length</span><span style="color: #C792EA">:</span><span style="color: #D6DEEB"> </span><span style="color: #ECC48D">81</span></span>
<span><span style="color: #CAECE6">Content-Type</span><span style="color: #C792EA">:</span><span style="color: #D6DEEB"> </span><span style="color: #ECC48D">text/html; charset=UTF-8</span></span>
<span></span>
<span><span style="color: #D6DEEB">&lt;html&gt;</span></span>
<span><span style="color: #D6DEEB">Congratulations!  You&#39;ve downloaded the first Wireshark lab file!</span></span>
<span><span style="color: #D6DEEB">&lt;/html&gt;</span></span></code></pre></div><div class="light:important-block" style="display:none;" data-v-ad49d235><pre class="shiki light" style="background-color: #FBFBFB" tabindex="0"><code><span><span style="color: #403F53">HTTP/1.1 200 OK</span></span>
<span><span style="color: #994CC3">Date:</span><span style="color: #403F53"> </span><span style="color: #4876D6">Tue, 13 Jun 2023 11:14:57 GMT</span></span>
<span><span style="color: #994CC3">Server:</span><span style="color: #403F53"> </span><span style="color: #4876D6">Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.33 mod_perl/2.0.11 Perl/v5.16.3</span></span>
<span><span style="color: #994CC3">Last-Modified:</span><span style="color: #403F53"> </span><span style="color: #4876D6">Tue, 13 Jun 2023 05:59:01 GMT</span></span>
<span><span style="color: #994CC3">ETag:</span><span style="color: #403F53"> </span><span style="color: #4876D6">&quot;51-5fdfc882a3e6f&quot;</span></span>
<span><span style="color: #994CC3">Accept-Ranges:</span><span style="color: #403F53"> </span><span style="color: #4876D6">bytes</span></span>
<span><span style="color: #994CC3">Content-Length:</span><span style="color: #403F53"> </span><span style="color: #4876D6">81</span></span>
<span><span style="color: #994CC3">Content-Type:</span><span style="color: #403F53"> </span><span style="color: #4876D6">text/html; charset=UTF-8</span></span>
<span></span>
<span><span style="color: #403F53">&lt;html&gt;</span></span>
<span><span style="color: #403F53">Congratulations!  You&#39;ve downloaded the first Wireshark lab file!</span></span>
<span><span style="color: #403F53">&lt;/html&gt;</span></span></code></pre></div></section>
<p>server 可以通过 Cookie 识别用户<span class="mojikumi-line-end">，</span>cookie 通过 response 中的 <code>Set-Cookie</code> header 设置<span class="mojikumi-line-end">，</span>在之后的每次 request 中通过 <code>Cookie</code> header 发给 server<span class="mojikumi-line-end">。</span></p>
<p>机构可以设置 Web cache<span class="mojikumi-line-end">，</span>使用户先向 Web cache 发送请求<span class="mojikumi-line-end">，</span>若 cache hit 则直接由 Web cache 发给用户<span class="mojikumi-line-end">，</span>若 cache miss 则 Web cache 向 origin server 发送请求再返回给用户<span class="mojikumi-line-end">。</span>Web cache 可以减小延迟<span class="mojikumi-line-end">，</span>降低带宽压力<span class="mojikumi">。</span><wbr><span class="mojikumi-line-start">（</span>与之类似的 CDN 则在<a href="#content-distribution-networks">后文</a>有详细讲解<span class="mojikumi">。</span><span class="mojikumi-line-end">）</span></p>
<p>可以通过 <code>If<wbr>-<wbr>Modified<wbr>-<wbr>Since</code> header 进行 <i>conditional GET</i><span class="mojikumi-line-end">，</span>若没有修改则会返回 body 为空的 304 Not Modified<span class="mojikumi-line-end">。</span></p>
<p>HTTP/2 提供了 request and response multiplexing<span class="mojikumi-line-end">、</span>prioritization<span class="mojikumi-line-end">、</span>server push 来优化性能<span class="mojikumi-line-end">：</span></p>
<ul>
<li>multiplexing<span class="mojikumi-line-end">：</span>persistent connection 减少了建立 TCP connection 带来的 RTT<span class="mojikumi-line-end">，</span>但又引入了 Head of Line (HOL) blocking<span class="mojikumi-line-end">，</span>即共用一个 TCP connection 时较小的资源需要等待较大的资源加载完毕<span class="mojikumi-line-end">，</span>所以在 HTTP/1.1 中浏览器经常还是会建立多个 TCP 连接<span class="mojikumi-line-end">，</span>除了解决 HOL blocking<span class="mojikumi-line-end">，</span>也可以在 TCP 的 congestion control 中取得更多带宽<span class="mojikumi-line-end">。</span>HTTP/2 则将每个 message 划分成了多个小的 frame<span class="mojikumi-line-end">，</span>并交替发送不同 message 的 frame<span class="mojikumi-line-start">（</span>frame interleaving<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>从而小的资源无需等待大的资源发送完毕<span class="mojikumi-line-end">。</span></li>
<li>prioritization<span class="mojikumi-line-end">：</span>同时发送多个请求时<span class="mojikumi-line-end">，</span>可以为每个 response 设置优先级<span class="mojikumi-line-end">，</span>让 server 优先发送高优先级的 response<span class="mojikumi-line-end">。</span>除此之外<span class="mojikumi-line-end">，</span>还可以设置 response 之间的依赖关系<span class="mojikumi-line-end">。</span></li>
<li>server push<span class="mojikumi-line-end">：</span>一个 request 可以有多个 response<span class="mojikumi-line-end">，</span>即除了对应于 request 的 response<span class="mojikumi-line-end">，</span>server 还可以额外 <i>push</i><span class="mojikumi-line-end">，</span>例如在返回一个 HTML 页面时可以 push 这个页面引用的其他资源<span class="mojikumi-line-end">。</span></li>
</ul>
<p>HTTP/3 使用基于 UDP 的 QUIC 代替了 TCP<span class="mojikumi-line-end">。</span></p>
<h2 id="electronic-mail-in-the-internet" class="heading"><a href="#electronic-mail-in-the-internet" class="heading-anchor" aria-label="章节： Electronic Mail in the Internet" tabindex="-1"></a><span>Electronic Mail in the Internet</span></h2>
<p>e-mail 系统有三个主要组件<span class="mojikumi-line-end">：</span>user agent<span class="mojikumi-line-end">、</span>mail server 和 SMTP (Simple Mail Transfer Protocol)<span class="mojikumi-line-end">。</span></p>
<p>发送邮件时<span class="mojikumi-line-end">，</span>Alice 写完邮件后由她的 user agent 发送到她的 mail server<span class="mojikumi-line-end">，</span>她的 mail server 再发到 Bob 的 mail server 中属于 Bob 的 mailbox<span class="mojikumi-line-end">，</span>之后 Bob 再通过他的 user agent 从他的 mail server 获取他的 mailbox 中的邮件并阅读<span class="mojikumi-line-end">。</span></p>
<p>发送方的 mail server 会维护一个待发送邮件列表<span class="mojikumi-line-end">，</span>如果接收方的 mail server 在当时不可用<span class="mojikumi-line-end">，</span>则会等待一段时间后再次尝试<span class="mojikumi-line-end">，</span>多次失败则会退回<span class="mojikumi-line-end">。</span></p>
<p>mail server 使用 SMTP 向其他 mail server 发送邮件<span class="mojikumi-line-end">，</span>发送方作为 SMTP client<span class="mojikumi-line-end">，</span>接收方作为 SMTP server<span class="mojikumi-line-end">。</span></p>
<p>SMTP 的默认端口是 25<span class="mojikumi-line-end">。</span></p>
<p>SMTP 是一个比 HTTP 还古老的协议<span class="mojikumi-line-end">，</span>带来的后果之一是它整个 message 都只能包含 ASCII<span class="mojikumi-line-end">。</span></p>
<p>一次 SMTP 通信如下所示<span class="mojikumi-line-end">：</span><sup><a href="#user-content-fn-smtp-example" id="user-content-fnref-smtp-example" data-footnote-ref aria-describedby="footnote-label">3</a></sup></p>
<section class="code-block relative my-6 shadow" itemprop="hasPart" itemscope itemtype="https://schema.org/SoftwareSourceCode" data-v-ad49d235><div class="h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex" style="display:none;" data-v-ad49d235><h3 class="text-3 text-footer" itemprop="programmingLanguage" aria-label="plain 代码块" data-v-ad49d235>plain</h3><ile-root id="ile-3"><button title="复制到剪贴板" class="copy-button b-footer text-footer" data-v-9288569d><span class="i-mdi-content-copy" data-v-9288569d></span><span class="sr-only" role="status" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-3--></div><div class="light:hidden" itemprop="text" data-v-ad49d235><pre class="shiki dark" style="background-color: #011627" tabindex="0"><samp><span><span style="color: #d6deeb">S: 220 smtp.example.com ESMTP Postfix</span></span>
<span><span style="color: #d6deeb">C: HELO relay.example.org</span></span>
<span><span style="color: #d6deeb">S: 250 Hello relay.example.org, I am glad to meet you</span></span>
<span><span style="color: #d6deeb">C: MAIL FROM:&lt;bob@example.org&gt;</span></span>
<span><span style="color: #d6deeb">S: 250 Ok</span></span>
<span><span style="color: #d6deeb">C: RCPT TO:&lt;alice@example.com&gt;</span></span>
<span><span style="color: #d6deeb">S: 250 Ok</span></span>
<span><span style="color: #d6deeb">C: RCPT TO:&lt;theboss@example.com&gt;</span></span>
<span><span style="color: #d6deeb">S: 250 Ok</span></span>
<span><span style="color: #d6deeb">C: DATA</span></span>
<span><span style="color: #d6deeb">S: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span></span>
<span><span style="color: #d6deeb">C: From: &quot;Bob Example&quot; &lt;bob@example.org&gt;</span></span>
<span><span style="color: #d6deeb">C: To: &quot;Alice Example&quot; &lt;alice@example.com&gt;</span></span>
<span><span style="color: #d6deeb">C: Cc: theboss@example.com</span></span>
<span><span style="color: #d6deeb">C: Date: Tue, 15 Jan 2008 16:02:43 -0500</span></span>
<span><span style="color: #d6deeb">C: Subject: Test message</span></span>
<span><span style="color: #d6deeb">C:</span></span>
<span><span style="color: #d6deeb">C: Hello Alice.</span></span>
<span><span style="color: #d6deeb">C: This is a test message with 5 header fields and 4 lines in the message body.</span></span>
<span><span style="color: #d6deeb">C: Your friend,</span></span>
<span><span style="color: #d6deeb">C: Bob</span></span>
<span><span style="color: #d6deeb">C: .</span></span>
<span><span style="color: #d6deeb">S: 250 Ok: queued as 12345</span></span>
<span><span style="color: #d6deeb">C: QUIT</span></span>
<span><span style="color: #d6deeb">S: 221 Bye</span></span></samp></pre></div><div class="light:important-block" style="display:none;" data-v-ad49d235><pre class="shiki light" style="background-color: #FBFBFB" tabindex="0"><samp><span><span style="color: #403f53">S: 220 smtp.example.com ESMTP Postfix</span></span>
<span><span style="color: #403f53">C: HELO relay.example.org</span></span>
<span><span style="color: #403f53">S: 250 Hello relay.example.org, I am glad to meet you</span></span>
<span><span style="color: #403f53">C: MAIL FROM:&lt;bob@example.org&gt;</span></span>
<span><span style="color: #403f53">S: 250 Ok</span></span>
<span><span style="color: #403f53">C: RCPT TO:&lt;alice@example.com&gt;</span></span>
<span><span style="color: #403f53">S: 250 Ok</span></span>
<span><span style="color: #403f53">C: RCPT TO:&lt;theboss@example.com&gt;</span></span>
<span><span style="color: #403f53">S: 250 Ok</span></span>
<span><span style="color: #403f53">C: DATA</span></span>
<span><span style="color: #403f53">S: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span></span>
<span><span style="color: #403f53">C: From: &quot;Bob Example&quot; &lt;bob@example.org&gt;</span></span>
<span><span style="color: #403f53">C: To: &quot;Alice Example&quot; &lt;alice@example.com&gt;</span></span>
<span><span style="color: #403f53">C: Cc: theboss@example.com</span></span>
<span><span style="color: #403f53">C: Date: Tue, 15 Jan 2008 16:02:43 -0500</span></span>
<span><span style="color: #403f53">C: Subject: Test message</span></span>
<span><span style="color: #403f53">C:</span></span>
<span><span style="color: #403f53">C: Hello Alice.</span></span>
<span><span style="color: #403f53">C: This is a test message with 5 header fields and 4 lines in the message body.</span></span>
<span><span style="color: #403f53">C: Your friend,</span></span>
<span><span style="color: #403f53">C: Bob</span></span>
<span><span style="color: #403f53">C: .</span></span>
<span><span style="color: #403f53">S: 250 Ok: queued as 12345</span></span>
<span><span style="color: #403f53">C: QUIT</span></span>
<span><span style="color: #403f53">S: 221 Bye</span></span></samp></pre></div></section>
<p>其中 <code>HELO</code><span class="mojikumi-line-end">、</span><code>MAIL FROM</code><span class="mojikumi-line-end">、</span><code>RCPT TO</code><span class="mojikumi-line-end">、</span><code>DATA</code><span class="mojikumi-line-end">、</span><code>QUIT</code> 等是 <i>command</i><span class="mojikumi-line-end">，</span>用来进行 handshake 等操作<span class="mojikumi-line-end">。</span>如果要向同一个 mail server 连续发送多封邮件<span class="mojikumi-line-end">，</span>可以只 <code>HELO</code><span class="mojikumi-line-end">、</span><code>QUIT</code> 一次<span class="mojikumi-line-start">（</span>但要 <code>MAIL FROM</code><span class="mojikumi-line-end">、</span><code>RCPT TO</code> 多次<span class="mojikumi-line-end">）</span>从而共用一个 TCP 连接<span class="mojikumi-line-end">。</span><code>DATA</code> 后是邮件的内容<span class="mojikumi-line-end">，</span>这一内容的开头是邮件的 header<span class="mojikumi-line-end">，</span>结尾是仅包含 <code>.</code> 的一行<span class="mojikumi-line-end">。</span></p>
<p>email 是 user agent → mail server → mail server → user agent 而非 user agent → user agent<span class="mojikumi-line-end">，</span>一大原因是如果 user agent 经常不在线则直接发很可能收不到邮件<span class="mojikumi-line-end">，</span>需要用 mail server 来提高在线率以及提供对方不在线时重试的机制<span class="mojikumi-line-end">。</span></p>
<p>从 user agent 发到 mail server 时可以使用 SMTP 或 HTTP<span class="mojikumi-line-end">，</span>从 mail server 拉取到 user agent 时可以使用 HTTP 或 IMAP (Internet Mail Access Protocol)<span class="mojikumi-line-start">（</span>不能用 SMTP<span class="mojikumi-line-end">，</span>因为 SMTP 是 push protocol<span class="mojikumi-line-end">，</span>不能用来 pull<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<h2 id="dns--the-internet’s-directory-service" class="heading"><a href="#dns--the-internet’s-directory-service" class="heading-anchor" aria-label="章节： DNS—The Internet’s Directory Service" tabindex="-1"></a><span>DNS—The Internet<span class="mojikumi-narrow-left">’</span>s Directory Service</span></h2>
<h3 id="services-provided-by-dns" class="heading"><a href="#services-provided-by-dns" class="heading-anchor" aria-label="章节： Services Provided by DNS" tabindex="-1"></a><span>Services Provided by DNS</span></h3>
<p>host 由 hostname 或 IP 地址识别<span class="mojikumi-line-end">，</span>hostname 对人类更友好<span class="mojikumi-line-end">，</span>而 IP 地址对路由器更友好<span class="mojikumi-line-end">。</span></p>
<p>将 hostname 翻译为 IP 地址是 DNS 的主要任务<span class="mojikumi-line-end">。</span>DNS 是由多个层级的 DNS server 共同构成的 distributed database<span class="mojikumi-line-end">，</span>也是使得 application 能够查询这个 distributed database 的 application-layer protocol<span class="mojikumi-line-end">。</span></p>
<p>DNS 被很多其他 application-layer protocol 所使用<span class="mojikumi-line-end">，</span>例如在 HTTP/SMTP 中<span class="mojikumi-line-end">，</span>可以使用 hostname 来访问网站 / mail server<span class="mojikumi-line-end">，</span>这时就会调用 DNS<span class="mojikumi-line-end">。</span></p>
<p>DNS 在提供 hostname 到 IP 地址的翻译的同时<span class="mojikumi-line-end">，</span>还提供了下列功能<span class="mojikumi-line-end">：</span></p>
<ul>
<li>host aliasing: 可以让一个 host 在有 canonical hostname 的同时还有其他 alias<span class="mojikumi-line-end">。</span></li>
<li>mail server aliasing: 可以让同一个 hostname 在作为 Web server 和作为 mail server 时指向不同的 host<span class="mojikumi-line-end">。</span></li>
<li>load distribution: 可以让同一个 hostname 指向多个 host<span class="mojikumi-line-end">，</span>在返回查询结果时进行 rotate<span class="mojikumi-line-start">（</span>即改变位于首位的 IP 地址<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></li>
</ul>
<h3 id="overview-of-how-dns-works" class="heading"><a href="#overview-of-how-dns-works" class="heading-anchor" aria-label="章节： Overview of How DNS Works" tabindex="-1"></a><span>Overview of How DNS Works</span></h3>
<p>由于下列原因<span class="mojikumi-line-end">，</span>DNS 必须是分布式的<span class="mojikumi-line-end">，</span>单点式的 DNS 无法 scale<span class="mojikumi-line-end">：</span></p>
<ul>
<li>single point of failure</li>
<li>traffic volume 过大</li>
<li>离部分用户距离过远<span class="mojikumi-line-end">，</span>带来较大的延时</li>
<li>难以维护<span class="mojikumi-line-start">（</span>数据总量大<span class="mojikumi-line-end">，</span>更新频繁<span class="mojikumi-line-end">）</span></li>
</ul>
<p>一般来说<span class="mojikumi-line-end">，</span>DNS 分为以下几层<span class="mojikumi-line-end">：</span></p>
<ol>
<li>root DNS server: 分散在世界各地的 13 个不同 root server 各自的共上千个 copy<span class="mojikumi-line-end">，</span>用来查询 TLD server</li>
<li>top-level domain (TLD) server: 每个 TLD 有自己的 TLD server (or server cluster)<span class="mojikumi-line-end">，</span>用来查询 authoritative DNS server</li>
<li>authoritative DNS server: 每个 subdomain 有自己的 authoritative DNS server<span class="mojikumi-line-end">，</span>可以是组织自己维护的或者由服务商提供的<span class="mojikumi-line-end">，</span>用来查询 hostname 到 IP 地址的映射</li>
</ol>
<p>除此之外<span class="mojikumi-line-end">，</span>TLD server 和 authoritative DNS server 之间还可能有 intermediate DNS server<span class="mojikumi-line-end">。</span></p>
<p>在上述 DNS server 的 hierarchy 之外<span class="mojikumi-line-end">，</span>还有 local DNS server<span class="mojikumi-line-start">（</span>就是电脑的网络设置里设的 DNS 服务器<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>作为 proxy 来代替 requesting host 向 DNS server 进行查询<span class="mojikumi-line-end">。</span></p>
<p>从逻辑上来说<span class="mojikumi-line-end">，</span>向一个 DNS server 进行查询时<span class="mojikumi-line-end">，</span>如果它自己不知道最终的 answer (IP 地址)<span class="mojikumi-line-end">，</span>它可以让你换一个 DNS server 继续查 (iterative query)<span class="mojikumi-line-end">，</span>或者帮你向其他 DNS server 发送查询 (recursive query) 然后返回最终的结果<span class="mojikumi-line-end">。</span>而在实际中<span class="mojikumi-line-end">，</span>如上文所述<span class="mojikumi-line-end">，</span>一般是向 local DNS server 查询时会进行 recursive query<span class="mojikumi-line-end">，</span>而 local DNS server 再从 root DNS server 向下直到 authoritative DNS server 进行 iterative query<span class="mojikumi-line-end">。</span></p>
<p>为了减少查询的数量<span class="mojikumi-line-end">，</span>DNS 设有 caching<span class="mojikumi-line-end">。</span>每个查询的发起者<span class="mojikumi-line-start">（</span>requesting host 或者 local DNS server<span class="mojikumi-line-end">）</span>会将收到的查询结果保存一段时间<span class="mojikumi-line-end">，</span>cache miss 才会向其他 DNS server 发起查询<span class="mojikumi-line-end">。</span>例如<span class="mojikumi-line-end">，</span>常用的 TLD server 的 IP 地址往往都在 cache 中<span class="mojikumi-line-end">，</span>大大减少了 root DNS server 收到的请求数量<span class="mojikumi-line-end">。</span></p>
<h3 id="dns-records" class="heading"><a href="#dns-records" class="heading-anchor" aria-label="章节： DNS Records" tabindex="-1"></a><span>DNS Records</span></h3>
<p>DNS distributed database 存储的信息单元是 <i>resource record</i> (RR)<span class="mojikumi-line-end">。</span></p>
<p>每个 RR 包含 type<span class="mojikumi-line-end">、</span>name<span class="mojikumi-line-end">、</span>value<span class="mojikumi-line-end">、</span>TTL 四项信息<span class="mojikumi-line-end">，</span>其中 TTL 表示 cache 多久过期<span class="mojikumi-line-end">。</span>常见的 type 包括以下几个<span class="mojikumi-line-end">：</span></p>
<ul>
<li>A: name 是 hostname<span class="mojikumi-line-end">，</span>value 是 IP 地址<span class="mojikumi-line-end">，</span>表示一个 hostname 到 IP 地址的映射<span class="mojikumi-line-end">。</span></li>
<li>NS: name 是 domain<span class="mojikumi-line-end">，</span>value 是其 name server 的 hostname<span class="mojikumi-line-end">，</span>表示可以在这个 name server 进行这个 domain 的进一步查询<span class="mojikumi-line-end">。</span></li>
<li>CNAME: name 是 alias hostname<span class="mojikumi-line-end">，</span>value 是 canonical hostname<span class="mojikumi-line-end">，</span>用来提供 host aliasing<span class="mojikumi-line-end">。</span></li>
<li>MX: name 是 alias hostname<span class="mojikumi-line-end">，</span>value 是 canonical hostname<span class="mojikumi-line-end">，</span>用来提供 mail server aliasing<span class="mojikumi-line-end">。</span></li>
</ul>
<p>对一个 hostname 来说 authoritative 的 DNS server 会包含被查询的 host 的 A record<span class="mojikumi-line-end">。</span>不 authoritative 的 DNS server 则会包含相应的 NS record<span class="mojikumi-line-end">，</span>以及这个 name server 的 A record<span class="mojikumi-line-end">。</span></p>
<p>下面是一个例子<span class="mojikumi-line-end">：</span></p>
<div class="overflow-auto my-6"><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">name</th>
<th align="center">value</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">NS</td>
<td align="center"><code>.</code></td>
<td align="center"><code>a<wbr>.<wbr>root<wbr>-<wbr>servers<wbr>.<wbr>net<wbr>.</code></td>
</tr>
<tr>
<td align="center">A</td>
<td align="center"><code>a<wbr>.<wbr>root<wbr>-<wbr>servers<wbr>.<wbr>net<wbr>.</code></td>
<td align="center"><code>198.41.0.4</code></td>
</tr>
<tr>
<td align="center">NS</td>
<td align="center"><code>moe.</code></td>
<td align="center"><code>ns1<wbr>.<wbr>dns<wbr>.<wbr>nic<wbr>.<wbr>moe<wbr>.</code></td>
</tr>
<tr>
<td align="center">A</td>
<td align="center"><code>ns1<wbr>.<wbr>dns<wbr>.<wbr>nic<wbr>.<wbr>moe<wbr>.</code></td>
<td align="center"><code>156<wbr>.<wbr>154<wbr>.<wbr>144<wbr>.<wbr>114</code></td>
</tr>
<tr>
<td align="center">NS</td>
<td align="center"><code>ouuan.moe.</code></td>
<td align="center"><code>amos<wbr>.<wbr>ns<wbr>.<wbr>cloudflare<wbr>.<wbr>com<wbr>.</code></td>
</tr>
<tr>
<td align="center">A</td>
<td align="center"><code>amos<wbr>.<wbr>ns<wbr>.<wbr>cloudflare<wbr>.<wbr>com<wbr>.</code></td>
<td align="center"><code>172<wbr>.<wbr>64<wbr>.<wbr>35<wbr>.<wbr>120</code></td>
</tr>
<tr>
<td align="center">A</td>
<td align="center"><code>ouuan.moe.</code></td>
<td align="center"><code>172<wbr>.<wbr>67<wbr>.<wbr>181<wbr>.<wbr>123</code></td>
</tr>
</tbody>
</table></div>
<p>在 registar 购买域名时可以填写 name server 的信息<span class="mojikumi-line-end">，</span>由 registar 负责将相应的 NS 以及 A record 添加到 TLD server<span class="mojikumi-line-end">。</span>可以使用域名商的 DNS server<span class="mojikumi-line-end">、</span>其他服务商<span class="mojikumi-line-start">（</span>例如 Cloudflare<span class="mojikumi-line-end">）</span>的 DNS server 或者自己搭建的 DNS server 作为 authoritative DNS server<span class="mojikumi-line-end">。</span></p>
<p>DNS 最初只能静态更新<span class="mojikumi-line-start">（</span>通过配置文件等方式<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>后来有了 DDNS 来通过 DNS message 动态更新<span class="mojikumi-line-end">。</span></p>
<h3 id="dns-messages" class="heading"><a href="#dns-messages" class="heading-anchor" aria-label="章节： DNS Messages" tabindex="-1"></a><span>DNS Messages</span></h3>
<p>DNS message 通过 UDP 发送到 port 53<span class="mojikumi-line-end">。</span></p>
<p>DNS message 的结构如下图所示<span class="mojikumi-line-end">：</span><sup><a href="#user-content-fn-fig-2.21" id="user-content-fnref-fig-2.21" data-footnote-ref aria-describedby="footnote-label">4</a></sup></p>
<p><picture><source type="image/webp" srcset="/assets/cnatda-fig-2.21.b9121041.webp"><img srcset="/assets/cnatda-fig-2.21.8f9be477.png" loading="lazy" src="/assets/cnatda-fig-2.21.8f9be477.png" width="1349" height="804" alt="DNS message format"></picture></p>
<p>identification 由 client 设置<span class="mojikumi-line-end">，</span>即用来识别 query 和 reply 对应关系的 ID<span class="mojikumi-line-end">。</span></p>
<p>flags 包括以下几个<span class="mojikumi-line-end">：</span></p>
<ul>
<li>query or reply: 这条 message 是 query 还是 reply</li>
<li>authoritative or not: 返回的结果是否是最终的答案</li>
<li>recursion desired: client 是否希望 server 进行 recursive query</li>
<li>recursion available: server 是否可以进行 recursive query</li>
</ul>
<p>4 个 section 中都包含若干 RR<span class="mojikumi-line-end">。</span></p>
<p>在 query 中<span class="mojikumi-line-end">，</span>question section 里会包含 name 和 type<span class="mojikumi-line-end">。</span></p>
<p>对于 type A 的查询<span class="mojikumi-line-end">：</span></p>
<ul>
<li>如果 reply 是 authoritative 的<span class="mojikumi-line-start">（</span>向 authoritative DNS server 查询<span class="mojikumi-line-end">，</span>或者进行了 recursive query<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>则会在 answer section 中列出所查询的 A record<span class="mojikumi-line-end">。</span></li>
<li>如果不是 authoritative 的<span class="mojikumi-line-end">，</span>则会在 authority section 中列出 NS record<span class="mojikumi-line-end">，</span>在 additional section 中列出这些 name server 的 A record<span class="mojikumi-line-end">。</span></li>
</ul>
<p>在 additional section 中<span class="mojikumi-line-end">，</span>还可能列出 canonical hostname 的 A record 之类的<span class="mojikumi-line-end">。</span></p>
<h2 id="peer-to-peer-file-distribution" class="heading"><a href="#peer-to-peer-file-distribution" class="heading-anchor" aria-label="章节： Peer-to-Peer File Distribution" tabindex="-1"></a><span>Peer-to-Peer File Distribution</span></h2>
<p>在传输大文件时<span class="mojikumi-line-end">，</span>client-server 的架构在用户数量增多时需要更大的 server bandwidth 才能保证用户的下载速度<span class="mojikumi-line-end">，</span>而 P2P 的架构则是 self-scalable 的<span class="mojikumi">。</span><wbr><span class="mojikumi-line-start">（</span>书中有简化模型的定量计算<span class="mojikumi">。</span><span class="mojikumi-line-end">）</span></p>
<p>BitTorrent 是较为流行的 P2P file distribution protocol<span class="mojikumi-line-end">。</span>在 BitTorrent 中<span class="mojikumi-line-end">，</span>以 chunk 为下载文件的基本单位<span class="mojikumi-line-end">。</span>一个 peer 刚加入 torrent 时没有 trunk 所以只能下载<span class="mojikumi-line-end">，</span>在获取到一些 trunk 后就会开始上传给其他 peer<span class="mojikumi-line-end">，</span>下载完成后可以自私地离开或者无私地保种<span class="mojikumi-line-end">。</span></p>
<p>每个 torrent 会有<span class="mojikumi-line-start">（</span>至少<span class="mojikumi-line-end">）</span>一个 tracker<span class="mojikumi-line-end">，</span>peer 在加入/离开时会通知 tracker<span class="mojikumi-line-end">，</span>并在过程中定期告知 tracker 自己仍在活动<span class="mojikumi-line-end">。</span>tracker 会给每个 peer 提供一些其他 peer 的 IP 地址和端口<span class="mojikumi-line-end">。</span></p>
<p>在下载过程中<span class="mojikumi-line-end">，</span>每个 peer 拥有一部分 chunk<span class="mojikumi-line-end">，</span>并向其他 peer 请求 chunk<span class="mojikumi-line-end">。</span>每个 peer 需要决定优先下载哪个 trunk 以及上传给谁<span class="mojikumi-line-end">。</span></p>
<p>优先下载的 trunk 可以采用 <i>rarest first</i> 的策略<span class="mojikumi-line-end">，</span>即优先下载已知的 peer 中拥有人数最少的 chunk<span class="mojikumi-line-end">，</span>这样的话就能使得各个 trunk 较为均匀地在 peer 间分布<span class="mojikumi-line-end">。</span></p>
<p>在下载过程中<span class="mojikumi-line-end">，</span>会采用被称作<span class="mojikumi-line-start">“</span>tit-for-tat<span class="mojikumi-line-end">”</span>的策略决定上传给谁<span class="mojikumi-line-end">：</span>上传给自己<span class="mojikumi-line-start">（</span>即从他那下载<span class="mojikumi-line-end">）</span>的速度最快的几个 peer 被称作<span class="mojikumi-line-start">“</span>unchoked<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>除此之外还会每隔一段时间随机选择一个 peer 被称作<span class="mojikumi-line-start">“</span>optimistically unchoked<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>最后做出的选择就是上传给<span class="mojikumi-line-start">“</span>unchoked<span class="mojikumi-line-end">”</span>和<span class="mojikumi-line-start">“</span>optimistically unchoked<span class="mojikumi-line-end">”</span>的这些 peer<span class="mojikumi-line-end">。</span>这个策略实际上可以被绕过<span class="mojikumi-line-end">，</span>但不被绕过时它提供了一个激励大家上传的机制<span class="mojikumi">。</span><wbr><span class="mojikumi-line-start">（</span>注<span class="mojikumi-line-end">：</span>在下载完毕后保种时<span class="mojikumi-line-end">，</span>会使用另外的策略<span class="mojikumi-line-end">。</span><sup><a href="#user-content-fn-seed-choking" id="user-content-fnref-seed-choking" data-footnote-ref aria-describedby="footnote-label">5</a></sup><span class="mojikumi-line-end">）</span></p>
<p>除了通过 tracker<span class="mojikumi-line-end">，</span>还可以通过 Distributed Hash Table (DHT<span class="mojikumi-line-end">，</span>一种 P2P 架构的 distributed database) 来获取 peer<span class="mojikumi-line-end">。</span></p>
<h2 id="video-streaming-and-content-distribution-networks" class="heading"><a href="#video-streaming-and-content-distribution-networks" class="heading-anchor" aria-label="章节： Video Streaming and Content Distribution Networks" tabindex="-1"></a><span>Video Streaming and Content Distribution Networks</span></h2>
<h3 id="http-streaming-and-dash" class="heading"><a href="#http-streaming-and-dash" class="heading-anchor" aria-label="章节： HTTP Streaming and DASH" tabindex="-1"></a><span>HTTP Streaming and DASH</span></h3>
<p>视频需要耗费大量的流量<span class="mojikumi-line-start">（</span>以及存储空间<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>而 streaming 时需要保证至少有视频 bitrate 这么多的带宽才能避免卡顿<span class="mojikumi-line-end">，</span>所以一般会根据可用的带宽选择不同质量的视频版本<span class="mojikumi-line-end">。</span></p>
<p>最基础的 streaming 方式是 HTTP streaming<span class="mojikumi-line-end">，</span>即通过 HTTP GET 获取视频文件至缓冲区并播放<span class="mojikumi-line-end">，</span>但这样无法适应不同用户的不同带宽<span class="mojikumi-line-end">，</span>更无法适应同一个用户随时间变化的带宽<span class="mojikumi-line-end">。</span></p>
<p>在 Dynamic Adaptive Streaming over HTTP (DASH) 中<span class="mojikumi-line-end">，</span>视频被编码为多个不同质量的版本<span class="mojikumi-line-end">，</span>client 每次获取一个几秒的视频片段<span class="mojikumi-line-end">，</span>并根据可用带宽动态调整选择的版本<span class="mojikumi-line-end">。</span></p>
<p>在开始播放之前<span class="mojikumi-line-end">，</span>client 首先会获取 manifest file 来得到各个视频版本的 URL 以及 bitrate<span class="mojikumi-line-end">。</span>在播放过程中<span class="mojikumi-line-end">，</span>通过 HTTP GET 请求以及 byte range header 获取视频片段<span class="mojikumi-line-end">，</span>同时计算可用带宽<span class="mojikumi-line-end">，</span>决定接下来选择的视频版本<span class="mojikumi-line-end">。</span></p>
<h3 id="content-distribution-networks" class="heading"><a href="#content-distribution-networks" class="heading-anchor" aria-label="章节： Content Distribution Networks" tabindex="-1"></a><span>Content Distribution Networks</span></h3>
<p>和 DNS 类似<span class="mojikumi-line-end">，</span>video streaming 往往也不能仅通过单个 data center 实现<span class="mojikumi-line-end">，</span>因为<span class="mojikumi-line-end">：</span></p>
<ul>
<li>离部分用户过远<span class="mojikumi-line-end">，</span>虽然 streaming 对延时要求不高<span class="mojikumi-line-end">，</span>但更多的 communication link 很可能意味着更低的 bottleneck bandwidth<span class="mojikumi-line-end">。</span></li>
<li>同一个视频会在同一个 communication link 上被传输多次<span class="mojikumi-line-end">，</span>造成网络资源以及资费的浪费<span class="mojikumi-line-end">。</span></li>
<li>single point of failure</li>
</ul>
<p>为了解决这些问题<span class="mojikumi-line-end">，</span>video-streaming company 往往会使用 Content Distribution Networks (CDN) 来分发视频<span class="mojikumi-line-end">。</span></p>
<p>CDN 会在全球各地放置 server (cluster)<span class="mojikumi-line-end">，</span>在每个节点存放一份 content 的 copy<span class="mojikumi-line-end">，</span>在处理 user request 时尽量由最好<span class="mojikumi-line-start">（</span>最近<span class="mojikumi-line-end">）</span>的节点负责响应<span class="mojikumi-line-end">。</span></p>
<p>CDN 可以是 private CDN<span class="mojikumi-line-start">（</span>例如 Google 的 CDN<span class="mojikumi-line-end">）</span>或者 third-party CDN<span class="mojikumi-line-start">（</span>例如 Akamai<span class="mojikumi-line-end">、</span>Limelight<span class="mojikumi-line-end">、</span>Level-3<span class="mojikumi-line-end">，</span><s>书中竟然没提到 Cloudflare</s><span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<p>CDN 通常有两种放置策略<span class="mojikumi-line-end">：</span></p>
<ul>
<li>Enter Deep: 放在 access ISP<span class="mojikumi-line-end">，</span>cluster 数量多<span class="mojikumi-line-end">，</span>性能更好<span class="mojikumi-line-end">，</span>维护成本更高<span class="mojikumi-line-end">。</span></li>
<li>Bring Home: 放在 IXP<span class="mojikumi-line-end">，</span>cluster 数量少<span class="mojikumi-line-end">，</span>维护成本更低<span class="mojikumi-line-end">，</span>性能相对差<span class="mojikumi-line-end">。</span></li>
</ul>
<p>CDN 的更新有 push 和 pull 两种方式<span class="mojikumi-line-end">，</span>push 就是内容更新时 push 到各个 cluster<span class="mojikumi-line-end">，</span>pull 则与 cache 类似<span class="mojikumi-line-end">，</span>在 cache miss 时再从上游获取并<span class="mojikumi-line-start">（</span>在 stream 给用户的同时<span class="mojikumi-line-end">）</span>保存下来<span class="mojikumi-line-end">。</span></p>
<p>将用户重定向到 CDN 节点的一种方式是通过 DNS<span class="mojikumi-line-end">：</span>authoritative DNS server 返回 CDN 的 DNS server 的 NS record<span class="mojikumi-line-end">，</span>然后再由 CDN 的 DNS server 进行节点选择并返回节点的 IP 地址<span class="mojikumi-line-end">。</span></p>
<p><span class="mojikumi-line-start">（</span>基于 DNS 进行 CDN 重定向时<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>选择节点的两种方式是<span class="mojikumi-line-end">：</span></p>
<ul>
<li>
<p>geographically closest: 由 local DNS server 的 IP 确定地理位置<span class="mojikumi-line-end">，</span>然后选择最近的节点<span class="mojikumi-line-end">。</span>这样做的主要问题在于<span class="mojikumi-line-end">，</span>地理位置近不一定意味着网络距离近/带宽高<span class="mojikumi-line-end">，</span>并且 local DNS server 有可能离用户很远<span class="mojikumi-line-end">。</span></p>
</li>
<li>
<p>real-time measurements: 可以每隔一段时间向各个 local DNS server 发送探测信号来检测网络性能<span class="mojikumi-line-end">，</span>这样做的主要问题在于 DNS server 可能会拒绝响应这样的探测<span class="mojikumi-line-end">。</span></p>
</li>
</ul>
<h3 id="case-studies-netflix-and-youtube" class="heading"><a href="#case-studies-netflix-and-youtube" class="heading-anchor" aria-label="章节： Case Studies: Netflix and YouTube" tabindex="-1"></a><span>Case Studies: Netflix and YouTube</span></h3>
<p>Netflix 和 YouTube 都是大型 video streaming 服务商<span class="mojikumi-line-end">，</span>但它们的架构有很大不同<span class="mojikumi-line-end">，</span>这很大程度上是由于它们视频类型的不同<span class="mojikumi-line-start">（</span>剧 vs UGC<span class="mojikumi">）</span><span class="mojikumi-line-end">。</span></p>
<h4 id="netflix" class="heading"><a href="#netflix" class="heading-anchor" aria-label="章节： Netflix" tabindex="-1"></a><span>Netflix</span></h4>
<p>Netflix 使用 Amazon cloud 运行 Web server 以及视频处理<span class="mojikumi-line-end">，</span>而使用私有的 CDN 分发视频<span class="mojikumi-line-end">。</span></p>
<p>Netflix 的私有 CDN cluster 安装在 ISP 和 IXP 中<span class="mojikumi-line-end">，</span>其中 IXP 的 cluster 往往容量较大<span class="mojikumi-line-end">，</span>可以装下整个 Netflix 的所有视频的各个版本<span class="mojikumi-line-end">，</span>而 ISP 的 cluster 往往容量较小<span class="mojikumi-line-end">，</span>只存放最热门的视频<span class="mojikumi-line-end">。</span></p>
<p>Netflix 不使用 pull-caching<span class="mojikumi-line-end">，</span>而是在每天的低峰期采用 push 进行更新<span class="mojikumi-line-end">。</span></p>
<p>因为 Netflix 的私有 CDN 只负责分发视频<span class="mojikumi-line-end">，</span>它不需要使用 DNS redirect<span class="mojikumi-line-end">，</span>直接由 Web server 告诉 client IP 地址即可<span class="mojikumi-line-end">。</span></p>
<h4 id="youtube" class="heading"><a href="#youtube" class="heading-anchor" aria-label="章节： YouTube" tabindex="-1"></a><span>YouTube</span></h4>
<a id="google-的-network-infrastructure" name="google-的-network-infrastructure" aria-hidden="true"></a>
<aside role="note" data-v-a2ab257f><div class="shadow-md rd-1 b-l-6 my-6 bg-blue-1 dark:bg-blue-9 b-blue" data-v-a2ab257f><div class="p-3 flex justify-between items-center" data-v-a2ab257f><h5 class="flex items-center gap-1 font-bold" data-v-a2ab257f><span class="text-5 i-mdi-pencil text-blue" data-v-a2ab257f></span><span class="sr-only" data-v-a2ab257f>Note: </span><span data-v-a2ab257f>Google 的 network infrastructure</span></h5><!--v-if--></div><div class="overflow-auto rd-br-1 bg-card px-6 dark:bg-bghover" data-v-a2ab257f><p>Google 部署了一个庞大的 private network and CDN infrastructure<span class="mojikumi-line-end">，</span>包含以下三级 server clusters<span class="mojikumi-line-end">：</span></p><ol>
<li>约 20 个<span class="mojikumi-line-start">“</span>mega data center<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>分布在北美<span class="mojikumi-line-end">、</span>欧洲和亚洲<span class="mojikumi-line-end">，</span>每个 cluster 有数十万服务器<span class="mojikumi-line-end">，</span>用来 serve dynamic content<span class="mojikumi-line-end">。</span></li>
<li>约 90 个部署在 IXP 的 cluster<span class="mojikumi-line-end">，</span>每个 cluster 有数百个服务器<span class="mojikumi-line-end">，</span>用来 serve 包括 YouTube 视频在内的 static content<span class="mojikumi-line-end">。</span></li>
<li>数百个部署在 access ISP 的 cluster<span class="mojikumi-line-end">，</span>每个 cluster 有数十个服务器<span class="mojikumi-line-end">，</span>用来进行 TCP splitting 以及 server static content<span class="mojikumi-line-end">，</span>例如网页上的静态资源<span class="mojikumi-line-end">。</span></li>
</ol><p>在访问 Google 的服务时<span class="mojikumi-line-end">，</span>不同内容往往会来自不同层级的 cluster<span class="mojikumi-line-end">。</span></p><p>这些 cluster 通过 Google 的 private network 连接<span class="mojikumi-line-end">，</span>使得它们之间的很多通信都不依赖于 public Internet<span class="mojikumi-line-end">，</span>与用户的通信也往往只涉及到 access ISP 这一层<span class="mojikumi-line-end">。</span></p></div></div></aside>
<p>YouTube 使用 Google 的私有 CDN 分发视频<span class="mojikumi-line-end">，</span>并且使用 pull-caching 和 DNS redirect<span class="mojikumi-line-end">。</span>在选择节点时<span class="mojikumi-line-end">，</span>会综合考虑 client 到 cluster 的 RTT 以及负载均衡<span class="mojikumi-line-end">。</span></p>
<p>在用户上传视频时<span class="mojikumi-line-end">，</span>会在 Google 的 data center 进行处理<span class="mojikumi-line-end">。</span></p>
<h2 id="socket-programming-creating-network-applications" class="heading"><a href="#socket-programming-creating-network-applications" class="heading-anchor" aria-label="章节： Socket Programming: Creating Network Applications" tabindex="-1"></a><span>Socket Programming: Creating Network Applications</span></h2>
<p>一般来说<span class="mojikumi-line-end">，</span>编写 network application 需要编写 client program 和 server program<span class="mojikumi-line-end">。</span></p>
<h3 id="socket-programming-with-udp" class="heading"><a href="#socket-programming-with-udp" class="heading-anchor" aria-label="章节： Socket Programming with UDP" tabindex="-1"></a><span>Socket Programming with UDP</span></h3>
<p>使用 UDP 时<span class="mojikumi-line-end">，</span>每次发送 datagram<sup><a href="#user-content-fn-datagram" id="user-content-fnref-datagram" data-footnote-ref aria-describedby="footnote-label">6</a></sup> 都需要指定 address<span class="mojikumi-line-start">（</span>IP 地址 &#x26; 端口<span class="mojikumi">）</span><span class="mojikumi-line-end">，</span>接收 datagram 时也会收到对方的 address<span class="mojikumi-line-end">。</span></p>
<p><s>一看就懂但书上解释了半天的</s> 例子<span class="mojikumi-line-end">：</span></p>
<section class="code-block relative my-6 shadow" itemprop="hasPart" itemscope itemtype="https://schema.org/SoftwareSourceCode" data-v-ad49d235><div class="h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex" style="display:none;" data-v-ad49d235><h4 class="text-3 text-footer" itemprop="programmingLanguage" aria-label="python 代码块" data-v-ad49d235>python</h4><ile-root id="ile-4"><button title="复制到剪贴板" class="copy-button b-footer text-footer" data-v-9288569d><span class="i-mdi-content-copy" data-v-9288569d></span><span class="sr-only" role="status" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-4--></div><div class="light:hidden" itemprop="text" data-v-ad49d235><pre class="shiki dark" style="background-color: #011627" tabindex="0"><code><span><span style="color: #C792EA">from</span><span style="color: #D6DEEB"> socket </span><span style="color: #C792EA">import</span><span style="color: #D6DEEB"> </span><span style="color: #C792EA">*</span></span>
<span><span style="color: #D6DEEB">serverName </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #D9F5DD">&#39;</span><span style="color: #ECC48D">hostname</span><span style="color: #D9F5DD">&#39;</span></span>
<span><span style="color: #D6DEEB">serverPort </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #F78C6C">12000</span></span>
<span><span style="color: #D6DEEB">clientSocket </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #B2CCD6">socket</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">AF_INET</span><span style="color: #D9F5DD">,</span><span style="color: #82AAFF"> SOCK_DGRAM</span><span style="color: #D6DEEB">) </span><span style="color: #637777"># AF_INET 表示 IPv4 地址，SOCK_DGRAM 表示 UDP</span></span>
<span><span style="color: #D6DEEB">message </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #C5E478">input</span><span style="color: #D6DEEB">(</span><span style="color: #D9F5DD">&#39;</span><span style="color: #ECC48D">Input lowercase sentence:</span><span style="color: #D9F5DD">&#39;</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">clientSocket.</span><span style="color: #B2CCD6">sendto</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">message.</span><span style="color: #B2CCD6">encode</span><span style="color: #D6DEEB">()</span><span style="color: #D9F5DD">,</span><span style="color: #82AAFF"> (serverName, serverPort)</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">modifiedMessage, serverAddress </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> clientSocket.</span><span style="color: #B2CCD6">recvfrom</span><span style="color: #D6DEEB">(</span><span style="color: #F78C6C">2048</span><span style="color: #D6DEEB">) </span><span style="color: #637777"># 2048 是 buffer size</span></span>
<span><span style="color: #C5E478">print</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">modifiedMessage.</span><span style="color: #B2CCD6">decode</span><span style="color: #D6DEEB">())</span></span>
<span><span style="color: #D6DEEB">clientSocket.</span><span style="color: #B2CCD6">close</span><span style="color: #D6DEEB">()</span></span></code></pre></div><div class="light:important-block" style="display:none;" data-v-ad49d235><pre class="shiki light" style="background-color: #FBFBFB" tabindex="0"><code><span><span style="color: #994CC3">from</span><span style="color: #403F53"> socket </span><span style="color: #994CC3">import</span><span style="color: #403F53"> </span><span style="color: #994CC3">*</span></span>
<span><span style="color: #403F53">serverName </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #111111">&#39;</span><span style="color: #C96765">hostname</span><span style="color: #111111">&#39;</span></span>
<span><span style="color: #403F53">serverPort </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #AA0982">12000</span></span>
<span><span style="color: #403F53">clientSocket </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #0C969B">socket</span><span style="color: #403F53">(</span><span style="color: #4876D6">AF_INET</span><span style="color: #111111">,</span><span style="color: #4876D6"> SOCK_DGRAM</span><span style="color: #403F53">) </span><span style="color: #989FB1"># AF_INET 表示 IPv4 地址，SOCK_DGRAM 表示 UDP</span></span>
<span><span style="color: #403F53">message </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #4876D6">input</span><span style="color: #403F53">(</span><span style="color: #111111">&#39;</span><span style="color: #C96765">Input lowercase sentence:</span><span style="color: #111111">&#39;</span><span style="color: #403F53">)</span></span>
<span><span style="color: #403F53">clientSocket.</span><span style="color: #0C969B">sendto</span><span style="color: #403F53">(</span><span style="color: #4876D6">message.</span><span style="color: #0C969B">encode</span><span style="color: #403F53">()</span><span style="color: #111111">,</span><span style="color: #4876D6"> (serverName, serverPort)</span><span style="color: #403F53">)</span></span>
<span><span style="color: #403F53">modifiedMessage, serverAddress </span><span style="color: #994CC3">=</span><span style="color: #403F53"> clientSocket.</span><span style="color: #0C969B">recvfrom</span><span style="color: #403F53">(</span><span style="color: #AA0982">2048</span><span style="color: #403F53">) </span><span style="color: #989FB1"># 2048 是 buffer size</span></span>
<span><span style="color: #4876D6">print</span><span style="color: #403F53">(</span><span style="color: #4876D6">modifiedMessage.</span><span style="color: #0C969B">decode</span><span style="color: #403F53">())</span></span>
<span><span style="color: #403F53">clientSocket.</span><span style="color: #0C969B">close</span><span style="color: #403F53">()</span></span></code></pre></div></section>
<section class="code-block relative my-6 shadow" itemprop="hasPart" itemscope itemtype="https://schema.org/SoftwareSourceCode" data-v-ad49d235><div class="h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex" style="display:none;" data-v-ad49d235><h4 class="text-3 text-footer" itemprop="programmingLanguage" aria-label="python 代码块" data-v-ad49d235>python</h4><ile-root id="ile-5"><button title="复制到剪贴板" class="copy-button b-footer text-footer" data-v-9288569d><span class="i-mdi-content-copy" data-v-9288569d></span><span class="sr-only" role="status" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-5--></div><div class="light:hidden" itemprop="text" data-v-ad49d235><pre class="shiki dark" style="background-color: #011627" tabindex="0"><code><span><span style="color: #C792EA">from</span><span style="color: #D6DEEB"> socket </span><span style="color: #C792EA">import</span><span style="color: #D6DEEB"> </span><span style="color: #C792EA">*</span></span>
<span><span style="color: #D6DEEB">serverPort </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #F78C6C">12000</span></span>
<span><span style="color: #D6DEEB">serverSocket </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #B2CCD6">socket</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">AF_INET</span><span style="color: #D9F5DD">,</span><span style="color: #82AAFF"> SOCK_DGRAM</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">serverSocket.</span><span style="color: #B2CCD6">bind</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">(</span><span style="color: #D9F5DD">&#39;&#39;</span><span style="color: #82AAFF">, serverPort)</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #C5E478">print</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">”The server </span><span style="color: #C792EA">is</span><span style="color: #82AAFF"> ready to receive”</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #C792EA">while</span><span style="color: #D6DEEB"> </span><span style="color: #FF5874">True</span><span style="color: #D6DEEB">:</span></span>
<span><span style="color: #D6DEEB">    message, clientAddress </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> serverSocket.</span><span style="color: #B2CCD6">recvfrom</span><span style="color: #D6DEEB">(</span><span style="color: #F78C6C">2048</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">    modifiedMessage </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> message.</span><span style="color: #B2CCD6">decode</span><span style="color: #D6DEEB">().</span><span style="color: #B2CCD6">upper</span><span style="color: #D6DEEB">()</span></span>
<span><span style="color: #D6DEEB">    serverSocket.</span><span style="color: #B2CCD6">sendto</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">modifiedMessage.</span><span style="color: #B2CCD6">encode</span><span style="color: #D6DEEB">()</span><span style="color: #D9F5DD">,</span><span style="color: #82AAFF"> clientAddress</span><span style="color: #D6DEEB">)</span></span></code></pre></div><div class="light:important-block" style="display:none;" data-v-ad49d235><pre class="shiki light" style="background-color: #FBFBFB" tabindex="0"><code><span><span style="color: #994CC3">from</span><span style="color: #403F53"> socket </span><span style="color: #994CC3">import</span><span style="color: #403F53"> </span><span style="color: #994CC3">*</span></span>
<span><span style="color: #403F53">serverPort </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #AA0982">12000</span></span>
<span><span style="color: #403F53">serverSocket </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #0C969B">socket</span><span style="color: #403F53">(</span><span style="color: #4876D6">AF_INET</span><span style="color: #111111">,</span><span style="color: #4876D6"> SOCK_DGRAM</span><span style="color: #403F53">)</span></span>
<span><span style="color: #403F53">serverSocket.</span><span style="color: #0C969B">bind</span><span style="color: #403F53">(</span><span style="color: #4876D6">(</span><span style="color: #111111">&#39;&#39;</span><span style="color: #4876D6">, serverPort)</span><span style="color: #403F53">)</span></span>
<span><span style="color: #4876D6">print</span><span style="color: #403F53">(</span><span style="color: #4876D6">”The server </span><span style="color: #994CC3">is</span><span style="color: #4876D6"> ready to receive”</span><span style="color: #403F53">)</span></span>
<span><span style="color: #994CC3">while</span><span style="color: #403F53"> </span><span style="color: #BC5454">True</span><span style="color: #403F53">:</span></span>
<span><span style="color: #403F53">    message, clientAddress </span><span style="color: #994CC3">=</span><span style="color: #403F53"> serverSocket.</span><span style="color: #0C969B">recvfrom</span><span style="color: #403F53">(</span><span style="color: #AA0982">2048</span><span style="color: #403F53">)</span></span>
<span><span style="color: #403F53">    modifiedMessage </span><span style="color: #994CC3">=</span><span style="color: #403F53"> message.</span><span style="color: #0C969B">decode</span><span style="color: #403F53">().</span><span style="color: #0C969B">upper</span><span style="color: #403F53">()</span></span>
<span><span style="color: #403F53">    serverSocket.</span><span style="color: #0C969B">sendto</span><span style="color: #403F53">(</span><span style="color: #4876D6">modifiedMessage.</span><span style="color: #0C969B">encode</span><span style="color: #403F53">()</span><span style="color: #111111">,</span><span style="color: #4876D6"> clientAddress</span><span style="color: #403F53">)</span></span></code></pre></div></section>
<h3 id="socket-programming-with-tcp" class="heading"><a href="#socket-programming-with-tcp" class="heading-anchor" aria-label="章节： Socket Programming with TCP" tabindex="-1"></a><span>Socket Programming with TCP</span></h3>
<p>TCP 是一个 connection-oriented protocol<span class="mojikumi-line-end">，</span>在 server 上分为 welcoming socket 和 connection socket<span class="mojikumi-line-end">，</span>一开始需要通过 welcoming socket 建立 connection 并得到 connection socket<span class="mojikumi-line-end">，</span>而在建立了 connection 之后就无需再指定对方的 address<span class="mojikumi-line-end">。</span></p>
<p><span class="mojikumi-line-start">（</span>下面的代码除了换成 TCP 还对上面的 UDP 代码有若干没有本质区别的修改<span class="mojikumi-line-end">，</span>要是我写肯定会避免<span class="mojikumi-line-end">，</span>但是从书上复制就懒得改了<span class="mojikumi">。</span><span class="mojikumi-line-end">）</span></p>
<section class="code-block relative my-6 shadow" itemprop="hasPart" itemscope itemtype="https://schema.org/SoftwareSourceCode" data-v-ad49d235><div class="h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex" style="display:none;" data-v-ad49d235><h4 class="text-3 text-footer" itemprop="programmingLanguage" aria-label="python 代码块" data-v-ad49d235>python</h4><ile-root id="ile-6"><button title="复制到剪贴板" class="copy-button b-footer text-footer" data-v-9288569d><span class="i-mdi-content-copy" data-v-9288569d></span><span class="sr-only" role="status" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-6--></div><div class="light:hidden" itemprop="text" data-v-ad49d235><pre class="shiki dark" style="background-color: #011627" tabindex="0"><code><span><span style="color: #C792EA">from</span><span style="color: #D6DEEB"> socket </span><span style="color: #C792EA">import</span><span style="color: #D6DEEB"> </span><span style="color: #C792EA">*</span></span>
<span><span style="color: #D6DEEB">serverName </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #D9F5DD">&#39;</span><span style="color: #ECC48D">servername</span><span style="color: #D9F5DD">&#39;</span></span>
<span><span style="color: #D6DEEB">serverPort </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #F78C6C">12000</span></span>
<span><span style="color: #D6DEEB">clientSocket </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #B2CCD6">socket</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">AF_INET</span><span style="color: #D9F5DD">,</span><span style="color: #82AAFF"> SOCK_STREAM</span><span style="color: #D6DEEB">) </span><span style="color: #637777"># SOCK_STREAM 是 TCP</span></span>
<span><span style="color: #D6DEEB">clientSocket.</span><span style="color: #B2CCD6">connect</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">(serverName, serverPort)</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">sentence </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #C5E478">input</span><span style="color: #D6DEEB">(</span><span style="color: #D9F5DD">&#39;</span><span style="color: #ECC48D">Input lowercase sentence:</span><span style="color: #D9F5DD">&#39;</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">clientSocket.</span><span style="color: #B2CCD6">send</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">sentence.</span><span style="color: #B2CCD6">encode</span><span style="color: #D6DEEB">())</span></span>
<span><span style="color: #D6DEEB">modifiedSentence </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> clientSocket.</span><span style="color: #B2CCD6">recv</span><span style="color: #D6DEEB">(</span><span style="color: #F78C6C">1024</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #C5E478">print</span><span style="color: #D6DEEB">(</span><span style="color: #D9F5DD">&#39;</span><span style="color: #ECC48D">From Server: </span><span style="color: #D9F5DD">&#39;</span><span style="color: #D9F5DD">,</span><span style="color: #82AAFF"> modifiedSentence.</span><span style="color: #B2CCD6">decode</span><span style="color: #D6DEEB">())</span></span>
<span><span style="color: #D6DEEB">clientSocket.</span><span style="color: #B2CCD6">close</span><span style="color: #D6DEEB">()</span></span></code></pre></div><div class="light:important-block" style="display:none;" data-v-ad49d235><pre class="shiki light" style="background-color: #FBFBFB" tabindex="0"><code><span><span style="color: #994CC3">from</span><span style="color: #403F53"> socket </span><span style="color: #994CC3">import</span><span style="color: #403F53"> </span><span style="color: #994CC3">*</span></span>
<span><span style="color: #403F53">serverName </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #111111">&#39;</span><span style="color: #C96765">servername</span><span style="color: #111111">&#39;</span></span>
<span><span style="color: #403F53">serverPort </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #AA0982">12000</span></span>
<span><span style="color: #403F53">clientSocket </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #0C969B">socket</span><span style="color: #403F53">(</span><span style="color: #4876D6">AF_INET</span><span style="color: #111111">,</span><span style="color: #4876D6"> SOCK_STREAM</span><span style="color: #403F53">) </span><span style="color: #989FB1"># SOCK_STREAM 是 TCP</span></span>
<span><span style="color: #403F53">clientSocket.</span><span style="color: #0C969B">connect</span><span style="color: #403F53">(</span><span style="color: #4876D6">(serverName, serverPort)</span><span style="color: #403F53">)</span></span>
<span><span style="color: #403F53">sentence </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #4876D6">input</span><span style="color: #403F53">(</span><span style="color: #111111">&#39;</span><span style="color: #C96765">Input lowercase sentence:</span><span style="color: #111111">&#39;</span><span style="color: #403F53">)</span></span>
<span><span style="color: #403F53">clientSocket.</span><span style="color: #0C969B">send</span><span style="color: #403F53">(</span><span style="color: #4876D6">sentence.</span><span style="color: #0C969B">encode</span><span style="color: #403F53">())</span></span>
<span><span style="color: #403F53">modifiedSentence </span><span style="color: #994CC3">=</span><span style="color: #403F53"> clientSocket.</span><span style="color: #0C969B">recv</span><span style="color: #403F53">(</span><span style="color: #AA0982">1024</span><span style="color: #403F53">)</span></span>
<span><span style="color: #4876D6">print</span><span style="color: #403F53">(</span><span style="color: #111111">&#39;</span><span style="color: #C96765">From Server: </span><span style="color: #111111">&#39;</span><span style="color: #111111">,</span><span style="color: #4876D6"> modifiedSentence.</span><span style="color: #0C969B">decode</span><span style="color: #403F53">())</span></span>
<span><span style="color: #403F53">clientSocket.</span><span style="color: #0C969B">close</span><span style="color: #403F53">()</span></span></code></pre></div></section>
<section class="code-block relative my-6 shadow" itemprop="hasPart" itemscope itemtype="https://schema.org/SoftwareSourceCode" data-v-ad49d235><div class="h-6 items-center rd-t-1 bg-area px-4 dark:bg-#2A313A media-screen:important-flex" style="display:none;" data-v-ad49d235><h4 class="text-3 text-footer" itemprop="programmingLanguage" aria-label="python 代码块" data-v-ad49d235>python</h4><ile-root id="ile-7"><button title="复制到剪贴板" class="copy-button b-footer text-footer" data-v-9288569d><span class="i-mdi-content-copy" data-v-9288569d></span><span class="sr-only" role="status" data-v-9288569d></span></button></ile-root><!--ISLAND_HYDRATION_PLACEHOLDER_ile-7--></div><div class="light:hidden" itemprop="text" data-v-ad49d235><pre class="shiki dark" style="background-color: #011627" tabindex="0"><code><span><span style="color: #C792EA">from</span><span style="color: #D6DEEB"> socket </span><span style="color: #C792EA">import</span><span style="color: #D6DEEB"> </span><span style="color: #C792EA">*</span></span>
<span><span style="color: #D6DEEB">serverPort </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #F78C6C">12000</span></span>
<span><span style="color: #D6DEEB">serverSocket </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> </span><span style="color: #B2CCD6">socket</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">AF_INET</span><span style="color: #D9F5DD">,</span><span style="color: #82AAFF"> SOCK_STREAM</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">serverSocket.</span><span style="color: #B2CCD6">bind</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">(</span><span style="color: #D9F5DD">&#39;&#39;</span><span style="color: #82AAFF">, serverPort)</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #D6DEEB">serverSocket.</span><span style="color: #B2CCD6">listen</span><span style="color: #D6DEEB">(</span><span style="color: #F78C6C">1</span><span style="color: #D6DEEB">) </span><span style="color: #637777"># 1 是 connection queue 的最大长度</span></span>
<span><span style="color: #C5E478">print</span><span style="color: #D6DEEB">(</span><span style="color: #D9F5DD">&#39;</span><span style="color: #ECC48D">The server is ready to receive</span><span style="color: #D9F5DD">&#39;</span><span style="color: #D6DEEB">)</span></span>
<span><span style="color: #C792EA">while</span><span style="color: #D6DEEB"> </span><span style="color: #FF5874">True</span><span style="color: #D6DEEB">:</span></span>
<span><span style="color: #D6DEEB">    connectionSocket, addr </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> serverSocket.</span><span style="color: #B2CCD6">accept</span><span style="color: #D6DEEB">()</span></span>
<span><span style="color: #D6DEEB">    sentence </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> connectionSocket.</span><span style="color: #B2CCD6">recv</span><span style="color: #D6DEEB">(</span><span style="color: #F78C6C">1024</span><span style="color: #D6DEEB">).</span><span style="color: #B2CCD6">decode</span><span style="color: #D6DEEB">()</span></span>
<span><span style="color: #D6DEEB">    capitalizedSentence </span><span style="color: #C792EA">=</span><span style="color: #D6DEEB"> sentence.</span><span style="color: #B2CCD6">upper</span><span style="color: #D6DEEB">()</span></span>
<span><span style="color: #D6DEEB">    connectionSocket.</span><span style="color: #B2CCD6">send</span><span style="color: #D6DEEB">(</span><span style="color: #82AAFF">capitalizedSentence.</span><span style="color: #B2CCD6">encode</span><span style="color: #D6DEEB">())</span></span>
<span><span style="color: #D6DEEB">    connectionSocket.</span><span style="color: #B2CCD6">close</span><span style="color: #D6DEEB">()</span></span></code></pre></div><div class="light:important-block" style="display:none;" data-v-ad49d235><pre class="shiki light" style="background-color: #FBFBFB" tabindex="0"><code><span><span style="color: #994CC3">from</span><span style="color: #403F53"> socket </span><span style="color: #994CC3">import</span><span style="color: #403F53"> </span><span style="color: #994CC3">*</span></span>
<span><span style="color: #403F53">serverPort </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #AA0982">12000</span></span>
<span><span style="color: #403F53">serverSocket </span><span style="color: #994CC3">=</span><span style="color: #403F53"> </span><span style="color: #0C969B">socket</span><span style="color: #403F53">(</span><span style="color: #4876D6">AF_INET</span><span style="color: #111111">,</span><span style="color: #4876D6"> SOCK_STREAM</span><span style="color: #403F53">)</span></span>
<span><span style="color: #403F53">serverSocket.</span><span style="color: #0C969B">bind</span><span style="color: #403F53">(</span><span style="color: #4876D6">(</span><span style="color: #111111">&#39;&#39;</span><span style="color: #4876D6">, serverPort)</span><span style="color: #403F53">)</span></span>
<span><span style="color: #403F53">serverSocket.</span><span style="color: #0C969B">listen</span><span style="color: #403F53">(</span><span style="color: #AA0982">1</span><span style="color: #403F53">) </span><span style="color: #989FB1"># 1 是 connection queue 的最大长度</span></span>
<span><span style="color: #4876D6">print</span><span style="color: #403F53">(</span><span style="color: #111111">&#39;</span><span style="color: #C96765">The server is ready to receive</span><span style="color: #111111">&#39;</span><span style="color: #403F53">)</span></span>
<span><span style="color: #994CC3">while</span><span style="color: #403F53"> </span><span style="color: #BC5454">True</span><span style="color: #403F53">:</span></span>
<span><span style="color: #403F53">    connectionSocket, addr </span><span style="color: #994CC3">=</span><span style="color: #403F53"> serverSocket.</span><span style="color: #0C969B">accept</span><span style="color: #403F53">()</span></span>
<span><span style="color: #403F53">    sentence </span><span style="color: #994CC3">=</span><span style="color: #403F53"> connectionSocket.</span><span style="color: #0C969B">recv</span><span style="color: #403F53">(</span><span style="color: #AA0982">1024</span><span style="color: #403F53">).</span><span style="color: #0C969B">decode</span><span style="color: #403F53">()</span></span>
<span><span style="color: #403F53">    capitalizedSentence </span><span style="color: #994CC3">=</span><span style="color: #403F53"> sentence.</span><span style="color: #0C969B">upper</span><span style="color: #403F53">()</span></span>
<span><span style="color: #403F53">    connectionSocket.</span><span style="color: #0C969B">send</span><span style="color: #403F53">(</span><span style="color: #4876D6">capitalizedSentence.</span><span style="color: #0C969B">encode</span><span style="color: #403F53">())</span></span>
<span><span style="color: #403F53">    connectionSocket.</span><span style="color: #0C969B">close</span><span style="color: #403F53">()</span></span></code></pre></div></section>
<section data-footnotes class="footnotes"><h2 class="sr-only" id="footnote-label">Footnotes</h2>
<ol>
<li id="user-content-fn-fig2.8">
<p>p103, Figure 2.8: General format of an HTTP request message <a href="#user-content-fnref-fig2.8" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-fig2.9">
<p>p104, Figure 2.9: General format of an HTTP response message <a href="#user-content-fnref-fig2.9" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-smtp-example">
<p><a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol#SMTP_transport_example">SMTP transport example - Simple Mail Transfer Protocol - Wikipedia</a> <a href="#user-content-fnref-smtp-example" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-fig-2.21">
<p>p133, Figure 2.21: DNS message format <a href="#user-content-fnref-fig-2.21" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-seed-choking">
<p><a href="https://www.libtorrent.org/reference-Settings.html#seed_choking_algorithm_t">seed_choking_algorithm - libtorrent</a> <a href="#user-content-fnref-seed-choking" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-datagram">
<p>在书中 1.5 节<span class="mojikumi-line-end">，</span>transport-layer packet 被称作 <span class="mojikumi">“</span>segment<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>network-layer packet 被称作 <span class="mojikumi">“</span>datagram<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>但实际上 UDP 的 <span class="mojikumi">“</span>D<span class="mojikumi">”</span> 就是 <span class="mojikumi">“</span>datagram<span class="mojikumi">”</span><span class="mojikumi-line-end">，</span>而 TCP 的 packet 才叫 <span class="mojikumi">“</span>segment<span class="mojikumi">”</span><span class="mojikumi-line-end">。</span>ref: <a href="https://stackoverflow.com/questions/11636405/definition-of-network-units-fragment-segment-packet-frame-datagram">networking - Definition of Network Units: Fragment, Segment, Packet, Frame, Datagram - Stack Overflow</a> <a href="#user-content-fnref-datagram" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
</ol>
</section>]]></content:encoded>
            <category domain="https://ouuan.moe/tag/cnatda">cnatda</category>
            <category domain="https://ouuan.moe/tag/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">学习笔记</category>
        </item>
    </channel>
</rss>