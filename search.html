<!DOCTYPE html><html lang="zh-CN"><head>
    <meta charset="UTF-8">
<title>搜索 - ouuan's blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="ouuan 写东西的地方，涵盖了 Web 开发、计算机系统、Linux 使用、大学学习生活等多个主题。">
<meta property="og:url" content="https://ouuan.moe/search">
<meta property="og:site_name" content="ouuan's blog">
<meta property="og:title" content="搜索 · ouuan's blog">
<meta property="og:description" content="ouuan 写东西的地方，涵盖了 Web 开发、计算机系统、Linux 使用、大学学习生活等多个主题。">
<meta property="twitter:domain" content="ouuan.moe">
<meta property="twitter:title" content="搜索 · ouuan's blog">
<meta property="twitter:description" content="ouuan 写东西的地方，涵盖了 Web 开发、计算机系统、Linux 使用、大学学习生活等多个主题。">
<meta property="twitter:url" content="https://ouuan.moe/search">
<style>html:not(.dark):not(.light) { visibility: hidden; } body { visibility: hidden; }</style>
<script>(() => { let dark; try { const theme = localStorage && localStorage.getItem('vueuse-color-scheme'); if (theme === 'dark') dark = true; else if (theme === 'light') dark = false; else dark = window.matchMedia('(prefers-color-scheme: dark)').matches; } catch (e) { dark = false; } document.documentElement.classList.add(dark ? 'dark' : 'light'); })()</script>
<noscript><style>@media (prefers-color-scheme: light) { :root:not(.dark):not(.light) { color-scheme: light; --text-color: #232637; --bg-color: #DEE6EE; --card-color: #EFF3F7; --link-color: #1E66B8; --hover-color: #2E80DD; --active-color: #164C89; --bghover-color: #D6E0EA; --popup-color: #F7F9FB; --footer-color: #5F627B; --area-color: #E1E2E8; --nested-color: #F0F0F3; } } @media (prefers-color-scheme: dark) { :root:not(.dark):not(.light) { color-scheme: dark; --text-color: #E6EDF2; --bg-color: #0D0E15; --card-color: #1F2130; --link-color: #8BB8EC; --hover-color: #A2C6F0; --active-color: #74AAE8; --bghover-color: #353853; --popup-color: #2C2F45; --footer-color: #9699AE; --area-color: #2F313D; --nested-color: #3C3E4E; } } html { visibility:visible !important; }</style></noscript>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="canonical" href="https://ouuan.moe/search">
<link rel="alternate" type="application/rss+xml" href="/feed.xml" title="RSS Feed - ouuan's blog">
<link rel="alternate" type="application/atom+xml" href="/feed.atom" title="Atom Feed - ouuan's blog">
<link rel="alternate" type="application/json" href="/feed.json" title="JSON Feed - ouuan's blog">
<link rel="dns-prefetch" href="https://plausible.ouuan.moe">
<link rel="preconnect" href="https://blog-visitor-count.ouuan.moe">
<link rel="stylesheet" href="/vendors/katex/katex.css">
<link rel="sitemap" href="https://ouuan.moe/sitemap.xml">
<meta name="author" content="ouuan">
<meta name="twitter:creator" content="@ouuan">
<meta name="twitter:card" content="summary">
<meta property="og:image" content="https://ouuan.moe/android-chrome-512x512.png">
<meta property="generator" content="îles">
<meta name="robots" content="noindex">
    <link rel="stylesheet" href="/assets/style-cfd49c27.css">
    
  <link rel="modulepreload" href="/assets/iles.e381640b.js" crossorigin=""><link rel="modulepreload" href="/assets/vendor-vue.bda4d3d4.js" crossorigin=""><link rel="modulepreload" href="/assets/vite.5ce4fca4.js" crossorigin=""><link rel="modulepreload" href="/assets/SearchBar.a9e18075.js" crossorigin=""><link rel="modulepreload" href="/assets/FuseSearch.9b17d26d.js" crossorigin=""><link rel="modulepreload" href="/assets/PostHead.26f9e680.js" crossorigin=""><link rel="modulepreload" href="/assets/VisitorCount.065e72b2.js" crossorigin=""><link rel="modulepreload" href="/assets/site.b21fb919.js" crossorigin=""><link rel="modulepreload" href="/assets/fuse-js.6ab03eb8.js" crossorigin=""><style>@font-face { font-family: "Noto Serif SC Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Regular.common.79ca374e.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Regular.common.2a06c596.woff') format('woff'); unicode-range: U+0-ff1b; }</style><link rel="preload" href="/assets/fonts/NotoSerifSC-Regular.common.79ca374e.woff2" as="font" type="font/woff2" crossorigin=""></head>
  <body itemscope="" itemtype="https://schema.org/SearchResultsPage">
    <div id="app"><header class="bg-card shadow print:hidden" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPHeader"><div class="flex flex-wrap justify-center whitespace-nowrap px-4 page-container sm:flex-nowrap"><div class="flex basis-full items-stretch justify-center sm:mr-3 sm:basis-auto"><a class="flex items-center p-3 text-xl font-serif bghover" href="/"><span>ouuan<span class="mojikumi-narrow-left">’</span>s blog</span></a></div><nav class="flex"><ul class="flex"><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/"><span>首页</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/posts"><span>文章</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/tags"><span>标签</span></a></li><li class="flex flex-1 items-stretch justify-center"><a class="flex items-center p-3 bghover" href="/about"><span>关于</span></a></li></ul></nav><div class="sm:basis-full"></div><ul class="flex"><li class="flex"><ile-root id="ile-1"><div class="flex items-stretch lg:hidden"><a class="flex items-center p-2 bghover" href="/search" title="全站搜索"><span class="i-mdi-magnify text-xl"></span></a></div><form role="search" class="hidden items-stretch justify-center lg:flex"><div class="flex items-center"><input value="" class="w-48 rd-full bg-area px-3 py-1" type="search" placeholder="关键词" aria-label="全站搜索"></div><a class="flex items-center p-2 bghover" href="/search?q=" title="全站搜索"><span class="i-mdi-magnify text-xl"></span></a></form></ile-root><script></script><script type="module" async="">import{h as r,c as a}from"/assets/iles.e381640b.js";import{_ as m}from"/assets/SearchBar.a9e18075.js";import"/assets/vendor-vue.bda4d3d4.js";import"/assets/vite.5ce4fca4.js";r(a,m,"ile-1",{},{});
</script></li><li class="flex items-stretch"><a class="flex items-center p-2 bghover" href="/feed.xml" title="RSS 订阅"><span class="i-mdi-rss text-xl"></span></a></li><li class="flex"><ile-root id="ile-2"><div class="relative flex items-stretch"><button title="暗色模式设置" class="flex items-center p-2 bghover" aria-haspopup="menu" aria-controls="__theme-switcher" aria-expanded="false"><span class="i-mdi-theme-light-dark text-xl"></span></button><ul style="display:none;" id="__theme-switcher" class="absolute right-0 top-full z-20 whitespace-nowrap rd-1 bg-popup shadow-md" role="menu" aria-label="暗色模式选项"><li class="bghover" role="menuitemradio" aria-checked="true"><button class="flex items-center p-1 text-hover"><span class="i-mdi-cellphone md:i-mdi-tablet lg:i-mdi-monitor mr-1"></span><span>跟随系统</span></button></li><li class="bghover" role="menuitemradio" aria-checked="false"><button class="flex items-center p-1"><span class="i-mdi-white-balance-sunny mr-1"></span><span>总是亮色</span></button></li><li class="bghover" role="menuitemradio" aria-checked="false"><button class="flex items-center p-1"><span class="i-mdi-weather-night mr-1"></span><span>总是暗色</span></button></li></ul></div></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(o=>o.v),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/ThemeSwitcher.9b91f8bf.js"),["assets/ThemeSwitcher.9b91f8bf.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js","assets/useTheme.546d36da.js"])).default});s(u,v,"ile-2",{},{})});export default E();
</script></li></ul></div></header><main class="min-h-100vh py-6 page-container" itemprop="mainContentOfPage" itemscope="" itemtype="https://schema.org/WebPageElement"><ile-root id="ile-8"><div class="m-4 flex flex-col gap-6"><div class="flex flex-wrap gap-x-5 gap-y-2"><form role="search" class="max-w-100 flex grow items-center gap-2"><label class="flex items-center" for="__search_keywords"><span class="i-mdi-magnify text-xl"></span><span class="sr-only">搜索关键词</span></label><input id="__search_keywords" class="w-full rd-1 bg-card p-1" type="search" placeholder="关键词"></form><a class="flex items-center text-link" href="https://fusejs.io/examples.html#extended-search"> 高级搜索语法 </a><div class="flex items-center gap-1"><input id="__search_showmore" type="checkbox"><label for="__search_showmore">显示匹配程度较低的结果</label></div></div><div class="standard-card"><p class="my-3"> 请输入关键词进行搜索 </p></div></div></ile-root><script></script><script type="module" async="">import{h as tn,c as an}from"/assets/iles.e381640b.js";import{_ as rn}from"/assets/FuseSearch.9b17d26d.js";import"/assets/vendor-vue.bda4d3d4.js";import"/assets/vite.5ce4fca4.js";import"/assets/PostHead.26f9e680.js";import"/assets/VisitorCount.065e72b2.js";import"/assets/site.b21fb919.js";import"/assets/fuse-js.6ab03eb8.js";tn(an,rn,"ile-8",function(n,e,t,a,i,r,o,s,u,c,l,d,m,p,g,F,h,b,f,y,v,C,w,x,k,S,P,E,A,T,D,$,I,N,L,M,_,R,z,j,q,O,U,H,G,B,X,V,W,K,Y,Q,J,Z,nn,en){return{data:[{title:d,tags:"",content:`## 关于我

你好，我是 ouuan， I’m from China. 下面是关于我的一些信息。

---

-   贴贴：[驰雨Chiyuru ——『姑妄言之姑妄听之』](https://chiyuru.github.io/)。
-   祖籍是 & 出生于江西，但不到一岁就来到了武汉。
-   如果你有幸 (?) 需要在线下作为赛博朋友称呼我，出于顺口的考虑 (?)，可以叫我“欧元”（~~为什么是 yuan 不是 wan 呢，因为从出处来说正确的写法应该是 ouüan（~~，但如果你不介意拗口的话 (?)，也可以读成 O-U-U-A-N，~~甚至 óu yǔ án~~（

---

-   曾经是一名现役的 OIer。
-   现在是位于 THU 的一名本科生，班上只有两位同学不（曾经）是 OIer ~~，但学的都是数学~~，培养方案里既有大量数学系核心课，又有大量贵系核心课。
-   大一和大二的 9 门计算机专业课全部 4.0，5 门 A+，但是 7 门数学课的均绩是 2 开头，体育课是 D+、P、P、D，四种课的绩点分布区间 almost disjoint，GPA 很低，排名靠后。
-   不喜欢听课，喜欢自学 ~~或者不学（~~；不喜欢考试，喜欢大作业；最喜欢的是有清晰的课程文档、没有不合理的考核要求、完全不用听课、对自学友好、~~有 TUNA 群友当助教~~ 的课。
-   对网络（安全）方向比较感兴趣，系统之类的似乎也不错，总之还没确定，但是不想搞 AI（

---

-   GitHub: [ouuan](https://github.com/ouuan)，参与维护/开发了一些或不大或很小的项目，例如 [CP Editor](https://github.com/cpeditor/cpeditor), [OI Wiki](https://github.com/OI-wiki/OI-wiki), [pacwatch](https://github.com/ouuan/pacwatch) 等。
-   从 2020 年初开始使用 Linux 作为主力操作系统，现在是 [Arch Linux](https://wiki.archlinux.org/title/Arch_Linux) / [i3-wm](https://i3wm.org/) / [Neovim](https://neovim.io/) / [nnn](https://github.com/jarun/nnn) / [yadm](https://github.com/TheLocehiliosan/yadm) 等软件/项目的用户。
-   从 2021 年末开始租了一个 VPS，虽然感觉上面 host 的服务不值 VPS 这个价，但是好玩就行（
-   写了一个代码语法树猜谜游戏 [Codle](https://codle.ouuan.moe/)，可是没多少人玩（

---

-   最喜欢的番剧（以及原作漫画）目前是 [3月のライオン](https://bgm.tv/subject/147068)，曾经是 [CLANNAD](https://bgm.tv/subject/51)。
-   头像是 https://www.pixiv.net/artworks/61603233 。
-   [《月がきれい》](https://bgm.tv/subject/207573)[《荒ぶる季節の乙女どもよ。》](https://bgm.tv/subject/268070)[《風が強く吹いている》](https://bgm.tv/subject/248154)[《BEASTARS》](https://bgm.tv/subject/273843)[《ピンポン》](https://bgm.tv/subject/93739)[《SHIROBAKO》](https://bgm.tv/subject/110467)[《ウマ娘 プリティーダービー Season 2》](https://bgm.tv/subject/315574)[《リズと青い鳥》](https://bgm.tv/subject/216371)这几部番也很棒。
-   在 [<span class="text-muse">μ's Final LoveLive!</span>](https://zh.moegirl.org.cn/μ's_Final_LoveLive!_~μ'sic_Forever~) 的两个月前被同学安利由动画入坑 [<span class="text-muse">LL</span>](https://zh.moegirl.org.cn/LoveLive!)，这也是我的入宅番。之后有玩过一段时间 [sif](https://zh.moegirl.org.cn/zh-cn/LoveLive!学园偶像祭)，但缪的三次元活动（广播生放 live 之类）都看的很少，后面也逐渐淡坑，直到星团。[<span class="text-liella">星</span>](https://zh.moegirl.org.cn/LoveLive!Superstar!!) 是在一期动画结束后开始看的；[<span class="text-nijigasaki">虹</span>](https://zh.moegirl.org.cn/LoveLive!虹咲学园学园偶像同好会) 是二期动画放送中开始看的；[<span class="text-aqours">水</span>](https://zh.moegirl.org.cn/LoveLive!Sunshine!!) 没太关注，动画只追到一期的一半，但开始看虹星后也多少看了一点切片；音乐剧和莲完全没去了解，感觉现在虹星就已经推不动了，没法加推。主推大概是 [<span class="text-kanon">sayu</span>/<span class="text-kanon">合</span>](https://zh.moegirl.org.cn/伊达小百合)[<span class="contrast-keke-link">鲤</span>](https://zh.moegirl.org.cn/Liyuu)/[<span class="text-mia">秀酱</span>](https://zh.moegirl.org.cn/内田秀)/[<span class="text-emma">麻圆</span>](https://zh.moegirl.org.cn/指出毬亚)。但现在其实已经又淡坑了，最近都看得比较少。
-   [《罗小黑战记》](https://bgm.tv/subject/13603) 是除了动画电影以及小时候看的动画片，唯一一部较为完整地看过的国漫。
-   有在用 [bangumi](https://bgm.tv/user/ouuan)，但是用的较晚，所以（早期的）时间胶囊会比较乱，早期看的番的评分大概也比较乱来（~~说的好像最近看的番评分就有多正确一样~~）。
-   听的最多的是日语歌，目前[歌单](https://music.163.com/#/playlist?id=5091819419)的前六名有三首[匹老板](https://space.bilibili.com/203655966/)的歌和三首[花譜](https://space.bilibili.com/488970166/)的歌。

    P.S. 感觉找不到一个满意的歌单管理解决方案，以至于懒得更新歌单。想以后自己写一个。
-   大概是一名[轴芯](https://space.bilibili.com/61639371)。只不过看 [v](https://zh.moegirl.org.cn/虚拟UP主) 看的多的还是 2020 年，曾经还看过很多其他 v，现在看得少（时间 & 人数）了。
-   偶尔（~~曾经~~）会[在 b 站上发一些视频](https://space.bilibili.com/11067182)。感觉除了 [av65924361](https://www.bilibili.com/video/av65924361) 和 [av79877987](https://www.bilibili.com/video/av79877987) 基本上都是划水或者黑历史（两个项目介绍的项目虽然不划水，但介绍挺划水的（
-   不喜欢 BV 号，所以写了个 [bv2av](https://greasyfork.org/zh-CN/scripts/398535-bv2av) 的 userscript。

---

-   <del>在[十六型人格测试](https://www.16personalities.com/ch/)中稳定获得[“逻辑学家”人格 (INTP)](https://www.16personalities.com/ch/intp-人格) 的测试结果（有时会在 INTP-A 和 INTP-T 之间摇摆）</del> 最新测试结果还是 INTP，但除了 I 是 90%，其他几项都不到 55%，所以实际上是 IXXX 了（
-   不擅言辞，不会交际。常有语出冒犯的时候。虽希望善良待人，但不会为人处事。([origin](http://web.archive.org/web/20210123202817/https://blog.yuuta.moe/about/))
-   我相信人与人之间的误解远多于分歧。
-   > 「没有人是怪物」「理解不等于赞同」  

    引自《〈和陌生人说话〉：越汹涌，越平静》，Vista 看天下 2021.12.18
    （其实应该是“越平静，越汹涌”；原标题如此）
-   高三的时候同学带了很多《Vista 看天下》到班上供大家借阅，就利用晚自习和考前“复习”看了很多；高中毕业后自己订阅了电子版的看天下，现在也一直在看，可以说是除了社交媒体外的主要信息来源。
-   幻想有一天用户为开源/[自由软件](https://www.gnu.org/philosophy/free-sw.html)付费能成为常态，就像观众为能免费看的直播打赏成为常态一样。现在越来越觉得这只能是个幻想，而且或许会有比用户不愿付费更大的阻碍。

---

-   GPG key: [\`863A0F9FA8127FA4\`](https://github.com/ouuan.gpg)（~~有听说 [The PGP Problem](https://latacora.micro.blog/2019/07/16/the-pgp-problem.html) 之类的，但暂时懒得研究~~）

---

## 关于本博客

这是我继博客园、hexo-theme-next、hugo-theme-even 后的第四代博客。博客园和 Hexo 的文章已全部移至 Hugo 博客，但 Hugo 博客的文章（以 OI 相关内容为主）将不会移至本博客，可在 [原 Hugo 博客](https://ouuan.github.io/) 查看。

本博客由 ouuan 自己设计、制作，主要基于 [îles](https://github.com/ElMassimo/iles)（[Vue](https://vuejs.org/)、[Vite](https://vitejs.dev/)）和 [UnoCSS](https://github.com/unocss/unocss)。设计有在一定程度上借鉴 [hugo-theme-even](https://github.com/olOwOlo/hugo-theme-even)、[hexo-theme-next](https://github.com/next-theme/hexo-theme-next)、[Sukka's Blog](https://blog.skk.moe/)、GitHub 的 Markdown 显示，但大部分是原创设计，且借鉴部分的代码基本都是自己写的。

博客正文部分使用的字体是 [思源宋体](https://github.com/adobe-fonts/source-han-serif)，引用块部分使用的是 [<span class="font-kai">霞鹜文楷</span>](https://github.com/lxgw/LxgwWenKai)，二者均以 OFL 授权。web font 的划分、生成可以参考[《另一种很新的中文字体网页嵌入方案》](/post/2023/01/glyph-segregator)，其他排版优化（包括标点挤压的实现）详见[《一些博客排版优化小 trick》](/post/2023/02/typography-tricks)。

代码高亮使用的是 [Shiki](https://github.com/shikijs/shiki/)，主题是 [Night Owl](https://github.com/sdras/night-owl-vscode-theme)（选了一个用的人较多，有暗色和亮色，配色整体偏蓝、和博客主题比较贴合的；我自己的 neovim 还是用的 [gruvbox](https://github.com/ellisonleao/gruvbox.nvim)）。[remark](https://github.com/remarkjs/remark) 插件和 Vue component 是自己写的，可以参考 [remarkShiki.ts](https://github.com/ouuan/iles-blog/blob/master/src/remark/remarkShiki.ts)、[CodeBlock.vue](https://github.com/ouuan/iles-blog/blob/master/src/components/CodeBlock.vue)、[CopyButton.vue](https://github.com/ouuan/iles-blog/blob/master/src/components/CopyButton.vue)（如果用的不是 iles 大概不能直接照抄）。

可以在遵循 [AGPL v3](https://github.com/ouuan/iles-blog/blob/master/LICENSE)（或其更新的版本）的条件下参考/使用 [本博客代码](https://github.com/ouuan/iles-blog) 的 **片段**，但请 **尽量不要** 直接在整个代码的基础上进行修改，因为并没有按照人人可以拿来用的模板进行设计，很多地方会硬编码一些东西，修改比较困难，如果我这里有更新要同步也很麻烦，也可能在某些系统环境无法正常构建之类的。如果真的直接使用，也需要遵循 [AGPL v3](https://github.com/ouuan/iles-blog/blob/master/LICENSE)，并且请务必小心，一切后果自负。

本博客使用 ouuan 自行搭建的 [Plausible Analytics](https://plausible.io/) 实例进行访问量统计，不使用 Cookies 且满足 GDPR 等条例要求。使用 [giscus](https://giscus.app/) 提供评论服务，发表评论需要登录 GitHub 帐号，除了发表评论也可以给文章点赞/点踩。网站托管于 [Cloudflare Pages](https://pages.cloudflare.com/)。

<Card type="info" fold title="RSS 订阅">

<Card type="question" fold title="什么是 RSS？">

-   [高效获取信息，你需要这份 RSS 入门指南 - 少数派](https://sspai.com/post/56391)
-   [我有特别的 RSS 使用技巧 | Hi, DIYgod](https://diygod.me/ohmyrss/)
-   [RSS - Wikipedia](https://en.wikipedia.org/wiki/RSS)

</Card>

-   一些 RSS 阅读器：
    <div class="inline-img mb-2">
    -   [![Follow on Inoreader](https://shields.ouuan.moe/static/v1?label=Inoreader&message=follow&style=social&logo=data:image/webp;base64,UklGRlICAABXRUJQVlA4IEYCAADwDQCdASpIAEgAPpFCmkolo6Ihp7gKGLASCWYA05nA/qumqeI8zavP3naz1m+oDbAc9Hpne9AL91aqgA91zGCWx8nzKx0FkaT+q4k67MyE2/hZym+6Qlfro/6nbI7vMhtFzlbdteFFMPzGJSH6DzATVS/YBx+Pv1gA/tYx/G8ZLrdlf+Ur43bsXBh+7KArqPth0CslagD4VKOmauUvNe1dhwxpfrDwqRKvSQEviUNf9AoDJ89/8dEHpu/J/vIsQVr8/SLJPEy8MGcw3ZV+gyLplT/tqzDYluRQ9IQKj9PPk/ExqxMI98/ACDXEYrdimUzsiz7qxRCKQ81JCgKiZTVeMiujTknatA6miOW2wTG1KSEoCa+6eyuzyo1puxJMM8ZbYt3aayIQAQ1DhjYxtMb/RD1SZZtmsBl9puxniEDqgnw2hIPekG5SatAlFeiJJw6A5B+dDCTeP+0Tir6PRDuQVXCzNBmtLFHXyBO/YYYsVq8ifCYlqn5bFEyJ4NHidwPWyf4NmVmquIwYbyxd/253wVwQQQig9oO9zHFMW8erqf9qk9N7V0yU5VOEHYGqmcWVB1cvOQuvja7SX3aoiGVMMsEelV0sH0USncQ7lx9aI6DTfLjQJyQ3Hl91g6JEcEjv4TCh0KewAnNpCM4PuEvn1kWgGusR2kcUUDZxn+pJLv8XJUbA2PkZ3O2e6eySmglzu8+ytxDe+TzGrAGF/SCcLth5IuX4eeBVDVjn0TqDEjOncMk0AIzNDD8Wdw/1aAAB4oAAAAA=)](https://www.inoreader.com/feed/https%3A%2F%2Fouuan.moe%2Ffeed.xml)
    -   [![Follow on Feedly](https://shields.ouuan.moe/static/v1?label=Feedly&message=follow&style=social&logo=data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTExLjU1LjY1MmEyLjE3NCAyLjE3NCAwIDAgMC0zLjEwNSAwTC42NCA4LjZhMi4yNzQgMi4yNzQgMCAwIDAgMCAzLjE2M2w1LjU3IDUuNjczYy4zODguMzQzLjg5NC41NTMgMS40NS41NTNoNC42NzdhMi4xOCAyLjE4IDAgMCAwIDEuNTYtLjY1OWw1LjQ2Mi01LjU2MmEyLjI3MiAyLjI3MiAwIDAgMCAwLTMuMTYzTDExLjU1MS42NTJ6bS0uMjE2IDE0LjUxOGwtLjc4Ljc5MmEuMzEuMzEgMCAwIDEtLjIyMy4wOTVoLS42NjdhLjMxMy4zMTMgMCAwIDEtLjIwNi0uMDhsLS43OTUtLjgwOGEuMzI1LjMyNSAwIDAgMSAwLS40NTJsMS4xMTQtMS4xMzRhLjMwOS4zMDkgMCAwIDEgLjQ0MyAwbDEuMTE0IDEuMTM1YS4zMjQuMzI0IDAgMCAxIDAgLjQ1MnptMC00Ljc1OWwtMy4xMTUgMy4xNzNhLjMxMi4zMTIgMCAwIDEtLjIyMy4wOTNINy4zM2EuMzEzLjMxMyAwIDAgMS0uMjA4LS4wNzhsLS43OTMtLjgwOGEuMzI2LjMyNiAwIDAgMSAwLS40NTNsMy40NDktMy41MTJhLjMxLjMxIDAgMCAxIC40NDMgMGwxLjExNCAxLjEzNWEuMzIyLjMyMiAwIDAgMSAwIC40NXptMC00Ljc1NmwtNS40NSA1LjU1YS4zMS4zMSAwIDAgMS0uMjI0LjA5NGgtLjY2N2EuMzExLjMxMSAwIDAgMS0uMjA3LS4wNzhsLS43OTQtLjgxYS4zMjMuMzIzIDAgMCAxIDAtLjQ1bDUuNzg1LTUuODkyYS4zMS4zMSAwIDAgMSAuNDQzIDBsMS4xMTQgMS4xMzRhLjMyNC4zMjQgMCAwIDEgMCAuNDUyeiIgZmlsbD0iIzJBQjE0QyIvPjwvc3ZnPg==)](https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fouuan.moe%2Ffeed.xml)
    -   [![Follow on follow.it](https://shields.ouuan.moe/static/v1?label=follow.it&message=follow&style=social&logo=data:image/webp;base64,UklGRtABAABXRUJQVlA4IMQBAAAQDgCdASpkAGQAPpFGnkqlpCMhp9aocLASCUASsGppds4Y7itw+9LtpfMBz//pVdQBvNb5erWMAKna+qj/c5jfNiyUrDFqi3eD6AyfUe6ISt9zmrlUv2UAjxTG+eKE7qwoJNK39PMAcA69EnBUL63cyqTxw+B6YhgAAP7E7/m0mB7/+fmfzv87bYAa20JIb/DcScQ/QlgNi1R1d5K3VmoCDeADr6/SZMY4nBAdm0CaZ2RpgiVkoynHcHSonLrL/PnqPiR3/roVeiudb9EaMEQ/p3uAQRL25vUE9YaeovyxgRWMK+sTdmazKTpHlERAxIvOpyWnv3md3AXnpxETXCkcXS5IqWNh/+qsybjBIt9SS8eaCh1cPh/I7u3oCgzciiwhUCke8PuElhuW7eM5tgCiULVgkIo2ewuVHLZcUBPd7XVNU7QfwXwFAWPx7EesLRyGgVZat672D6n79nFnjydEgAjPgFSGGgdZKy+a9DxKClQ6UtEep9nj5APCAaqS7lTJNx63XEWvY5/qQCSaRUPTHdgmpJVAEK/963VJXfgPGJzy5dDei7IkCP9WAA5IfaQ7jHVP4fUCd6v2Jj7x7kMWAAAAAA==)](https://follow.it/ouuan)
    -   [![Follow on Feeds Pub](https://shields.ouuan.moe/static/v1?label=Feeds%20Pub&message=follow&style=social&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEUAAABFCAYAAAAcjSspAAAACXBIWXMAAAInAAACJwG+ElQIAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAASkSURBVHgB7Ztdcts2EMf/oDyeNO5MnBOUN4hzAtNvrZ0H8QSimwPEPoHlE9g5gZkTSJ46mU77YPYEVd/6yN5AnWkzrVNxuxAhN3UA0YL46eA3Y30AkDT8c7FY7MKAw+FwlIfAAyAafe2rl/w8m8bhjxOsQedEiUbBNrAVeQLPCBTwJfiaYROiWRiH36ewYAMdIBfiUV+I3oDfBrKN5j3Ge7rDYy/4eQ8WtFoUOS08zxsQiSN+u73ap7EDS1opCosR8J0+4ZcBEWyZwpJWiRKN9tnsxRnUFFkHIjqFJa1wtNJneN7WCVvFEexgqyD+E1MBkWaUXcbhuxiWNC7Ky8sXrzKiIVbzGVO2hDeANwb+mMRhYj1VdDQmytw6xJcXvKz2V/hYwk73NA6vElRII6Io3zHCPNgqhK1CvGaLOC/bIkzU7mij0TccbwgZQxRNl9rFWFCrpby8PBhkhLhoHPsLFuP9sG4xFtQmioo9rguGcXgujqv2GUX0UAMyMmVBpA8xThllHYdx+MOvaJhafIqyEN/Qzb7DY+v4LkZLqFwUFYf4hm4Zb+yxIGtt9cumUp+ipo3RSliQ5xx5tkoQiYdK8QIYBcFxGwWRVCoKxyMnhi4Ozd+eo6VUJopKEfq6PqKbQ7SYCh3txs4iP3aHqRCbZ4fjA16eSS3RIp0/CkyyjH4BssQ2lVgGFYqS7Rj8uBQiyF/e9vvygf0MB3iyrYdvxwdxRrPTJsSpZPrkq47YxRqwjUW8cv0sN4+omdJFkXGJvBiUkD1jtlnc649KGLVQ2vTJ8yOPzzhQi1AuPN08mZGzzcqtTCmWIgURYuuaICJUAFvLADWydkS7EAT3LClwFPsT3wuOUbIU2OTUwI20BOl85WrEuRYM9J/782lnkkwq4XxvZ8h3/auL/tXY0D0+HO/v6qp+vc3HT7BG2WIV1po+vDJEFhl4P6/4mRDaC5/dfHiKmlhLlCVhvIw5ONtOqb73i0DXGo36UiyD1X1IURPWokgrgXn3+5r3NlHuPzQ/anCcPe8fk0NN60xNWouyxEr4At6pKSUS3QBepYK7U0jGIqr+oxmPBDViJYqKMn1dH+dYP9rsbUqHqrvD84rgf993m3fR+xoSb1AjVktyNDo44qXzTNM1uei/ff7/sfvnbFWvdN8jRG4ZBacKEv5OqyMVtlgtyewTdkmzAybKNHc045ikpxWFxRiiAKJZ7WkGq+lDt1v+u/Q+yaTJXW5e1LL4nXl2rjO7ZFMi+m/DCrEx5IcUq/zCvGbcTHbOUhTh61pNB/DicMxZ+5n0CynuQW4hV0M0xMqiqABLx9I4Ip9Gsz1ejsdLhiV5hr/Z/K2Fo/1r21BYLAyulH8Io9GLgB2wLLQ/ExzWZ5T9Js+aNF0uXdDI8S518Qlaio1P8Q3tKR4IFRfDuokTRYONKKmh3ccDwVmKBieKBieKBgtRHpmCtKLTjp1hZVHkPsbQ9fmK8jlgK4rWWpaXLrqDbT5FK4oqWHUeN300OFE0OFE02KYjU13r7Ob973gA2GXziY5xZwXKE83N/NdF2VifT8mPXHlHXAN6knEFry2pRIfD4XA4usm//qauBcoh1b8AAAAASUVORK5CYII=)](https://feeds.pub/feed/https%3A%2F%2Fouuan.moe%2Ffeed.xml)
    </div>
-   最新文章: [RSS 订阅](https://ouuan.moe/feed.xml) / [Atom 订阅](https://ouuan.moe/feed.atom) / [JSON 订阅](https://ouuan.moe/feed.json)
-   某个 tag 的最新文章: 在 tag URL 的后面加上 \`/feed.xml\`/\`.atom\`/\`.json\`，例如 [csapp 标签的 RSS 订阅](https://ouuan.moe/tag/csapp/feed.xml)

Tips: 可以使用 [RSSHub Radar](https://github.com/DIYgod/RSSHub-Radar) 等插件自动发现这些订阅。

</Card>

## 关于我在一些其他地方的 profile

> 如果奇迹有颜色的话，那么其中之一必是<span class="text-honoka">橙色</span>的吧。

这是 [我在 b 站上](https://space.bilibili.com/11067182) 的个性签名，应该是 16 或 17 年就开始在用了。[出自 Snow Halation](https://zh.moegirl.org.cn/如果奇迹有颜色，那一定是橙色) 但把“那”改成了“其中之一”。
[在洛谷上](https://www.luogu.com.cn/user/49742)，因为当时洛谷换了新 UI 后个人空间和 b 站长得有点像，我就特意用头图和个性签名模仿了 b 站个人空间。

> この道行きの最後が 天国か そこらじゃあないとしても  
> 这条路的尽头会是天国吗 就算不是也没有关系
>
> ただの君と笑って立っていたいよ  
> 单纯的想和你相视而笑并肩而立
>
> 誇らしさとか 願いとか 希望とか  
> 我的骄傲 愿望 希望
>
> もっと ずっと 持ち合わせとくよ  
> 愿能永久地伴我同行

这是 [3 狮 OP2](https://music.163.com/#/song?id=456185218) 的一段歌词，我把它设为了一些地方的个人空间头图。

> 生き方は 無限にある。  
> 生活的方法有无限种。

这是 [No.1](https://music.163.com/#/song?id=1416874718) 的一句歌词，是我现在的 QQ 个性签名。
`},{title:m,tags:"btrfs Arch Linux 问题解决记录",content:`记录一下之前困扰我近一年的 [Btrfs](https://wiki.archlinux.org/title/Btrfs) 快照导致的系统无响应问题。



## 系统无响应的具体表现

每次整点时有概率出现，在一分钟左右的时间内，和磁盘写入相关的操作都会卡死，例如直接和文件操作相关的保存文件，或者会写入 \`~/.zsh_history\` 的在终端输入命令，以及打开新的 GUI 应用等等，基本上就是整个系统完全卡死。

另外，我有观察到，在笔记本不使用外接电源时这一问题表现地更为严重，即更容易被察觉到、每次卡住的时间更长。

## 最初解决问题的尝试

遇到问题后不久，我就怀疑上了一些每小时自动运行的任务，包括 [Timeshift](https://github.com/linuxmint/timeshift) 的快照以及一些自己写的 crontab。

最值得怀疑的就是 Timeshift 的快照了，然而，当时我曾经尝试过暂时关闭自动快照，但问题似乎没有得到解决，具体原因已不可考了。当时我还在一个群里提出了这个猜想，然后群友说快照是原子级操作，不应该卡住，我感觉很有道理，就在很长时间内没有怀疑自动快照的问题了。

后来我又尝试着关闭各种 crontab，当然也没有解决问题。

有想过在整点时用 \`htop\` 查看进程信息，但由于卡住时运行不了命令（当然可以关闭终端的历史记录，但关了也不见得不卡，而且我懒啊x），需要提前打开 \`htop\`，而且也不是每小时都会遇到这个问题，看到了进程信息也不一定能找到问题所在，最后也没有成功。

当时自然也尝试过各种搜索，至于为什么没有搜索到或者注意到 [Freeze issues with BTRFS and Timeshift](https://forum.manjaro.org/t/freeze-issues-with-btrfs-and-timeshift/22005) 也不可考了，可能是搜索关键词不对吧，毕竟当时我一定程度上排除了对快照的怀疑。

由于问题的严重程度和是否外接电源有关，我甚至一度怀疑过是硬件问题，想换电脑（

## 最终问题的解决

在被这一问题困扰了大半年后，我又忍不住想搜索解决方法，这一次很快就搜到了 [Freeze issues with BTRFS and Timeshift](https://forum.manjaro.org/t/freeze-issues-with-btrfs-and-timeshift/22005)，然后按里面说的禁用了 quota: \`sudo btrfs quota disable /\`。

但过了几天，我发现问题又出现了，以为这个方法不管用。

后来又过了一段时间，我又忍不了了，再仔细阅读了一下，发现这个 thread 里有提到 Timeshift 会自动打开 quota，要修改 Timeshift 的设置才行。至此，问题解决。

<Card title="关于 Brtfs Quota">

[Btrfs quota](https://wiki.archlinux.org/title/Btrfs#Quota) 主要用于快速查看每个 subvolume 的磁盘用量（可以用 [btrfs-du](https://github.com/nachoparker/btrfs-du) 查看），如果没有启用的话，每次查看就需要几十秒的时间来重新扫描。

但是，这一功能有很多 [已知问题](https://btrfs.wiki.kernel.org/index.php/Quota_support#Known_issues)（当然也包括本文描述的这个），所以目前不建议启用。

</Card>

## 后记: Timeshift 已修复此问题

实际上，Timeshift 已在我自己解决问题前不久就修复了这一问题: [Fix #865, #839, #680: Do not create or remove Qgroups when snapshots are created or removed](https://github.com/linuxmint/timeshift/commit/8d77b18fe7b725c11baefe721633561d755b3630)

虽然 [Timeshift 在 5 月 29 日就发布了修复](https://github.com/linuxmint/timeshift/releases/tag/v22.06.1)，但是 [archlinuxcn 在 7 月 1 日才更新](https://github.com/archlinuxcn/repo/commits/master/archlinuxcn/timeshift)，于是我“有幸”在 Timeshift 更新的前一天自己解决了问题 🙃...

![消息记录，发于 6 月 30 日: 前段时间听说关 quota 可以解决这个问题，但关了之后还是经常卡。今天才发现 timeshift 里设置了开 quota，得把 timeshift 的自动开 quota 关了才行 🌚 需要观察几天是否还会整点卡](btrfs-quota-timeshift-message-screenshot.png)

其实我还是写这篇博客的时候想看一眼 Timeshift 的 quota 设置发现没有这个设置项了才知道 Timeshift 已经修了...
`},{title:p,tags:"CSS Web 问题解决记录",content:`同时使用 \`display: none\` 和 \`loading="lazy"\` 可能会让内容永远加载不出来。

<p class="dark:hidden">![截图：评论加载中](comments-loading-light.png)</p>
<p class="hidden dark:block">![截图：评论加载中](comments-loading-dark.png)</p>



## 问题背景

虽然 [giscus](https://giscus.app/) 自带一个加载页面，但首先这个加载页面自身就有可能加载很久才显示，而且这个自带的加载页面没有任何有效信息，所以我自己写了一个加载页面，附上了 Discussions 链接。

我使用的是 giscus 的 [giscus-to-parent \`message\` events](https://github.com/giscus/giscus/blob/main/ADVANCED-USAGE.md#giscus-to-parent-message-events) 功能来检测 giscus 已加载，而这和 giscus 显示在页面上有一定的时间间隔，所以在检测到加载好之前需要先把 giscus 隐藏起来。因为是用的 Vue，很自然地就是用 \`v-show\` 让 giscus 加载好再显示。

除此之外，本着“不用白不用”的精神，我还启用了 giscus 的 lazy load（本质上是 \`<iframe>\` 的 \`loading="lazy"\`）。

并且，我使用的是 Firefox，上述配置在 Firefox 上是没有问题的。

## 问题的发现与解决

一位群友告诉我评论加载不出来，于是我试了一下各个浏览器，在第二次（为什么是第二次呢，不懂）试 Chrome 的时候发现没加载出来。

console 没有任何报错；查看 DOM，发现 \`<iframe>\` 里面是空的，幸好我还记得自己用了 lazy load，所以很快就明白了问题所在：Chrome 比较“聪明”，看到 \`display: none;\` 就懒了，没加载这个 \`<iframe>\`。

把 \`v-show\` 换成 \`opacity-0 absolute\` 就解决了问题。

但最后还有点小插曲，因为这个 \`opacity-0\` 在 SSR 的时候是没有的，没被 [UnoCSS](https://github.com/unocss/unocss) 扫描到，就挂了，最后换成了 inline style。

## 后记

这件事告诉我们，~~有好的群友~~在不同浏览器上多测试几遍是非常重要的。

~~这点事值得发博客吗；当然是博客太空了随便水一篇~~

P.S. 虽然问题的解决很简单，但还是浅搜了一下看看有没有什么 best practice。倒是没搜到什么有用的，但是搜到[一个有趣的](https://developers.weixin.qq.com/community/develop/doc/0006ec11c48ec072b6e7b79975b000)（

![论坛截图：麻烦提供下代码片段。你们已经是成熟的开发团队了，要学会自己复现bug。](reproduce-yourself.png)

## 再后记

发现加载中的 \`<iframe>\` 虽然看不见但点的到..需要加一个 \`z-index: -1\`。

## 再后记的后记

这个东西虽然怎么都看不见了，但宽度会让整个页面出现水平滚动条，所以要加 \`width: 0; height: 0;\`。
`},{title:g,tags:"选课 THU 经验分享",content:`还记得刚入学的时候，我一开始完全没弄明白要怎么选课，当时就想着弄明白了要写一篇选课指南。

后来，我弄明白之后发现不记得自己以前为什么不明白了，写不出来了（

再后来，我发现一些身边的同学到了选大二的课的时候还没弄明白选课流程（

所以，虽然选课指南是写不出来了，姑且是列举一些常见问题与注意事项，供参考。



因为选课相关问题错综复杂，下面的内容按顺序阅读可能会有困难，因为有后文才介绍的概念前文已经出现的情况。（这也是为什么我说这篇不是“指南”而是“常见问题与注意事项”（

<Card type="warn">

本文内容仅供参考，可能因为规则具有时效性、不同院系之间存在差别、笔者的认识错误或笔误而与实际选课不符，还请以实际的选课规则为准，必要时向老师或辅导员咨询。

</Card>

当然如果发现了什么错误可以评论区告诉我。

## 选课入口 —— 在哪选课啊，我找不到

[中文选课入口](https://zhjwxk.cic.tsinghua.edu.cn/xklogin.do)

反正我是每次在地址栏输入 \`xk\`，然后匹配到的第一个历史记录就是选课入口。

除此之外，还可以在 [academic](https://academic.tsinghua.edu.cn) 登录后点击 [“进入本科生选课”](https://zhjw.cic.tsinghua.edu.cn/xkBks.vxkBksXkbBs.do?m=main) 进入。

如果是在校外，就要用 VPN 访问，一般使用 [webvpn](https://webvpn.tsinghua.edu.cn/)，登录进去后就会有选课入口的链接。

在抢课刚开始等热门时段，选课系统一般会非常卡，据说使用 [英文选课系统](https://zhjwxkyw.cic.tsinghua.edu.cn/xklogin.do) 会不卡一些，但不确定是不是真的。

## 选课流程 —— 什么是预选、正选、补退选？什么是抽签、抢课？

### 选课流程

#### 新生选课流程

刚入学时的第一次选课与后面的选课是有一定差异的，如果不意识到这一点，看到一个对正常选课流程的描述，发现和新生选课不同，就可能被搞晕。

新生选课主要有这些特点：

-   没有正选环节
-   不分一二三志愿
-   老生已在上学期末完成了预选和正选，而新生在入学时才会进行预选
-   一些课程会在老生选课时给新生预留部分课容量（若新生没选满，老生可以在补退选时再抢课）

#### 正常选课流程

在选课系统点击“选课时间安排”就能看到当前学期的完整选课时间安排。

一般来说，选课的主体流程为: 预选 → 正选 → 补退选第一阶段 → 补退选第二阶段 & 特殊原因补选

除此之外，还会有二级选课、重修体育课分项等特殊类型选课，以及记 P/F 和退课。

<Card type="warn" title="记得选课！">

~~你在说啥？我怎么会忘记选课，不会有通知吗~~

可能会和你想象中不同，选课经常是没有通知的，或者，更准确地说，你不一定关注了发布通知的渠道，以及通知可能发布得比选课时间早很多，等到选课时你可能已经忘了。

运气好时，你可能会收到通知，或者看到群里有同学在讨论选课相关的话题。但是，如果你运气不太好，或者是你遇到的是 **二级选课、补退选、记 P/F、退课** 等并非人人关注的选课环节，可能真的没有任何人会来通知你。所以，一定要在选课期间关注选课时间安排，不要错过选课。

</Card>

#### 夏季学期（小学期）选课流程

夏季学期没有预选也没有补退选，也就是不抽签直接抢课。具体差别请在夏季学期选课时查看选课系统中的“选课时间安排”。

### 选课环节

#### 预选

所谓的“抽签” ~~“赌场”~~ 指的就是预选了。

对于每个课，若选课人数超过课容量，就会在预选结束后进行抽签，在选了这个课的人里随机抽取课容量这么多的人，他们就选上这门课了，而其他人则按随机顺序加入 Waiting List。

但是，这里的“随机”不是完全的随机，而是有优先级的 —— 先看课程属性，再看志愿优先级。课程属性分为必修、限选、任选，除新生选课外志愿分为一二三三档，满足特殊条件的话还可以在任选课中拿到“优先志愿”，总的排序就是: 必修一志愿 > 必修二志愿 > 必修三志愿 > 限选一志愿 > 限选二志愿 > 限选三志愿 > 任选优先志愿 > 任选一志愿 > 任选二志愿 > 任选三志愿。

抽签时，会先依次让每个优先级的所有人选上课，如果一个优先级的人数大于当前课余量，就会在这一优先级内随机抽取课余量这么多人选上课，而没有抽到的人以及更低优先级的人则会落选，并按优先级顺序加入 Waiting List。也可以理解为以优先级为第一关键字、随机数为第二关键字进行排序，然后取前课容量这么多的人选上课，余下的人按原序加入 Waiting List。

<Card title="Waiting List 顺序与志愿优先级">
有一个流传甚广的传言，是 Waiting List 顺序与志愿优先级无关。这个传言能流传开来，大概是因为实际抽到的 WL 位置不能 100% 证伪这个传言，而每学期又只有最多那么几门课会进入 WL，也很难收集足够多的数据以在大概率上证伪。而一旦把中午 12:00 的志愿当作最终志愿，把有人退出队列后的队列位置当作抽到的队列位置，或者是怎么算错了，就可能误以为“证实”了这个传言。

实际上 [本科生选课系统Waiting List方案介绍](https://announce.cic.tsinghua.edu.cn/node/26766) 就明确说了：

> 未中签的学生，系统根据抽签级别顺序进入该课程的WL中候选。同一级别的学生随机排序。

但大家看起来都没有看到这个方案介绍，都靠口口相传来了解选课规则（
</Card>

一二三志愿是选课者自行选择的，**每个课程属性**都可以选择至多 1 门一志愿、至多 2 门二志愿、任意门三志愿，而不同课程属性的志愿之间互不影响，也就是说必修一志愿和任选一志愿可以各有一个。优先志愿一般是给相关院系/专业的学生，需要满足的条件会写在“选课文字说明”中，例如，课程“计算机科学基础”的选课文字说明为“优先:计算机类、信息与计算科学专业学生选课”。

在预选期间，可以多次修改所选的课程或志愿等级，也可以在 选课查询 → 志愿填报情况查询 中查到所有课的志愿填报情况。但是，这个志愿填报情况并非实时更新，而是只会在每天 8、12、16、20 点更新，且预选阶段的最后一次更新会在预选结束前四小时左右，所以，你查到的志愿填报情况可能和最终的真实情况差别极大。如何选择填报志愿的时机、如何根据情报调整自己的志愿等级、教师乃至课程选择，都是一场惊心动魄的博弈 ~~，这也是预选被称作“赌场”的重要原因之一~~。（博弈有风险，推荐同学们尽早填报真实志愿，瞒报志愿可能害人害己。）

抽签结果一般在预选结束后好几天才会公布（可能是要安排教室、必要时调整课容量之类的）。

在抽签完成后，可以在选课系统的课表查询中查看抽签情况，选上的课会和预选时一样是 <span style="color:#855512;">棕色</span> 的，而掉了的课则会显示为“候选”并且是 <span style="color:#6684A5;">蓝色</span> 的。

#### 正选、补退选、Waiting List

所谓的“抢课”主要指的就是正选，以及补退选。

这两者在选课操作上基本上是一样的，最大的区别就是正选在上学期末、预选结束后不久进行，而补退选在新学期开始上课后进行，新生选课则没有正选环节。

在这一环节中，选课不再以抽签进行，而是先到先得。

在这一阶段中，除了选课，还可以退选。这里就涉及到了 *Waiting List* 的概念。顾名思义，Waiting List（简称 WL）就是排队等待课程坑位空出来，而空出坑位一般就是有人退选了（也可能是课程扩容了）。当出现新的课余量时，排在 WL 最前端的人就会递补选上这门课。可以选择退出 WL，这也可以看作是退选的一种。

特别地，补退选分为两个阶段，分别位于上课第一周和上课第二周，在第二阶段中只能退选不能补选。

<Card title="退出 WL">

想选的课只要苦苦等待就可能有机会选上，为什么要退出呢？主要有两个原因：

1.  同一个课程号的课只能选一个。例如，你选了 A 老师的数学分析，不幸进入 WL，只有退出 WL 才能再选 B 老师的数学分析。

2.  WL 中的课程不受学分限制，但递补时受学分限制。例如，你已经选择了 24 学分的课程，学分限制为 26，你还有两门 2 学分的课程 A 和 B 在 WL 中，你比起 B 更想选上 A，并且两门课都排在 WL 前端，有希望成功递补。第二天早上，你起来一看，两门课都递补了，但 B 先递补上，占满了学分限制，所以后递补的 A 就直接退出了 WL，如果想选就得再排在 WL 尾部了。

    除了删除不必要的 WL，若学分可能受限而递补希望大，也可以考虑删除已经选上的课来为 WL 中的课留出学分。

如何退出 WL 也是困扰很多同学的一大难题（~~选课系统的 UI 是谁设计的~~）。在 选课查询 → 队列系统查询 里是只能查询队列信息不能退出队列的，要在 选课操作 → 一级选课 → 队列信息 里退出。（知道在哪退 WL 可能让你在新生第一次补退选中抢占先机（~~也可能不止新生那一次，直到选大二的课的时候我室友还在问我怎么退 WL~~

</Card>

#### 二级选课

二级选课也是先到先得，一般是用来做实验之类的，在课程信息中会标明一个课是否有二级选课，但选课前不一定会告诉你有哪些时间段可以选，所以可能需要预留出一些时间给二级课，不能选太满或者太分散以至于没有大段的空余时间（依具体课程而定，可以考虑咨询学长学姐）。

数学课的习题课也可能会被标注成有二级选课，但我目前上过的数学课都不会真的进行二级选课，而是会和同学们一起协商出习题课的时间。

#### 特殊原因补选（手选）

特殊原因补选，也称手选（手动选课），是一种无视其余选课规则的存在（不受课程容量、院系专业限制、甚至上课时间冲突等条件制约），只要任课教师和开课院系同意（~~这是可以“只要”的吗~~ 如果课容量满了，可能需要说明具体原因，但如果只是受到专业限制之类的而课容量没满，还是很可能申请通过的），就能选上课。申请流程详见 [网上特殊原因补选课申请系统操作说明（学生篇）.docx](https://jwcbg.cic.tsinghua.edu.cn/download.jsp?attachSeq=2962)

由于手选一般安排在开学后第二周，最好是通过提前和老师发邮件等方式确定能否手选上，也可以一并了解上课地点以及发布给选上课的同学的相关通知。

#### 记 P/F

记 P/F 即成绩以 P(ass) 或 F(ailure) 记录，不记录具体等级，只要过了就都一样。记 P/F 的课不会有绩点，也不会计入 GPA。

一般情况下，只有任选课可以记 P/F，必修和限选课不能记，并且每学期最多只能选择一门课记 P/F。实际操作中，如果想记 P/F 的课完全是自己感兴趣而选的、不在培养方案中，应该就可以放心记 P/F；而如果在培养方案中的话，最好咨询一下（教务）老师或者辅导员，以免对培养方案的完成或者保研等造成影响。

除了在记 P/F 阶段在选课系统中主动记 P/F，有的课程（一般是通识课、选修课）会自带 P/F，即无需手动选择就以 P/F 记录成绩，这样的 P/F 不会占用每学期一门课的名额，也不会对培养方案的完成造成影响。有的课程会在课程介绍中说明是否自带 P/F，而有的课就需要咨询学长学姐或者等开课后才知道了。

#### 退课

每学期会有两次退课阶段，一般安排在期中附近以及期中后一个月左右。在退课阶段退课，除非退掉的是还没开课的课程（一般是在第一次退课时退掉后八周开课的课程），会在成绩单上记一个 “W”（W ~~onderful~~ ithdrew）。这个 “W” 貌似不会有什么实际的影响，但总之会显示在你的成绩单上。

大家一般会因为对课程不感兴趣、对自己前半学期的学习情况不满意 <del>、对期中考试的成绩不满意</del> 等原因而选择退课。退课是一件需要慎重考虑的事，如果退掉的是比较重要的课，就要考虑到重修带来的各方面的影响。

<Card type="info" title="第二次退课">

自 2023-2024 秋季学期起，位于期中后的第二次退课只能退后八周开设的课程。

</Card>

<Card title="我到底是在退课，退课，还是退课 😵 —— 删课 vs 退选 vs 退课">

在预选、正选/补退选、退课三个不同的阶段，都有类似“退课”的操作。其实我也不知道这三个阶段中的“退课”分别应当叫做什么，而在实际交谈中，同学们可能会把这三种“退课”混为一谈。

在预选阶段，删除一门课是不会有任何负面影响的，选一门课再删掉和从来没选过完全一样，删掉再选和不删也完全一样（当然，你会需要多操作两次，而且别人看到的志愿填报情况可能会不一样）。

在正选/补退选阶段，如果退选一门课，空出来的位置就随时可能被他人抢走，但成绩单上不会有 “W”。

在退课阶段退课，就是真正的退课了，没有再选课的机会，并且成绩单上也会有一个 “W”。

</Card>

## 课程信息与选课操作 —— 怎么找不到要选的课？怎么知道课在哪上呢？

### 切换学期

选课系统的左上角会有一个学期，选课前需要先确认没有选错学期。

### 查看课程信息

在选课系统的 开课信息 → 一级课开课信息 中可以找到当前学期所有课程的信息，可以在这搜索你想上的通识选修课有没有开课，查看课程简介、上课时间、选课要求，查看教师信息（包括邮箱）。

### 选课操作与课程属性

在 选课操作 → 一级选课 中，首先看到的会是当前学期的必修课。如果在必修课和限选课（以及体育课）中都没有看到想报的课，就要在任选课中手动搜索。

~~这不是废话吗~~ 但是，这里的课程属性可能和你想像中不一样，因为同一个课程在不同地方会有不同的属性：

-   在培养方案中会有课程属性，你认为的课程该有的属性很可能就是培养方案中的课程属性。
-   选课系统中的课程属性取决于当前学期的指导性教学计划，所以下学期的必修课很可能是当前学期的任选课。特别地，外语课总是任选课，大约是因为教学计划中虽然有外语课的位置，但每人要上的外语课具体是哪一门是不一样的。
-   info 上的成绩单以及培养方案完成情况中会另有一套课程属性，大致是限选课变成了必修，任选课变成了限选。

需要注意的是，决定志愿优先级的课程属性也是由教学计划决定的，这也是鼓励大家按教学计划选择必修课，如果错过了必修课在教学计划的学期，之后的志愿等级可能就是任选了。

### 教室位置查看

教室的位置在预选时是尚未安排好的，要在预选结果出来后才能在课表等位置看到教室在哪。

在 [courseX](https://tsinghua.app/courses) 上可以看到他人分享的教室位置信息，但不一定全。这些信息主要是 [learnX](https://tsinghua.app/learnX) 在用户主动同意后自动收集的，learnX 是对 [网络学堂](https://learn.tsinghua.edu.cn) 非常好的补充，推荐使用，也希望大家能在设置中开启课程信息共享。

### 关于上课时间

上课时间一般会以大节编号和周数的形式呈现，例如 \`1-1(全周),3-4(全周)\` 表示每周一第一大节和每周三第四大节上课，\`4-6(前八周)\` 表示前八周周四第六大节上课。

每大节的具体时间可以在课表中查看。一大节一般是两小节课各 45min 中间有 5min 休息，但第二大节和第六大节都有三小节，有的课会上满三小节，而有的课会只上两小节，而这一般可以通过课程的学分看出来，每一学分对应全周的一小节课，也就是八周的两小节课。如果一个 4 学分的课在全周的一个第二大节和一个第三大节上，那很有可能就是第二大节只上两小节。特别地，思想道德与法治、中国近现代史纲要、马克思主义基本原理等课程会比学时对应的学分多一分，这三节课分别是 3、3、4 学分，但分别对应全周上 2、2、3 小节。

## 体育课 —— 为什么 26 分的限制 TA 可以报 28 分还不用申请特批学分？

体育课在选课中有一些特殊之处：

1.  体育课是不占用学分限制的
2.  体育课在选课时具有单独的课程属性，算在必限任之外（这也是有人找不到或者忘记报体育课的一大原因）
3.  体育课虽然只能上一门，但预选时可以报很多门，等级高的志愿优先选上，等级低的志愿就会自动取消
4.  如果体育课挂科了，重修选课时会有特殊的流程，详见“选课时间安排”

正因为前三点，可以多报几门体育课，提高选上想上的课的概率，既不会占用学分限制也不会浪费一二志愿。
`},{title:F,tags:"caddy-security uptime-kuma caddy server 问题解决记录",content:`[Caddy Security](https://authp.github.io/) 不仅会将未经认证的访问者拒之门外，也会拦住 [~~可爱的 kuma 酱~~ Uptime Kuma](https://uptime.kuma.pet/)。这里会分享一下我的一个放过 kuma 的小技巧。



~~（P.S. 这是不是应该算“经验分享”而不是“问题解决记录”，这两个 tag 的分界线到底在哪呢）~~

## 问题描述

[Caddy Security](https://authp.github.io/) 可以为 [Caddy](https://caddyserver.com/) 上的路由提供身份认证，而这一认证发生在连接到服务之前，所以如果不通过认证就无法通过网络访问来获知服务是否正常运行，进而影响到 [Uptime Kuma](https://uptime.kuma.pet/) 的运作。

## 初步解决方案，以及存在的问题

一个自然的想法是，可以关闭一些非敏感路由的身份认证，用于 uptime 监控。比如说，一个服务的首页可能是非敏感可以公开的，敏感信息都位于其它路由，则可以：

\`\`\`caddyfile
example.com {
    handle / {
        reverse_proxy localhost:2333
    }
    authenticate with some-auth-policy
    reverse_proxy localhost:2333
}
\`\`\`

这看起来很好，但问题在于，一个网页往往不只是这个路径本身，还有 js、css 等资源需要使用。Caddy Security 只会在访问需要认证的网页时进行认证，而不会在加载需要认证的资源时进行认证。如果访问一个无需认证的网页，但其使用的资源需要认证，这些资源就可能加载不出来。

将这些资源全部列出来会很麻烦，如果处理不当也有泄露敏感信息的风险。

## 解决方案: 给 kuma 一个单独的路由

上面的方案的问题只对人类访问者有影响，而解决了 kuma 的问题。所以可以使用同样的思路，但只影响 kuma 而不影响访问者：

\`\`\`caddyfile
example.com {
    handle /for_uptime_kuma {
        uri replace /for_uptime_kuma /
        reverse_proxy localhost:2333
    }
    authenticate with some-auth-policy
    reverse_proxy localhost:2333
}
\`\`\`

然后在 Uptime Kuma 中把监控网址设成 \`https://example.com/for_uptime_kuma\` 即可。

如果在多个路由都用到这个操作，每次重复会比较繁琐，可以使用 [Caddy 的 snippet 功能](https://caddyserver.com/docs/caddyfile/concepts#snippets)：

\`\`\`caddyfile
(kuma) {
    handle /for_uptime_kuma {
        uri replace /for_uptime_kuma {args.1}
        reverse_proxy localhost:{args.0}
    }
}

homepage-public.example.com {
    import kuma 2333 /
    authenticate with some-auth-policy
    reverse_proxy localhost:2333
}

public-public.example.com {
    import kuma 6666 /public
    authenticate with some-auth-policy
    reverse_proxy localhost:6666
}
\`\`\`

## 另一种解决方案: 使用非网页资源进行监控

既然遇到的问题是网页会需要资源，只放开网页的认证会加载不出资源，另一个思路就是监控资源而非网页（不一定是 js、css 这些，也可以是可以公开的 API，或者几乎不会被访问或访问时一定已经认证了的网页之类的）。这比较简单，就不多讲了。
`},{title:h,tags:"busuanzi live2d JavaScript Web 问题解决记录",content:`昨天在一位网友的 Hexo 博客遇到了很诡异的 busuanzi 访问量统计不显示问题，经过一番研究发现是 busuanzi 代码的一处问题和 live2d 插件的一处问题凑在一起导致的。

今天在写博客之前先搜了一下 “busuanzi live2d”，发现搜出来一堆结果，我还以为我白研究了..结果点进去一看，第一页结果里没有一个指出了问题的根本原因，而且修复方法基本上都是删 feature 或者换组件，但实际上只要知道问题的根本原因就可以在不妨碍正常功能运作的前提下进行修复。所以昨天晚上没白忙活，我这篇博客还是要写的。



当然，我只看了第一页搜索结果，可能有更深入研究的文章被搜索引擎埋没了，我这篇文章说不定也不会被搜到，只不过既然第一页没有，就让我也来成为被搜索引擎埋没的一员，这样的话说不定被搜到的可能性就增加了（

## 问题描述

在一个同时启用了 busuanzi 访问量统计和 live2d 插件的 Hexo 博客里，访问或刷新博客时有大概率 busuanzi 会被隐藏。

被隐藏的具体表现为，刷新的瞬间 id 为 \`busuanzi_container_*\` 的容器是显示的，然后容器的样式很快被设为 \`display: none\`。

查看 F12 的 Network，busuanzi 相关请求正常返回；console 中没有报错。

## 问题定位

注：这个过程中我也走了一些弯路，就不写出来了。

### 设置 \`display: none\` 的定位

查看 [busuanzi.pure.mini.js](https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js)，发现 \`display: none\` 在 \`hides\` 函数中被设置：

\`\`\`javascript
hides: function() {
  this.bszs.map(function(a) {
    var b = document.getElementById("busuanzi_container_" + a);
    b && (b.style.display = "none")
  })
},
\`\`\`

而 hides 函数仅在一处被调用：

\`\`\`javascript
try {
  a(b), scriptTag.parentElement.removeChild(scriptTag)
} catch (c) {
  bszTag.hides()
}
\`\`\`

所以是在 \`a(b), scriptTag.parentElement.removeChild(scriptTag)\` 抛出异常时容器被隐藏。

### 异常原因的定位

由于在其它地方的 busuanzi 不会出现这一问题，而问题的原因还完全不清楚，为了尽可能还原原始环境以复现问题，我选择了使用 [Firefox 的 Header Editor 插件](https://addons.mozilla.org/zh-CN/firefox/addon/header-editor/) 直接在原博客进行测试。具体来说，就是在本地复制一份 busuanzi 的代码，然后跑一个 http server，在 Header Editor 里把 busuanzi 代码的请求重定向到本地的 http server。

首先，在 \`catch\` 中添加 \`console.error(c)\`，得到错误内容 \`TypeError: scriptTag.parentElement is null\`。

查看代码中 \`scriptTag\` 相关的部分：

\`\`\`javascript
scriptTag = document.createElement("SCRIPT"), scriptTag.type = "text/javascript", scriptTag.defer = !0, scriptTag.src = a, scriptTag.referrerPolicy = "no-referrer-when-downgrade", document.getElementsByTagName("HEAD")[0].appendChild(scriptTag)
\`\`\`

所以，再在 \`catch\` 中添加 \`s = document.querySelector("[src*=BusuanziCallback]"); console.log(s.parentElement);\`，发现 \`s.parentElement\` 不是 \`null\`。

再添加 \`console.log(s === scriptTag)\`，发现结果是 \`s\` 和 \`scriptTag\` 不同，所以原因在于此时的 \`scriptTag\` 变量已经不指向 DOM 中的这个元素了。

### 定位到 live2d 插件

此时我原本是没有任何头绪的，但我发现，并不是每次刷新页面都会触发这一问题，所以没有触发问题时和触发问题时的差别就成了问题的突破口。

经过多次刷新，我发现，有一串 console 输出，在出现问题时总位于我在 \`catch\` 中添加的调试信息之前，而在没出现问题时则位于调试信息之后：

\`\`\`
Live2D 2.1.00_1 live2d.core.js:5925:16
profile : Desktop live2d.core.js:5913:16
  [PROFILE_NAME] = Desktop live2d.core.js:5918:20
  [USE_ADJUST_TRANSLATION] = false live2d.core.js:5918:20
  [USE_CACHED_POLYGON_IMAGE] = false live2d.core.js:5918:20
  [EXPAND_W] = 2
\`\`\`

多亏了 live2d 的这串输出，我得以将问题定位到 live2d 插件上。

实际上，如果没有这些 console 输出，也可以通过 \`<head>\` 中 \`L2Dwidget.0.min.js\` 和 \`busuanzi?jsonpCallback=BusuanziCallback\` 两个 \`<script>\` 的相对位置发现问题，只不过这样的话就更隐蔽更难发现了。

### 在 live2d 插件中定位问题

在 \`L2Dwidget.min.js\` 的第一行有源码地址以及时间：\`/*! https://github.com/xiazeyu/live2d-widget.js built@2019-4-6 09:38:17 */\`

因为注释中给出的时间不是最新版本，先查看 git log 并 checkout 到相应时间的版本。

既然问题在于 \`<script>\` 元素被重新创建而导致原变量不指向 DOM 中元素，就在代码中 grep \`head\`，然后发现 [问题代码](https://github.com/xiazeyu/live2d-widget.js/blob/fa8f2d831a1a9e96cd85bd1ef593a3336aeac720/src/dialog/index.js#L4-L38)：\`document.head.innerHTML += ……\`

至此，问题原因已发现，就是 live2d 插件通过修改 \`document.head.innerHTML\` 来添加样式，导致 busuanzi 的 \`scriptTag\` 变量指向的不再是 DOM 中的 \`<script>\` 元素。

实际上，live2d 插件的这一问题 [已经修复](https://github.com/xiazeyu/live2d-widget.js/pull/61)，但需要使用新版才行。

## 解决方法

### 修改 busuanzi 的解决方法

因为 busuanzi 的代码较短，而且本来就是用的外部的代码，改起来比较容易。

把 \`scriptTag.parentElement.removeChild(scriptTag)\` 修改为 \`s=document.querySelector('[src*=BusuanziCallback]'),s.parentElement.removeChild(s)\` 即可。可以把修改后的静态文件放在博客里，然后修改 busuanzi \`<script>\` 的 \`src\`。

<Card title="相关代码" fold>

修改后的 busuanzi 代码（还在 \`catch\` 里加了个 \`console.error\`）：

\`\`\`javascript
var bszCaller,bszTag;!function(){var c,d,e,a=!1,b=[];ready=function(c){return a||"interactive"===document.readyState||"complete"===document.readyState?c.call(document):b.push(function(){return c.call(this)}),this},d=function(){for(var a=0,c=b.length;c>a;a++)b[a].apply(document);b=[]},e=function(){a||(a=!0,d.call(window),document.removeEventListener?document.removeEventListener("DOMContentLoaded",e,!1):document.attachEvent&&(document.detachEvent("onreadystatechange",e),window==window.top&&(clearInterval(c),c=null)))},document.addEventListener?document.addEventListener("DOMContentLoaded",e,!1):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){/loaded|complete/.test(document.readyState)&&e()}),window==window.top&&(c=setInterval(function(){try{a||document.documentElement.doScroll("left")}catch(b){return}e()},5)))}(),bszCaller={fetch:function(a,b){var c="BusuanziCallback_"+Math.floor(1099511627776*Math.random());window[c]=this.evalCall(b),a=a.replace("=BusuanziCallback","="+c),scriptTag=document.createElement("SCRIPT"),scriptTag.type="text/javascript",scriptTag.defer=!0,scriptTag.src=a,scriptTag.referrerPolicy="no-referrer-when-downgrade",document.getElementsByTagName("HEAD")[0].appendChild(scriptTag)},evalCall:function(a){return function(b){ready(function(){try{a(b),s=document.querySelector('[src*=BusuanziCallback]'),s.parentElement.removeChild(s)}catch(c){console.error(c),bszTag.hides()}})}}},bszCaller.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback",function(a){bszTag.texts(a),bszTag.shows()}),bszTag={bszs:["site_pv","page_pv","site_uv"],texts:function(a){this.bszs.map(function(b){var c=document.getElementById("busuanzi_value_"+b);c&&(c.innerHTML=a[b])})},hides:function(){this.bszs.map(function(a){var b=document.getElementById("busuanzi_container_"+a);b&&(b.style.display="none")})},shows:function(){this.bszs.map(function(a){var b=document.getElementById("busuanzi_container_"+a);b&&(b.style.display="inline")})}};
\`\`\`

然后将

\`\`\`html
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"><\/script>
\`\`\`

修改为（如果上面的代码放在了博客的 \`/js/busuanzi.pure.mini.js\`）

\`\`\`html
<script async src="/js/busuanzi.pure.mini.js"><\/script>
\`\`\`

</Card>

网上搜到的很多解决办法是把 \`id="busuanzi_container_*"\` 删掉，这样当然就不会被隐藏了，只不过这个隐藏本意是在出错时不把错误或者无意义的内容显示给访客，保留这一行为还是挺好的。

### 修改 live2d 的解决方法

总之，就是把 \`innerHTML +=\` 换成 \`createElement\` 和 \`appendChild\`，按 [xiazeyu/live2d-widget.js#61](https://github.com/xiazeyu/live2d-widget.js/pull/61/files#diff-61426849230d9976d234f7c4ca195c623d9bb05a91d76b7ae51501e394f81860L10-R43) 改就行。

live2d 的代码还是挺长的，直接修改 minify 后的代码不太好。如果是 hexo 插件的话，要修改应该也蛮麻烦的。总之，如果你知道怎么改比较好的话可以改，不然的话还是推荐改 busuanzi。

## 问题启示

### 不要修改原 DOM 中的 innerHTML

直接修改 DOM 元素的 innerHTML 会让其中的元素都重新渲染（加载？创建？），不仅指向其中元素的变量会失效，也可能导致画面闪烁等问题（例如导致 live2d-widget 修复这一问题的不是 busuanzi 失效而是 [CSS 闪烁](https://github.com/EYHN/hexo-helper-live2d/issues/149)）。

所以，如果是添加 DOM 元素，应当避免修改 \`innerHTML\`，而应当使用 [\`document.createElement\`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) 和 [\`Node.appendChild()\`](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild) 以及 \`removeChild\`、\`replaceChild\`、\`insertBefore\` 等 API。

### 不要依赖于指向 DOM 元素的变量长时间不改变

如果 DOM 因各种原因部分重建，指向 DOM 元素的变量很可能不再指向当前 DOM 中的元素。所以，最好不要在过了一段时间后（例如在 callback 中）再次使用指向 DOM 元素的变量，而应当再次获取这一元素。

### 不要 silently fail

在处理异常，尤其是未知的异常时，即使不 throw 出去，也最好用 \`console.error\` 等方法记录下来。记录在 console 中的错误信息并不会显示给普通用户，但可以给寻找问题所在的用户提供宝贵的提示信息。

### 使用 Header Editor 在对原环境最小修改的情况下进行调试

这次使用 Header Editor 调试还是我临时想到的（~~知道有这么个插件还是以前用 [mahjong-helper](https://github.com/EndlessCheng/mahjong-helper)，当然现在已经没在用了~~）。一开始还用 pastebin 上传代码，效率极低，后来才想起来本地跑个 http server 就可以了..用这个插件来调试还是挺方便的。

### 留心依赖版本

一开始我还在 GitHub 上搜到一个 [busuanzi.pure.js](https://github.com/JoeyBling/busuanzi.pure.js)，调了一会儿才发现这个代码和 https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js 不一样..

live2d 的版本也要注意开头包含时间的注释，因为最新版本已经把问题修复了。
`},{title:b,tags:"Rust 学习记录",content:`早就想学 Rust 了，但一直咕着。这次小学期的程设训练开了 Rust 课堂，就毫不犹豫地选了，也以此为契机学了 Rust。

这篇就是简单记录一下大体上的学习过程，如果有什么心得体会、经验分享之类应该会开新的文章。

顺便也算是程设训练的游记了（“游记”这个词来源于 OI 时期的习惯）。



## 初学 —— The Rust Programming Language

不同于 Python、JavaScript，这次学 Rust 更像是当初学 C++，不是先魔改代码、用啥搜啥、StackOverflow，而是在还没怎么接触过时就直接看书。

虽然没有细看中文翻译的质量如何，但至少术语是不好翻译的，就直接看了英文版的 [The Rust Programming Language](https://doc.rust-lang.org/book/)。

这本书看下来给我的感觉是，很多地方没有按知识点依赖关系的拓扑排序来讲，而似乎是以某种由浅入深的顺序来的，很多后面才学到的概念在前文就出现，而前面学的概念的完全不需要后面知识的扩展又在后面才补充，还有一些零碎的知识是在 project chapter 讲的。

反正，每天看两三章，~~还能有不少时间摸鱼，摸个~~ 一两周就看得差不多了（

## 初步练习 —— 洛谷

看书的同时在 [洛谷](https://www.luogu.com.cn/) 上随便挑了点入门题和板子题写。只不过一开始没学 io 之类的，会再多语法也做不动题，~~但幸好有 GitHub Copilot~~。

在这放个读入的例子：

\`\`\`
6 0
1 1 4 5 1 4
\`\`\`

\`\`\`rust
fn main() {
    let stdin = std::io::stdin();
    let mut input = String::new();

    stdin.read_line(&mut input).unwrap();
    let mut parts = input.split_whitespace();
    let n = parts.next().unwrap().parse::<u32>().unwrap();
    assert_eq!(n, 6);
    let m = parts.next().unwrap().parse::<u32>().unwrap();
    assert_eq!(m, 0);

    input.clear();
    stdin.read_line(&mut input).unwrap();
    let a = input
        .split_whitespace()
        .map(|x| x.parse::<i32>().unwrap())
        .collect::<Vec<_>>();
    assert_eq!(a, vec![1, 1, 4, 5, 1, 4]);
}
\`\`\`

## 复习 —— A half-hour to learn Rust

之前在 Hacker News 上看到了 [A half-hour to learn Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust) 这篇文章。如果真的是看这个东西来学 Rust，不说能不能学会，肯定是学不扎实的。但是，看完书之后很多语法也忘了，看这个用来复习还是非常不错的。（另外，我感觉这个的顺序貌似比书更有条理一些，虽然初学不一定友好 🤔）

## 深入了解 —— The Rust Standard Library

其实看书的时候就感觉到了，很多时候不懂一段代码不是不懂语法，而是不懂 [标准库](https://doc.rust-lang.org/stable/std/) 的实现，而把 API 理解成了没学过的语法。了解标准库，不仅是提升编码和运行的效率，也是能够看懂很多基础代码的关键。

看文档的时候发现，不仅是学到了很多有用的 methods，也学到了很多其它东西。比如说：

-   一般来说都可以用 [\`std::cmp::max\`](https://doc.rust-lang.org/stable/std/cmp/fn.max.html) 来取 max，但 [\`f32\` 专门有一个 \`pub fn max(self, other: f32) -> f32\`](https://doc.rust-lang.org/stable/std/primitive.f32.html#method.max)，这是因为浮点数有 NaN 这个特殊情况导致 \`f32\` 没有 impl [\`Ord\`](https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html)，而 \`std::cmp::max\` 需要 \`Ord\`
-   书里貌似没讲到的 [keyword \`ref\`](https://doc.rust-lang.org/stable/std/keyword.ref.html)（以及在 pattern matching 中和 \`&\` 的区别）
-   引用之间进行比较时会自动转成指向的值，即实际进行比较的是指向的值（可以通过 [\`std::ptr::eq\`](https://doc.rust-lang.org/stable/std/ptr/fn.eq.html) 来比较地址）
-   从标准库的 API 设计能领会到很多 trait 和 generic 的用法，体会到它们组合在一起的强大
-   [\`Iterator\` 自动有 \`IntoIterator\`](https://doc.rust-lang.org/std/iter/index.html#for-loops-and-intoiterator)，所以用 \`IntoIterator\` 代替 \`Iterator\` 作为 trait bound 可以让函数更灵活
-   ……

简单看一看就能知道 the book 里涉及到的真的只是冰山一角，学 Rust 标准库的意义会比学 C++ 的 STL 大得多（个人感觉）（也可能是我 C++ 水平太低 / 没认真学 STL 😢）（或者 Primer Plus 讲的全一些）。

## 上课

### Class 1

因为自学过了，所以上课就基本上是把老师的声音当作 bgm 偶尔听一下，然后继续看标准库文档（

上课的时候老师提到 Rust 编译器可以提示如何修改，于是我顺势在课程群里发了个 [rust 程序员现状](https://twitter.com/st1page/status/1477168761744805891) 的截图（

![rust程序员现状](rust-programmers-be-like.jpg)

课后把 OJ 上的作业速通后发现榜不是公开的 😢

后来还发现自己一道题写了个 \`collect\` 得到的 \`Vec\` 只用在一个 \`for\` 里（就是说可以直接把迭代器用在 \`for\` 不用先 \`collect\`）😵 想改过来，但虽然没有公开榜，还是不想承受可能的罚时（

### Class 2

第二节课前后共一天多的时间，写了 16h 左右，把 Wordle 大作业的基础功能写完了。（~~本来以为 Wordle 挺好写的，没想到需求这么多，需求文档模糊不清的地方还有的要问有的要自己设计。~~）

感觉课上讲的又快，大作业需要的知识又没讲全，很难想象如果不自学该怎么应对这个课（

### Class 3

修了一些文档说明不清导致的 bug，然后研究了一下扩展功能怎么写。

不知道为什么把单词按信息熵排序写了半天，明明挺简单的。可能是听着老师讲课没法专心想算法。

后来试着用 [rayon](https://docs.rs/rayon/latest/rayon/) 把信息熵计算并行化了，在我本机除了第一次猜测基本上都能秒出结果，感觉很爽 ~~，甚至玩了半天意义不明的照着提示输入~~。

再后来发现用 release 模式编译的优化比并行还大 🌚

### 第一次大作业验收

验收在 THUWC 去过的东主楼，但上大学后还是第一次去，结果走错了，迟到了 5min 😵 然后非常慌张地展示提高功能，都没太演示全，~~感觉白写了~~（

### Class 4~8

略（

### 第二次大作业验收

这次真的有比 pretests 强很多的 system test 了，还好没 FST（助教：这个点你为什么能过啊（x

可能是因为这个课不是学前端的，而且助教只简单看了一下界面演示没看代码，槽点很多的前端被夸了很科学（

可能是因为这个课不是学数据库的，而且听说有其他同学数据库里全是 JSON，普普通通的建表被夸了很科学（

### 关于课上的一些翻译

为什么什么都要翻译出来啊（虽然如果英语母语的话看原文应该也很尬 🤣

![trait: 特型；panic: 恐慌；poisoned: 中毒；crate: 箱；library crate: 库箱](rust-translations.jpg)

### 大作业代码

听说可以把代码公开 ~~加速熔断~~，这就放上来（

https://github.com/ouuan/course-assignments/tree/master/rust

## Async Rust

先是看了 [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/)，感觉看得一知半解的（尤其是 \`Pin\`），好像大概知道 \`Future\` 在干什么又不完全知道（~~而且这本书好咕啊，\`TODO\` 的章节应该是有生之年了~~

没看完 async book，直接去看 [Tokio Tutorial](https://tokio.rs/tokio/tutorial) 和 [Async programming in Rust with async-std](https://book.async.rs/) 了。作为 async runtime 的教程，它们涉及到的具体原理和实现少一些，更注重怎么实际使用，读起来会容易理解一些。因为 Tokio 更 popular，主要看的是 Tokio 的教程。

## 数据库: Diesel

感觉 [diesel 的教程](https://diesel.rs/guides/) 写的挺简略的，但对着 examples 硬查文档也勉强能看懂基本用法。ORM 看着就很“安全”，只不过实在是太类型体操了，不仅文档查起来有点小麻烦，代码复用也经常因为繁琐的 trait bounds 写不太动（也可能是我没学会）。

[diesel-derive-enum](https://crates.io/crates/diesel-derive-enum) 是好用的。

Sqlite 的 \`RETURNING\` 语句需要启用 \`returning_clauses_for_sqlite_3_35\` feature flag（并且需要至少 3.35 版本的 Sqlite）。没启用的时候对着一堆 trait bound 不满足的错误信息（就和 C++ 模板感觉差不多了..）根本发现不了错误原因，还是翻文档翻半天发现的。

还遇到一个 Sqlite 锁死的坑，通过 [使用 r2d2 设定 \`busy_timeout\`](https://stackoverflow.com/a/57717533) 并 [使用 WAL mode 以及 immediate transaction](https://github.com/the-lean-crate/criner/issues/1) （hopefully）解决了。
`},{title:f,tags:t,content:`[CS:APP](https://csapp.cs.cmu.edu/) 第二章 “Representing and Manipulating Information” 的学习笔记。

这章的主要内容为 byte、整数和浮点数的存储及计算。



## Information Storage

byte 而非 bit 是 memory 的基本单位，memory 可以看作 array of bytes。

一个 byte 常用两个十六进制数码表示。

word size 表示 virtual memory 的位数（大小），所以也是指针的位数。在 C 语言中，word size 也会影响到整型的大小。

### Byte Ordering

很多时候，单个数据需要用多个 byte 表示，于是就有两种可能的 byte ordering: big endian 和 little endian。

如果把每个 byte 看作一个“数位”，而把由多个 byte 组成的单个数据看作一个“256 进制数”，那么 big endian 就是从高位开始“书写”，little endian 就是从低位开始“书写”。也就是说，big endian 看上去是更加符合人类的“书写习惯”的，而 little endian 则像是把 1234 写成 4321。但是，little endian 会把低位存在低地址，从这个角度来说又更加“自然”一些。

由于 byte 是 memory 的基本单位，endian 影响的是 byte 的排列顺序，而不是 bit 的排列顺序。如果把一串 byte 分别用 big endian 和 little endian 写出来，例如 big endian \`0x1234\`，little endian \`0x3412\`，可能会感觉 endian 不影响“byte 内部的顺序”很奇怪，但其实 \`0x12\` 和 \`0x34\` 只是 byte 的一种表示方式，并不代表“byte 内部的顺序”。上面说“把由多个 byte 组成的单个数据看作一个‘256 进制数’”，也是考虑到 10 进制数的“反过来写”是为人熟知的，这样的话用“256 进制数”来作类比会比较好理解且不容易误解。

一般来说，byte ordering 对于程序员来说是无关紧要的。但是，如果要将数据与外界分享（例如通过网络传输），或者需要查看原始的 byte array（在 machine-level program 中），或者需要通过类型转换、union 等方式绕开 C 语言的类型系统，则 byte ordering 会非常重要。

字符串的表示是不受 byte ordering 影响的。

### 位运算

主要是左移、右移，其它是熟知的。

左移时高位会被丢弃，低位会填充零。

右移则有两种: 逻辑右移和算术右移。两者都是丢弃低位，但逻辑右移是高位填零，算术右移是高位填原来最高位的值。

在 C 语言中，unsigned integer 一定是逻辑右移，而 signed integer 则一般是算术右移。

算术右移的行为是为了在使用补码表示负数时得到正确的结果。

在位移过大（超过 word size）时，行为是不确定的，但一般会将位移对 word size 取模。

## Integer Representations

### 整型编码

unsigned integer 的编码就是普通的二进制。

signed integer 一般采用补码 (two’s-complement encoding)，即在 word size 为 $w$ 时最高位表示 $-2^{w-1}$ 而非 $2^{w-1}$。也就是说，最高位为 0 表示非负，为 1 表示负数；在最高位为 0 时和 unsigned integer 是一致的，而在最高位为 1 时是同样编码的 unsigned integer 减去 $2^w$。

### signed unsigned 转换

在 C 语言中，在同样长度的 signed 和 unsigned 之间转换时，虽然不一定，但一般是不改变编码地只进行类型的转换。

若算术运算符的两侧分别是 signed 和 unsigned，则会将 signed 隐式转换为 unsigned，这在运算符为比较运算符时尤其可能导致意外的结果，例如 \`-1 > 0u\`。

<Card type="warn">
由于 signed 与 unsigned 转换可能带来意外的结果，很多时候最好避免使用 unsigned integer。如果要将 signed 和 unsigned 放在同一个表达式中运算一般是会有 warning 的，如果要显式进行转换则要小心。
</Card>

### 整型增长

将某个长度的 unsigned integer 转换为更长的 unsigned integer 时，会在高位补零。

将某个长度的 signed integer 转换为更长的 signed integer 时，会在高位补原来的最高位，类似于 arithmetic right shift，以保证转换后数值不变。

如果一个类型转换既要增长又要转变 signed/unsigned，会先转换长度再转换 signed/unsigned。

### 整型缩短

无论是 signed 还是 unsigned，在缩短整型时会直接将高位截去。在新的整型长度为 $w$ 时，这相当于对 $2^w$ 取模。

## Integer Arithmetic

### 加法和取反

unsigned integer 的加法：模 $2^w$。

判断 unsigned integer 加法是否发生溢出：\`x + y\` 溢出当且仅当 \`x + y < x\`。

unsigned integer 取反：$x \\mapsto \\begin{cases} 0 & x = 0 \\\\ 2^w - x & x > 0 \\end{cases}$

取反有两种计算方式：

-   按位取反后加一；
-   或者找到二进制表示中最低位的 \`1\` 然后将比这一位高的位取反。

signed integer 的加法：把编码当作 unsigned integer 算，就可以实现 positive overflow 和 negative overflow 的效果，即 overflow 后保持模 $2^w$ 不变。

判断 signed integer 加法是否发生溢出：\`x + y\` positive overflow 当且仅当 \`x > 0 && y > 0 && x + y <= 0\`，negative overflow 当且仅当 \`x < 0 && y < 0 && x + y >= 0\`。

signed integer 取反: 把编码当作 unsigned integer 来取反即可，表现为，能表示的最小值取反得到自身，其它值取反就是其相反数。

<Card type="warn">
signed integer 取最小值时取反得到自身而非其相反数，这可能会是被忽视的 corner case 而导致 bug。
</Card>

### 乘法

无论 signed integer 还是 unsigned integer，乘法都是丢弃高位即模 $2^w$，且在编码上是等价的。

如果乘法运算中的某个因数是常数，编译器可能会把乘法优化为位移和加法的组合。是否以及如何进行优化取决于常数的值以及相关指令（加法、位移、乘法，可能还有 \`LEA\` 等指令）的相对速度，与具体机器密切相关。

### 除以 2 的幂

如果除法运算中除数是 2 的幂，编译器会将除法优化为右移。

### 总结

计算机的整数运算总的来说通过取模来处理溢出，而使用补码表示 signed integer 可以使 signed integer 和 unsigned integer 的运算在编码层面上的实现相同。

## Floating Point

### IEEE 浮点表示

浮点数大体上是一个二进制的科学计数法，形如 $(-1)^s \\times M \\times 2^E$。

IEEE 浮点表示的编码包含三部分：

1.  sign bit，表示 $s$
2.  exponent field，表示 $E$，下文中记其表示的 unsigned integer 为 $e$
3.  fraction field，表示 $M$，下文中记 fraction field 为 $f_{n-1} \\cdots f_1 f_0$

如果简单地使用普通整数的表示法来表示 $M$ 和 $E$，会遇到一些问题：

-   $E$ 需要能是负数，以用来表示比较小的数
-   若 $M = 0.f_{n-1} \\cdots f_1 f_0$，那么：
    -   $E$ 不同的编码可能表示同一个值，造成编码的浪费
    -   可能会出现 $E$ 更大但值更小的情况，会给比较两个数造成困难
-   不能表示 $\\pm \\infty$ 和 \`NaN\` 等特殊值

为了解决这些问题，IEEE 浮点表示采取了如下措施。

首先，浮点数被分为三类：normalized values, denormalized values 和 special values。

Normalized values:

-   一个浮点数是 normalized value，当且仅当其 exponent field 既不全零也不全一
-   $E = e - \\mathrm{Bias}$，其中 $\\mathrm{Bias}$ 是一个预先设置的常量
-   $M = 1.f_{n-1} \\cdots f_1 f_0$

Denormalized values:

-   一个浮点数是 denormalized value，当且仅当其 exponent field 全零
-   $E = 1 - \\mathrm{Bias}$
-   $M = 0.f_{n-1} \\cdots f_1 f_0$

Special values:

-   一个浮点数是 special value，当且仅当其 exponent field 全一
-   若 fraction field 全零，则根据 sign bit 表示 $\\pm \\infty$
-   若 fraction field 非全零，则表示 \`NaN\`

现在来看这套编码规则如何解决了上面提出的问题：

1.  设置 $\\mathrm{Bias}$，以表示小于零的 $E$
2.  将 normalized values 的 $M$ 的最高位钦定为 1，以避免不同 $E$ 表示同一个数。这和标准的十进制科学计数法要求小数在 $[1, 10)$ 的范围内是一个道理，在二进制科学计数法中就是要求小数在 $[1, 2)$ 的范围内。
3.  由于 $E$ 的取值范围有限，normalized values 的 $M$ 最高位强制为 1 使其无法表示 $0.0$ 以及接近 $0$ 的数（能够表示 $2^{-\\mathrm{Bias}}$ 和 $(1 + \\varepsilon) \\times 2^{-\\mathrm{Bias}}$，却无法表示位于 $[0, 2^{-\\mathrm{Bias}})$ 内的数），所以增设 denormalized values 这一分类用来表示接近 $0$ 的数以及 $\\pm 0.0$。由于 denormalized values 没有将 $M$ 的最高位设为 $1$，它的 $E$ 设置为 $1 - \\mathrm{Bias}$ 而非 $-\\mathrm{Bias}$ 作为补偿。
4.  通过 special values 的分类，表示了 $\\pm \\infty$ 以及 \`NaN\`。
5.  使用 exponent fields 按照 denormalized -> normalized -> special 的顺序进行分类，对于同一符号的浮点数，只需将 exponent field 和 fraction field 看作无符号整数即可比较大小（实际比较时，除了先比较符号位，可能还要考虑 $\\pm 0.0$、\`NaN\` 等特殊情况）。

IEEE 浮点表示还规定了每个 field 的长度：

-   32 位: exponent field 8 位，fraction field 23 位
-   64 位: exponent field 11 位，fraction field 52 位

记 exponent field 的位数为 $k$，则 $\\mathrm{Bias} = 2^{k-1} - 1$，即 32 位为 $127$，64 位为 $1023$。

### 特殊（标志性）的浮点数

exponent field 和 fraction field 全零表示 $\\pm 0.0$。

exponent field 全零，fraction field 最低位 1 其它位 0，是能够表示的最接近零的数（32 位约为 $1.4 \\times 10^{-45}$，64 位约为 $4.9 \\times 10^{-324}$）。（注意这个数的值为 $2^{2-2^k-n}$，和 $\\varepsilon = 2^{-n}$ 不同。）

exponent field 最高位 0 其它位 1（这得益于 $\\mathrm{Bias}$ 的设定），fraction field 全零，表示 $\\pm 1.0$。

exponent field 最低位 0 其它位 1，fraction field 全一，是能够表示（非 special value）的最大的数（32 位约为 $3.4 \\times 10^{38}$，64 位约为 $1.8 \\times 10^{308}$）。

### 浮点数舍入

浮点数的舍入有四种模式可供选择：

-   round-to-even: 类似于“四舍六入五成双”但是二进制，是默认的舍入模式
-   round-toward-zero
-   round-down
-   round-up

### 浮点数运算

除了一些特殊值（如 \`sqrt(-1.0)\`、\`1/0.0\`），浮点数的运算结果被定义为精确计算后进行舍入得到的结果，但具体计算的实现方式是随意的（不需要真的先精确计算再进行舍入）。

浮点数的加法和乘法会进行舍入、可能溢出，所以不满足结合律、分配律（但是满足交换律）。调换结合顺序可能改变计算结果，意味着编译器无法以改变结合顺序为代价进行优化。

### C 语言中浮点数类型转换

简单来说，整数转成浮点数或不同类型的浮点数之间进行转换可能舍入也可能溢出。浮点数转成整数会向零取整，溢出时行为不确定。
`},{title:y,tags:t,content:'[CS:APP](https://csapp.cs.cmu.edu/) 第三章 “Machine-Level Representation of Programs” 的学习笔记。\n\n这章的主要内容为汇编（machine-level programming）。\n\n\n\n近年来，随着编译器和高级语言的发展，手写汇编、机器码的需求越来越低，但阅读、理解编译器的输出在优化程序性能、避免安全漏洞等方面依然重要。\n\n## Program Encodings\n\n### 汇编/机器码中的程序状态\n\nx86-64 的程序状态包含：\n\n-   program counter，表示待执行的下一条指令的地址，用 `%rip` 表示\n-   [register file](#寄存器)，16 个用来存储整型的寄存器\n-   [status flags](#status-flags)，用来存储最近执行的运算的状态\n-   [vector registers](#ymm-寄存器)，用来存储多个整型或浮点数\n\n### 将 C 代码编译为汇编代码\n\n可以通过 `gcc -S` 生成汇编代码，通过 `gcc -Og` 来启用“以调试体验为目标的优化”（后文中叙述的很多编译行为都是需要一些基本的优化的，如果完全不启用任何优化，可能编译结果会有很大的差别；也就是说，完全不优化和过度优化都会降低汇编代码的可读性）。\n\n为了方便，可以用一条命令编译并不留文件地查看汇编代码: `gcc a.c -Og -S -o - | bat -l asm`。\n\n例如，下面的代码：\n\n```c\nlong mult2(long, long);\n\nvoid multstore(long x, long y, long *dest)\n{\n    long t = mult2(x, y);\n    *dest = t;\n}\n```\n\n编译为如下的汇编代码：\n\n```asm\n	.file	"a.c"\n	.text\n	.globl	multstore\n	.type	multstore, @function\nmultstore:\n.LFB0:\n	.cfi_startproc\n	pushq	%rbx\n	.cfi_def_cfa_offset 16\n	.cfi_offset 3, -16\n	movq	%rdx, %rbx\n	call	mult2@PLT\n	movq	%rax, (%rbx)\n	popq	%rbx\n	.cfi_def_cfa_offset 8\n	ret\n	.cfi_endproc\n.LFE0:\n	.size	multstore, .-multstore\n	.ident	"GCC: (GNU) 12.2.0"\n	.section	.note.GNU-stack,"",@progbits\n```\n\n### 反汇编与机器码\n\n可以通过 `objdump` 反汇编，例如 `gcc a.c -Og -c && objdump -d a.o` 得到：\n\n```asm\na.o：     文件格式 elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 <multstore>:\n   0:	53                   	push   %rbx\n   1:	48 89 d3             	mov    %rdx,%rbx\n   4:	e8 00 00 00 00       	call   9 <multstore+0x9>\n   9:	48 89 03             	mov    %rax,(%rbx)\n   c:	5b                   	pop    %rbx\n   d:	c3                   	ret\n```\n\n可以看出，机器码就是一串 bytes，若干个 bytes 合在一起表示一条指令。而每条指令对应的 bytes 数量不同，与 operands 个数以及指令的常用程度相关（类似摩斯电码、UTF-8）。\n\n<Card title="指令集的 reference；ATT 格式 vs Intel 格式">\nCS:APP 以及 gcc 默认使用的是 ATT 格式的汇编，可以在 [Instruction Set Mapping - Oracle x86 Assembly Language Reference Manual](https://docs.oracle.com/cd/E19253-01/817-5477/enmzx/index.html) 查看 ATT 格式汇编和实际指令之间的对应关系，在 [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)（下文中以 “Intel Manual” 指代）（主要是第 2 卷）查看具体指令的 reference。\n\nATT 格式与 Intel 格式有一些差别，其中在查看 reference 时需要注意的是，Intel 格式的指令没有 `b/w/l/q` 的类型后缀，并且 operands 的顺序和 ATT 格式恰好相反。\n\n</Card>\n\n## Data Formats\n\n由于历史原因，Intel 使用 “word” 表示 16 bits，而用 “double word” 表示 32 bits，用 “quad word” 表示 64 bits。\n\nC 语言类型在 x86-64 中的大小：\n\n| C 语言类型 |  Intel 数据类型  |  汇编后缀   | bytes |\n| :--------: | :--------------: | :---------: | :---: |\n|   `char`   |       byte       |     `b`     |   1   |\n|  `short`   |       word       |     `w`     |   2   |\n|   `int`    |   double word    | `l` (long)  |   4   |\n|   `long`   |    quad word     |     `q`     |   8   |\n|    指针    |    quad word     |     `q`     |   8   |\n|  `float`   | single precision | `s` (short) |   4   |\n|  `double`  | double precision | `l` (long)  |   8   |\n\n每种类型都有一个用在汇编指令中的后缀，表示 operand 的类型，例如 `movb`、`movw`、`movl`、`movq`。`l` 既用于 double word 也用于 double precision，但整数和浮点数涉及的指令不同，所以不会有歧义。（后文中 [Floating-Point Code](#floating-point-code) 用的 AVX2 指令并不使用 `s`/`l` 的浮点数类型后缀。）\n\n## Accessing Information\n\n### 寄存器\n\nx86-64 CPU 有 16 个 general-purpose register，可以用来存整数或指针：\n\n| quad word | double word |  word   |  byte   |     用途      |\n| :-------: | :---------: | :-----: | :-----: | :-----------: |\n|  `%rax`   |   `%eax`    |  `%ax`  |  `%al`  | return value  |\n|  `%rbx`   |   `%ebx`    |  `%bx`  |  `%bl`  | callee saved  |\n|  `%rcx`   |   `%ecx`    |  `%cx`  |  `%cl`  | 4th argument  |\n|  `%rdx`   |   `%edx`    |  `%dx`  |  `%dl`  | 3rd argument  |\n|  `%rsi`   |   `%esi`    |  `%si`  | `%sil`  | 2nd argument  |\n|  `%rdi`   |   `%edi`    |  `%di`  | `%dil`  | 1st argument  |\n|  `%rbp`   |   `%ebp`    |  `%bp`  | `%bpl`  | callee saved  |\n|  `%rsp`   |   `%esp`    |  `%sp`  | `%spl`  | stack pointer |\n|   `%r8`   |   `%r8d`    | `%r8w`  | `%r8b`  | 5th argument  |\n|   `%r9`   |   `%r9d`    | `%r9w`  | `%r9b`  | 6th argument  |\n|  `%r10`   |   `%r10d`   | `%r10w` | `%r10b` | caller saved  |\n|  `%r11`   |   `%r11d`   | `%r11w` | `%r11b` | caller saved  |\n|  `%r12`   |   `%r12d`   | `%r12w` | `%r12b` | callee saved  |\n|  `%r13`   |   `%r13d`   | `%r13w` | `%r13b` | callee saved  |\n|  `%r14`   |   `%r14d`   | `%r14w` | `%r14b` | callee saved  |\n|  `%r15`   |   `%r15d`   | `%r15w` | `%r15b` | callee saved  |\n\n每个 register 可以用四种不同的长度访问，其中短的是长的的低位。修改 byte 或 word 的值时高位不变，修改 double word 的值则会将高位清零。\n\n不同寄存器的用途将在后文说明（主要是在 [Procedures](#procedures) 这一节）。\n\n### Operand 格式\n\n指令的 operand 有三种指定方式：\n\n1.  Immediate，即字面值，代码为 `$Imm`，例如 `$123` 表示 123，`$0x123` 表示 0x123\n2.  Register，代码为寄存器的名称，例如 `%rax`\n3.  Memory，完整形态的代码为 `Imm(rb, ri, s)`，表示 `M[Imm + R[rb] + R[ri] * s]`（其中 `ri` 不为 `%rsp`，$s \\in \\{1, 2, 4, 8\\}$），例如 `2(%rax, %rbx, 4)` 表示 memory 中地址为 `2 + %rax + 4 * %rbx` 的值；`Imm`、`rb`、`, ri, s` 分别可以省略，例如 `Imm`、`(rb)`、`Imm(, ri, s)`；指定了 `ri` 时也可以省略 `s` 表示 `s` 为 1。\n\n在下文中，用 `imm32`、`r64`、`m16`、`r/m64` 等方式表示指令 operand 的类型。\n\n（在 ATT 格式中）有两个 operand 时，第一个是 source，第二个是 destination。\n\n### move 类指令\n\n虽然叫 “move”，但实际上是复制。\n\n#### MOV 指令\n\nsource 和 destination 类型相同。\n\n-   `movb imm/r8, r/m8`\n-   `movb m8, r8`\n-   `movw imm/r16, r/m16`\n-   `movw m16, r16`\n-   `movl imm/r32, r/m32`\n-   `movl m32, r32`\n-   `movq imm32/r64, r/m64`\n-   `movq m64, r64`\n-   `movabsq imm64, r64`\n\n其中，source 和 destination 不能同时是 memory。\n\n特别地，`movq` 不接受 imm64，复制时会在 imm32 的高位补符号位；`movabsq` 可以接受 imm64，但 destination 只能是寄存器。这样设计的原因可以参考 [assembly - why we can\'t move a 64-bit immediate value to memory? - Stack Overflow](https://stackoverflow.com/questions/62771323/why-we-cant-move-a-64-bit-immediate-value-to-memory)。实际上，支持 imm64 作为 operand 的指令是少数，后面还会看到很多不接受 imm64 的指令，一般都是高位补符号位。\n\n#### MOVZ 指令\n\n将高位补零后复制。\n\n-   `movzbw r/m8, r16`\n-   `movzbl r/m8, r32`\n-   `movzwl r/m16, r32`\n-   `movzbq r/m8, r64`\n-   `movzwq r/m16, r64`\n\n没有 `movzlq` 这条指令，因为将寄存器的值修改为一个 double word 时就会将高位清零，所以使用 `movl` 就可以了。\n\n<Card\n    type="question"\n    title="没用的 <code>movzbq</code> 和 <code>movzwq</code> 🤔？"\n>\n    虽然有 `movzbq` 和 `movzwq`，但一般会用 `movzbl` 和 `movzwl`\n    实现相应的功能。没搜到为什么会有这两条指令...\n</Card>\n\n#### MOVS 指令\n\n将高位补符号位后复制。\n\n-   `movsbw r/m8, r16`\n-   `movsbl r/m8, r32`\n-   `movsbq r/m8, r64`\n-   `movswl r/m16, r32`\n-   `movswq r/m16, r64`\n-   `movslq r/m32, r64`\n-   `cltq`: 和 `movslq %eax, %rax` 效果相同（但编码更短）\n\n### push/pop stack\n\n-   `pushq imm32/r/m64`: 将 `R[%rsp]` 减八，然后将 operand 复制到 `M[R[%rsp]]`（`PUSH` 指令不支持 imm64，会将 imm32 高位补符号位）\n-   `popq r/m64`: 将 `M[R[%rsp]]` 复制到 operand，然后将 `R[%rsp]` 加八\n\n可以看出，program stack 是 memory 中连续的一段，每个元素是一个 quad word，top 的地址比 bottom 低，push 时 stack pointer 减小。\n\n由于 stack 不过是由 `%rsp` 标记栈顶的一段 memory，可以通过给 `%rsp` 加上一个 offset 访问非栈顶元素，例如 `8(%rsp)` 为栈顶下面的第一个元素。\n\n<Card title="为什么 top 位于低地址？">\n    top 位于低地址可能看起来很怪，可以参考 [Why does the stack address grow\n    towards decreasing memory addresses? - Stack\n    Overflow](https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses)。简单来说，由于\n    memory layout 和 memory 曾经很小的历史原因，stack 和 heap\n    会往不同的方向增长，总会有一个在增长时减小地址，而 x86-64 选择了 push stack\n    时减小地址，这也使得访问非栈顶元素不需要给 offset 加负号。\n</Card>\n\n<Card title="<code>pushq</code>/<code>popq</code> vs 直接修改 <code>%rsp</code>">\n    除了 `pushq`/`popq`，也可以减小 `%rsp` 来向栈顶压入未初始化的数据，或者增大\n    `%rsp` 来释放栈空间，但这样做和 `pushq`/`popq`\n    相比哪个性能更好是比较复杂的，可以参考 [assembly - What C/C++ compiler can\n    use push pop instructions for creating local variables, instead of just\n    increasing esp once? - Stack\n    Overflow](https://stackoverflow.com/questions/49485395/what-c-c-compiler-can-use-push-pop-instructions-for-creating-local-variables)。\n</Card>\n\n## Arithmetic and Logical Operations\n\n### Load Effective Address\n\n`leaq m, r64`: 将 source operand 的地址复制到 destination operand（只计算 source operand 的地址，与其指向的 memory 中存储的值无关）\n\nLEA 可以用来优化一些简单的算术，例如：\n\n```c\nlong scale(long x, long y, long z)\n{\n    long t = x + 4 * y + 12 * z;\n    return t;\n}\n```\n\n```asm\nscale:\n	leaq	(%rdi,%rsi,4), %rax\n	leaq	(%rdx,%rdx,2), %rdx\n	leaq	(%rax,%rdx,4), %rax\n	ret\n```\n\n这里三个 LEA 分别计算了 $x + 4y$, $z + 2z$ 和 $(x + 4y) + 4 (z + 2z)$。\n\n### 一元运算\n\n每种一元运算都有 b/w/l/q 四个类型，接受一个相应类型的 r/m，将这个 operand 计算后的结果存入这个 operand：\n\n-   `INC`: 加一\n-   `DEC`: 减一\n-   `NEG`: 取反 (negate)\n-   `NOT`: 按位取反 (complement)\n\n### 二元运算\n\n每种二元运算都有 b/w/l/q 四个类型，接受相应类型的 imm/r/m 作为 source（除了 imm64），相应类型的 r/m 作为 destination（source 和 destination 不能同时为 memory），效果为将 source“作用于”destination，将运算结果存入 destination。\n\n-   `ADD`: 加\n-   `SUB`: destination 减去 source\n-   `IMUL`: 乘\n-   `XOR`: 按位异或\n-   `OR`: 按位或\n-   `AND`: 按位与\n\n特别地，类似 `xorl %rdx, %rdx` 的代码可以用来优化 `movl $0, %rdx`，参见 Practice Problem 3.11 以及 [performance - What is the best way to set a register to zero in x86 assembly: xor, mov or and? - Stack Overflow](https://stackoverflow.com/questions/33666617/what-is-the-best-way-to-set-a-register-to-zero-in-x86-assembly-xor-mov-or-and)。\n\n### 位移\n\n位移有 b/w/l/q 四个类型，source 只能是 imm8 或者 `%cl`，destination 是相应类型的 r/m。\n\n-   `SAL`/`SHL`: 左移\n-   `SAR`: 算术右移\n-   `SHR`: 逻辑右移\n\n<Card type="question" title="对过大位移位数的处理">\n    CS:APP 上说位移的位数会对 operand size 取模，但根据 Intel Manual\n    以及我自己实验的结果，应该是 b/w/l 对 32 取模，q 对 64 取模；errata\n    也没看到这一条，不知道是怎么回事。\n</Card>\n\n### 结果是 operand 两倍长度的运算\n\n128 位的整数叫做 oct word，需要存在两个寄存器中，在指令中一般高位放在 `R[%rdx]` 低位放在 `R[%rax]`。\n\n虽然截去高位时是否有符号对编码层面的乘法没有影响，不截去高位时就需要对 signed 和 unsigned 使用不同的指令了：\n\n-   `imulq r/m64`: 计算 operand 和 `R[%rax]` 作为 signed integer 相乘而不截去高位的结果，存在 `R[%rdx]:R[%rax]` 中。（如果有两个 operand 就是上面的 [二元运算](#二元运算) 了。）\n-   `mulq r/m64`: 计算 operand 和 `R[%rax]` 作为 unsigned integer 相乘而不截去高位的结果，存在 `R[%rdx]:R[%rax]` 中。\n\n除法以及取模：\n\n-   `cqto`/`cqtd`: 将 `R[%rax]` 高位填符号位放在 `R[%rdx]:R[%rax]`（也就是用 `R[%rax]` 的符号位填满 `R[%rdx]`）。\n-   `idivq`: 计算 `R[%rdx]:R[%rax]` 有符号地除以 operand，商放在 `R[%rax]`，余数放在 `R[%rdx]`。\n-   `divq`: 计算 `R[%rdx]:R[%rax]` 无符号地除以 operand，商放在 `R[%rax]`，余数放在 `R[%rdx]`。\n\n得到的商都是向 0 取整，所以被除数为负时余数非正。\n\n若商溢出了，则会触发 divide error 异常。所以被除数一般会是 64 位整数（在 `idivq` 之前用 `cqto` 来设置 `R[%rdx]`，在 `divq` 之前将 `R[%rdx]` 置为全零），否则很可能溢出而触发异常。\n\n这些运算也有 operand 为 32 位，结果为 64 位的版本：`imull`、`mull`、`cltd`、`idivl`、`divl`。它们以 `%edx` 和 `%eax` 来代替 128 位运算中的 `%rdx` 和 `%rax`。\n\n## Control\n\n<Card type="hint" title=\'<span class="mojikumi">“</span>status flag<span class="mojikumi">”</span> vs <span class="mojikumi">“</span>condition code<span class="mojikumi">”</span>\'>\n    在 CS:APP 中 `CF`/`ZF`/`SF`/`OF` 等被叫做 “condition code”；而在 Intel Manual\n    中，`CF`/`ZF`/`SF`/`OF` 等被叫做 “status flag”，“condition code” 指的是 status\n    flags 的组合。下文采用 Intel 的叫法。\n</Card>\n\n### Status Flags\n\nstatus flags 中存储了最近一次运算的状态，常用的 status flag 有四个：\n\n-   `CF`: Carry Flag，表示运算过程中发生了超出 operand 长度的进位或借位，即将运算视作 unsigned 发生了溢出。\n-   `ZF`: Zero Flag，表示运算结果为零。\n-   `SF`: Sign Flag，表示运算结果（看作补码）为负，即运算结果的符号位。\n-   `OF`: Overflow Flag，表示若将运算视作 signed 发生了溢出。\n\n<Card title="ARM 中的 carry flag —— carry flag vs borrow flag" fold>\n在 ARM 中，计算减法时，与 x86 相反，carry flag 为 0 表示溢出，为 1 表示没有溢出。\n\n这是因为，计算减法有两种方式，[subtract with borrow 和 subtract with carry](https://en.wikipedia.org/wiki/Carry_flag#Vs._borrow_flag)：\n\n-   subtract with borrow 相当于普通的减法竖式计算，计算过程中记录 borrow flag，最后存储在 carry flag 中，表现为若最后发生借位则 carry flag 为 1。\n-   subtract with carry 利用了 `-x = ~x + 1` 的性质，通过 `a + ~b + 1` 来计算 `a - b`，而和普通加法一样计算 carry flag；而在 subtract with borrow 最后发生借位时，subtract with carry 反而 carry flag 是 0。\n\n可以这么理解这两者间的差异：设计算是 $w$ 位的，最后计算完成时，borrow flag 表示第 $w+1$ 位上是 $-1$，carry flag 表示第 $w+1$ 位上是 $1$，而 subtract with carry 相当于先加上了 $2^w$ 再进行减法，就会将第 $w+1$ 位从 $-1$ 变成 $0$，从 $0$ 变成 $1$。\n</Card>\n\nLEA 不会改变 status flags。\n\n[一元运算](#一元运算) 和 [二元运算](#二元运算) 都会改变 status flags。特别地，`INC` 和 `DEC` 不会改变 `CF`。\n\n位移对 status flags 的影响比较复杂（可以参考 Intel Manual），简单来说 `CF` 会被设为最后一个移出的位，只有位移位数为 1 时才会改变 `OF`。\n\n### Condition Codes\n\ncondition code 是 status flags 的组合，常用的有：\n\n| condition code |               名称 (意义)                |        取值        |\n| :------------: | :--------------------------------------: | :----------------: |\n|    `e`/`z`     |               equal / zero               |        `ZF`        |\n|   `ne`/`nz`    |           not equal / not zero           |       `~ZF`        |\n|      `s`       |             sign (negative)              |        `SF`        |\n|      `ns`      |         not sign (non-negative)          |       `~SF`        |\n|   `g`/`nle`    |  greater / not less equal (signed $>$)   | `~(SF ^ OF) & ~ZF` |\n|   `ge`/`nl`    | greater equal / not less (signed $\\ge$)  |    `~(SF ^ OF)`    |\n|   `l`/`nge`    |  less / not greater equal (signed $<$)   |     `SF ^ OF`      |\n|   `le`/`ng`    | less equal / not greater (signed $\\le$)  | `(SF ^ OF) \\| ZF`  |\n|   `a`/`nbe`    |  above / not below equal (unsigned $>$)  |    `~CF & ~ZF`     |\n|   `ae`/`nb`    | above equal / not below (unsigned $\\ge$) |       `~CF`        |\n|   `b`/`nae`    |  below / not above equal (unsigned $<$)  |        `CF`        |\n|   `be`/`na`    | below equal / not above (unsigned $\\le$) |     `CF \\| ZF`     |\n\n这些 condition code 都是按照减法的结果来命名的，在使用 `CMP` 指令时这些名称是自然的，但如果不是 `CMP`/`SUB` 则要考虑进行的运算是什么以及每个 condition code 实际的取值。\n\n`l`/`nge` 可以理解为，溢出后会变号，所以 `SF ^ OF` 就是如果不溢出的符号；`b`/`nae` 是因为减法发生借位时会标记 `CF`。\n\n### CMP 和 TEST 指令\n\n如果真的进行运算，destination 的值会被覆盖，所以，如果计算结果是不需要的，一般会用 `CMP` 和 `TEST` 来获取 status flags。\n\n`CMP` 和 `TEST` 的 operands 和 [二元运算](#二元运算) 相同。\n\n`CMP` 相当于执行 `SUB` 但只更新 status flags 不更新 destination。常用于比较两个数的大小。\n\n<Card type="warn" title="CMP 的比较顺序">\n    由于 ATT 格式的汇编是 source 在前 destination 在后， `CMP` 的减法是\n    destination 减去 source， 所以比较是看起来是反的，例如 `l` 其实是第二个\n    operand 小于第一个 operand。\n</Card>\n\n`TEST` 相当于执行 `AND` 但只更新 status flags 不更新 destination。常见的用法有两种，一种是两个 operand 为同一个寄存器以判断其符号，另一种是 source 为 bit mask。\n\n### SETcc 指令\n\n`SETcc r/m8`: 将 `cc` 复制到 operand 处。其后缀不是 operand 的长度，而是 condition code，例如 `sete r/m8`、`setne r/m8`、`sets r/m8`...\n\n### Jump 类指令\n\n#### Label\n\n在汇编中 jump 通常会使用 label 作为 jump target，例如（CS:APP P205）：\n\n```asm\n    movq $0, %rax\n    jmp  .L1\n    movq (%rax), %rdx\n.L1:\n    popq %rdx\n```\n\n这里的 `.L1` 就是一个 label。\n\n#### 无条件跳转\n\n-   `jmp Label`: 跳转到 `Label` 处\n-   `jmp *r/m64`: 跳转到 operand 存储的 jump target 处，例如 `jmp *%rax`、`jmp *(%rax)`。\n\n#### 条件跳转\n\n`Jcc Label`: 如果满足 `cc`，则跳转到 `Label` 处。\n\n#### rep; ret\n\n如果 `ret` 会作为某个分支的第一条指令（即 jump 指令的下一条指令或 jump target），一般会把 `ret` 换成 `rep; ret`，效果和 `ret` 一样，但可以避免错误的分支预测，从而优化性能。具体可以参考 [repz ret - repz ret](https://repzret.org/p/repzret/)。\n\n#### jump 指令编码\n\n在进行汇编时，label 会被替换为 _jump 指令的**下一条**指令（其实就是 program counter 的值）到 jump target 的地址差_。而在链接时，虽然指令的地址变了，但指令之间相对的地址差不变，则 jump 指令不用改变。\n\n例如（CS:APP P207）：\n\n```asm\n    movq %rdi, %rax\n    jmp .L2\n.L3:\n    sarq %rax\n.L2:\n    testq %rax, %rax\n    jg .L3\n    rep; ret\n```\n\n汇编后：\n\n```asm\n   0:	48 89 f8             	mov    %rdi,%rax\n   3:	eb 03                	jmp    0x8\n   5:	48 d1 f8             	sar    %rax\n   8:	48 85 c0             	test   %rax,%rax\n   b:	7f f8                	jg     0x5\n   d:	f3 c3                	repz ret\n```\n\n这里 `jmp .L2` 的 operand 编码为 `0x03`，即其下一条指令的地址 `0x5` 到 jump target `0x8` 的距离；`jg .L3` 的 operand 编码为 `0xf8` 即 -8，也就是其下一条指令的地址 `0xd` 到 jump target `0x5` 的距离。\n\n链接后：\n\n```asm\n000000000000112e <foo>:\n    112e:       48 89 f8                mov    %rdi,%rax\n    1131:       eb 03                   jmp    1136 <foo+0x8>\n    1133:       48 d1 f8                sar    %rax\n    1136:       48 85 c0                test   %rax,%rax\n    1139:       7f f8                   jg     1133 <foo+0x5>\n    113b:       f3 c3                   repz ret\n```\n\n### CMOVcc 指令\n\n`CMOVcc` 可以在满足 `cc` 时将 source 复制到 destination。这条指令在 ATT 格式中没有长度类型后缀，通过 destination register 的长度来推断类型。不接受 byte 作为 operand。\n\n-   `CMOVcc r/m16, r16`\n-   `CMOVcc r/m32, r32`\n-   `CMOVcc r/m64, r64`\n\n### 实现 if-else 语句\n\n实现 if-else 语句主要有两种方式：\n\n1.  Conditional control: 即通过 jump 指令更改指令执行的顺序。\n2.  Conditional moves: 即通过 `CMOVcc` 等指令，根据条件决定是否执行这一条指令，但不改变指令执行的顺序。\n\n（具体实现方式可以参考 CS:APP 中的例子。）\n\nconditonal control 是通用的，但 conditonal moves 只在有限的情况下可以使用。一般来说，使用 conditional moves 时需要先将两个分支都算出来，然后根据条件来进行 move，所以要求分支中没有副作用。\n\nconditional moves 有时可以用来优化性能，主要是因为现代处理器的 _pipelining_，即在物理上同时执行多条指令（但在效果上和按顺序执行一致）。条件跳转使得处理器不能确定未来要执行哪些指令，而只能进行分支预测，如果预测失败 pipelining 就白费了。而 conditional move 不会破坏指令执行的顺序，也就不影响 pipelining，所以可以起到优化的效果。但是，conditional moves 除了要求分支无副作用，还需要两个 branch 都执行，所以如果分支过大，就不如 conditional control。\n\n### 实现循环语句\n\n`do while`: 跑完一段代码后进行测试，通过则跳转到开头。\n\n`while`: 在 `do while` 的基础上，要么在开头直接跳转到测试 (jump to middle)，要么在开头进行一次测试，不通过则跳到结尾 (guarded do)。\n\n`for`: 在 `while` 的基础上，开头初始化，测试前更新。\n\n### 实现 switch 语句\n\n具体例子可以参考 CS:APP，重点在于，如果 cases 的值不过于稀疏，可以建一个叫做 jump table 的数组，以 cases 的值作为下标，label 作为值，这样就可以用一次数组访问而非多次条件跳转来实现 `switch` 语句。jump table 也可以和条件跳转结合，以处理 default case 或者个别 cases。\n\n## Procedures\n\nprocedure 的实现主要涉及三个方面：\n\n-   在不同的 procedure 之间转移控制权，即调用 procedure 时交出控制权，procedure 返回时拿回控制权\n-   传递参数和返回值\n-   为局部变量分配/释放内存\n\n调用 procedure 的核心是在 [push/pop stack](#pushpop-stack) 一节中介绍过的 runtime stack。大体上来讲，stack 会分成一堆 frame，栈顶的 frame 为当前 procedure 的相关数据，从栈顶到栈底的各个 frame 依次放着调用链上的各个 procedure，在调用一个 procedure 时会将相关数据压入栈中，返回时再弹出。\n\n这部分会采取“简介-原则-实现”的结构，先简单介绍大概是什么样的，再说明实现需要遵循的原则，再说明具体实现，以及实现是如何满足以及利用原则的。\n\n### 转移控制权\n\n调用 procedure 时，会将当前 program counter 的值存在 stack 中，然后将 program counter 修改为 callee，在返回时再从 stack 中取出 caller 的地址设为 program counter。\n\n<Card type="hint" title="存放 caller 地址的原则">\n进入一个 procedure 时，栈顶放的是 caller 的地址（具体来说，是 `call` 指令的下一条指令的地址）。\n\n返回时，这个 caller 的地址会出栈，即返回后的 `%rsp` 是进入时的 `%rsp` 加 8。\n\n</Card>\n\n具体实现会使用 `CALL` 和 `RET` 两条指令：\n\n-   `call Label`\n-   `call *(r/m64)`\n-   `ret`\n\n其中 `call` 的 operand 和 `jmp` 是一样的，效果相当于先 `pushq %rip` 再 `jmp`。`ret` 则相当于把 `popq` 的结果作为 `jmp` 的 operand。\n\n### 传递参数\n\n寄存器中有 6 个用来存放 procedure 的 arguments，如果参数多于 6 个，则会放在 stack 中。\n\n| bits |   1    |   2    |   3    |   4    |   5    |   6    |\n| :--: | :----: | :----: | :----: | :----: | :----: | :----: |\n|  64  | `%rdi` | `%rsi` | `%rdx` | `%rcx` | `%r8`  | `%r9`  |\n|  32  | `%edi` | `%esi` | `%edx` | `%ecx` | `%r8d` | `%r9d` |\n|  16  | `%di`  | `%si`  | `%dx`  | `%cx`  | `%r8w` | `%r9w` |\n|  8   | `%dil` | `%sil` | `%dl`  | `%cl`  | `%r8b` | `%r9b` |\n\n<Card type="hint" title="存放参数的原则">\n    进入 procedure 时，前 6 个参数（如果有）会被放在相应的寄存器中；其余参数放在\n    stack 中，具体来说，第 $n$ 个参数被放在栈顶下面的第 $n-6$ 个位置，也就是\n    `M[R[%rsp] + 8(n-6)]`。\n</Card>\n\n具体实现为：\n\n-   在 caller 中、`call` 之前：将前 6 个参数放在相应的寄存器，并将其余参数按从后向前的顺序依次压入 stack\n-   在 caller 中、`call` 之后：把 stack 中的参数（如果有）弹出 (`addq $8(n-6), %rsp`)\n-   在 callee 中：从相应的寄存器或 stack 中读取参数\n\n### 传递返回值\n\n<Card type="hint" title="存放返回值的原则">\n    在调用 procedure 并返回后，如果该 procedure 有返回值，`%rax`\n    中存放的是该返回值。\n</Card>\n\n具体实现就是在 `ret` 前确保 `%rax` 中放的是返回值。\n\n### 存储局部变量\n\n局部变量一般会优先放在寄存器中，如果放不下就会放在 stack 中。\n\n特别地，如果代码中涉及到取局部变量的地址，或者局部变量是结构化数据（例如数组或结构体），则必须放在 stack 中。\n\n如果局部变量放在寄存器中，且在使用该局部变量的过程中调用了 procedure，那么该局部变量就会需要先存起来以保证调用 procedure 之后不会改变，而这有两种方式实现：\n\n-   caller saved，即在 caller 中将寄存器里的值存在 stack 里。\n-   callee saved，即在 callee 中存储：有一些特殊的寄存器是 callee-saved register，如果把局部变量存在这些寄存器中，在 caller 中就不用担心它们的值会在调用 procedure 后被修改。\n\n<Card type="hint" title="callee-saved registers 的使用原则">\n有 6 个特殊的寄存器 `%rbx`、`%rbp`、`%r12-15` 是 callee-saved register。\n\n任何 procedure 都要保证，每个 callee-saved register 的值在进入和返回时是相同的。\n\n</Card>\n\ncaller saved 的具体实现：在 `call` 之前（以及压入超过 6 个的参数之前）将局部变量入栈，`call` 之后（以及弹出放在栈中的参数之后）再把栈中存的弹出到寄存器中。\n\ncallee saved 的具体实现：如果一个 procedure 使用了某个 callee-saved register，则要在 procedure 的开头将这个寄存器原本的值入栈，而在 procedure 的结尾将存下来的这个原本的值弹出到相应的寄存器中。\n\n为了尽可能使用（数量尽量少的）寄存器而非 stack，经常会有多个生命周期不交叉的的变量共用一个寄存器，或者临时地把局部变量放在一般用于存放参数或返回值的寄存器中。\n\n### 可变大小的 stack frame\n\n通常情况下一个 procedure 的 stack frame 的大小是确定的，但有时 stack frame 的大小是不能在编译时确定的（例如有非确定大小的数组）。\n\nstack frame 大小确定主要是为了能够通过与 `%rsp` 即栈顶的相对距离来访问局部变量等，在 stack frame 大小不确定时，则可以通过记录 stack frame 底部的地址来访问局部变量。\n\n<Card type="hint" title="stack frame pointer 的原则">\n    在 stack frame 大小不确定时，使用 `%rbp` 作为 frame pointer (base\n    pointer)，其值为刚进入 procedure 时的 `%rsp`。\n</Card>\n\n具体实现为：\n\n```asm\nfunction_name:\n    pushq %rbp\n    movq %rsp, %rbp\n    ……\n    leave\n    ret\n```\n\n设置好 `%rbp` 后，就可以使用 `-8(%rbp)` 等方式访问相对于 stack frame 底端的位置了。\n\n这里有一个新指令 `leave`: 没有 operand，相当于 `move %rbp, %rsp` 然后 `pop %rbp`。\n\n<Card title="<code>leave</code> vs <code>enter</code>">\n    上面的代码中使用了 `leave` 而非 `move %rbp, %rsp`、`pop %rbp`，但没有使用\n    `enter` 指令，简单来说是历史以及性能原因，可以参考 [assembly - "enter" vs\n    "push ebp; mov ebp, esp; sub esp, imm" and "leave" vs "mov esp, ebp; pop\n    ebp" - Stack\n    Overflow](https://stackoverflow.com/questions/5959890/enter-vs-push-ebp-mov-ebp-esp-sub-esp-imm-and-leave-vs-mov-esp-ebp)。\n</Card>\n\n除了使用 `%rbp` 作为 frame pointer，为非确定大小的数组分配栈空间还涉及到 [data alignment](#data-alignment) 的问题，可以参考 CS:APP Practice Problem 3.49。\n\n### Stack Frame Alignment\n\nx86-64 中要求 stack frame 以 16 byte 对齐。具体来说，就是执行 `call` 之前 `%rsp` 的值必须是 16 的倍数，而在进入一个 procedure 时 `%rsp` 的值就模 16 余 8。\n\n为了满足这一对齐要求，有时会在 `call` 之前先 `subq $8, %rsp`，`call` 之后再 `addq $8, %rsp`。\n\n## Array Allocation and Access\n\n简单来说，`Imm(rb, ri, s)` 的 operand 格式使得数组访问变得容易。\n\n而编译器会做很多优化，例如用指针加法代替每次都算一遍乘法。\n\n## Heterogeneous Data Structures\n\n### Struct\n\n结构体也是内存中连续的一段，会在编译时在结构体地址的基础上加上相应的 offset 来访问各个 field。\n\n### Union\n\nunion 的大小是最大的 field 的大小，每个 field 的 offset 都是 0。\n\n在使用 union 时，byte ordering 可能非常重要。\n\n### Data Alignment\n\n在 x86-64 中，进行 data alignment 可以提升程序效率。具体要求为，任何（主要是结构体内的）primitive type 的地址需要是其长度的倍数。\n\n为了满足 alignment 要求，可能需要：\n\n1.  在结构体的不同 field 之间添加 padding\n2.  保证结构体自身的地址是其自身 alignment 的倍数\n3.  在结构体末尾添加 padding，例如在数组中需要保证下一个元素的起始地址为其 alignment 的倍数\n\n汇编代码中会使用 `.align` directive 来指定 data alignment。\n\n## Thwarting Buffer Overflow Attacks\n\n了解了 stack 的构造，就能更加明白数组越界的危害：可以修改 stack 上包括 caller address 在内的数据，导致程序出错或跳转到错误的位置，而攻击者可以利用这一漏洞跳转到设计好的位置以执行攻击代码。\n\n下面是一些无需修改程序代码就能做到的降低 buffer overflow 危害的方法，当然，这些方法也不是万能或总是有效的。\n\n### Stack Randomization\n\n可以修改 stack 的起始地址，以降低指令地址的可预测性，增大攻击难度。这在 Linux 中已经是标准做法了，是 address-space layout randomization (ASLR) 的一部分。\n\n攻击者可以通过 “nop sled”，即通过大量 `nop` 指令来增长攻击代码的长度，来降低猜测指令地址的难度。\n\n### Stack Corruption Detection\n\ngcc 使用 _stack protector_ 来检测 stack corruption，以避免 corrupted stack 造成的危害。\n\n简单来说，使用 stack protector 时，会在 stack frame 中插入一个运行时随机生成的 _canary value_ (_guard value_) ，并在 `ret` 前检查这个值是否被修改。\n\n### Limiting Executable Code Regions\n\n可以限制能够被执行的 memory region，以避免攻击者执行位于 stack 中的、由攻击者注入的指令。\n\n但是，有的语言（例如 Java）可能需要能够执行动态生成的指令，这样的话就不能禁止执行 stack 中的指令。\n\n## Floating-Point Code\n\n这部分内容基于 AVX2 指令集，可以指定 `-mavx2` 选项来让编译器使用 AVX2 指令。\n\n如果不支持 AVX，则可以使用 SSE 指令集，大体上是类似的。简单来说，主要的区别就是 AVX 指令的名称会有一个 `v` 的前缀，而很多 AVX 中三个 operand 的指令在 SSE 中是两个 operand。\n\n### YMM 寄存器\n\n浮点数存放在 16 个 YMM registers 中，每个寄存器有 256 bits，叫做 `%ymm0-15`，而低位 128 bits 叫做 `%xmm0-15`。\n\n这些寄存器可以存多个浮点数 (packed data) 并对它们同时进行操作以加速计算；而如果只对单个浮点数 (scalar) 进行操作，就只涉及到 `%xmm0-15` 的低位。\n\n### 浮点数的移动指令\n\n下面的指令都没有列全可能的 operand 类型，仅列出 CS:APP 里讲到的常用的。\n\n-   `vmovss m32, xmm`\n-   `vmovss xmm, m32`\n-   `vmovsd m64, xmm`\n-   `vmovsd xmm, m64`\n-   `vmovaps xmm, xmm`\n-   `vmovapd xmm, xmm`\n\n其中 `v` 是 AVX 指令的前缀，`ss` 表示 scalar single-precision，`sd` 表示 scalar double-precision，`a` 表示 aligned，`ps` 表示 packed single-precision，`pd` 表示 packed double-precision。也就是说，`s` 结尾的用于 float，`d` 结尾的用于 double。\n\n### 浮点数类型转换\n\n#### 浮点数转为整数\n\n-   `vcvttss2si xmm/m32, r32`\n-   `vcvttsd2si xmm/m64, r32`\n-   `vcvttss2siq xmm/m32, r64`\n-   `vcvttsd2siq xmm/m64, r64`\n\n其中 `cvttss2si` 的意思是: `cvt` -> convert, `t` -> (with) truncation, `ss` -> scalar single-precision, `2` -> to, `si` -> signed integer。\n\n`ss` 用于 float，`sd` 用于 double；结尾为 `q` 的用来转成 64 位整数。\n\n#### 整数转为浮点数\n\n-   `vcvtsi2ss r/m32, xmm, xmm`\n-   `vcvtsi2sd r/m32, xmm, xmm`\n-   `vcvtsi2ssq r/m64, xmm, xmm`\n-   `vcvtsi2sdq r/m64, xmm, xmm`\n\n这里 `cvt` 后少了一个 `t` 是因为整数转为浮点数不会 truncate。\n\n效果是把第一个 operand 转换后放在第三个 operand 处，而第二个 operand 一般不用管，设为和第三个 operand 一样即可。（转换结果会放在 destination 的低位，而第二个 operand 用来设置 destination 的高位。）\n\n#### 浮点数精度转换\n\n-   `vcvtss2sd xmm, xmm, xmm`\n-   `vcvtsd2ss xmm, xmm, xmm`\n\noperand 的作用和上面整数转为浮点数的指令一样。\n\n<Card title="gcc 使用的浮点数精度转换指令">\n    在某些版本的 gcc 中，或针对某些处理器架构进行优化时，gcc\n    可能会使用另外的指令来进行浮点数精度转换。详见\n    [另一篇博客](/post/2022/10/gcc-use_vector_fp_converts)。\n</Card>\n\n### 函数调用中的浮点数\n\n-   前 7 个浮点参数可以存在 `%xmm0-7` 中，其余参数存在 stack 里。\n-   浮点函数返回值存在 `%xmm0` 中。\n-   没有 callee-saved 寄存器（所有寄存器都是 caller-saved）。\n\n看参数是第几个、放在哪个寄存器时，浮点参数和整型参数是分开算的，例如 `double f1(int x, double y, long z)` 和 `double f2(double y, int x, long z)` 的参数寄存器分配是相同的。\n\n### 浮点数算术运算\n\n下面的指令把 `ss` 换成 `sd`、`m32` 换成 `m64` 即为 double-precision 的版本。\n\n#### 浮点数二元运算\n\n记三个 operand 分别为 $S_1, S_2, D$，则效果为计算 $S_2$ 与 $S_1$ 的运算结果，存在 $D$ 中，例如 `vsubss S_1 S_2 D` 是 $D \\gets S_2 - S_1$。\n\n-   `vaddss xmm/m32, xmm, xmm`\n-   `vsubss xmm/m32, xmm, xmm`\n-   `vmulss xmm/m32, xmm, xmm`\n-   `vdivss xmm/m32, xmm, xmm`\n-   `vmaxss xmm/m32, xmm, xmm`\n-   `vminss xmm/m32, xmm, xmm`\n\n#### 浮点数一元运算\n\n`sqrtss xmm/m32, xmm`: 将 source 开方存入 destination\n\n这里 CS:APP 中列出的是 SSE 指令 `sqrtss` 而非 AVX 指令 `vsqrtss`，我自己编译出来也是。可能可以参考 [c++ - Using AVX intrinsics instead of SSE does not improve speed -- why? - Stack Overflow](https://stackoverflow.com/questions/8924729/using-avx-intrinsics-instead-of-sse-does-not-improve-speed-why)。\n\n### 浮点数常量\n\n浮点数相关的指令不接受 immediate value 作为 operand，所以使用常量时需要先存下来，例如：\n\n```c\ndouble foo() { return 1.8; }\n```\n\n```asm\nfoo:\n	vmovsd	.LC0(%rip), %xmm0\n	ret\n.LC0:\n	.long	-858993459\n	.long	1073532108\n```\n\n### 浮点数位运算\n\n位运算都是在整个寄存器上对 packed data 进行的。\n\n-   `vxorps xmm/m128, xmm, xmm`\n-   `vxorpd xmm/m128, xmm, xmm`\n-   `vandps xmm/m128, xmm, xmm`\n-   `vandpd xmm/m128, xmm, xmm`\n\noperands 格式和上面一样。\n\n一些浮点数位运算的实际运用：\n\n-   用 and 运算将 sign bit 置零，以取绝对值\n-   用 xor 运算将 sign bit 取反，以取相反数\n-   将 xor 的两个 source 设为同一个寄存器以得到 0\n\n<Card\n    type="question"\n    title="packed single/double precision 在移动和位运算上的区别？"\n>\n    `vmovaps` 和 `vmovapd`、`vxorps` 和 `vxorpd`、`vandps` 和 `vandpd`\n    看起来效果是一样的，为什么要给 single/double precision 分别一条指令呢 🤔\n</Card>\n\n### 浮点数比较\n\n-   `vucomiss xmm/m32, xmm`\n-   `vucomisd xmm/m64, xmm`\n\n效果为，计算第二个 operand 减去第一个 operand 并设置 status flags。\n\n浮点数的比较是 “unordered” 的，即若某个 operand 是 NaN，则比较结果为 unordered。\n\n不同的比较结果对应的 status flags 以及 condition code 为：\n\n|  比较结果   | CF  | ZF  | PF  | condition code |\n| :---------: | :-: | :-: | :-: | :------------: |\n|  unordered  |  1  |  1  |  1  |      `p`       |\n| $S_2 < S_1$ |  1  |  0  |  0  |      `b`       |\n| $S_2 = S_1$ |  0  |  1  |  0  |      `e`       |\n| $S_2 > S_1$ |  0  |  0  |  0  |      `a`       |\n\n其中 PF 在浮点数比较中用来表示 unordered，在整数计算中也会被设置但几乎没用。\n'},{title:v,tags:t,content:`想开一个 [CS:APP](https://csapp.cs.cmu.edu/) 学习笔记的系列，感觉还是有一些东西需要在系列开头简单说一下，所以有这篇序。



---

这学期要上“计算机系统概论”这门课，其实就是 CS:APP。（只不过老师声称这门课没有教材，CS:APP 只是参考书。）

本来是想暑假自学的，但暑假多少有点摆，就咕了 🕊️

虽然上一学年以数学课为主都挺摆的，但这学期（上（夏季小）学期？）开始也有一些计算机的课了，还是想好好学一下的。尤其是 CS:APP，因为系统这块我了解的不多，相比程设训练、软件工程什么的还是不太有信心。就算暑假摆了，也不能靠听课学吧，~~不会真的有什么东西是听课学能学会的吧（~~

看的书是当前最新的第三版。虽然听说 CS:APP 的中文翻译质量还不错，但我感觉术语翻译应该多少还是会有些奇怪，就还是看的英文版（~~如果有不翻译术语的中文版就好了~~）。一开始看的是 Global Edition，然后发现习题答案错的离谱，[勘误表](https://csapp.cs.cmu.edu/3e/errata.html) 也说放弃 Global Edition 了，就换成了 North American Edition。

因为这本书有很多细节知识点，~~而且废话很多~~，感觉是适合做笔记的，~~正好博客也缺内容~~，就想在博客上写学习笔记。

然后，因为是在上课的“同时”写这些学习笔记，我希望是能在每节课之前写完相应内容的部分，这样的话就不会有课堂内容外泄的嫌疑了（虽然就算是上课记的笔记公开分享也不会有什么问题，吧 🤔）；除去避嫌的原因，也是督促自己跟上进度。（如果只是把上课讲的内容提前自学倒还压力不大，但上课有跳过不讲的（盲猜有的部分会放到大三的组成原理讲 🤔），也有不按书的顺序讲的，我还是想按书的顺序学完，就有点难顶了。）

UPD：因为其他课的作业以及自己的摆烂，还是搞不完了..只能跟着课程的顺序跳着学了，起码保证课上讲的内容提前自学..

书的第一章是总览性的介绍，就跳过不写学习笔记了。

系列目录可以看 [tag: csapp](/tag/csapp)。
`},{title:C,tags:"TeX R 物理实验 经验分享",content:`这学期选了物理实验B。

以前基本上只在 Markdown 里写 LaTeX，没怎么写过 \`.tex\`，R 则完全没有接触过。理论上我应该好好学一学再用，但实际上没时间好好学。总不能用 Word 写实验报告并且手算吧（

这里总结一下我写实验报告用到的 TeX 和 R。



## TeX

### 中文

\`\`\`tex
\\documentclass[UTF8, 11pt, fontset=none]{ctexart}  % 需要禁用默认 fontset 才能自定义字体
\\setCJKmainfont{Source Han Serif SC}
\\usepackage[T1]{fontenc}
\`\`\`

### 基本页面格式

\`\`\`tex
\\ctexset{section/format=\\Large\\bfseries}  % 参照讲义上的格式，标题左对齐
\\usepackage[a4paper, hmargin=1.5cm, vmargin=2cm]{geometry}  % 页面大小和边距
\\usepackage{enumitem}
\\setlist{topsep=0pt,itemsep=-4pt}  % 列表间距
\\pagestyle{plain}                  % ctex 默认的页码在右上角，改成下方
\\setlength{\\parskip}{0.5em}        % 段落间距
\`\`\`

### PDF metadata

\`\`\`tex
\\usepackage[pdfusetitle]{hyperref}
\`\`\`

### 标题

\`\`\`tex
\\title{实验名称\\ 实验报告}
\\author{姓名}
\\makeatletter

\\begin{center}
    \\LARGE
    \\textbf{\\@title}

    \\vspace{0.5cm}
    \\normalsize
    实验者姓名: \\@author\\hspace{15pt}
    学号: 2021000000\\hspace{15pt}
    实验日期: 2202年10月32日\\hspace{15pt}
    实验台号: 1\\hspace{15pt}
    \\vspace{0.5cm}
\\end{center}
\`\`\`

### 章节

\`\`\`tex
\\section{实验目的}

\\subsection{测一下这个东西}
\`\`\`

### 图表

\`\`\`tex
\\usepackage{graphicx}
\\usepackage{float}
\\usepackage[hidelinks]{hyperref}  % 使用 hidelinks 选项来禁用链接的红框
\\usepackage{cleveref}
\\crefname{figure}{图}{图}
\\crefname{table}{表}{表}
\`\`\`

可以用 \`\\label\` 和 \`\\cref\` 来在正文中引用图表，这样就可以避免添加图表时重新标号。

\`\`\`tex
\\begin{figure}[H]
    \\centering
    \\includegraphics[width=0.6\\textwidth]{picture.png}
    \\caption{这是一幅图，老师说图的标题放下面}
    \\label{this-is-a-picture}
\\end{figure}

如\\cref{this-is-a-picture} 所示
\`\`\`

\`\`\`tex
如\\cref{this-is-a-table} 所示

\\begin{table}[H]
    \\centering
    \\caption{这是一张表，老师说表的标题放上面}
    \\vspace{1em}
    \\begin{tabular}{|c|c||c|c|}
        \\hline
        序号 & 值 & 序号 & 值 \\\\
        \\hline
        1  & 1.14 & 6  & 5.14 \\\\ \\hline
        2  & 1.93 & 7  & 5.95 \\\\ \\hline
        3  & 2.74 & 8  & 6.75 \\\\ \\hline
        4  & 3.55 & 9  & 7.53 \\\\ \\hline
        5  & 4.35 & 10 & 8.32 \\\\ \\hline
    \\end{tabular}
    \\label{this-is-a-table}
\\end{table}
\`\`\`

如果想把几张图/表放在单独一页，使得这一页没有其他文字，可以把 \`[H]\` 改成 \`[p]\`。

### 斜线表头

\`\`\`tex
\\usepackage{diagbox}

\\begin{tabular}{|c|}
\\diagbox{左下}{右上}
\\end{tabular}

\\begin{tabular}{|c|}
\\diagbox{左下}{中间}{右上}
\\end{tabular}
\`\`\`

还可以设置其它样式，但应该用不上。

### 多行/多列（合并单元格）

可以参考 [Latex 表格技巧 - 合并单元格\\_TheNetAdmin的博客](https://blog.csdn.net/wzxlovesy/article/details/69063271)。

### 单位、科学计数法、不确定度、角度

\`\`\`tex
\\usepackage[separate-uncertainty=true]{siunitx}[=v2]
\`\`\`

其中 \`[=v2]\` 用来修复使用 \`T1\` 编码时 \`\\micro\` 的样式: [siunitx#619](https://github.com/josephwright/siunitx/issues/619)

\`siunitx\` 这个包解决了若干问题：

-   单位需要用正体，手写的话需要 \`\\mathrm\`
-   数字和单位之间最好有一些间距
-   有的单位会让你纠结怎么写比较好，[例如摄氏度](https://tex.stackexchange.com/questions/258306/how-to-insert-degree-celsius-symbol-in-node-text-in-pgfplots-tikz)
-   科学计数法写 \`\\times 10^\` 比较麻烦
-   比较长的数字不分段的话看不清
-   不确定度和测量结果末位对齐
-   这个包还可以将不确定度写成括号的形式，只不过实验报告的要求是 $\\pm$ 的形式
-   ~~只记得单位的字母，不记得单位的英文名~~

例子：

\`\`\`tex
$t = \\SI{22.5}{\\celsius}$

$v = \\SI{1.91981 \\pm 0.114514 e3}{\\kilo\\metre / \\hour}$
\`\`\`

其中下面那个的渲染效果大概是（没研究这个包的源码，只是看样子大概复刻一下）：

 $v = (1.919\\,810 \\pm 0.114\\,514) \\times 10^3 \\, \\mathrm{km/h}$

\`$v = (1.919\\,810 \\pm 0.114\\,514) \\times 10^3 \\, \\mathrm{km/h}$\`

可以用 \`\\unit\` 来只有单位没有数字，用 \`\\num\` 来只有数字没有单位，或者用 \`\\SI\` 但把一部分留空。

可以用 \`\\ang{1;02;}\` 来显示 $1^\\circ 2'$，用 \`\\ang[parse-numbers=false]{1;02;}\` 来显示 $1^\\circ 02'$，用 \`\\sisetup{parse-numbers=false}\` 来在当前环境（例如表格）内设置 \`parse-numbers=false\`，就不用每条命令单独设置。

更多用法可以参考 siunitx 的文档。

### 模板

<Card fold title="实验报告完整模板">

\`\`\`tex
\\documentclass[UTF8, 11pt, fontset=none]{ctexart}
\\setCJKmainfont{Source Han Serif SC}
\\usepackage[T1]{fontenc}

\\pagestyle{plain}
\\ctexset{section/format=\\Large\\bfseries}
\\usepackage[a4paper, hmargin=1.5cm, vmargin=1.9cm]{geometry}
\\setlength{\\parskip}{0.5em}
\\usepackage{enumitem}
\\setlist{topsep=0pt,itemsep=-4pt}

\\usepackage{amsmath}
\\usepackage[separate-uncertainty=true]{siunitx}[=v2]

\\usepackage{multirow}
\\usepackage{diagbox}

\\usepackage[pdfusetitle, hidelinks]{hyperref}
\\usepackage{graphicx}
\\usepackage{float}
\\usepackage{cleveref}
\\crefname{figure}{图}{图}
\\crefname{table}{表}{表}
\\crefname{page}{页}{页}
\\crefname{section}{节}{节}

\\begin{document}

\\title{XXX\\ 实验报告}
\\author{姓名}
\\makeatletter

\\begin{center}
    \\LARGE
    \\textbf{\\@title}

    \\vspace{0.5cm}
    \\normalsize
    实验者姓名: \\@author\\hspace{15pt}
    学号: 2021000000\\hspace{15pt}
    实验日期: 2022年XX月XX日\\hspace{15pt}
    实验台号: XX\\hspace{15pt}
    \\vspace{0.5cm}
\\end{center}

\\section{实验目的}

\\begin{enumerate}
    \\item
    \\item
    \\item
\\end{enumerate}

\\section{实验仪器}

\\begin{itemize}
    \\item
    \\item
\\end{itemize}

\\newpage

\\section{数据处理及结果}

% \\begin{table}[H]
%     \\centering
%     \\caption{}
%     \\vspace{1em}
%     \\begin{tabular}{|c|c|c|}
%     \\end{tabular}
%     \\label{}
% \\end{table}

% \\begin{figure}[H]
%     \\centering
%     \\includegraphics[width=\\textwidth]{.png}
%     \\caption{}
%     \\label{}
% \\end{figure}

\\newpage

\\section{原始数据记录}

\\begin{center}
\\includegraphics[width=\\textwidth]{data.jpg}
\\end{center}

\\end{document}
\`\`\`

</Card>

## R

### Arch 装 R package

[arch4edu](https://github.com/arch4edu/arch4edu) 有一些 R package，可以减少 AUR 的需求。

### 读取数据

\`\`\`r
data <- readr::read_csv(file = "data.csv")
\`\`\`

### 平均数、标准偏差

\`\`\`r
ybar <- mean(data$y)
Sy <- sd(data$y)
\`\`\`

### 线性回归

\`\`\`r
model <- lm(log(y) ~ x, data)
b <- coefficients(model)[2]   # 线性回归系数
r <- cor(log(data$y), data$x) # 相关系数
nu <- df.residual(model)      # 自由度 (n-2)
\`\`\`

### t 因子

\`\`\`r
t <- qt(p=0.025, df=nu, lower.tail=FALSE)
\`\`\`

R 里面有好几个和 student 分布相关的函数，我猜可能有的东西可以直接用这些函数算出来，但我懒得研究了，反正能拿到 t 因子自己代公式就是了（

### 非线性函数的拟合

\`\`\`r
model <- nls(
    y ~ a * cos(2 * pi * (14.5 - x) / lambda),
    data = data,
    start = list(a = 200, lambda = 10)
)
co <- coef(model)
a <- co["a"]
lambda <- co["lambda"]
\`\`\`

如果一个函数长得很奇怪，不能线性拟合，可以用 \`nls\` (Non-linear Least Squares) 来以减小残差平方和为目标进行拟合。

\`nls\` 需要传入 \`start\` 参数作为拟合的起点，可以自己大致估计一下参数大概是多少，如果估计的偏差太大，可能导致最后拟合的结果出错。

### 简陋的函数图像

画个简陋的图可以用来检查函数拟合的情况：

\`\`\`r
plot(data)
curve(a * cos(2 * pi * (14.5 - x) / lambda), add = TRUE)
\`\`\`

如果是在 non-interactive 模式下（例如使用 \`R -f foo.R\` 运行），生成的图像默认会放在 \`Rplots.pdf\` 中。

### ggplot 画散点 / 折线图

\`\`\`r
library(tidyverse)

# 导入字体
library(extrafont)
font_import()
loadfonts()
fonts()
fonttable()

data <- readr::read_csv(file = "data.csv")

p <- data %>%
    ggplot(aes(a, b + c)) + # 以表中的 a 为横坐标，b + c 为纵坐标
    geom_point() + # 散点
    geom_line() + # 折线
    labs(x = "a", y = "b") + # 坐标轴标题
    theme(text = element_text(family = "Source Han Serif SC")) # 字体
ggsave("plot.png", plot = p)
\`\`\`
`},{title:w,tags:"csapp 学习笔记 WIP",content:'[CS:APP](https://csapp.cs.cmu.edu/) 第四章 “Processor Architecture” 的学习笔记。\n\n这章的主要内容为一个简化的指令集 Y86-64 的设计以及 Y86-64 处理器的实现（顺序实现和 pipeline 实现）。\n\n\n\n## The Y86-64 Instruction Set Architecture\n\n这部分定义了在这一章中用作演示的名为 “Y86-64” 的玩具 ISA。\n\n### Y86-64 程序状态\n\n-   15 个寄存器（x86-64 的寄存器除去 `%r15`，为了简化编码）\n-   3 个 status flag: `ZF`、`SF`、`OF`\n-   program counter: `PC`\n-   memory\n-   status code: `Stat`，用来表示程序正常运行或发生了异常\n\n### Y86-64 指令\n\nY86-64 指令大致上是 x86-64 的一个子集，但在 operand 等方面有一些简化或区别。\n\noperand 与 x86-64 的区别是：\n\n-   Immediate、Register、Memory 都只有 64 位的版本\n-   Register 只有 15 个\n-   Memory 不支持 `(, ri, s)` 的部分，只能是 `Imm`/`(rb)`/`Imm(rb)`\n\ncondition code 只有六个，即 signed compare: `le`/`l`/`e`/`ne`/`ge`/`g`\n\n指令列表，以及与 x86-64 的区别：\n\n-   `irmovq`/`rrmovq`/`mrmovq`/`rmmovq`，即将 `movq` 按 operand 类型拆成了四个指令\n-   `addq`/`subq`/`andq`/`xorq`，它们只接受寄存器作为 operand，且只设置 `ZF`、`SF`、`OF` 三个 status flag\n-   `jmp`/`jle`/`jl`/`je`/`jne`/`jge`/`jg`，包括 `jmp` 在内都只能跳转到固定的地址，不接受寄存器作为 operand，且这个地址是绝对地址而非相对于 PC 的地址\n-   `cmovle`/`cmovl`/`cmove`/`cmovne`/`cmovge`/`cmovg`，它们只接受寄存器作为 operand\n-   `call`: 地址是绝对地址\n-   `ret`、`pushq`、`popq`、`nop`: 与 x86-64 基本相同\n-   `halt`: 停止运行，将 status code 设为 `HLT`\n\n### Y86-64 指令编码\n\nY86-64 通过对指令的简化，同时也使编码得到了简化，但相应地使得编码不紧凑，会有浪费。\n\nCS:APP Figure 4.2 简明地展示了 Y86-64 的指令编码：\n\n![Y86-64 指令编码示意图](csapp-fig4.2.png)\n\n#### 指令类型的编码\n\n指令编码的第一个 byte 表示指令的类型。这个 byte 的高位叫做 *code*，低位叫做 *function*，其中 function 只在某几个指令有用。特别地，`rrmovq` 和 `cmovXX` 的 code 是相同的，这表示 `rrmovq` 可以看作一种特殊的 `cmovXX`。\n\n算术运算的 function: `add` 0, `sub` 1, `and` 2, `xor` 3\n\ncondition code 的 function: `le` 1, `l` 2, `e` 3, `ne` 4, `ge` 5, `g` 6；`jmp` 的 function 为 0\n\n#### Register Specifier Byte\n\n除了 `jXX` 和 `call`，指令编码的第二个 byte（如果有）的高低位分别表示一个 register identifier。\n\nregister identifier 从 `%rax` 为 `0` 到 `%r14` 为 `E`；`F` 表示不是寄存器。\n\n#### Constant Word\n\n在 `irmovq`、`rmmovq`/`mrmovq`、`jXX`/`call` 中，分别有一个 8-byte 的 constant word，用来表示 immediate value 或地址，byte ordering 是 little endian。\n\n### Y86-64 异常\n\nstatus code `Stat` 有四种可能的取值：\n\n-   `AOK`: 正常\n-   `HLT`: 执行了 `halt` 指令\n-   `ADR`: 访问了不合法的地址\n-   `INS`: 指令编码不合法\n\n在 Y86-64 中，遇到异常后处理器会立即停止运行。\n\n### Y86-64 程序\n\nCS:APP Figure 4.8 展示了一个完整的 Y86-64 程序：\n\n![完整 Y86-64 程序的汇编与机器码](csapp-fig4.8.png)\n\n可以下载 [Y86-64 tools](http://csapp.cs.cmu.edu/3e/sim.tar) 并使用 `yas` 进行汇编，使用 `yis` 模拟运行。编译 `yas` 时 [需要添加 `-fcommon` 编译选项](https://stackoverflow.com/questions/63152352/fail-to-compile-the-y86-simulatur-csapp)。\n\n### 对 %rsp 进行 push/pop\n\n`pushq %rsp`、`popq %rsp` 这两条指令虽然没什么用，但它们的行为可能有歧义，所以在设计 ISA 时明确规定它们的行为是有必要的。\n\nY86-64 遵循和 x86-64 相同的规则：`pushq %rsp` 会将旧的（没有减 8 的）`%rsp` 的值入栈，`popq %rsp` 相当于 `mrmovq (%rsp), %rsp`。\n\n## Logic Design and the Hardware Control Language HCL\n\n这一章中使用玩具语言 HCL (hardware control language) 来描述 Y86-64 处理器的逻辑设计。（与之类似但不是玩具的语言，例如 VHDL、Verilog 等，叫做 “[hardware description language (HDL)](https://en.wikipedia.org/wiki/Hardware_description_language)”。）\n\n### 逻辑门\n\nCSAPP Figure 4.9:\n\n![与或非逻辑门](csapp-fig4.9.png)\n\n-   图中只展示了输入个数为 2 的 AND 和 OR，但可以有更多输入\n-   一旦输入改变，逻辑门的输出很快就会随之改变\n\n### 组合逻辑电路\n\n组合逻辑电路即由若干逻辑门组合而成的电路，它的特点是无状态，输出仅与输入有关，输入改变后输出很快就会随之改变。\n\n在 HCL 中，用逻辑表达式来表示组合逻辑电路，例如 `bool eq = (a && b) || (!a && !b)` 表示计算 `a`、`b` 是否相等的电路。因为它表示的是电路而不是计算，在这条语句之后，一旦 `a`、`b` 的值发生改变，`eq` 的输出也会改变（和 Vue 的 computed 类似）。\n\n### 以 word 为单位进行操作的电路\n\n在处理器的设计中，经常需要对一个 word 而非单个 bit 进行操作。\n\n在 HCL 中，一般使用大写的名称表示 word，例如: `bool Eq = (A == B)` 表示计算 word `A`、`B` 是否相等的电路，可以实现为判断每个 bit 是否相等再 AND。\n\n### Multiplexor (MUX)\n\nmultiplexor (MUX) 的功能是通过信号输入的值来在其它输入中选择一个作为输出，word-level 的 MUX 电路如图 (CSAPP Figure 4.13)：\n\n![word-level MUX 电路](csapp-fig4.13.png)\n\n在 HCL 中，使用 *case expressions* 表示 MUX，例如\n\n```hcl-csapp\nword Mux = [\n    !s1 && !s0: A;\n    !s1: B;\n    !s0: C;\n    1: D;\n];\n```\n\n表示一个由 `s0` 和 `s1` 控制的、在 `A`、`B`、`C`、`D` 中选一个作为输出的 MUX。\n\ncase expression 在逻辑上的语义是依次判断每个条件，以第一个满足的条件作为输出，类似于 Rust 的 match。\n\n下面的 HCL 代码表示计算 `A`、`B`、`C` 中的最小值：\n\n```hcl-csapp\nword Min3 = [\n    A <= B && A <= C: A;\n    B <= C: B;\n    1: C;\n];\n```\n\n### Arithmetic/logic unit (ALU)\n\nALU 是用来进行算术/逻辑运算的组合逻辑电路元件，它接收两个 data input 以及一个表示进行何种运算的 control input，输出运算的结果。\n\n### 测试值是否属于集合\n\n在 HCL 中，可以使用 `in` 来表示测试值是否属于集合的电路，例如: \n\n```hcl-csapp\nbool s1 = code in { 2, 3 };\nbool s0 = code in { 1, 3 };\n```\n\n### Memory and Clocking\n\n组合逻辑电路是无状态且实时更新的；与之相对，memory 可以存储状态，但更新由 clock 控制。\n\n这一章中会用到的 memory 有两大种三小种：\n\n-   clocked register: 存储一个值，有一个输入和一个输出。输出即存储的值，而每次 clock rise 时会将存储的值修改为输入。\n-   random access memory:\n    -   register file: 存储 15 个值（在 Y86-64 处理器中），有两个 read port 和一个 write port：\n        -   每个 read port 有一个输入 `src` 表示 register identifier，有一个输出 `val` 表示这个 register 存储的值，且 `src` 改变后 `val` 会立刻改变。\n        -   write port 有一个输入 `dst` 表示 register identifier，另有一个输入 `val` 用于写入。每次 clock rise 时，如果 `dst` 不是 `F` 就会将 `val` 写入相应的 register。\n    -   data memory: 存储很多个值，用地址进行索引。\n        -   有一个地址输入 `address`。\n        -   有一个信号输入 `write` 表示进行写入而非读取。\n        -   有一个数据输出 `data out`。若 `write` 为 0，`data out` 会立刻输出 `address` 处存储的值。\n        -   有一个数据输入 `data in`。若 `write` 为 1，在 clock rise 时会将 `data in` 写入 `address` 处。\n        -   有一个信号输出 `error`，在 `address` 不是合法地址时输出 1。\n\n可以看到，这几种 memory 的共同点是读取是实时的，但写入由 clock 控制。\n\n在 Y86-64 的程序状态中，寄存器存在 register file 中，status flags、program counter、status code 存在 clocked register 中，memory 存在 data memory 中。\n\nY86-64 处理器还有一个额外的 read-only instruction memory 用来读取指令，而在真实的处理器中这是和内存一体的。\n\n<Card type="question" title="data memory 的 read 信号">\n383 页的图中 data memory 还有一个 `read` 信号，但在文字说明中没有提到它的作用，而对 `write` 信号的说明似乎使得 `read` 信号无用 🤔\n</Card>\n\n## Sequential Y86-64 Implementations\n\n这一节会实现一个名为 SEQ 的顺序执行的处理器。在这个处理器中，指令是按顺序一条接着一条执行的，且每条指令都会在一个 clock cycle 内执行完毕，这要求 clock cycle 很长，会导致处理器的执行很慢，下两节将对此进行优化。\n\n### 指令执行的阶段划分与具体操作\n\n将指令的执行划分为多个阶段，可以使行为有很大差别的不同指令有一定的统一性，方便硬件实现。\n\n本节会将指令执行划分为六个阶段：\n\n1.  Fetch: 将指令编码中不同部分的值读取出来\n2.  Decode: 读取寄存器的值（我感觉 fetch 和 decode 这两个名字互换一下才比较对 🤔）\n3.  Execute: 执行运算\n4.  Memory: 写入或读取内存\n5.  Write back: 写入寄存器\n6.  PC update: 更新 program counter\n\n每个指令每阶段的具体操作如图（CS:APP Figure 4.18~4.21、Solution 4.17）：\n\n![OPq, rrmovq, irmovq](csapp-fig4.18.png)\n\n![rmmovq, mrmovq](csapp-fig4.19.png)\n\n![pushq, popq](csapp-fig4.20.png)\n\n![jXX, call, ret](csapp-fig4.21.png)\n\n![cmovXX](csapp-sol4.17.png)\n\n### SEQ 的主体电路\n\nCS:APP Figure 4.23 大致展示了 SEQ 的主体电路：\n\n![SEQ 主体电路](csapp-fig4.23.png)\n\n其中蓝色的元件是 black box，灰色的元件会在后面进行设计，还有部分电路连接没有画出来。\n\n这个电路大概看着有个印象即可，细节会在后面说明。\n\n### SEQ 的时序控制\n\n在 SEQ 中，每个时钟周期执行一条指令，而时钟控制的只有各种 memory 的写入，memory 的读取和运算都是用组合逻辑电路实现的，虽然在逻辑上有执行顺序，在电路上却是同时执行的，可以看成一个关于 memory 的函数。\n\n也就是说，整个执行过程是：读取 memory 并计算出需要写入 memory 的值，然后在 clock rise 时执行写入，从而读取到新的 memory 的值而执行下一条指令。\n\n为了这个设计能够实现，一条重要的原则是 “No reading back”，即一条指令不能先更新再读取同一个值。例如，在 `pushq` 中，不是先更新 `R[%rsp]` 再写入 `M[R[%rsp]]`，而是先算出 `valE`，再写入 `M[valE]`，最后将 `valE` 写入 `R[%rsp]`。又例如，有的指令会修改 status flags，有的会读取，但没有指令既修改又读取。\n\n因为运算都是同时进行的，执行的六个阶段实际上是六个部分。\n\n### SEQ 的具体实现\n\n\n'},{title:x,tags:t,content:"[CS:APP](https://csapp.cs.cmu.edu/) 第七章 “Linking” 的学习笔记。\n\n这章的主要内容为程序的链接。学习链接有助于：理解链接报错，避免链接相关的 bug，理解变量（函数）的作用域，理解程序运行过程中与链接相关的步骤，了解如何使用共享库（动态链接库）。\n\n\n\n## Compiler Drivers\n\n编译源文件其实分成若干步骤，compiler driver（如 gcc）会依次调用这些步骤，可以用 `gcc -v` 来查看这些步骤的详细信息。\n\n1.  `cpp`: 预处理，源代码 `.c` ->  intermediate file `.i`\n2.  `cc1`: `.i` -> 汇编代码 `.s`\n3.  `as`: `.s` -> relocatable object file `.o`\n4.  `ld`: 链接，多个 `.o` (或 library) -> executable object file\n\nP.S. 中间步骤的文件也可以作为参数传递给 `gcc`，例如 `gcc a.s -o a`。\n\n## Static Linking\n\n静态链接主要有两个任务：\n\n1.  *Symbol resolution*: relocatable object file 中有很多 symbol，包括函数、全局变量、静态变量等，linker 需要将每个 symbol reference 对应到一个 symbol definition。\n2.  *Relocation*: relocatable object file 中地址从 0 开始，linker 需要将每个 symbol definition 重新分配到正确的地址，并相应地修改每个 symbol reference。\n\n## Object Files\n\nobject file 分为三种：\n\n1.  Relocatable object file\n2.  Executable object file\n3.  Shared object file: 一种特殊的 relocatable object file，可以在 load time 或 run time 进行动态链接\n\nobject file 有不同的格式，Windows 使用 Portable Executable (PE) 格式，macOS 使用 Mach-O 格式，现代的 x86-64 Linux/Unix 系统使用 Executable and Linkable Format (ELF) 格式。本章会基于 ELF-64。\n\n## Relocatable Object Files\n\nELF relocatable object file 通常包含以下 section：\n\n1.  `.text`: 程序的机器码\n2.  `.rodata`: 只读的数据\n3.  `.data`: 需要初始化的全局变量和静态变量\n4.  `.bss`: 未初始化或初始化为零的全局变量和静态变量，它们在运行时会以零为初值，从而在 object file 中不占据文件大小\n5.  `.symtab`: symbol table，存储 symbol（函数、全局变量）的信息，不需要 `-g` 编译选项，但不含局部变量的信息\n6.  `.rel.text`: 列出了 `.text` 中在链接时需要修改的地方，一般是调用外部函数或引用全局变量时需要修改，而 [调用本地函数不需要修改](/post/2022/09/csapp-3#jump-指令编码)\n7.  `.rel.data`: 列出了 `.data` 中在链接时需要修改的地方，一般是全局变量的值为其他全局变量或外部函数的地址时需要修改\n8.  `.debug`: 调试信息，包含局部变量的信息、typedef 信息、源代码等，需要 `-g` 编译选项才有\n9.  `.line`: 源代码与机器码行号间的对应关系，需要 `-g` 编译选项才有\n10. `.strtab`: 一堆字符，用于其它 section，可以指向其中一个位置来表示一个字符串（从这个位置起到 `\\0` 为止）\n\n## Symbols and Symbol Tables\n\n对 linker 来说，symbol 有三种：\n\n1.  本地定义，可以被外部访问的: C 中非 `static` 的函数和全局变量\n2.  外部定义的，例如 C 中 `extern` 的全局变量\n3.  本地定义，外部不可访问的: C 中 `static` 的函数和变量\n\n一个 ELF64 symbol 包含如下信息（CS:APP Figure 7.4）：\n\n```c\ntypedef struct\n{\n    int   name;      /* String table offset */\n    char  type:4,    /* Function or data (4 bits) */\n          binding:4; /* Local or global (4 bits) */\n    char  reserved;  /* Unused */\n    short section;   /* Section header index */\n    long  value;     /* Section offset or absolute address */\n    long  size;      /* Object size in bytes */\n} Elf64_Symbol;\n```\n\n`value` 在 relocatable object file 中是 symbol 的地址相对于 section 开头的 offset，在 executable object file 中是 symbol 的绝对地址。\n\n`section` 是 object file 的 section 之一（的 index），在 relocatable object file 中还可以是一个 pseudosection:\n\n-   ABS: 不应被 relocate 的 symbol\n-   UNDEF: 未定义（在其他 module 中定义）的 symbol\n-   COMMON: 多个 module 共用的 symbol（见 [Symbol Resolution](#symbol-resolution)），此时 `value` 的值给出 data alignment 的要求，`size` 给出的是 minimum size\n\n未初始化的静态变量以及初始化为零的全局或静态变量会放在 `.bss`。\n\n未初始化的全局变量，如果启用了 `-fcommon` 编译选项则会放在 COMMON，否则放在 `.bss`。在 gcc 9 及之前默认选项是 `-fcommon`，而自 gcc 10 起默认选项是 `-fno-common`。在 C++ 中 `-fcommon` 是无效的，未初始化的全局变量总是放在 `.bss`。\n\n可以使用 `readelf -s a.o` 来查看 `a.o` 的 `.symtab`。\n\n## Symbol Resolution\n\nSymbol resolution 即把每个 symbol reference 对应到一个 symbol definition。\n\nlocal symbol 的 resolution 是容易的，因为编译单个 module 时就保证了 local symbol 是唯一的。\n\nglobal symbol 可能遇到几种情况：\n\n-   只有一个 module 里定义了这个 global symbol，则使用这个 symbol\n-   没有任何 module 里定义了这个 global symbol，则报错 undefined reference\n-   在多个 module 里定义了这个 global symbol，则：\n    -   如果其中有多个 symbol 不在 COMMON 段，则报错 multiple definition\n    -   如果其中只有一个不在 COMMON 段，则使用这个 symbol\n    -   如果这些 symbol 都在 COMMON 段，则使用其中 `size` 最大的一个（如果 `size` 相同则使用哪个是没有区别的）；如果这些 symbol 有不一样的 `size`，linker 还会给出警告\n\n也就是说，若编译选项为 `-fcommon`，如果在多个 module 中定义了同一个全局变量且其中最多有一个初始化了，则可能导致意外的结果。可以理解为，multiple definition 在本质上是 multiple initialization。\n\n在 C++ 中，函数重载、类方法会通过 *mangling* 来使得函数的每种重载有独特的 symbol name。\n\n## Static Libraries\n\nStatic library 其实就是一堆 object file 包装在一起，它的好处是：\n\n1.  不用每次重新编译（比起提供源码）\n2.  使得库和编译器解耦（比起将库函数内置到编译器中）\n3.  只需将用到的 object file 复制到最终的可执行文件中，避免空间浪费（比起提供单个 object file）\n4.  可以自动选择用到的 object file，在编译命令中只需指定少量库的名称（比起提供一堆 object file）\n\n可以使用类似 `ar rcs libabc.a a.o b.o c.o` 的命令来创建一个 static library。\n\n在编译时，有两种使用 static library 的方式：\n\n-   直接将 static library 的路径作为参数: `libabc.a`\n-   使用 `-lname` 来使用 `libname.a`，但需要使用 `-Ldir` 来将 `dir` 加入到 `-l` 的搜索路径之中: `-L. -labc`\n\n特别地，编译器会自动将 `libc.a` 提供给 linker，不需要手动指定。\n\n在链接时，linker 会依次处理每个参数：\n\n-   如果一个参数是 object file 就一定会使用\n-   如果是 static library，则会依次查看其中包含的每一个 object file，如果一个 object file 中定义了某个当前引用了但仍未定义的 symbol，则会使用这个 object file，而这样的过程会反复迭代进行直到没有新的 object file 被使用为止（例如 `main.c` 引用了 `b.o` 而没有引用 `a.o`，而 `b.o` 中引用了 `a.o`，且在 `libabc.a` 中 `a.o` 位于 `b.o` 之前，那么第一次迭代中只会使用 `b.o`，第二次迭代才会使用 `a.o`，而 `c.o` 不会被使用）\n\n这样的过程使得编译命令中参数的顺序以及 static library 中 object file 的顺序可能影响编译结果：\n\n-   一般来说需要将 library 放在编译命令的末尾，否则处理一个 library 时还没有引用其中的 symbol，就不会使用相应的 object file，最后就会报错 undefined reference\n-   如果多个 library 之间有依赖关系，需要将被其他 library 依赖的 library 放在靠后的位置\n-   如果多个 library 之间有循环依赖，可能需要在编译命令中多次指定同一个 library（或者也可以将这两个 library 合并成一个，这样的话通过多次迭代就可以解决循环依赖）\n-   library 的设计应当避免 multiple definition，但理论上存在不同的参数顺序或 static library 中 object file 的顺序导致 multiple definition 的可能\n\n## Relocation\n\nrelocation 分为两步：\n\n1.  给 symbol definition 重新分配内存地址\n2.  相应地修改 symbol reference\n\n第一步是简单的，把各个 object file 中的各个 section 分别拼在一起即可。\n\n为了让 linker 知道如何修改 symbol reference，需要让 linker 知道：\n\n1.  需要被修改的 symbol reference 在哪\n2.  需要修改成什么\n\n在 relocatable object file 的 `.rel.text` 和 `.rel.data` 中存放了相关的信息，一条这样的信息称作一个 relocation entry，包含的内容为：\n\n-   `offset`: 这个 symbol reference 相对于其所在的 section 的偏移量。也就是说，在这个 reference 所在的 section 的地址的基础上加上 `offset` 就得到了这个 reference 的地址。\n-   `type`: 有很多种 relocation，CS:APP 中只介绍其中的 `R_X86_64_PC32` 和 `R_X86_64_32` 两种。\n-   `symbol`: 被 reference 的 symbol 在 symbol table 中的 index。\n-   `addend`: 计算 symbol 地址时加在最后的常数（见后文）。\n\n简单来说，`R_X86_64_32` 使用绝对地址进行定位，`R_X86_64_PC32` 使用相对于 PC 的地址进行定位，且这两种类型的 relocation 都只支持 32 位的地址（如果一个程序的大小超过 2GB，就需要指定编译选项 `-mcmodel=medium/large`）。\n\n-   `R_X86_64_32`: 修改后的 reference 为 symbol 的地址加上 `addend`\n-   `R_X86_64_PC32`: 修改后的 reference 为 symbol 的地址与 reference 的地址之差加上 `addend`；需要注意的是，是与 reference 的地址之差，而不是与执行到 reference 所在语句时的 PC 之差，所以通常会需要通过 `addend` 来修正\n\n可以使用 `objdump -dx` 以在反汇编结果中显示 relocation entry，或者使用 `readelf -r` 显示所有 relocation entry。\n\n例如，使用 GCC 8.5 编译\n\n```c\nint foo(int *arr);\n\nint a[3] = {1, 2, 3};\nint *b = &a[2];\n\nint bar()\n{\n    return foo(&a[1]);\n}\n```\n\n`readelf -r`:\n\n```\nRelocation section '.rela.text' at offset 0x250 contains 2 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000001  000a0000000a R_X86_64_32       0000000000000008 a + 4\n000000000006  000b00000002 R_X86_64_PC32     0000000000000000 foo - 4\n\nRelocation section '.rela.data' at offset 0x280 contains 1 entry:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000000  000a00000001 R_X86_64_64       0000000000000008 a + 8\n```\n\n在 `.rela.text` 中，`a` 的 `addend` 是 `4`，是直接得到 `a[1]` 而非 `a[0]` 的地址；`foo` 的 `addend` 是 `-4`，是因为 reference 的地址是 reference 所在的 `jmp` 指令的下一条指令的地址减 4，导致 PC 的地址加上 `foo` 的地址减去 reference 的地址得到的是 `foo` 的地址加 4，需要 `addend` 来修正。\n\n## Executable Object Files\n\n可执行文件的内容大体上和 relocatable object file 类似，主要的区别是：\n\n-   在 ELF header 中指定了程序的 entry point\n-   有一个 `.init` section，定义了一个简单的函数，用来初始化程序\n-   有一个 program header table，描述了程序文件与内存的对应关系，即要把文件的哪一段映射到内存的哪一段，地址如何对齐，以及每一段的权限（`.init`、`.text`、`.rodata` 的权限为 `r-x`，`.data` 和 `.bss` 的权限为 `rw-`）\n-   `.symtab`、`.debug`、`.line`、`.strtab` 在执行时不会加载到内存中\n-   如果 fully linked，则没有 `.rel` section\n\n## Loading Executable Object Files\n\n在程序运行时，run-time memory image 大致如下图（CS:APP Figure 7.15）所示：\n\n![Linux x86-64 run-time memory image](csapp-fig7.15.png)\n\n（[errata](https://csapp.cs.cmu.edu/3e/errata.html) 中指出，栈的起始地址并不是 $2^{48}-1$。）\n\n因为地址对齐、address-space layout randomization 等原因，实际上的内存结构会与上图有一定的差异，但每一段的相对位置是和图中一致的。\n\nloader 加载可执行文件时，首先创建 memory image，然后根据 program header table 将可执行文件的内容映射到内存中，最后跳转到程序的 entry point。C 语言程序的 entry point 是 `_start` 函数（在 `crt1.o` 中定义）的地址，`_start` 又会调用 `__libc_start_main` 函数（在 `libc.so` 中定义），进行运行环境的初始化，然后调用 `main` 函数，最后对返回值进行处理。\n\n## Dynamic Linking with Shared Libraries\n\n静态库有一些问题：\n\n1.  更新静态库需要重新链接\n2.  每个程序都有一份库的拷贝，会造成空间的浪费\n\n共享库 (shared library) 可以解决这些问题。共享库可以在 run time 或者 load time 被动态链接。动态链接由 dynamic linker 完成。共享库也被称作 shared object，在 Linux 中后缀名为 `.so`，在 Windows 中被叫做 DLL。\n\n共享库在两个层面上被共享：\n\n1.  在文件系统上只有一份 `.so` 文件，而在可执行文件中没有库的拷贝\n2.  在内存中共享库的 `.text` section 的单份拷贝可以被多个进程同时使用\n\n可以用类似于 `gcc -shared -fpic a.c b.c c.c -o libabc.so` 的命令构建共享库。编译选项中 `-shared` 告诉编译器要生成 shared object，`-fpic` 用来生成 [position-independent code](#position-independent-code-pic)。\n\n可以用类似 `gcc main.c ./libabc.so -o main` 的命令来使用共享库。\n\n运行 `main` 时，loader 会在进入 entry point 前在 `.interp` section 中发现 dynamic linker `ld-linux.so`，于是让 dynamic linker 完成共享库的 relocation 并修改程序中的 symbol reference，最后将控制权交还给程序。\n\n## Loading and Linking Shared Libraries from Applications\n\n除了在编译时指定要链接到的共享库并在 load time 链接，也可以在 run time 加载并使用共享库。\n\nC 语言中的相关函数放在 `dlfcn.h` 头文件中，编译时需要 `-ldl` 来使用这些函数：\n\n-   `void *dlopen(const char *filename, int flag)`: 加载共享库\n\n    -   返回值: 成功加载则返回 handle，否则返回 `NULL`\n\n    -   `filename`: 共享库文件名\n\n    -   `flag`: 影响如何处理共享库中引用的 external symbol，必须包含 `RTLD_NOW` 和 `RTLD_LAZY` 两者之一\n\n        -   `RTLD_NOW`: 立即 resolve 所有 external symbol\n        -   `RTLD_LAZY`: 等到运行共享库中的代码时再 resolve external symbol\n        -   `RTLD_GLOBAL`: 之后给其他共享库 resolve external symbol 时可以使用当前这个共享库\n\n        如果编译程序时启用了 `-rdynamic` 选项，在 resolve external symbol 时，除了使用其他加载时启用了 `RTLD_GLOBAL` 选项的共享库，也可以使用程序自身的 global symbol。\n\n-   `void *dlsym(void *handle, char *symbol)`: 获得共享库中某个 symbol 的地址\n\n    -   `symbol`: symbol 名称\n\n    -   返回值: 成功获取则返回 symbol 地址，否则返回 `NULL`\n\n-   `int dlclose(void *handle)`: 关闭共享库\n\n    -   返回值: 成功关闭则返回 `0`，出错则返回 `-1`\n\n-   `const char *dlerror(void)`: 获取最后一次调用 `dlopen` / `dlsym` / `dlclose` 的报错信息，如果最后一次调用没有出错则返回 `NULL`\n\nCS:APP 给出了一份参考代码 [code/link/dll.c](https://csapp.cs.cmu.edu/3e/ics3/code/link/dll.c)。\n\n## Position-Independent Code (PIC)\n\n共享库的一条重要性质是它的代码段在内存中只有一份，而可以被多个进程共享，这就使得它的代码中的 symbol reference 不能在动态链接时被修改，适用于静态链接的 relocation 无法完成，所以共享库的代码需要是 position-independent 的。\n\nPIC 的主要思路基于以下两点：\n\n1.  虽然共享库的代码段是共享的，但数据段是每个进程各有一份的\n2.  无论整个共享库被放到内存的哪个位置，代码段和数据段地址的距离是固定的（这与上一条不矛盾，应该是因为虚存）\n\n因此，可以在数据段中存放效果相当于 relocation 的信息，来间接达到 relocation 的效果。说白了就是，因为没法修改代码段，所以把 symbol 的地址放到数据段里。具体实现中，数据段的开头有一个 *global offset table* (GOT)，表中每一项都是一个地址，可以由 dynamic linker 进行修改，而由于代码段和数据段的地址距离固定，就可以用 PC-relative 的方式寻址到表中的项。\n\nPIC data reference 是简单的，只要在 GOT 中为每个 data symbol (全局或 static 变量) 创建一个表项，在动态链接时由 dynamic linker 修改这些项，而在代码中通过这个表项来间接地进行 data reference，例如 (CS:APP Figure 7.18，`GOT[3]` 中存放了全局变量 `x` 的地址)：\n\n```asm\n    movq Ox2OO8b9(%rip), %rax   # %rax = *GOT[3] = &x\n    addl $0x1, (%rax)           # ++x\n```\n\n如果是本地定义的变量，也可以使用 PC-relative 的定位方式直接引用，而只对外部定义的变量使用 GOT，但编译器也可能选择不做这样的区分而是使用统一的方法来处理。\n\nPIC procedure call 也可以和 data reference 一样处理（可以用 `-fno-plt` 编译选项来这样做），但实际上会使用名为 *lazy binding* 的技术进行优化。\n\n这是因为，链接到一个共享库时，往往最终会调用的只是它提供的大量函数中的一小部分，如果对整个共享库用到的外部函数都在动态链接时计算出相应的 offset，就可能造成浪费。而 lazy binding 则是在第一次调用某个外部函数时绑定这个函数的地址。\n\nlazy binding 基于一个名为 *procedure linkage table* (PLT) 的结构。PLT 位于代码段中，表中的每一项其实是三条指令，如 CS:APP Figure 7.19 所示：\n\n![PLT 原理示意图](csapp-fig7.19.png)\n\n整个流程就是：\n\n1.  调用 `addvec` 时，实际上调用的是 `PLT[2]` 的地址\n2.  `PLT[2]` 的第一条指令会跳转到 `GOT[4]`，`GOT[4]` 里一开始放的是 `PLT[2]` 的第二条指令，所以首次调用 `PLT[2]` 时就从第一条指令跳到第二条指令\n3.  第二条指令是往栈里压入 `addvec` 的 ID，是用来告诉 dynamic linker 这是哪个函数\n4.  第三条指令会跳转到 `PLT[0]` \n5.  `PLT[0]` 的第一条指令是往栈里压入 relocation entries 的地址，第二条指令是跳转到 dynamic linker\n6.  dynamic linker 通过放在栈中的函数的 ID 以及 relocation entries 计算出 `addvec` 的地址，放在 `GOT[4]`，然后跳转到 `addvec`\n7.  因为一路上都是 `jmp`，跳转到 `addvec` 后可以正常返回到调用 `PLT[2]` 的位置\n8.  第二次调用 `PLT[2]` 时，`GOT[4]` 里已经是 `addvec` 的地址，所以就在 `PLT[2]` 的第一条指令处跳转到了 `addvec`\n\n## Library Interpositioning\n\nLinux 的链接器支持一个名为 *library interpositioning* 的技术，可以用来把共享库的函数替换掉，一般会换成一个 wrapper function 用来 trace，但也可以换成完全不同的东西。\n\n看了下中文版 CS:APP，这个东西竟然叫“库打桩”（\n\n编译时的 library interpositioning 就是用 `#define` 换掉某个函数 ~~，在机房里被 `#define sort random_shuffle` 过的大家想必对此非常熟悉~~。\n\n链接时的 library interpositioning 是给 linker 传参 `--wrap foo`，然后调用 `foo` 就会实际上调用 `__wrap_foo`，而调用 `__real_foo` 则会调用原本的 `foo`。一般会给 `gcc` 而非 `ld` 传参，就是用 `gcc -Wl,--wrap,foo` 代替 `ld --wrap foo`，其中 `-Wl` 表示给 linker 传参，后面的逗号会被换成空格。\n\n运行时的 library interpositioning 是在运行程序时设置环境变量 `LD_PRELOAD=\"/path/to/wrapper.so /path/to/anotherwrapper.so\"`，然后在使用任意共享库中的函数之前就会优先尝试使用 `wrapper.so` 和 `anotherwrapper.so`。这时，为了能在 wrapper function 中调用原本的函数，就需要 [在运行时加载共享库](#loading-and-linking-shared-libraries-from-applications)。\n\n如果想看具体实现，可以参考 CS:APP。\n\n编译时的 library interpositioning 需要修改源代码，链接时的 library interpositioning 需要获取到 object file 并重新链接得到可执行文件，而运行时 library interpositioning 只需要设置环境变量，不需要对可执行文件进行任何修改，可以方便地对很多不同程序的某个函数调用进行跟踪。\n"},{title:k,tags:"gcc 性能优化 问题解决记录",content:`在学习 [浮点数精度转换指令](/post/2022/09/csapp-3#浮点数精度转换) 时，CS:APP 里提到 gcc 并不使用 \`vcvtss2sd\`/\`vcvtsd2ss\`，而是使用 \`vunpcklps\` & \`vcvtps2pd\` / \`vmovddup\` & \`vcvtpd2psx\`，但是我使用 gcc 12.2.0 编译得到的结果就是 \`vcvtss2sd\`/\`vcvtsd2ss\`。对此，CS:APP 没有深究：

> It is unclear why GCC generates this code. There is neither benefit nor need to have the value duplicated within the XMM register.

但是 CS:APP 选择放弃反而会激发读者的斗志啊（

虽然但是，我确实没想到这玩意会让我断断续续搞了三天，ddl 又要寄了 🌚



## 问题描述

这一问题可以由下面的代码所展示：

\`\`\`c
double f2d(float x)
{
    return x;
}

float d2f(double x)
{
    return x;
}

double fp2d(float *x)
{
    return *x;
}

float dp2f(double *x)
{
    return *x;
}
\`\`\`

它编译成汇编的结果有如下几种：

<Card title="编译结果" fold>

汇编中不重要的部分已省去。

A:

\`\`\`asm
f2d:
    cvtss2sd    %xmm0, %xmm0
    ret
d2f:
    cvtsd2ss    %xmm0, %xmm0
    ret
fp2d:
    pxor        %xmm0, %xmm0
    cvtss2sd    (%rdi), %xmm0
    ret
dp2f:
    pxor        %xmm0, %xmm0
    cvtsd2ss    (%rdi), %xmm0
    ret
\`\`\`

B：

\`\`\`asm
f2d:
    unpcklps    %xmm0, %xmm0
    cvtps2pd    %xmm0, %xmm0
    ret
d2f:
    unpcklpd    %xmm0, %xmm0
    cvtpd2ps    %xmm0, %xmm0
    ret
fp2d:
    movss       (%rdi), %xmm0
    cvtps2pd    %xmm0, %xmm0
    ret
dp2f:
    movq        (%rdi), %xmm0
    cvtpd2ps    %xmm0, %xmm0
    ret
\`\`\`

A with AVX2：

\`\`\`asm
f2d:
    vcvtss2sd   %xmm0, %xmm0, %xmm0
    ret
d2f:
    vcvtsd2ss   %xmm0, %xmm0, %xmm0
    ret
fp2d:
    vxorps      %xmm0, %xmm0, %xmm0
    vcvtss2sd   (%rdi), %xmm0, %xmm0
    ret
dp2f:
    vxorps      %xmm0, %xmm0, %xmm0
    vcvtsd2ss   (%rdi), %xmm0, %xmm0
    ret
\`\`\`

B with AVX2：

\`\`\`asm
f2d:
    vunpcklps   %xmm0, %xmm0, %xmm0
    vcvtps2pd   %xmm0, %xmm0
    ret
d2f:
    vmovddup    %xmm0, %xmm0
    vcvtpd2psx  %xmm0, %xmm0
    ret
fp2d:
    vmovss      (%rdi), %xmm0
    vcvtps2pd   %xmm0, %xmm0
    ret
dp2f:
    vmovq       (%rdi), %xmm0
    vcvtpd2psx  %xmm0, %xmm0
    ret
\`\`\`

</Card>

| 函数 |          A          |            B            |      A with AVX2       |        B with AVX2        |
| :--: | :-----------------: | :---------------------: | :--------------------: | :-----------------------: |
| f2d  |     \`cvtss2sd\`      | \`unpcklps\` & \`cvtps2pd\` |      \`vcvtss2sd\`       | \`vunpcklps\` & \`vcvtps2pd\` |
| d2f  |     \`cvtsd2ss\`      | \`unpcklpd\` & \`cvtpd2ps\` |      \`vcvtsd2ss\`       | \`vmovddup\` & \`vcvtpd2psx\` |
| fp2d | \`pxor\` & \`cvtss2sd\` |  \`movss\` & \`cvtps2pd\`   | \`vxorps\` & \`vcvtss2sd\` |  \`vmovss\` & \`vcvtps2pd\`   |
| dp2f | \`pxor\` & \`cvtsd2ss\` |   \`movq\` & \`cvtpd2ps\`   | \`vxorps\` & \`vcvtsd2ss\` |  \`vmovq\` & \`vcvtpd2psx\`   |

问题在于，gcc 为什么/在什么情况下会生成如 B 所示的指令。其中，使用两条理解起来都不太容易的指令（\`unpcklps\`、\`cvtps2pd\`）来代替指令集中自带的 \`cvtss2sd\`/\`cvtsd2ss\` 最令人费解。而 source 为指针的另外两个函数是受 [performance - Why don't GCC and Clang use cvtss2sd \\[memory\\]? - Stack Overflow](https://stackoverflow.com/questions/16597587/why-dont-gcc-and-clang-use-cvtss2sd-memory) 启发。

我先尝试了各种关键词用搜索引擎进行搜索，均未找到答案。

## gcc 版本的定位

使用 [Compiler Explorer](https://gcc.godbolt.org/) 进行尝试，很快就能确认，是在 gcc 4.8.5 / 4.9.0 之间行为出现了变化。

于是，我先看了 [gcc 4.9 changes](https://gcc.gnu.org/gcc-4.9/changes.html)，又在 commit log 里大力搜索 “\`cvtss2sd\`” “\`cvtsd2ss\`” “\`unpcklp\`” “floating point” “convert”……都没找到相关内容。

## 具体 commit 的定位：git bisect / 编译 gcc

在各种搜索都失败后，我决定使用 \`git bisect\` 找到行为出现变化的 commit。

要 bisect，就得编译 gcc 4.8.5 ~ 4.9.0，步骤大致如下：

1.  将 gcc 代码 clone 下来: \`git clone https://github.com/gcc-mirror/gcc --branch releases/gcc-4.9 --depth 50000\`
2.  创建 \`build\` 目录
3.  在 \`build\` 目录下运行 \`gcc\` 仓库根目录的 \`configure\` 脚本
4.  在 \`build\` 目录下运行 \`make\`

其中，\`configure\` 的配置可以参考 [Installing GCC: Configuration - GNU Project](https://gcc.gnu.org/install/configure.html)，但我只是 bisect 一下，就没仔细研究。

过程中走的弯路就不一一细说了，只说一下最终的解决方案中遇到的几个主要问题。

最终的编译命令为:

\`\`\`sh
CC=gcc-4.8
CXX=g++-4.8
make distclean
../gcc/configure --enable-languages=c --disable-multilib --disable-libsanitizer
make -j$(nproc)
\`\`\`

### 语言标准问题

因为编译的是多年前的 gcc 4.8~4.9，用现在的编译器会遇到一些语言标准不同的问题。修改编译选项大概能解决问题，但改起来麻烦，也不见得能解决所有问题，不如直接用旧版 gcc 来编译。

~~但是现在目标就是编译旧版 gcc，你哪来的旧版 gcc 用来编译？~~

用旧版 gcc 解决编译旧版 gcc 遇到的问题看起来很矛盾，但我们要解决的是编译两个版本之间的一堆 commit，而获得一个用来编译的旧版 gcc 只需要一个 gcc release 的可执行文件。这个用来编译的旧版 gcc 可以用各种方式下载一个，而我用的是 Arch Linux，就装了 [AUR 里的 gcc48](https://aur.archlinux.org/packages/gcc48)。

获得了一个旧版 gcc 后，运行 \`configure\` 时修改环境变量 \`CC\` 和 \`CXX\` 即可使用。

P.S. 我本来想用 AUR 的 PKGBUILD 来编译，但能编译 release 不代表能编译各个 commit，然后踩各种坑踩了半天..

### struct ucontext

还会遇到一个编译错误: \`md-unwind-support.h:65:47: error: dereferencing pointer to incomplete type 'struct ucontext'\`

将相应代码中的 \`ucontext\` 修改为 \`ucontext_t\` 即可。

reference: [How to compile gcc 6.4.0 with gcc 7.2 in Archlinux - Stack Overflow](https://stackoverflow.com/questions/46999900/how-to-compile-gcc-6-4-0-with-gcc-7-2-in-archlinux)

### libsanitizer

还会遇到一些编译错误，在搜索其中一个的解决方案时，我找到了 [一次令人吐血的 ubuntu 源码安装 gcc-5.4.0 经历\\_亿零贰肆的博客-CSDN 博客\\_ubuntu 安装 gcc5.4.0](https://blog.csdn.net/tuibianhuaisheng/article/details/115399019)。

这篇博客也提到了上面说的 \`struct ucontext\` 的问题，而仔细一看就会发现，剩下其他问题全都是 \`libsanitizer\` 里的，而我研究这个问题不需要 \`libsanitizer\`，直接 \`--disable-libsanitizer\` 就能解决这一堆编译错误还能缩短编译用时。

### make distclean

修改各种选项或者更换 commit 后，如果直接 \`make\` 容易出问题，可以先 \`make distclean\` 来重置。

### git bisect

在处理完上面几个问题之后，编译就很顺利了。在我 8C16T 的 AMD Ryzen 7 4800H 上，编译一次大约需要 9min。

需要注意的是，因为原问题可以看成是在更老的版本出现，即新版本 good 老版本 bad，但 \`git bisect\` 默认是老版本 good 新版本 bad，这里容易搞反，需要注意。（\`git bisect\` 可以把 good/bad 改成 old/new，但我懒得（研究怎么）改了。）

bisect 找到的 commit 是 [915e8e6e](https://github.com/gcc-mirror/gcc/commit/915e8e6eec05fb595d445cb738e4875d607ce126)。

从这个 commit 的内容可以得知，那些看起来有些奇怪的编译结果是一个叫做 \`use_vector_fp_converts\` 的优化的结果。这个 commit 使得这个优化只对 amdfam10 架构生效，在新版 gcc 中仍可使用 \`-mtune=amdfam10\` 选项观察到这一行为（也可以使用 \`-mtune-ctrl=use_vector_fp_converts\` 来启用这个优化）。代码中对这一优化给出的理由是 “avoids partial write to the destination”，也就是说 \`cvtss2sd\`/\`cvtsd2ss\` 只修改目标寄存器的低位，可能导致效率低。

## 优化最终被关闭的原因

锁定了问题出现的 commit，接下来就是搜索这个 commit 修改的原因了。

[在 \`gcc-patches\` 里搜索 \`use_vector_fp_converts\`](https://www.mail-archive.com/search?l=gcc-patches%40gcc.gnu.org&q=use_vector_fp_converts)，然后再顺着邮件内容找，就可以找到相关邮件：

-   [\\[Google\\] X86_TUNE_USE_VECTOR_CONVERTS adjustment](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg59433.html)
-   [\\[PATCH\\] disable use_vector_fp_converts for m_CORE_ALL](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg61372.html) ([157ca3e9](https://github.com/gcc-mirror/gcc/commit/157ca3e989605194001568cc1864603b32fbd025))
-   [Revisit Core tunning flags](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg62058.html)
-   [Re: \\[PATCH i386\\]: Enable push/pop in pro/epilogue for modern CPUs](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg46926.html)

令我自闭的是..直接搜索 \`cvtss2sd\`/\`cvtsd2ss\` 就能搜到这些邮件 😵 为什么 bisect 出来才想着在邮件列表里搜呢...（低情商：wssb；高情商：还是 mailing list 使用经验不足 😢）

总结一下这些邮件的内容，就是：

1.  在一些 Intel CPU 上，某些 test case 上启用 \`use_vector_fp_converts\` 更快，另一些 test case 上不启用更快。
2.  在启用 \`use_vector_fp_converts\` 更快的 test case 上，可以通过在 \`cvtss2sd\`/\`cvtsd2ss\` 之前将 XMM 寄存器清空（\`pxor %xmm0, %xmm0\`）以避免只更新低位带来的性能损失，从而达到和启用 \`use_vector_fp_converts\` 差不多的性能。所以 [157ca3e9](https://github.com/gcc-mirror/gcc/commit/157ca3e989605194001568cc1864603b32fbd025) 就对 \`m_CORE_ALL\` 关闭了这个优化并且在需要时先将 XMM 寄存器清空。
3.  在 [Re: \\[PATCH\\] disable use_vector_fp_converts for m_CORE_ALL](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg62712.html) 中，Honza 表示可以先把上面那个 patch commit 了，他测试一下再决定是否对 \`m_GENERIC\` 也关闭这个优化，所以 157ca3e9（对 \`m_CORE_ALL\` 关闭优化并在需要时清空 XMM）和 915e8e6e（对 \`m_GENERIC\` 关闭优化）分成了两个 commit。

## 优化最初被添加的原因

继续追根溯源下去，通过 \`git blame\` 来找到一开始添加这个优化的原因。

首先找到 [54723b46](https://github.com/gcc-mirror/gcc/commit/54723b46231868447f68ed5322d916bd05bffae3)，这个 commit 将 \`TARGET_USE_VECTOR_FP_CONVERTS\` 从 \`TARGET_USE_VECTOR_CONVERTS\` 中抽离出来成为单独的优化开关。

然后找到 [4845dbb5](https://github.com/gcc-mirror/gcc/commit/4845dbb50ed31ad03c579364e4b70bbe90e7af99)，这个 commit 添加了 \`X86_USE_VECTOR_CONVERTS\`，即 \`X86_TUNE_USE_VECTOR_FP_CONVERTS\` 的前身。

4845dbb5 的邮件是 [SSE conversion optimization](https://gcc.gnu.org/pipermail/gcc-patches/2007-September/225078.html)，里面写的很简略，就是 “Amdfam10 preffers doing packed conversions destinating SSE register rather than scalar”。

只不过 [performance - Why don't GCC and Clang use cvtss2sd \\[memory\\]? - Stack Overflow](https://stackoverflow.com/questions/16597587/why-dont-gcc-and-clang-use-cvtss2sd-memory) 里还是有一些解释的，反正简单来说就是 partial regisiter update 会有性能损失。

## 对 m_CORE_ALL、m_GENERIC 启用优化的原因

可以发现，一开始有这个优化时，是只对 \`m_AMDFAM10\` 启用的，这和现在是一样的，为什么中间绕了一圈又回到最开始的选择呢？继续寻找对 \`m_CORE_ALL\` 和 \`m_GENERIC\` 启用这个优化的原因。

首先找到 [3ad20bd4](https://github.com/gcc-mirror/gcc/commit/3ad20bd44836e57453b743466f1ca0d591bd10ac)，这个 commit 把相关代码挪了个位置。

然后找到 [3a579e09](https://github.com/gcc-mirror/gcc/commit/3a579e0930abe3ed91977a71284021399339860c)，这个 commit 把 \`m_CORE2I7\` 改成了 \`m_CORE_ALL\`。

然后找到 [3a4ffde6](https://github.com/gcc-mirror/gcc/commit/3a4ffde68cfc6fee3c20d282d6690f2569e2fffa)，这个 commit 修改了一堆处理器架构的 bitmask，然后..把 \`m_AMDFAM10\` 和 \`m_CORE2I7\` 换了个位置 🤔

然后找到 [ab247762](https://github.com/gcc-mirror/gcc/commit/ab2477624b15b5d1fe43972f8f4d6082c6893624)，这个 commit 新增了 \`m_CORE2I7\` 架构并且为它启用了 \`X86_TUNE_USE_VECTOR_FP_CONVERTS\`。这个 patch 的邮件是 [0005-Switch-Core-2-to-new-tuning](https://gcc.gnu.org/pipermail/gcc-patches/2010-November/300958.html)，给出的原因是 Core 2/i7 比较适合使用 generic tuning，而此时 \`X86_TUNE_USE_VECTOR_FP_CONVERTS\` 是对 \`m_GENERIC\` 启用的，就也对 \`m_CORE2I7\` 启用了。

这时再回头看上面找到的 [54723b46](https://github.com/gcc-mirror/gcc/commit/54723b46231868447f68ed5322d916bd05bffae3)，这个 commit 将 \`TARGET_USE_VECTOR_CONVERTS || TARGET_GENERIC\` 改成了 \`TARGET_USE_VECTOR_FP_CONVERTS\`，所以要 blame 这个 \`|| TARGET_GENERIC\`。

最后找到是 [bf019a1f](https://github.com/gcc-mirror/gcc/commit/bf019a1f7f992a1feb985c4b656e527475e73a30) 添加了 \`|| TARGET_GENERIC\`。这个 patch 的邮件是 [PR target/33396](https://gcc.gnu.org/pipermail/gcc-patches/2007-September/225425.html)，时间上紧跟着最初的 4845dbb5，而 changelog 和邮件里只提到了添加 \`TARGET_SSE_MATH\` 而没有提到添加 \`TARGET_GENERIC\` 的原因，并且这封邮件还没人回复。

至此，我已经不知道能如何继续探究下去了。我感觉可能是：

1.  [SSE conversion optimization](https://gcc.gnu.org/pipermail/gcc-patches/2007-September/225078.html) 中提到 “We are now testing if the patch is good for generic”，可能他自己测试之后因为某些原因得到了这个优化 good for generic 的结论，就 commit 了，也没再解释；
2.  或者是，[PR target/33396](https://gcc.gnu.org/pipermail/gcc-patches/2007-September/225425.html) 里提到了 “failure with 32bit generic”，可能是测试的时候加上了 \`TARGET_GENERIC\`，后来忘记删掉了 🤔
3.  或者是，有什么其他原因，但忘记写在 log / 邮件里了，或者写在某个隐秘的角落我没找到。

反正不管是什么原因，bf019a1f 都是一个 commit 做了两件事，还只写了一件事的 changelog，导致这成了一个谜。

## 与其他编译器的对比

使用 [Compiler Explorer](https://gcc.godbolt.org/) 看一下其他编译器是怎么做的。

clang: 无论是否 \`-mtune=amdfam10\` 都没有 \`use_vector_fp_converts\`。

MSVC: 无论是否 \`-mtune=amdfam10\` 都是 source in register 则 \`cvtss2sd\`/\`cvtsd2ss\`，source in memory 则表现出 \`use_vector_fp_converts\` 的行为。

但是我并不知道如何研究其他编译器为什么做出这样的选择 😢

## 性能测试

最后来实际测试一下这个优化的性能。

测试使用的代码为 [\\[PATCH\\] disable use_vector_fp_converts for m_CORE_ALL](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg61372.html) 中的 \`1.c\` 和 \`2.c\`，但原来的 \`2.c\` 用时太短，所以把循环范围改成了 \`1ll << 32\`：

<Card fold title="测试用代码">

\`1.c\`:

\`\`\`c
float total = 0.2;
int k = 5;

int main()
{
    int i;

    for (i = 0; i < 1000000000; i++)
    {
        total += (0.5 + k);
    }

    return total == 0.3;
}
\`\`\`

\`2.c\`:

\`\`\`c
double b[1024];

float a[1024];

int main()
{
    for(long i = 0 ; i < (1ll << 32); i++)
      a[i & 1023] = a[i & 1023] * (float)b[i & 1023];
    return (int)a[512];
}
\`\`\`

</Card>

测试使用的编译选项有：

1.  \`-O2 -mtune-ctrl=^use_vector_fp_converts\`
2.  \`-O2 -mtune-ctrl=^use_vector_fp_converts -mavx2\`
3.  \`-O2 -mtune-ctrl=use_vector_fp_converts\`
4.  \`-O2 -mtune-ctrl=use_vector_fp_converts -mavx2\`

其中值得注意的是，使用 2 号编译选项编译 \`2.c\` 时会通过将 \`vcvtsd2ss\` 指令的第二个 operand 设为 \`%xmm1\` 来代替 \`pxor %xmm0, %xmm0\` 以达到清空 \`%xmm0\` 的效果。

为了测试清空 XMM 寄存器的效果，在这 4 种编译选项之外，还对 \`2.c\` 增设了手动删掉用于清空 \`%xmm0\` 的指令的两份汇编代码。

所以总共有 10 份汇编代码用于测试：

-   1-1: \`1.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts\`
-   1-2: \`1.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts -mavx2\`
-   1-3: \`1.c\`，\`-O2 -mtune-ctrl=use_vector_fp_converts\`
-   1-4: \`1.c\`，\`-O2 -mtune-ctrl=use_vector_fp_converts -mavx2\`
-   2-1: \`2.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts\`
-   2-2: \`2.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts -mavx2\`
-   2-3: \`2.c\`，\`-O2 -mtune-ctrl=use_vector_fp_converts\`
-   2-4: \`2.c\`，\`-O2 -mtune-ctrl=use_vector_fp_converts -mavx2\`
-   2-5: \`2.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts\`，然后删掉 \`pxor %xmm0, %xmm0\`
-   2-6: \`2.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts -mavx2\`，然后将 \`vcvtsd2ss\` 的第二个 operand 改为 \`%xmm0\`。

<Card fold title="测试用汇编代码">

<Card fold title="1-1">

\`\`\`asm
	.file	"1.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pxor	%xmm1, %xmm1
	movss	total(%rip), %xmm0
	movl	$1000000000, %eax
	cvtsi2sdl	k(%rip), %xmm1
	addsd	.LC0(%rip), %xmm1
	.p2align 4,,10
	.p2align 3
.L2:
	cvtss2sd	%xmm0, %xmm0
	addsd	%xmm1, %xmm0
	cvtsd2ss	%xmm0, %xmm0
	subl	$1, %eax
	jne	.L2
	movss	%xmm0, total(%rip)
	xorl	%edx, %edx
	cvtss2sd	%xmm0, %xmm0
	ucomisd	.LC1(%rip), %xmm0
	setnp	%dl
	cmove	%edx, %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	k
	.data
	.align 4
	.type	k, @object
	.size	k, 4
k:
	.long	5
	.globl	total
	.align 4
	.type	total, @object
	.size	total, 4
total:
	.long	1045220557
	.section	.rodata.cst8,"aM",@progbits,8
	.align 8
.LC0:
	.long	0
	.long	1071644672
	.align 8
.LC1:
	.long	858993459
	.long	1070805811
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="1-2">

\`\`\`asm
	.file	"1.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	vxorps	%xmm1, %xmm1, %xmm1
	vmovss	total(%rip), %xmm0
	movl	$1000000000, %eax
	vcvtsi2sdl	k(%rip), %xmm1, %xmm1
	vaddsd	.LC0(%rip), %xmm1, %xmm1
	.p2align 4,,10
	.p2align 3
.L2:
	vcvtss2sd	%xmm0, %xmm0, %xmm0
	vaddsd	%xmm1, %xmm0, %xmm0
	vcvtsd2ss	%xmm0, %xmm0, %xmm0
	subl	$1, %eax
	jne	.L2
	vmovss	%xmm0, total(%rip)
	xorl	%edx, %edx
	vcvtss2sd	%xmm0, %xmm0, %xmm0
	vucomisd	.LC1(%rip), %xmm0
	setnp	%dl
	cmove	%edx, %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	k
	.data
	.align 4
	.type	k, @object
	.size	k, 4
k:
	.long	5
	.globl	total
	.align 4
	.type	total, @object
	.size	total, 4
total:
	.long	1045220557
	.section	.rodata.cst8,"aM",@progbits,8
	.align 8
.LC0:
	.long	0
	.long	1071644672
	.align 8
.LC1:
	.long	858993459
	.long	1070805811
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="1-3">

\`\`\`asm
	.file	"1.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pxor	%xmm1, %xmm1
	movss	total(%rip), %xmm0
	movl	$1000000000, %eax
	cvtsi2sdl	k(%rip), %xmm1
	addsd	.LC0(%rip), %xmm1
	.p2align 4,,10
	.p2align 3
.L2:
	unpcklps	%xmm0, %xmm0
	cvtps2pd	%xmm0, %xmm0
	addsd	%xmm1, %xmm0
	unpcklpd	%xmm0, %xmm0
	cvtpd2ps	%xmm0, %xmm0
	subl	$1, %eax
	jne	.L2
	movss	%xmm0, total(%rip)
	unpcklps	%xmm0, %xmm0
	xorl	%edx, %edx
	cvtps2pd	%xmm0, %xmm0
	ucomisd	.LC1(%rip), %xmm0
	setnp	%dl
	cmove	%edx, %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	k
	.data
	.align 4
	.type	k, @object
	.size	k, 4
k:
	.long	5
	.globl	total
	.align 4
	.type	total, @object
	.size	total, 4
total:
	.long	1045220557
	.section	.rodata.cst8,"aM",@progbits,8
	.align 8
.LC0:
	.long	0
	.long	1071644672
	.align 8
.LC1:
	.long	858993459
	.long	1070805811
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="1-4">

\`\`\`asm
	.file	"1.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	vxorps	%xmm1, %xmm1, %xmm1
	vmovss	total(%rip), %xmm0
	movl	$1000000000, %eax
	vcvtsi2sdl	k(%rip), %xmm1, %xmm1
	vaddsd	.LC0(%rip), %xmm1, %xmm1
	.p2align 4,,10
	.p2align 3
.L2:
	vunpcklps	%xmm0, %xmm0, %xmm0
	vcvtps2pd	%xmm0, %xmm0
	vaddsd	%xmm1, %xmm0, %xmm0
	vmovddup	%xmm0, %xmm0
	vcvtpd2psx	%xmm0, %xmm0
	subl	$1, %eax
	jne	.L2
	vmovss	%xmm0, total(%rip)
	vunpcklps	%xmm0, %xmm0, %xmm0
	xorl	%edx, %edx
	vcvtps2pd	%xmm0, %xmm0
	vucomisd	.LC1(%rip), %xmm0
	setnp	%dl
	cmove	%edx, %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	k
	.data
	.align 4
	.type	k, @object
	.size	k, 4
k:
	.long	5
	.globl	total
	.align 4
	.type	total, @object
	.size	total, 4
total:
	.long	1045220557
	.section	.rodata.cst8,"aM",@progbits,8
	.align 8
.LC0:
	.long	0
	.long	1071644672
	.align 8
.LC1:
	.long	858993459
	.long	1070805811
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-1">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	leaq	b(%rip), %rdi
	movabsq	$4294967296, %rsi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	pxor	%xmm0, %xmm0
	addq	$1, %rax
	andl	$1023, %edx
	cvtsd2ss	(%rdi,%rdx,8), %xmm0
	mulss	(%rcx,%rdx,4), %xmm0
	movss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	cvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-2">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	vxorps	%xmm1, %xmm1, %xmm1
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	movabsq	$4294967296, %rsi
	leaq	b(%rip), %rdi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	addq	$1, %rax
	andl	$1023, %edx
	vcvtsd2ss	(%rdi,%rdx,8), %xmm1, %xmm0
	vmulss	(%rcx,%rdx,4), %xmm0, %xmm0
	vmovss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	vcvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-3">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	leaq	b(%rip), %rdi
	movabsq	$4294967296, %rsi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	addq	$1, %rax
	andl	$1023, %edx
	movq	(%rdi,%rdx,8), %xmm0
	cvtpd2ps	%xmm0, %xmm0
	mulss	(%rcx,%rdx,4), %xmm0
	movss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	cvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-4">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	leaq	b(%rip), %rdi
	movabsq	$4294967296, %rsi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	addq	$1, %rax
	andl	$1023, %edx
	vmovq	(%rdi,%rdx,8), %xmm0
	vcvtpd2psx	%xmm0, %xmm0
	vmulss	(%rcx,%rdx,4), %xmm0, %xmm0
	vmovss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	vcvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-5">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	leaq	b(%rip), %rdi
	movabsq	$4294967296, %rsi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	addq	$1, %rax
	andl	$1023, %edx
	cvtsd2ss	(%rdi,%rdx,8), %xmm0
	mulss	(%rcx,%rdx,4), %xmm0
	movss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	cvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-6">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	movabsq	$4294967296, %rsi
	leaq	b(%rip), %rdi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	addq	$1, %rax
	andl	$1023, %edx
	vcvtsd2ss	(%rdi,%rdx,8), %xmm0, %xmm0
	vmulss	(%rcx,%rdx,4), %xmm0, %xmm0
	vmovss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	vcvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

</Card>

用于测试的机器有五台，CPU 型号分别为：

-   A: AMD Ryzen 7 4800H with Radeon Graphics （笔记本）
-   B: Intel(R) Xeon(R) CPU E5-2670 v2 @ 2.50GHz （Hostwinds）
-   C: Intel(R) Xeon(R) CPU E5-4610 v2 @ 2.30GHz （THU 校内服务器）
-   D: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz （腾讯云）
-   E: Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz （阿里云）

测试时，将程序运行 10 遍，记录其中第 3 短的用时。

<Card fold title="ssh 远程测试脚本">

\`\`\`bash
#!/bin/bash

eval "$(ssh-agent)"
ssh-add

dir="$(ssh "$1" mktemp -d)"
scp ./*-*.s "$1:$dir"

ssh "$1" 'grep "model name" /proc/cpuinfo | head -n1'

for i in 1-1 1-2 1-3 1-4 2-1 2-2 2-3 2-4 2-5 2-6; do
    echo "$i"
    ssh "$1" gcc "$dir/$i.s" -o "$dir/$i"
    for _ in $(seq 1 10); do
        ssh "$1" /usr/bin/time "$dir/$i"
    done
done

ssh "$1" rm -r "$dir"

ssh-agent -k
\`\`\`

</Card>

测试结果为：

| 代码/用时(s) |  A   |  B   |   C   |  D   |  E   |
| :----------: | :--: | :--: | :---: | :--: | :--: |
|     1-1      | 2.10 | 3.15 | 3.96  | 4.62 | 4.41 |
|     1-2      | 2.10 | 3.11 | 3.95  | 4.61 | 4.42 |
|     1-3      | 3.50 | 3.82 | 4.52  | 5.30 | 5.04 |
|     1-4      | 3.50 | 3.77 | 4.90  | 5.30 | 5.04 |
|     2-1      | 1.62 | 6.47 | 7.22  | 3.59 | 3.43 |
|     2-2      | 1.41 | 6.26 | 7.65  | 4.31 | 4.08 |
|     2-3      | 1.61 | 4.66 | 5.31  | 3.24 | 3.11 |
|     2-4      | 1.61 | 4.76 | 5.69  | 3.59 | 3.43 |
|     2-5      | 1.40 | 9.06 | 10.41 | 7.12 | 6.77 |
|     2-6      | 1.41 | 9.03 | 10.98 | 7.11 | 6.77 |

这数据真的非常让人怀疑是不是测错了（

只能说是大千世界无奇不有，性能优化实在是太玄学了（

但测试似乎表明，source in register 时关闭 \`use_vector_fp_converts\`、source in memory 时开启 \`use_vector_fp_converts\`，也就是 MSVC 的选择，在总体上是比较优的。
`},{title:S,tags:t,content:`[CS:APP](https://csapp.cs.cmu.edu/) 第八章 “Exceptional Control Flow” 的学习笔记。

本章的主要内容为 exception、system call、process、signal、longjmp。



在一般情况下，PC 会按照指令的顺序以及跳转指令来变化。但在很多时候，这样的控制流是不能满足需要的，需要 *exceptional control flow* (ECF) 作为跳转指令的补充，以处理一些“异常”的或者来自“外部”的变化。

ECF 存在于各个层次，例如：

-   硬件监测到事件发生时调用 exception handler
-   操作系统在不同进程之间进行 [context switch](#context-switch)
-   不同进程间通过发送 [signal](#signals) 来调用接收者的 signal handler
-   程序内部通过 [nonlocal jump](#nonlocal-jumps) 来实现错误处理

## Exceptions

*exception* 是由某种“状态改变”（可能是某条指令执行的结果，或者来自外部 I/O 的变化等等）导致的控制流的突变。

处理器检测到这种状态改变后，会调用 *exception handler*，然后跳转到触发前的指令或下一条指令，或者终止整个程序。

### Exception Handling

每种 exception 都会有一个 *exception number*，某些 exception 的 number 由硬件决定，另一些由操作系统决定。

内存中会有一个 *exception table*，以 exception number 为索引，每一项是对应的 exception handler。处理器中有一个 *exception table base register*，用来存 exception table 的起始地址，结合 exception number 就可以对每一项寻址。

exception 与 procedure call 的主要区别有：

-   procedure call 返回到栈顶存储的返回地址，而 exception 返回到触发时的指令或下一条指令，或终止程序。
-   调用 exception handler 时，会保存包括 condition codes 在内的一些处理器状态，在返回时恢复。
-   exception handler 在 [kernel mode](#user-kernel-mode) 下运行，使用的运行栈也是 kernel 的。

### Classes of Exceptions

exception 一般有四种：

-   interrupt: 异步触发（不是某条指令的执行导致了 exception），返回到下一条指令。一般是由外部 I/O 设备触发（设备通过 interrupt pin 告诉处理器有 interrupt，通过 system bus 发送 exception number，处理器在每执行完一条指令后检查 interrupt pin），触发后调用 interrupt handler，再回到原来的位置继续执行下一条指令。
-   trap: 同步触发，返回到下一条指令。比如 [system call](#linux-中的-system-call) 是一种常见的 trap，通过 \`syscall\` 指令主动触发 exception，看上去和函数调用类似，但可以在 kernel mode 下运行。
-   fault: 同步触发，返回到触发 exception 的指令或退出。一般来说，fault handler 会尝试解决导致 fault 发生的问题，如果成功解决则返回到触发 exception 的指令，并且能够不再次触发 exception 而继续执行下去；如果没能成功解决，则 abort。
-   abort: 同步触发，一定退出。一般代表严重的不可恢复的错误。

### Exceptions in Linux/x86-64 Systems

#### x86-64 中的 fault / abort

-   Divide Error Exception (Interrupt 0): 除以零。它是 fault，但实际上 Linux 不会尝试从 divide error 中恢复，而是会直接 abort，一般会显示为 “floating point exception”。
-   General Protection Exception (Interrupt 13): 有多种触发原因，例如访问未定义的内存，尝试写入只读的内存段。Linux 也不会尝试从中恢复，而是会直接 abort，一般会显示为 “segmentation fault”。
-   Page-Fault Exception (Interrupt 14): page fault 是一个名副其实的 fault，会尝试恢复，详见[第九章](/post/2022/11/csapp-9)。
-   Machine-Check Exception (Interrupt 18): 严重的硬件错误，是 abort。

（完整列表参见 [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html) Volume 3A 的 “6.15 EXCEPTION AND INTERRUPT REFERENCE” 一节。）

#### Linux 中的 system call

Linux 中常用的一些 system call 如 CS:APP Figure 8.10 所示：

![Linux 中常用的一些 system call](csapp-fig8.10.png)

（更多 system call 参见 \`man syscalls\`）

在 C 语言中，可以使用 \`syscall\` 函数来调用 system call，但一般不这样做，而是使用每个 system call 对应的 wrapper function。\`syscall\` 和 wrapper function 统称为 *system-level function*。

## Processes

一个系统中会有很多进程同时运行，但营造出了每个进程都独占了处理器和内存的假象。

进程独占内存的假象是通过每个进程的 private address space 实现的，详见[第九章](/post/2022/11/csapp-9)。

### Logical / Concurrent Flow

根据一个程序的指令得到的 control flow 称作 *logical (control) flow*。系统会在不同的进程间来回切换，从一个进程切换出去称作将这个进程 *preempt*。

如果两个 control flow 的存活时间有重叠，则称它们是 *concurrent flow* 或它们 *run concurrently*。这种现象被称作 *concurrency*，也被称作 *multitasking*。每次连续执行的同一个 logical flow 中的一段称作一个 *time slice*，所以 multitasking 也被称作 *time slicing*。如果两个 logical flow 在不同的 processor core 上运行，则称它们是 *parallel flow*，*run in parallel*。

### User / Kernel Mode

在处理器中存有一个 *mode bit*，表示当前是 user mode 还是 kernel mode。只有在 kernel mode 下才能执行某些 *privileged instruction*、修改 mode bit、访问地址空间中属于 kernel 的区域。

user mode 的程序只能通过 exception 来进入 kernel mode，以执行 privileged instruction 或者访问 kernel 的数据。在 Linux 中，也可以在 user mode 下访问 \`/proc\`、\`/sys\` 来获得一些 kernel 的数据。

### Context Switch

每个进程都有一个 *context*，包括寄存器内容、PC、user stack、kernel stack、condition codes、page table、process table、file table 等等。

操作系统通过 *context switch* 来在不同进程间切换，即保存当前进程的 context，恢复要切换到的进程的 context，最后切换过去。context switch 在 exception 中发生，处理 exception 时操作系统中的 *scheduler* 会决定是否进行 context switch，schedule 到哪个进程。例如：

-   在通过 system call 读取文件时进行 context switch，以在等待读取文件时先执行其他进程；读取到文件后在 interrupt 中再 context switch 回来。
-   系统会周期性地（例如每 1ms）触发 interrupt，从而可以在一个进程执行了一段时间后进行 context switch。

因为程序不知道操作系统会如何 schedule，一般来说，不同进程的执行顺序是没有保证的。

## System Call Error Handling

system-level function 一般以返回 -1 代表出错，而将具体的错误记录在全局整型变量 \`errno\` (\`#include <errno.h>\`)，函数 \`strerror\` 可以用来根据 \`errno\` 得到文字错误信息。

调用 system-level function 时应当检查错误。为了使错误处理更加简便，可以使用类似下面的 wrapper function：

\`\`\`c
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void unix_error(char *msg)
{
    fprintf(stderr, "%s: %s\\n", msg, strerror(errno));
    exit(errno);
}

pid_t Fork(void)
{
    pid_t pid = fork();

    if (pid < 0)
        unix_error("Fork error");

    return pid;
}
\`\`\`

## Process Control

C 语言中有很多用来控制 Unix 进程的函数。

### 获取 PID

每个进程都有一个 PID。

-   \`pid_t getpid(void)\`: 返回当前进程的 PID
-   \`pid_t getppid(void)\`: 返回当前进程的 parent 的 PID

### 进程的状态

每个进程可能处于三种状态之一：

1.  Running: 正在运行中，会被 schedule。
2.  Stopped: 被 suspend 了，不会被 schedule。Stopped 可能是 SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU 导致的，可以由 SIGCONT 恢复运行。
3.  Terminated: 进程永久地结束了，可能是从 \`main\` 函数返回、调用了 \`exit\` 函数或者收到了某些 signal。

-   \`void exit(int status)\`: 以某个 exit status 将当前进程 terminate

### fork

-   \`pid_t fork(void)\`: 创建子进程

fork 会将当前进程的所有状态复制一份创建一个新的进程，新的进程有着和原来相同的代码、数据、文件（例如 \`stdout\`），但 PID 不同，并且后续对数据的修改是和原进程独立的。

fork 会调用一次，返回两次，分别在两个进程中返回，在 parent 中返回 child 的 PID，在 child 中返回 0，出错则返回 -1。

fork 出的进程和原进程在接下来会执行同一份代码，所以一般会判断 \`fork\` 的返回值是否为 0 来让两个进程执行不同的分支。

### process group

每个进程会属于一个 process group，每个 process group 有一个 ID。

创建子进程时，子进程会默认处于 parent 的 process group。

-   \`pid_t getpgrp(void)\`: 返回当前进程的 process group ID
-   \`int setpgid(pid_t pid, pid_t pgid)\`: 将 \`pid\` 对应的进程的 progress group ID 修改为 \`pgid\`，\`pid\` 为 0 表示当前进程，\`pgid\` 为 0 表示修改为 \`pid\` 对应的进程的 PID

### wait

-   \`pid_t waitpid(pid_t pid, int *statusp, int options)\`: 等待子进程结束
-   \`pid_t wait(int *statusp)\`: \`waitpid(-1, statusp, 0)\`

#### waitpid 的 pid 参数

参数 \`pid\` 决定了要等待的是哪些子进程：

-   -1: 所有子进程
-   \\> 0: PID 为 \`pid\` 的子进程
-   0: process group 与当前进程相同的子进程
-   \\< -1: process group ID 为 \`-pid\` 的子进程

#### waitpid 的行为 (options)

默认情况下，\`waitpid\` 会等待到有某个被等待的子进程 terminate 再返回，\`options\` 可以改变这一行为，其值可以包含下列 flag：

-   \`WNOHANG\`: 立即返回，如果没有符合条件的子进程则返回 0
-   \`WUNTRACED\`: 除了 terminate，子进程 stop 也可以结束等待
-   \`WCONTINUED\`: 除了 terminate，子进程从 stopped 中 continue 也可以结束等待

#### reap

除了等待，wait 还会将 terminated 的子进程 *reap*，即彻底清除掉。没有被 reap 但 terminated 的进程被称作 *zombie*，会占用一定的系统资源。在 \`ps\` 中，zombie 显示为 \`[defunct]\`。

如果 parent terminate 了，没有 terminate 的子进程会被设置为 PID 为 1 的 \`init\` 进程的子进程，而 zombie 子进程则会被 \`init\` reap。

#### wait 获取子进程的 status

如果 \`statusp\` 参数不是 \`NULL\`，在 \`waitpid\` 返回时 \`*statusp\` 内就会存有引起等待结束的那个子进程的信息。

有一系列 macro 可以用来提取 status 中的信息（参数是 \`*statusp\`，不是指针）：

-   \`WIFEXITED(status)\`: 是否正常退出 (从 \`main\` 函数返回或调用了 \`exit\` 函数)
-   \`WEXITSTATUS(status)\`: 如果正常退出，则返回 exit status (\`main\` 函数返回值 / \`exit\` 函数参数)
-   \`WIFSIGNALED(status)\`: 是否由某个 signal terminate
-   \`WTERMSIG(status)\`: 如果是由某个 signal terminate，返回这个 signal
-   \`WIFSTOPPED(status)\`: 是否被 stop
-   \`WSTOPSIG(status)\`: 如果被 stop，返回使其 stop 的 signal
-   \`WIFCONTINUED(status)\`: 是否被 continue

#### wait 的报错

出错时 wait 会返回 -1，\`errno\` 可能是 \`ECHILD\` 表示被等待的子进程集合为空，可能是 \`EINTR\` 表示 wait 函数被某个 signal 中断了。

wait 会在每有一个子进程结束时返回，但子进程全部结束时会报错 \`ECHILD\`，可以利用这一点通过 \`while\` 循环来等待所有子进程全部结束。

### sleep

-   \`unsigned int sleep(unsigned int secs)\`: sleep 若干秒，返回剩余应当 sleep 的秒数（正常情况下没被 interrupt 就是 0）
-   \`int pause(void)\`: 一直 sleep，直到被 signal interrupt，总是返回 -1

### execve

-   \`int execve(const char *filename, char *const argv[], char *const envp[])\`

\`execve\` 会以 \`argv\` 作为参数、\`envp\` 作为环境变量，在当前进程内执行 executable object file \`filename\`。可以和 \`fork\` 配合来在子进程内执行其他程序。

\`argv\` 是一个以 \`NULL\` 为结尾的字符串数组，表示各个参数，其中第一个一般是程序的名称。

\`envp\` 也是以 \`NULL\` 为结尾的字符串数组，每个字符串形如 \`name=value\`。

有一些函数可以用来获取、设置环境变量：

-   \`char *getenv(const char *name)\`: 返回 \`NULL\` 或环境变量的值
-   \`int setenv(const char *name, const char *newvalue, int overwrite)\`: 成功则返回 0，失败（\`overwrite\` 为 0 而 \`name\` 已存在）则返回 -1
-   \`void unsetenv(const char *name)\`

## Signals

### signal 的种类

可以用 \`man signal.7\` 查看 signal 的列表（名称、语义、编号、默认行为）。

特别地：

-   除以零时会被发送 SIGFPE
-   执行非法指令时会被发送 SIGILL
-   非法访问内存时会被发送 SIGSEGV
-   按 Ctrl+C 时 foreground process group 会被发送 SIGINT
-   子进程 terminate 时会向 parent 发送 SIGCHLD
-   可以通过 SIGKILL 来强行 terminate 一个进程

### signal 的工作流程

-   每个进程会记录每个 signal 是否 *pending*、是否 *blocked*
-   发送 signal 会使接收者的这个 signal 变为 pending
-   进程可以改变每个 signal 的 blocked 状态
-   在切换到 user mode 执行进程时，如果一个 signal 处于 pending 状态且没有被 blocked，就会接收这个 signal，并设为没有在 pending

这意味着：

-   signal 只记录是否 pending，不会记录发送了几次，在被接收前多次发送只会被接收一次
-   在 blocked 状态下被发送 signal，会在 unblock 时收到

### 发送 signal

#### kill 命令

可以用 \`kill\` 命令在 shell 中向指定的进程发送信号。一般 shell 会有 builtin 的 \`kill\`，也有位于 \`/usr/bin/kill\` 的 \`kill\`，可能有一定的区别。

基础的 \`kill\` 命令形如 \`kill -sig pid\`，其中 \`-sig\` 可以形如 \`-INT\`/\`-SIGINT\`/\`-2\`，而 \`pid\` 表示要把信号发送给：

-   \\> 0: PID 为 \`pid\` 的进程
-   0: process group 和当前进程相同的进程
-   -1: 除 PID 为 1 的 \`init\` 外的所有进程
-   \\< 0: process group ID 为 \`-pid\` 的进程

这与 [waitpid 的 pid 参数](#waitpid-的-pid-参数) 是类似的。

#### 在 shell 中使用键盘发送 SIGINT / SIGTSTP

shell 中会有至多一个 foreground job 和零个或若干个 background job。shell 会给每个 job 中的所有进程指定同样的 process group。

Ctrl+C 会向 foreground group 发送 SIGINT，Ctrl+Z 会向 foreground group 发送 SIGTSTP。

#### 使用函数发送 signal

-   \`int kill(pid_t pid, int sig)\`: 与 [kill 命令](#kill-命令)类似
-   \`unsigned int alarm(unsigned int secs)\`: 让 kernel 在 \`secs\` 秒后向当前进程发送 SIGALRM；如果有尚未发送的 alarm 则取消掉，如果 \`secs\` 为 0 则取消后不会发送新的 SIGALRM；没有尚未发送的 alarm 则返回值是 0，否则是被取消的 alarm 还剩的秒数

### 设置 signal handler

除了 SIGKILL 和 SIGSTOP，其他 signal 的行为可以被改变。

\`\`\`c
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
\`\`\`

函数 \`signal\` 用来改变处理 signal \`signum\` 的方式。\`handler\` 可以是一个函数指针，也可以是 \`SIG_IGN\` 表示无视这个 signal，或者 \`SIG_DFL\` 表示使用这个 signal 的默认行为。

有 handler 时，接收到一个 signal 就会触发 exception 来执行 handler，在 handler 结束时一般会返回到原来的指令。

在执行 handler 的过程中，相应的 signal 会被 block，但 handler 可以被其他类型的 signal interrupt，在处理完这另一个 signal 后返回到一开始的 handler。

### block / unblock signal

进程可以主动 block / unblock 指定的 signal：

-   \`int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)\`

其中 \`how\` 是 \`SIG_BLOCK\` / \`SIG_UNBLOCK\` / \`SIG_SETMASK\`，分别表示 block \`set\` 里的 signal / unblock \`set\` 里的 signal / 将 blocked set 设为 \`set\`。

若 \`oldset\` 不是 \`NULL\`，则会将修改前的 blocked set 存下来。

还有一些用来设置 \`sigset_t\` 的函数：

-   \`int sigemptyset(sigset_t *set)\`: 将 \`set\` 设为空
-   \`int sigfillset(sigset_t *set)\`: 将 \`set\` 设为所有 signal
-   \`int sigaddset(sigset_t *set, int signum)\`: 将 \`signum\` 加入 \`set\`
-   \`int sigdelset(sigset_t *set, int signum)\`: 将 \`signum\` 从 \`set\` 中删去
-   \`int sigismember(const sigset_t *set, int signum)\`: 检查 \`signum\` 是否在 \`set\` 中，返回 0/1 或出错返回 -1

### 编写、使用 signal handler

#### 编写安全的 signal handler

由于 signal handler 和主程序并行运行、共享数据，并且主程序可能在意想不到的地方接收到 signal 而被 interrupt，编写安全的 signal handler 是困难的，一般要遵循下面的守则：

0.  handler 应当尽量简单，例如可以设置一个 flag 而在主程序中检查 flag 并进行处理，而非直接在 handler 中处理
1.  在 handler 中只调用 async-signal-safe 的函数（函数列表参见 \`man signal-safety\`），常用的 \`printf\`、\`sprintf\`、\`malloc\`、\`exit\` 都不是 async-signal-safe 的
2.  存储并恢复 \`errno\`，保证调用 handler 前后 \`errno\` 不变
3.  访问 handler 与主程序共享的数据时，block signal 以防止在访问的中途被 interrupt
4.  把在 handler 中修改而在主程序中访问的的全局变量声明为 \`volatile\` 的，防止编译器误认为变量没有被修改而错误地进行优化
5.  将 flag 声明为 \`sig_atomic_t\` 类型，它的单次访问是 atomic 的，不会被 interrupt（但先读后写是两次访问，可能被 interrupt）

<Card title="为什么函数会不 async-signal-safe">
以 \`printf\` 为例，\`printf\` 会使用一个 statically allocated buffer，如果在中途被 interrupt，而在返回到被 interrupt 的位置前的这段时间里，\`printf\` 再次被调用，那么这个 buffer 就会处于一个 inconsistent 的中间态，导致 UB。

也就是说，一个函数不 async-signal-safe 一般是因为使用了一些全局变量并且可能在执行过程中被 interrupt。要安全地调用这样的函数，在其被 interrupt 后，下次执行必须要是从被 interrupt 的地方继续，而不能从头开始。

除了在 handler 中只调用 async-signal-safe 的函数，也可以选择在主程序中调用非 async-signal-safe 函数时 block 掉 handler 使用了这一函数的 signal，但这很难做到。
</Card>

#### 正确处理多次发送的 signal

多次发送 signal 可能只会收到一次，所以处理 signal 时不能误以为收到的次数与发送的次数相同。

例如，接收 SIGCHLD 来 reap child 时，应当在 handler 中 reap 掉所有已 terminate 的子进程，而非只 reap 一个子进程。

#### 不同系统上 signal handling 的差异

在一些系统上，signal handling 的语义会有区别：

-   在一些系统上，调用了 handler 后这个 signal 就会恢复默认行为，需要在 handler 中重新调用 \`signal\` 才能一直使用这个 handler。

-   在一些系统上，需要执行较长时间的 system call 会在被 interrupt 后报错 EINTR，而在现代系统上会尽可能地自动重新执行这个 system call，详见 \`man signal.7\` 的 “Interruption of system calls and library functions by signal handlers” 一节。

    （P.S. 这就是 [Rise of Worse Is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html) 中用来举例的 “PC loser-ing problem”，原本采用 worse-is-better 的 Unix 现在也进化成了 the right thing）
    （P.P.S. 当时读这篇的时候我完全没看懂这一段，没想到现在竟然还能记起来）

可以通过 \`sigaction\` 函数来设置想要的 signal handling 语义。

#### 注意 handler 被调用的时机

handler 可能会在意想不到的时机被调用，为了避免出错（race），可能会需要暂时 block signal 来确保 handler 在正确的时机被调用。详见 CS:APP 上的例子。

### 等待 signal

-   \`int sigsuspend(const sigset_t *mask)\`: 将 blocked set 设为 \`mask\`，在接收到任何 signal 后返回

可以在程序的其他部分 block 掉某个 signal，然后在 \`sigsuspend\` 的参数中将其 unblock，以达到等待该 signal 的目的。因为 \`sigsuspend\` 等待的不是某个特定的 signal，可以配合 \`while\` 循环来检查由 handler 设置的某个 flag。

\`sigsuspend\` 的效果类似于下面的这段代码：

\`\`\`c
sigprocmask(SIG_SETMASK, &mask, &prev);
pause();
sigprocmask(SIG_SETMASK, &prev, NULL);
\`\`\`

不同的是，上面这段代码有可能会恰好在 \`sigprocmask\` 之后、\`pause\` 之前接收到 signal，导致这个 signal 没有将 \`pause\` interrupt 而一直 sleep 下去。\`sigsuspend\` 是 atomic 的，就不存在这样的问题。

## Nonlocal Jumps

-   \`int setjmp(jmp_buf env)\`
-   \`void longjmp(jmp_buf env, int val)\`

\`setjmp\` 会将当前的 PC 和寄存器等信息存在 \`env\` 中，而 \`longjmp\` 会恢复 \`env\` 中保存的信息，跳转到 \`setjmp\` 的位置。

这意味着 \`setjmp\` 可能返回多次，而 \`longjmp\` 不会返回。第一次调用 \`setjmp\` 会返回 0，而之后调用 \`longjmp\` 时会在 \`setjmp\` 的位置返回参数 \`val\` 的值（特别地，如果 \`val\` 的值是 0，会返回 1，强制和首次返回区分开）。

因为 \`setjmp\` / \`longjmp\` 只是恢复 PC 和寄存器（包括 \`%rsp\`）：

-   调用 \`longjmp\` 时 \`setjmp\` 所在的函数必须还没有返回，否则 \`setjmp\` 所在的 stack frame 就失效了。
-   \`setjmp\` 的返回值只应出现在[一些简单的表达式中](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setjmp.html)，否则是 UB。特别地，不应将 \`setjmp\` 的返回值赋给一个变量，但可以放在 \`if\` 或 \`switch\` 里。这是考虑到，计算一个复杂的表达式可能会有一些中间量以及 dynamic stack allocation，而 \`longjmp\` 回来时这些中间量、dynamic stack allocation 不一定能被正确恢复，导致表达式不一定能被正确计算。
-   如果修改了存放在内存中的局部变量，跳转后会是被修改过的值而不是原来的值，而存放在寄存器中的值则会被恢复。要确保变量不被存在寄存器中，必须使用 \`volatile\` 声明变量，否则（即便使用了 \`register\` 或 \`auto\` 来声明变量）编译器可能任意地把变量放在内存或寄存器中，造成跳转后变量的值不确定。

<Card type="question" title="volatile vs 取地址">
C99 rationale 和 \`man setjmp\` 都说要用 \`volatile\` 才能确保局部变量存在栈上，那如果一个局部变量被取了地址，还有可能存在寄存器中吗？如果有可能的话，是标准允许这样但事实上不会，还是真的可以在 gcc 中做到？
</Card>

-   \`int sigsetjmp(sigjmp_buf env, int savesigs)\`
-   \`void siglongjmp(sigjmp_buf env, int val)\`

\`sigsetjmp\` / \`siglongjmp\` 会额外存储、恢复 pending / blocked signal 的信息（需要以非 0 \`savesigs\` 调用 \`sigsetjmp\`），可以用于 signal handler。

nonlocal jump 主要有两种用途：

-   出错时直接跳转到一个集中的位置来处理错误，而不用一层层往上返回
-   处理 signal 时不返回到被 interrupt 的位置，而跳转到指定的位置

在 signal handler 中使用 nonlocal jump 时需要注意：

-   先 \`sigsetjmp\` 再 install signal handler，否则可能 race
-   \`siglongjmp\` 跳转到的后续代码中只能调用 async-signal-safe 的函数

nonlocal jump 可能造成可读性的问题，也可能因为跳过了中间很多函数的返回，造成内存泄露等后果，要谨慎使用。

## Tools for Manipulating Processes

-   \`strace\`: 显示程序调用的所有 system call，可以静态链接来避免看到大量共享库相关的输出
-   \`ps\`: 列出进程信息
-   \`top\`: 列出进程的资源使用（可以用 \`htop\`）
-   \`pmap\`: 查看进程的 memory map
-   \`/proc\`: 查看各种进程相关的信息 (\`man proc.5\`)
`},{title:P,tags:t,content:`[CS:APP](https://csapp.cs.cmu.edu/) 第九章 “Virtual Memory” 的学习笔记。

本章的主要内容为 page table、address translation、memory mapping、dynamic allocation。



虚存是对 main memory 的抽象，它的主要作用有：

-   将 main memory 用作 disk 的 cache，只将 active 的部分放在 main memory，在需要时在 disk 和 memory 之间传递数据
-   通过给应用程序提供统一的地址空间，简化内存管理
-   通过给不同进程提供独立的地址空间，防止一个进程的数据被其他进程破坏

虚存在系统中起着非常重要的作用，学习虚存一方面可以学会使用它的一些强大功能（例如将文件映射到内存中），另一方面可以避免一些内存管理相关的错误。

## Physical and Virtual Addressing

内存有两种寻址方式：物理寻址和虚拟寻址。

main memory 可以看作 $M$ 个 byte 排列在一起，地址分别为 $0 \\sim M-1$，物理寻址就是 CPU 直接将需要的地址传给 main memory，获取到数据后传回 CPU。

虚拟寻址需要硬件和操作系统配合，CPU 将虚拟地址传给 *memory management unit* (MMU)，MMU 将虚拟地址翻译成物理地址传给 main memory，而这个过程又和操作系统相关。

## Address Spaces

（线性）地址空间是连续的非负整数构成的集合，一个系统有一个物理地址空间 $[0, M-1]$，还有若干个虚拟地址空间 $[0, N-1]$，其中 $N = 2^n$，称作 $n$-bit 地址空间，一般是 32-bit 或者 64-bit。

同一份数据可以在不同的地址空间有不同的地址，是虚存的一个基本思想。

## VM as a Tool for Caching

可以说，虚存是存储在磁盘上的，而物理内存是虚存的 cache。（但实际上虚存在很多时候会只出现在这个 cache 里而只在必要时被写入到磁盘上。）

### page

虚存被分成了很多固定大小的块，每一块称作一个 *virtual page*，而物理内存被分为同样大小的块，每一块被称作一个 *physical page*。在 cache 中，这样的一块一般被称作一个 block，但在虚存中被称作一个 page。

因为 DRAM 比磁盘快很多，并且磁盘的连续访问比随机访问快很多：

-   虚存的一个 page 会比较大，一般有 4KB ~ 2MB
-   虚存是 [fully associative cache](/post/2022/12/csapp-6#cache-的分类)
-   操作系统会使用一些比 SRAM cache 更加复杂的算法作为 replacement policy 来管理虚存

一个 virtual page 可能处于三种状态之一: unallocated、cached、uncached。

### page table

在物理内存中存放着一张 *page table*，虚拟地址空间中的每个 page 都对应 page table 中的一项 (*page table entry*, PTE)。每一项包含一个 valid bit 和一个地址：

-   cached: valid bit set，地址为该 page 的缓存的物理地址
-   uncached: valid bit not set，地址指向磁盘上的 virtual page
-   unallocated: valid bit not set，地址为 null

### page fault

在地址翻译时，MMU 会查看传入的虚拟地址对应的 PTE，若 cached，则称作 *page hit*，就会将 PTE 存储的物理地址传给 main memory；否则，就是 cache miss，在虚存中被称作 *page fault*。

page fault 是一个 exception，会触发 kernel 中的 page fault handler。page fault handler 会在 physical memory 中选择一个 physical page（victim page）用来存这个触发 page fault 的 page，先将 victim page 原有的数据在必要时放回磁盘，然后将新的数据存入 victim page，再相应地修改 page table 中的这两个 PTE，使得 victim page 原来存的那个 virtual page 变为 uncached，而新存入的 virtual page 变为 cached 并且地址指向 victim page。page fault handler 的最终效果就是，一开始想要的 virtual page 已经 cached，于是在返回到 exception 触发的位置时就可以 page hit 而正常读取数据了。

在磁盘和内存间传递数据在虚存中被称作 *swapping* 或 *paging*：

> Pages are *swapped in* (*paged in*) from disk to DRAM, and *swapped out* (*paged out*) from DRAM to disk.

虚存的 cache miss 是非常昂贵的，但由于程序访问内存的 locality，一般来说 page fault 很少触发，效率就不会太差。不断触发 page fault 的情况称作 *thrashing*，会大大影响程序的效率。

## VM as a Tool for Memory Management

实际上，page table 在一个系统中并非只有一份，而是每个进程都有一份，并且可以把同一个 physical page 映射到不同进程中的多个 virtual page。

虚存为内存管理提供了如下的便利：

-   简化了 linking，使得链接时无需考虑具体的物理地址，不同程序可以使用同样的虚拟地址分配方案。
-   简化了 loading，使得加载程序时只需将可执行文件的段落映射到虚存中，不用拷贝数据，等访问到某个 page 时才会 page in。这样的将文件内容映射到虚存中的操作称作 [memory mapping](#memory-mapping)，Linux 提供了 \`mmap\` system call 来进行 memory mapping。
-   简化了内存共享，操作系统可以将进程私有的数据映射到不同的 physical page，而将共享的数据映射到相同的 physical page。
-   简化了内存分配，因为应用请求一段连续的 virtual pages 时，操作系统可以将其映射到不连续的 physical pages。

## VM as a Tool for Memory Protection

-   虚存可以轻松地给不同的进程提供不同的私有内存空间。
-   通过给 PTE 添加 permission bit \`SUP\`、\`READ\`、\`WRITE\`，就可以使某个 page 只读或者只能在 kernel mode 下被访问。如果试图访问一个 page 时权限出错，则会触发 CPU 的 general protection exception，进而由 exception handler 向进程发送 SIGSEGV。

## Address Translation

一个内存地址可以被分为两部分，虚拟地址被分为高位的 *virtual page number* (VPN) 和低位的 *virtual page offset* (VPO)，物理地址被分为 PPN 和 PPO。

CPU 中有一个 *page table base register* (PTBR)，指向 page table 的起始地址。地址翻译时，MMU 通过 PTBR 和 VPN 得到 PTE 的地址，从 main memory 获取 PTE，根据 valid bit，要么触发 page fault，要么获取到 PPN，而 PPO = VPO，就得到了物理地址。

SRAM cache 一般会以物理地址来 cache main memory，也就是说，通过 PTE 的地址访问 PTE、通过物理地址访问 main memory 时会首先尝试通过 SRAM cache 来访问。

如果每次都从 main memory 获取 PTE，即使在 L1 cache hit 了效率也不够高，所以 MMU 中还有一个小的 page table cache，叫做 *translation lookaside buffer* (TLB)。VPN 被分为两部分：低位的 TLBI (index) 和高位的 TLBT (tag)，其中 TLBI 用来选择 cache set，TLBT 用来进行 cache line matching。在地址翻译时，会优先查询 TLB，若 miss 再查询 page table。

地址空间往往很大，如果只用一张 page table，那么 page table 本身就会占用大量的空间，所以可以将 page table 分层，每层 page table 指向下一层 page table，直到最后一层指向 VP / PP。

## Case Study: Core i7 Address Translation

Core i7 memory system 如 CS:APP Figure 9.21 所示：

![The Core i7 memory system](csapp-fig9.21.png)

Core i7 使用 48-bit 的虚拟地址空间和 52-bit 的物理地址空间，page size 可以设置为 4KB 或 4MB，有四级 page table。

每个 PTE 有以下内容：（还有一些其他内容）

-   P: valid bit
-   R/W: 是否只读
-   U/S: 是否需要在 kernel mode 下访问
-   XD: 是否可以被读取指令（是否可执行）
-   A: reference bit，访问到时由 MMU 设置，而由软件清除（可以用于 replacement algorithm）
-   Base addr: child page table / physical page 的地址的高位 40 bits（剩下 12 bits 即 4KB，这要求地址以 4KB 对齐，而 page size 一般就是 4KB）

L1 page table 还有一项 PS 用来指定 page size。

L4 page table 还有 dirty bit D 用来表示 page 被写入过需要被 swap out (write back)，以及 G 表示 global page 即切换进程时不从 TLB 中 evict 掉。

VPN 有 36 bits，每 9 bits 用来访问一级 page table。

因为 L1 cache 是 8-way 32KB 的，正好有 12 bits 用来选择 cache set，所以在获取 PPN 的同时就可以把 VPO 发送给 L1 cache 来提前选择好 cache set。

## Linux Virtual Memory System

kernel 的虚存中包含：

-   kernel 的代码以及全局的数据结构

-   将整个物理内存连续地映射到虚存中，这样就可以方便地访问特定的物理地址

-   和每个进程相关的数据结构，例如 page table、kernel stack、\`task_struct\` 等

    （P.S. 这部分虽然是和每个进程相关，但并不会在每个进程中有所不同，CS:APP 中这里写错了，在 errata 中指出了）

Linux 将虚存划分为若干 *area*（也称 *segment*）来管理，例如 code segment、data segment、heap、shared library segment，每个 area 是虚存中连续的一段。

kernel 为每个进程维护了一个 \`task_struct\`，其中的 \`mm\` 一项是一个 \`mm_struct\`。\`mm_struct\` 的 \`pgd\` 一项是 L1 page table 的地址，而 \`mmap\` 指向一个 \`vm_area_struct\`。每个 \`vm_area_struct\` 表示一个 area，有以下几项（还有一些其他项）：

-   \`vm_start\` / \`vm_end\`: 指向 area 的开头 / 结尾
-   \`vm_page_prot\`: area 中所有 page 的 access permission
-   \`vm_flags\`: 一些 flag，例如这个 area 中的 page 是否被所有进程共享
-   \`vm_prev\` / \`vm_next\`: 指向相邻的 \`vm_area_struct\`，构成一个链表

在处理 page fault 时，page fault handler 首先会检查地址是否在某个 area 内（不在则触发 segmentation fault），然后会检查是否有访问权限（没有则触发 protection exception），如果一切 ok 就会根据 replacement algorithm 选择 victim page，若其 dirty 则将其 swap out，然后将新的 page swap in，最后更新 page table 并返回。

<Card type="question" title="segmentation fault vs protection exception">
segmentation fault 和 protection exception 有区别吗？general protection exception 不应该是 CPU 触发的吗，怎么是 page fault handler 触发？segmentation fault 和 SIGSEGV 是什么关系？

我的理解是 kernel 收到 CPU 的 general protection exception 会向进程发送 SIGSEGV，但 CS:APP 这里在相邻的两段分别用了 “segmentation fault” 和 “protection exception”。
</Card>

## Memory Mapping

将一个 *object* 的内容设为一段虚存的初始值称作 *memory mapping*。这个 object 可以是文件系统中一个文件的一段 (*file-backed*)，也可以是一个初始为空的 *anonymous file* (*demand-zero*)。

在 map 时并不会立即将数据放到物理内存中，而是等到访问到某个 page 时再 swap in，这称作 *demand paging*。操作系统会使用 *swap file* 来进行 swapping，但只有进行了修改才会需要 swap out，否则可以直接从 map 到的文件 swap in。

如果不同的进程映射到了同一个文件的同一段，在物理内存中会只有一份数据。

memory mapping 有 shared 和 private 两种：

-   map as shared objects: 修改对其他进程可见，如果是 file-backed 还会将内存修改同步到磁盘上的文件。
-   map as private objects: 修改对其他进程不可见，也不会同步到磁盘上，并且是 copy-on-write 的：一开始将 PTE 设为只读，在触发 protection exception 后，exception handler 发现这个 area 是可以写入但 private 的，就创建一个新的 page，将原来的 page 复制过去，将 PTE 设为可以写入。

### fork 的原理

fork 时会将原来的 \`mm_struct\` 以及 page table 复制一份，但是将原来的 private area 中的 PTE 可以写入的重新变为只读，从而在之后再写入时重新触发 copy-on-write，就做到了 parent 和 child 一开始有一样的数据但后续写入独立。在 fork 前就创建了的 shared area 会由两个进程共享，可以利用这一点在 parent 和 child 之间通信。

### execve 的原理

1.  删除当前进程的所有 area (\`vm_area_struct\`)
2.  根据 program header table 进行 memory mapping：
    -   \`.init\`、\`.text\`、\`.rodata\`: private, file-backed, read-only
    -   \`.data\`: private, file-backed, read/write
    -   \`.bss\`、heap、stack: private, demand-zero, read/write
3.  如果有 link 到共享库，会进行动态链接，将共享库 private, file-backed map
4.  修改 program counter

<Card title="关于共享库的 map 方式" fold type="info">

下面是一封发送于 2022.12.18，尚未收到回复的邮件：

> Dear Drs. Randy Bryant and Dave O'Hallaron,
> 
> I am a student at Tsinghua University and I am writing to ask a question about the book CS:APP3e.
> 
> In “9.8.3 The execve Function Revisited” on page 837, it is stated that shared libraries are “mapped into the shared region of the user’s virtual address space”. In Figure 9.31, it is stated that “Memory-mapped region for shared libraries” are “Shared, file-backed”.
> 
> However, I believe that shared libraries are actually mapped as private objects rather than shared objects. I have come to this conclusion for the following reasons:
> 
> 1.  If there is data in the shared library, it should be copy-on-write, and should not be shared among different processes.
> 2.  /proc/self/maps shows that all mappings to shared libraries of my shell are private.
> 3.  The source code and comments of dl-load indicate that the mapping should be private. (See https://github.com/bminor/glibc/blob/71e408e45dcacf429a94b2807f75aaadd8d37cb9/elf/dl-load.h#L32-L49 and https://github.com/bminor/glibc/commit/9b8a44cd18fbf1aedeb03e19f4bcdb06b0ee409b.)
> 
> I have checked the errata but did not find this issue addressed. I am writing to you in the hope that you can provide an explanation of this statement or add it to the errata. Thank you for your attention to this matter.
> 
> Sincerely,  
> Yufan You

</Card>

### mmap

\`void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)\`

-   \`addr\`: area 的起始地址，仅作提示作用，一般 \`NULL\` 就行
-   \`length\`: area 的长度
-   \`prot\`: \`PROT_EXEC\`、\`PROT_READ\`、\`PROT_WRITE\`、\`PROT_NONE\`
-   \`flags\`: 有很多，常用的有 \`MAP_SHARED\`、\`MAP_PRIVATE\`、\`MAP_ANONYMOUS\`
-   \`fd\`: map 到的 file descriptor
-   \`offset\`: map 到的文件内容的 offset，必须是 page size 的倍数

在 \`MAP_ANONYMOUS\` 时，最好将 \`fd\` 设为 -1、\`offset\` 设为 0（在有的实现中这是必须的）。

失败时 \`mmap\` 会返回 \`MAP_FAILED\`。

\`int munmap(void *addr, size_t length)\`: 将自 \`addr\` 起 \`length\` 长的范围内的 mapping 删除，以后再访问就会 segmentation fault。\`addr\` 必须是 page size 的倍数。

## Dynamic Memory Allocation

### 动态分配的相关函数

在 C 语言中，可以用 \`malloc\` 和 \`free\` 来获取 / 释放动态分配的内存。可以使用 \`calloc\` 来初始化分配到的内存并在使用乘法计算内存大小时检测是否发生溢出。可以使用 \`realloc\` 来给一块动态分配的内存调整大小。详见 \`man malloc\`。

为了让动态分配得到的内存可以用于任何数据类型，地址会以 double word 对齐，即 32 位系统对齐到 8 的倍数，64 位系统对齐到 16 的倍数。

操作系统使用 \`brk\` 指针来指向 heap 的结尾，可以通过 \`sbrk\` 函数来增大 heap。

### allocator 的要求和目标

Dynamic memory allocator 会将 heap 划分为若干大小不等的 block，每个 block 要么 allocated 要么 free。

allocator 需要做到：

-   能够处理以任意顺序发送的 allocate 和 free 请求（不能对顺序做任何假定）
-   立即对请求做出响应（不能离线）
-   只使用 heap 存储数据（不能将数据存储在虚存的其他位置）
-   满足对齐要求（能够存储任何类型的数据）
-   不能修改或移动 allocated block（可以修改 free block 或者 heap 中不是 block 的区域）

而 allocator 有两个性能方面的目标：

1.  更快地响应请求（更大的吞吐量）
2.  更高效地利用内存

其中，导致内存利用率低的主要原因是 *fragmentation*：

-   internal fragmentation: 实际分配的 allocated block 比 alloc 请求中申请的大
-   external fragmentation: 所有 free block 加起来大小足够，但每单个 free block 都不够大，导致需要使用更多 heap 空间

### 一种简单的 allocator 实现方式

#### block header

allocator 需要记录 block 的信息，而只能使用 heap 空间，所以直接在 block 的开头记录 block header，即 block size 以及是否 allocated。

因为地址有对齐要求，block size 的最低几位一定是 0，就可以用最低位来存 allocated bit。

block size 充当了单向链表的作用。如果想访问 free block，就得访问每个 block 再看是否 free，所以这样的结构被称作 *implicit free list*。

#### placement policy

allocate 时需要找到一个足够大的 free block，allocator 进行这样的搜索的方式称作 *placement policy*：

-   first fit：从头开始找，直到找到足够大的 free block
-   next fit：从上次搜索结束的地方开始找，直到找到足够大的 free block
-   best fit：遍历所有 free block，使用足够大的 free block 中最小的

使用 implicit free list 时，next fit 比 first fit 吞吐量更大但内存利用率更低，best fit 内存利用率最好但吞吐量最差。

#### 分割 free block

如果 allocate 时 free block 的剩余空间比需要的空间大，且大的超过一个 block 的 minimum size (double word)，就可以将这个 block 分为两半，一半用作 allocated block，另一半为 free block。

#### 获取更多的 heap 空间

如果已有的 heap 空间无法满足 allocate 请求，可以使用 \`sbrk\` 来获取更多的 heap 空间，并将新得到的空间设为 free block。

#### 合并 free block

如果很多 free block 相邻地放在一起，可能会造成 *false fragmentation*，即合并后能放下但每个单独无法放下，所以需要对相邻的 free block 进行合并 (coalesce)。

合并有两种策略：

-   immediate coalescing：每次 free 时都将新得到的 free block 与相邻的 free block 合并，这样的话每时每刻都不会有相邻的 free block
-   deferred coalescing：等到某个时候再合并，例如在未能找到足够大的 free block 时

immediate coalescing 的实现较为简单，可以在常数时间内完成，但可能会导致反复的合并和分割，带来不必要的性能损失。

合并时需要知道上一个 block 的信息，这可以通过在 block 尾部添加一个与 header 内容相同的 footer 来实现，这被称作使用 *boundary tags*。由于只有 free block 需要 footer，可以省去 allocated block 的 footer，而在 header 中存储上一块的 allocated bit，来节省空间。

### explicit free list

可以在 free block 中存储指向前驱后继的指针来维护一个 free block 的链表，称作 *explicit free list*。

这个 list 可以是 LIFO 的或者按地址顺序的。LIFO 的 list 可以在常数时间内完成 free 操作，而按地址顺序的 list 需要使用线性时间来找到一个 block 在 list 中的位置，但内存利用率更高。

由于需要足够大的空间来存储前驱后继的指针，explicit free list 的 minimum block size 更大，可能会出现更严重的 internal fragmentation 导致内存利用率下降。

### segregated free lists

可以将 block 按 size 分类，例如按 2 的次幂分类，每一类维护一个 list。具体实现方式有很多，例如 simple segregated storage 和 segregated fits。

#### simple segregated storage

每一类的所有 block 都是这一类的最大 size，如果一类 block 用光了就申请新的 heap 空间，free 时直接放回相应的 list，不合并也不分割。

这样的话，header 和 footer 都不需要了，只需在 free block 里存放一个后继指针即可，但 internal fragmentation 和 external fragmentation 都很严重。

#### segregated fit

每一类中有不同大小的 block，有分割和合并。allocate 时从相应的类别开始找，在一类中找不到就继续找下一类，这样近似于 best-fit search，但速度很快。

segregated fit 的综合性能较好，所以包括 libc 中的 \`malloc\` 函数在内的 allocator 往往选择使用 segregated fit。

#### buddy system

所有 block size 都是 2 的次幂，分割时每次分成两半直到大小合适，合并时只和 “buddy” 合并。

这里描述清楚可能比较复杂，就感性理解一下，所有的 block 会形成一个如下图所示树状的样子（有点树状数组的感觉），parent 相同的 block 就是 buddy。

![buddy system](buddy-system.png)

这样的话，搜索和合并会比较快速，但由于 block size 都是 2 的次幂，可能出现严重的 internal fragmentation。

### 平衡树维护 free block

CS:APP 中没有提到这种方式，但只要理解了上面这几种 free list，就很好理解，free block 不一定要用链表维护，也可以用平衡树维护：在 free block 中存放树的节点所需的 children、parent 等信息，就可以高效实现严格的 best fit，复杂度也不会像 segregated fit 一样在极端情况下发生退化。但是树的节点需要的信息往往比链表多，可能会让 minimum block size 增大到 6 个 word。

我自己写 malloc lab 的时候试着写了个 Splay，发现一般情况下还是比 segregated fit 慢不少，内存利用率也不一定有明显提升，不知道其他平衡树 / 特殊场景下性能如何。倒是在网上看到有说红黑树可以在 malloc lab 拿高分（~~谁用好的算法拿高分啊，不是考验对着数据调参的能力吗，我觉得我对数据过拟合的 segregated fit 分已经够高了~~）（~~虚假的 segregated fit：按 block size segregate 来寻找 fit；真正的 segregated fit：按测试数据 segregate 分别进行 fit~~）。

### malloc lab

CS:APP 经典 lab 的代码似乎是可以公开的（

https://github.com/ouuan/course-assignments/tree/master/csapp/malloc-lab

## Garbage Collection

可以通过 block 之间以及 stack、register、global 变量对 block 的引用关系找到不可达的 block 而进行 garbage collection。

在 C 中，由于没有类型信息，可能会将非指针类型的数据视作对 block 的引用，导致不可达的 block 被视作可达，所以 C 语言的 garbage collection 只能是 conservative 的。
`},{title:E,tags:"游泳 经验分享",content:`这学期选了游泳零基础班作为体育课。一开始的时候只是略低于平均水平，但到后来学习换气的时候，在 20~40m 左右卡了很久，最后能连续游 50m 比班上倒数第二晚了三节课。

在体育方面会垫底是我预料之中的，但比倒数第二差太多，长期和班上同学分开上课，还是挺难受的。但是，这段经历也让我有了丰富的失败经验（，可以水一篇踩坑记录，幸运的话可能还能在未来帮到某人。



在过程中，老师不断和我说“太紧张了”“要坚持下来”“呛到水、换气不充分要学会调整，不要总是停下来”“为什么停下来呢”（也有动作纠正，只不过在这之前有很多 PUA），但在最后学会之后，我还是觉得，正确的动作远胜于盲目的练习，更别提玄学的《心态》了。比起出问题后学会调整，不出问题才是最重要的。

不知道心态、毅力在游几百米时有多重要，但如果几节课都没什么进步、50m 都游不下来，很可能还是动作有问题。

虽然整个过程很艰辛，但总结起来也没多少东西，就是下面这几点：

1.  在抬头换气前，要先在水下把气吐干净。开始吐气的时机大概是换气前最后一次蹬腿时。
2.  如果蹬太多次腿再换气，可能会气不够，可以只蹬 1~2 次腿就换气。
3.  换气后下沉是正常的，换气后立即蹬一次腿可以缓解下沉。
4.  划手时，要以合适的角度往下撑，凭借下撑的反作用力让头抬起来。否则，如果单靠下巴和腰，头就很难抬高，从而没有充分的时间换气。
5.  虽然吸气只用嘴，但吐气时可以适当用鼻子辅助，也可以一定程度上防止鼻子进水。
6.  嘴巴要张大，类似于打哈欠的程度，以至于吸气时感受不到气流。如果嘴张的小，就容易换气不充分或者呛到水，时间久了也容易累、不适。一开始老师跟我说要张大的时候我还以为是从 wo 张大到 o，后来才知道要到打哈欠的程度。

不知道最后老师说“比上周好多了”“这不是 100m 就游下来了吗”的时候，是否觉得我“不紧张了”“能坚持下来了”。反正，我心里想的是：“原来嘴 tmd 要张这么大，嘴一张大立刻轻松一万倍。”

P.S. 这篇的 [og](https://ogp.me/) image 是 [【中字】打铁自述励志学游泳经历](https://www.bilibili.com/video/av556552520) 的 [封面](/images/2022/11/swim.jpg)，因为很草所以想起来就用作 og image 了（，然后重新看了一遍这个切片，当时看的时候还体会不到按距离分组、自己垫底的感觉，现在也能对 kanon（~~考哥震怒~~）的苦呀西感同身受了。
`},{title:A,tags:t,content:`[CS:APP](https://csapp.cs.cmu.edu/) 第六章 “The Memory Hierarchy” 的学习笔记。

这章的主要内容有：各种存储设备（RAM、ROM、HDD、SSD）的特点、程序的局部性、缓存的结构以及原理、缓存对程序性能的影响。



因为时间不太够，本来我想先跳过这章以后再补的，但学第九章的时候感觉还是跳不得，否则第九章有些东西感觉学了个半懂。~~虽然只用学一小部分就足以满足第九章的需求，但我打算摆烂了，该学的东西学不完就学不完，我想学啥就学啥。~~

## Storage Technologies

### RAM

*Random access memory* 分为 SRAM 和 DRAM 两种，SRAM 有更快的访问速度但更加昂贵。

#### SRAM

SRAM (Static RAM) 将每个 bit 存储在一个 *bistable* 的 memory cell 中，每个 cell 由 6 个晶体管组成，有两种可能的稳定态，遇到微小的扰动也会迅速恢复到这两种状态之一。

#### DRAM

DRAM (Dynamic RAM) 将每个 bit 存储在一个很小的电容中，容易受到外界干扰，所以需要周期性地将数据复制出去再复制回来以进行刷新，可能还会配合纠错码来保证数据正确。

DRAM 的设计使其存储密度更高，但访问速度更慢；SRAM 则更快，但密度更低，更贵，更费电。访问 DRAM 的用时大约是 SRAM 的 10 倍，而 SRAM 的造价大约是 DRAM 的 1000 倍。

#### Conventional DRAM

DRAM 芯片被分为若干 *supercell*，每个 supercell 存储一个 word，一般是 1 byte。supercell 排列为二维阵列，可以用二维坐标 $(i, j)$ 定位。

DRAM 通过 *pin* 连接到 *memory controller* 来和外界通信。读取位于 $(i, j)$ 的 supercell 时，memory controller 会依次发送 *row access strobe* (RAS) $i$ 和 *column access strobe* (CAS) $j$，在收到 RAS 后 DRAM 会将第 $i$ 行复制到一个内部的 row buffer，收到 CAS 后再从 row buffer 里将第 $j$ 列发送给 memory controller。

#### Memory Module

DRAM 芯片会被组装为 *memory module* 来插到主板上。

DIMM 是一种 memory module。例如，一个 DIMM 可以包含 8 个 DRAM 芯片，每个 64-bit 的 word 在每个 DRAM 芯片的同一个地址上分别存一个 byte，从而整个 DIMM 可以以 64-bit 为单位与外界通信。

#### Enhanced DRAM

朴素的 DRAM 是比较慢的，历史上曾经有过若干对 conventional DRAM 的优化：

1.  FPM (fast page mode) DRAM: 如果连续两次 RAS 是一样的，可以省略掉后续相同的 RAS，直接发送 CAS
2.  EDO (extended data out) DRAM: 延长了数据输出的时间，对 pipelining 有帮助
3.  SDRAM (synchronous): 通过时钟信号的 rising edge 同步地通信，而非通过发送 RAS/CAS 异步通信
4.  DDR (double data-rate) SDRAM: 通过同时使用时钟信号的 rising edge 和 falling edge 达到 double data-rate，分为 DDR、DDR2、DDR3、DDR4、DDR5 等
5.  VRAM (video): 一般用于显卡、frame buffer 等，它的输出是直接输出整个 buffer，并且可以并行地同时读和写

### ROM

RAM 会在断电后丢失数据，所以是 *volatile* 的。与之相对，还有 nonvolatile 的存储器，统称为 *read-only memory* (ROM)，尽管有的 ROM 是可以写入的。ROM 的写入称作 *reprogram*。

-   PROM (programmable ROM) 只能被写入一次。
-   EPROM (erasable PROM) 需要用特殊设备写入，可以写入大约 1000 次。
-   EEPROM (electrically EPROM) 不需要用特殊设备就可以写入，可以写入大约 $10^5$ 次。
-   flash memory 是一种基于 EEPROM 的 nonvolatile 存储器，被广泛使用，包括用于 [SSD](#ssd)。
-   固件 (firmware) 往往存储于 ROM 中。

### 访问 main memory

一个 *bus* 是一组用来通信的导线，可以传输地址、数据、控制信号等。CPU 和 main memory 之间的通信通过 *bus transaction* 进行。

CPU 通过 system bus 连接 I/O bridge，I/O bridge 通过 memory bus 连接 main memory。I/O bridge 负责 system bus signal 和 memory bus signal 之间的转换。

### HDD

#### 磁盘的结构

磁盘由若干 *platter*（盘片）组成。每个 platter 有两个 *surface*（表面），每个 surface 上覆盖着磁性记录材料。platter 由位于中心的 *spindle*（主轴）带动，以某个一般是 5400~15000 RPM 的速度转动。

每个 surface 被分成若干个称作 *track*（磁道）的同心圆环，每个 track 被分为若干 *sector*（扇区）。每个 sector 存有相同大小的数据（一般是 512 bytes），相邻的 sector 之间由 *gap*（间隙）隔开，gap 不存储数据，而是用来识别 sector。

一个磁盘通常由多个堆叠在一起的 platter 构成，这些 platter 共享一个 spindle。对于某个距离 $k$，一个磁盘内所有 surface 上离转轴距离为 $k$ 的 track 的集合称作一个 *cylinder*（柱面）。

整体结构如 CS:APP Figure 6.9 所示：

![磁盘结构示意图](csapp-fig6.9.png)

#### 磁盘的容量

磁盘的容量有三个衡量指标：

-   recording density: 单位长度的 track 存储的 bit 数量
-   track density: 单位长度的半径上的 track 个数
-   areal density: 单位面积上存储的 bit 数量

早期的磁盘的所有 track 都有相同数量的 sector，这样的话位于外部的 track 的 sector 就会更加稀疏。后来为了提高容量，将 cylinder 划分成了若干个 *recording zone*，每个 recording zone 由若干相邻的 cylinder 组成，同一个 recording zone 内的所有 track 有相同数量的 sector。

#### 磁盘的读写

磁盘通过连在传动臂上的读写头进行读写，每次读写前需要先将读写头移动到相应的位置（寻道），并等待目标 sector 转动到读写头下，再开始读写。

寻道用时与读写头原本的位置到目标位置的距离有关，等待转动的用时则看运气。在 CS:APP 举的例子中，寻道平均用时为 9 ms，等待旋转平均用时为 4 ms，读写一个 sector 用时 20 μs。

也就是说，磁盘读写的主要用时是寻道以及等待旋转用时，也就是初次访问一段连续的 sector 的用时，而与访问多少个连续的 sector 关系不大。对于单个 sector，磁盘访问的用时可以达到 SRAM 的 $10^4$ 倍，DRAM 的 $10^3$ 倍，但连续 sector 的读写用时仅为 DRAM 的不到十倍。

#### Logical Disk Blocks

磁盘对外提供了 *logical block* 作为 sector 的抽象，每个 logical block 的大小和一个 sector 相同，由连续的非负整数索引，通过 *disk controller* 翻译成形如 *(surface, track, sector)* 的坐标。

<Card title="磁盘格式化">
磁盘在使用前需要进行格式化：在 gap 中写入 sector 的标识信息，识别出有故障的 cylinder，将一些 cylinder 设为备用以防其他 cylinder 损坏。由于备用 cylinder 的存在，formatted capacity 会小于 maximum capacity。
</Card>

### I/O bus

不同的 I/O 设备通过 I/O bus 与 I/O bridge 连接。例如显卡、连接各种设备的 USB controller、通过 SCSI/SATA 等接口连接磁盘的 host bus adapter 等都会连接到 I/O bus。

### 访问磁盘

访问磁盘需要向磁盘发送三条指令：

1.  向磁盘发送一个信号，告诉磁盘要读取数据
2.  将要读取的 logical block number 发送给磁盘
3.  告诉磁盘读取到的数据要放在 main memory 的哪个地址

发送完这些指令后，CPU 会继续干其他事情。磁盘读取到数据后，会通过 I/O bus 直接将数据存放到 main memory 中而不经过 CPU，这被称作 *direct memory access* (DMA)。存放好数据后，磁盘向 CPU 发送 interrupt signal 来跳转到处理磁盘读取完成的 signal handler。

### SSD

SSD 将一个或多个 flash memory 包装起来，并且有一个 *flash translation layer* 来将输入的 logical block number 转换为对 flash memory 的访问，对外表现出与 HDD 类似的接口。

flash memory 由若干 block 组成，每个 block 又由若干（32-128 个）page 组成，每个 page 一般是 512B-4KB 大，数据传输的最小单位是 page。

SSD 的写入比较特殊：一个 page 需要在所属的整个 block 都被擦除（改为全 1）后才能写入一次，如果要写入第二次就得再把整个 block 擦除一遍。在写入时，为了擦除某个 block，可能会需要把这个 block 存储的数据复制到其他 block。擦除是一个耗时相对较长的操作，需要约 1 ms，并且每个 block 在擦除约 $10^5$ 次后就会损坏。

这使得 SSD 的写入比读取略慢，并且写入很多次后可能损坏。flash translation layer 会通过 *wear-leveling logic* 来尽可能使得每个 block 的擦除次数相同，以延长 SSD 的使用寿命。

disk、RAM、CPU 速度差异的历史变化如 CS:APP Figure 6.16 所示，其中 CPU cycle time 是单核的，effective CPU cycle time 是多核的：

![disk、RAM、CPU 速度差异的历史变化](csapp-fig6.16.png)

## Locality

好的程序具有良好的 *locality*。locality 有两种表现形式，*temporal locality* 指的是最近访问过的数据更有可能在不久的将来再次被访问，*spatial locality* 指的是访问过一处的数据后更有可能在不久的将来访问邻近的其他数据。

具有良好 locality 的程序跑得更快，因为计算机系统设计的各个层面都利用 locality 做了优化。

一些 locality 的例子：

-   重复引用同一个变量的程序有良好的 locality。
-   在一段连续内存（数组）中依次访问每个元素称作 *stride-1 reference pattern*，每次间隔 $k-1$ 个元素进行访问称作 *stride-k reference pattern*，$k$ 越小 locality 越好。遍历高维数组时尤其要注意访问的顺序。
-   由于循环会重复访问同一段指令，循环的指令读取局部性良好

## The Memory Hierarchy

在硬件上，不同存储技术之间存在性能、价格、容量的 trade-off；在软件上，程序具有 locality。硬件和软件的这两条性质正好可以搭配在一起，促使 memory system 采用了如 CS:APP Figure 6.21 所示的称作 *memory hierarchy* 的组织方式：

![The memory hierarchy](csapp-fig6.21.png)

memory hierarchy 的构成并不一定和上图完全一致，例如 SRAM 的级数可能不是三级、DRAM 和 HDD 间可能还有 SSD、磁带也可以作为 memory hierarchy 中比 HDD 更低的一级。

### Cache

caching 指的是用一个相对小而快的存储设备来存储一个相对大而慢的存储设备中最为活跃的部分，这个小的存储设备称作大的存储设备的 cache。

在 memory hierarchy 中，每一级都是下一级的 cache。数据会在各个相邻层级间不断地传输，不同层级之间会以不同的 block size 作为数据传输的基本单位。

### 从 cache 获取数据

想要从 memory hierarchy 的某一级获取数据时，首先会尝试从它的 cache 获取数据，如果成功获取则称作 *cache hit*，否则称作 *cache miss*。

发生 cache miss 时，一般会先将数据从下一级复制到上一级，从而最终还是表现为从 cache 中获取数据。如果 cache 满了，在从下一级获取数据时，就需要删除 cache 中的一些数据来腾出空间，这时需要在 cache 中选择被删除的数据，被删除的 block 称作 *victim block*，这个行为称作将 victim block *evict*，而选择 victim block 是根据 *replacement policy* 进行的，例如 random replacement policy、least recently used (LRU) replacement policy 等。

### Cache 的管理

cache 可能由硬件、OS、软件以及它们之间的相互配合来进行管理，而这在大部分时候都是自动完成的，无需应用程序的程序员操心。

各级 cache 如 CS:APP Figure 6.23 所示：

![无处不在的各式各样的 cache](csapp-fig6.23.png)

### Cache 对 locality 的利用

temporal locality 使得重复使用的数据留存在 cache 中从而更容易 cache hit；cache 中的数据按 block 存储则利用了 spatial locality，使得一个数据被 cache 时与其邻近的处于同一个 block 的数据也被 cache。

## Cache Memories

随着 CPU 和 DRAM 的速度差异越来越大，SRAM 被用来填充它们之间的 gap。

在下面的讨论中，为了简便，假设只有 L1 cache，没有 L2、L3 cache。（或者也可以看成是在介绍 L3 cache 是如何工作的。）

### Cache 的结构与读取

设 main memory 有 $2^m$ 个地址，每个地址存放一个 byte。它的 cache 会分成 $2^s$ 个 *cache set*，每个 cache set 包含 $E$ 个 *cache line*，每个 cache line 存放一个大小为 $2^b$ byte 的 data block、一个 *valid bit*、以及长度为 $t = m-b-s$ 的 *tag bits*。

每个地址会被分成三部分，高位的 $t$ 位是 tag，中间 $s$ 位是 set index，低位 $b$ 位是 block offset。获取存放在某个地址的数据时，先根据其 set index 找到对应的 cache set，再在 cache set 中找到 valid bit 为 1 且 tag 相符的 cache line，最后通过 block offset 来从 block 中提取出单个 byte。

在 cache miss 时，需要从下一级获取数据，存放到 cache 中。如果对应的 cache set 所有 cache line 都满了，就需要 evict 某个已有的 cache line。

### Conflict Miss

cache set 的设计基于一个假设，即在局部内访问的数据地址的低位往往是不同的，但实际上可能并非如此。如果以 $2^{s+b}$ 的倍数为地址间隔访问数据，就可能连续访问同一个 cache set 内的数据，导致 cache miss（$E$ 较小，尤其是 $E=1$ 时，这种情况更可能触发）。例如，数组的大小是 $2$ 的次幂而交替访问相邻数组的同一个下标时就可能这样。（这大概在 APIO2019 讲过，当时我自然是啥都没听懂，就只记得数组不要开 $2$ 的次幂。）

### Cache 的分类

$E=1$ 的 cache 称作 *direct-mapped cache*。（~~书上在这仔细解释了半天，感觉废话好多啊。~~）

$E > 1$ 的 cache 称作 *set associative cache*。其中，$s > 0$ 的称作 E-way set associative cache，而 $s = 0$ 的称作 fully associative cache。

### Cache 的写入

在 cache hit 时，有两种处理方式：

-   *write-through*: 既修改 cache，又修改下一级
-   *write-back*: 只修改 cache，并且在每个 cache line 中添加一个 *dirty bit*，用来记录是否被修改过，在被 evict 时若 dirty 则写入下一级

在 cache miss 时，也有两种处理方式：

-   *write-allocate*: 先从下一级获取数据，然后用与 cache hit 相同的处理方式
-   *no-write-allocate*: 直接写入下一级，不获取到 cache 中

一般 write-through 和 no-write-allocate 搭配，write-back 和 write-allocate 搭配。

实际上，cache 写入的优化是非常复杂的问题，这里只是简单介绍了一下。作为程序员，可以把 cache 写入当成是 write-back、write-allocate 的。

### i-cache 和 d-cache

只存放指令的 cache 称作 *i-cache*，只存放数据的 cache 称作 *d-cache*，都存放的 cache 称作 *unified cache*。

将 i-cache 和 d-cache 分开，就可以对它们分别进行优化，例如 i-cache 是只读的，二者可以有不一样的大小、不一样的 cache set 设置。将两者分开还可以一定程度上避免 conflict miss。

在 Core i7 处理器中，每个核有自己的 L1 i-cache、L1 d-cache、L2 unified cache，所有核共享一个 L3 unified cache。

### Cache 的性能

cache 性能的衡量指标有：

-   miss rate
-   hit rate
-   hit time: cache hit 时的访问用时
-   miss penalty: cache miss 时的访问用时，与最终从哪一级获取到数据有关

一般来说，cache 的参数对性能的影响是：

-   cache size 越大，hit rate 就越高，但速度会慢。
-   增大 block size 可以更好地利用 spatial locality，但也有可能因 cache line 数量减少而降低 hit rate，并且会因为每次需要传递的数据变多而增大 miss penalty。
-   更大的 $E$ 可以降低 conflict miss 的可能性，但也会使得 tag 匹配以及 victim line 的选择更加复杂，从而增大 hit time 和 miss penalty。在 Core i7 处理器中，L1、L2 cache 是 8-way 的，L3 cache 是 16-way 的。
-   write-through 实现起来更加容易，并且在 read miss 时不会触发写入。而 write-back 可以减少数据传递的总量，降低 I/O bus 带宽的占用，也可能降低数据传递的用时。一般来说，memory hierarchy 中较低的层级更倾向于使用 write-back。

## The Impact of Caches on Program Performance

### The Memory Mountain

对一定 size 的数据按照一定的 stride 进行访问，将 size、stride 与数据吞吐量的关系画成三维图像，就得到了 *memory mountain*。

CS:APP Figure 6.41 展示了一座 Core i7 的 memory mountain:（这也是 CS:APP 的封面）

![Core i7 的 memory mountain](csapp-fig6.41.png)

Memory mountain 较为完整地呈现了一个 memory system 的性能，以及 temporal locality 和 spatial locality 对性能的影响。

在每级 cache 的容量处，吞吐量会发生明显的突变。

在 size 相同时，stride 越小吞吐量越高。在 stride 接近 1 时变化尤其明显，这和 Core i7 系统的 prefetching 技术息息相关，处理器能够识别出 stride-1 reference pattern 并在实际访问到数据之前就进行 prefetch。

### 矩阵乘法的循环顺序

（书上在这讲了半天，~~感觉废话好多~~，我就放个测试结果上来吧。）（CS:APP Figure 6.46）

![Core i7 矩阵乘法性能](csapp-fig6.46.png)
`},{title:T,tags:r,content:`[DDPP5](https://wakerly.org/DDPP/) 第二章 “Number Systems and Codes” 的学习笔记。

本章的主要内容为一些常用的编码以及纠错码的原理。



开头整数编码的内容很多是 [CS:APP 第二章](/post/2022/09/csapp-2) 讲过的，也有一些新内容，但基本上都是标星的可选内容，我看是看了但懒得写笔记了（

---

一套编码被称作一个 *code*，一个 code 中的单个合法编码（二进制串）被称作一个 *code word*。

## Gray Code

Gray code 的性质：相邻两个数的 code word 只有一位不同，且 $2^n-1$ 的 code word 中只有一个 1（也就是说 $n$-bit Gray code 的首尾也只有一位不同）。

<Card title="4-bit Gray code" fold>

\`\`\`
 0: 0000
 1: 0001
 2: 0011
 3: 0010
 4: 0110
 5: 0111
 6: 0101
 7: 0100
 8: 1100
 9: 1101
10: 1111
11: 1110
12: 1010
13: 1011
14: 1001
15: 1000
\`\`\`

</Card>

递归构造：

1.  $1$-bit Gray code: 0 是 0，1 是 1
2.  $(n+1)$-bit Gray code:
    -   前 $2^n$ 个数和 $n$-bit Gray code 相同（开头加上 0）
    -   后 $2^n$ 个数是把 $2^n$ 个 $n$-bit Gray code 逆序排列再在开头加上 1

直接计算单个数的 Gray code：

-   递归就能直接计算，~~相信大家都会做 [NOIPD1T1](https://uoj.ac/problem/488) 吧，记得开 \`unsigned long long\`~~（
-   也可以这么算：$n$ 的 Gray code 第 $i$ 位为 1 当且仅当 $n$ 的二进制中第 $i$ 位和第 $i+1$ 位不同

书中描述了一个使用场景：一个磁盘的每个扇区需要编码，从扇区上读取若干 bits 来识别当前处于哪个扇区，在两个相邻扇区的交界处可能有部分 bits 来自其中一个扇区，另外的 bits 来自另一个扇区，Gray code 可以使最终读取到的结果一定是这两个扇区之一。

## Codes for Actions, Conditions, and States

说白了就是如何编码一个 enum。不同的编码方式有各自的特点，可以从编码长度、电路开销、设计难度、可纠错性等角度考虑，选择最合适的编码方式，或者组合使用多种编码方式。

-   顺着编码为二进制可以使编码长度最短（$\\lceil \\log_2 n \\rceil$）。
-   *1-out-of-n-code*：合法的 code word 只有一位是 1，每个 enum 对应某一位为 1。例如，控制哪个灯开时，这种编码方式无需再有电路来选择要开的灯，直接将编码的每一位连到一盏灯就可以了。
-   *m-out-of-n-code*：合法的 code word 恰有 $m$ 位是 1。要检测一个 code word，只需使用一个 $m$-input AND gate，电路较为简单。而 code word 总数有 $\\binom nm$，也很多。

## n-Cubes and Distance

以 $2^n$ 个 $n$-bit 二进制串作为顶点，在只有一个 bit 不同的串之间连边，得到的图被称作 *$n$-cube*，可以画成一个（超）立方体：（DDPP5 Figure 2-8）

![n-cubes for n = 1, 2, 3, and 4.](ddpp-fig-2-8.png)

图上两个二进制串之间的距离被称作 *Hamming distance*，表示两个串中不相同的位数。

## Codes for Detecting and Correcting Errors

实际存储、传输编码时，可能会发生错误。错误的具体行为可以由 *error model* 刻画。最简单的 error model 是 *independent error model*，即每个错误只独立地改变编码中的一位，多位同时发生错误的概率比一位发生错误的概率小得多。

### Error-Detecting Codes

对于一个 code，不是 code word 的二进制串称作 *noncode word*。

*error-detecting code* 具有这样的性质：任何一个 code word 在任意修改一位后都会得到一个 noncode word。

使用 error-detecting code 时，可以认为只要是 code word 都没有发生错误，noncode word 则一定发生了错误。

一个 $n$-bit error-detecting code 是 $n$-cube 的一个点独立集，也就是说任意两个 code word 的 Hamming distance 都至少为 2。

奇偶性可以用来设计 error-detecting code：任给一个 $n$-bit code，将第 $n+1$ 位设为前 $n$ 位中 1 的个数的奇偶性（称作 *parity bit*），则可以得到一个 $(n+1)$-bit error-detecting code。这样的编码称作 *1-bit parity code*，若 code word 都有偶数个 1 则称作 *even-parity code*，有奇数个 1 则称作 *odd-parity code*。

### Error-Correcting and Multiple-Error-Detecting Codes

如果一个 code 中两个 code word 的最小 Hamming distance 有 $2c+d+1$，则可以对最多 $c$ 位的错误进行纠正，并且检测到最多 $c+d$ 位的错误（一个 $c+d+1 \\sim 2c+d$ 位的错误会被认为是来自另一个方向的错误而被错误地纠正，从而不能被检测到；可以选择少纠错几位来检测到更多位的错误）。

纠错就是找到和一个 noncode word 的 Hamming distance 最小的唯一一个 code word，进行纠错的硬件被称作 error-correcting decoder。

### Hamming Codes

*Hamming code* 是一种通用的最小距离为 3 的编码。一个有 $n$ 个 check bit 的 Hamming code 最多可以存储 $2^n-n-1$ 个 information bit，从而总共有 $2^n-1$ 个 bit。

一个 $(2^n-1)$-bit Hamming code 的 bit 依次编号为 $1 \\sim 2^n-1$，编号为 $1, 2, 4, \\ldots, 2^{n-1}$ 的 bit 是 check bit。每个 check bit 代表一个 group，编号为 $2^i$ 的 check bit 所代表的 group 包含的是编号的二进制中包含 $2^i$ 的所有 bit。check bit 的取值使得每个 group 都含偶数个 1。

实际使用的 Hamming code 往往会将 check bit 移到末尾，例如一个 $15$-bit Hamming code 中 bit 的编号依次为 15, 14, 13, 12, 11, 10, 9, 7, 6, 5, 3, 8, 4, 2, 1。

因为每个 bit 都至少属于一个 group，改变一个 bit 会得到 noncode word。改变编号为 $i$ 和 $j$ 的两个 bit 时，会改变 $i$ 异或 $j$ 对应的 group，所以改变两个 bit 会得到 noncode word。所以 Hamming code 中两个 code word 的 Hamming distance 至少为 3。

纠错时，只要将错误的 check bit 的编号或起来就可以得到错误的 bit 的编号。

可以通过增加一个 parity bit 来得到一个最小距离为 4 的 $2^n$-bit extended Hamming code。

### CRC Codes

*cyclic-redundancy-check (CRC) codes* 是一种得到广泛应用的 error-correcting code，例如被用在文件系统和网络通信中，它可以检测到成团出现的多位错误，在一些场景中这种错误比随机出现的错误概率更高。

### Two-Dimensional Codes

如 DDPP5 Figure 2-14 (a) 所示：

![所有 bits 排列成一个矩阵，矩阵被划分为四个部分: information bits, checks on rows, checks on columns, checks on checks.](ddpp-fig-2-14-a.png)

选择 $C_{\\mathrm{row}}$ 和 $C_{\\mathrm{col}}$ 两种编码方式，设置 checks on rows 使得 information bits 所在的每一行都是一个 $C_{\\mathrm{row}}$ 的 code word，设置 checks on columns 使得 information bits 所在的每一列都是一个 $C_{\\mathrm{col}}$ 的 code word，而 checks on checks 则可以选择，要么每一行都是一个 $C_{\\mathrm{row}}$ 的 code word，要么每一列都是一个 $C_{\\mathrm{col}}$ 的 code word。

这样得到的 *two-dimensional code* 的最小距离是 $C_{\\mathrm{row}}$ 和 $C_{\\mathrm{col}}$ 的乘积，所以 two-dimensional code 也被叫做 *product code*。

RAID 就可以看作使用了 two-dimensional code：每块数据盘内的每个 block 都有 CRC code，还有一块硬盘用来存所有数据盘的 parity bits。

### Checksum Codes

parity bit 可以看作是 bits 在模 2 意义下的和，可以推广为 *checksum*。

例如，模 256 意义下，可以计算 bytes 的和，来检测 bytes 的错误。

除了改变模数，还可以改变计算方式，例如使用 ones’ complement 加法来计算模 255 或 65535 意义下的 checksum。

### m-out-of-n Codes

[m-out-of-n code](#codes-for-actions-conditions-and-states) 的最小距离为 2，并且能够检测到 *unidirectional multiple errors*，即所有错误都是 0 变 1 或 1 变 0 的改变多位的错误。

## Codes for Transmitting and Storing Serial Data

-   parallel data transmission: 一个 data word 的所有 bit 同时传输
-   serial data transmission: 一个 bit 一个 bit 传输

在某些场景下，serial data transmission 可以减少线路开销，或者减少一些设计上的困难。

最基本的 serial data transmission 需要三个信号：

-   CLOCK: 将时间划分为一个个 *bit cell*，标识出每个 bit 所处的时间范围
-   SERDATA: 实际传输的数据，具体内容依 *line code* 而定
-   SYNC: 用来标识 bit 的 significance，例如传输 bytes 时用来标记每个 byte 的开头

实际上，也可以选择合适的 line code 从而只需传输一个信号，从数据信号中读取出 CLOCK 和 SYNC 的信息。

<Card title="Serial Line Codes" type="wip">
Serial Line Codes 这一节我感觉有些地方没完全理解，也有和 Wikipedia 有出入的地方，也标星了，感觉后面不一定用得上，就先咕了。
</Card>
`},{title:D,tags:r,content:`[DDPP5](https://wakerly.org/DDPP/) 第三章 “Switching Algebra and Combinational Logic” 的学习笔记。

本章的主要内容为逻辑代数、逻辑代数在电路中的使用及化简、timing hazard。



## Switching Algebra

这一节基本上就是离散数学 (1) 开头两章的内容，术语和记号有很多不同，~~幸好忘的差不多了，不然都要搞混了~~。

### 记号

-   AND：$X\\ \\cdot\\ Y$
-   <span class="inline-block w-3"/>OR：$X + Y$
-   NOT：$X'$
-   AND 的优先级高于 OR

（yysy 我还是更喜欢 $\\lor, \\land$，$\\cdot$ 也还行，$+$ 真的有点难以接受。）（~~它们明明是对偶的怎么搞得像个环一样。~~）（主要还是下面这些定理用加号看起来真的好怪。）（异或不是还号称二进制加法吗。）

### 公理

$$
\\begin{array}{rl}
\\text{(A1)} & X \\ne 1 \\implies X = 0 \\\\
\\text{(A1D)} & X \\ne 0 \\implies X = 1 \\\\\\\\
\\text{(A2)} & X = 0 \\implies X' = 1 \\\\
\\text{(A2D)} & X = 1 \\implies X' = 0 \\\\\\\\
\\text{(A3)} & 0 \\ \\cdot\\  0 = 0 \\\\
\\text{(A3D)} & 1 + 1 = 1 \\\\\\\\
\\text{(A4)} & 1 \\ \\cdot\\  1 = 1 \\\\
\\text{(A4D)} & 0 + 0 = 0 \\\\\\\\
\\text{(A5)} & 0 \\ \\cdot\\  1 = 1 \\ \\cdot\\  0 = 0 \\\\
\\text{(A5D)} & 1 + 0 = 0 + 1 = 1
\\end{array}
$$

### 定理

中文名来自《数理逻辑与集合论（第二版）》2.2 节“等值公式”。

$$
\\begin{array}{ll}

\\begin{array}{rl}
\\enspace\\text{(T1)} & X + 0 = X \\\\
\\enspace\\text{(T1D)} & X \\ \\cdot\\  1 = X
\\end{array}
& \\text{Identities（同一律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T2)} & X + 1 = 1 \\\\
\\enspace\\text{(T2D)} & X \\ \\cdot\\  0 = 0
\\end{array}
& \\text{Null elements（零律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T3)} & X + X = X \\\\
\\enspace\\text{(T3D)} & X \\ \\cdot\\  X = X
\\end{array}
& \\text{Idempotency（幂等律）}
\\\\\\\\

\\begin{array}{rl}
\\quad\\ \\text{(T4)} & (X')' = X
\\end{array}
& \\text{Involution（双重否定律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T5)} & X + X' = 1 \\\\
\\enspace\\text{(T5D)} & X \\ \\cdot\\  X' = 0
\\end{array}
& \\text{Complements（补余律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T6)} & X + Y = Y + X \\\\
\\enspace\\text{(T6D)} & X \\ \\cdot\\  Y = Y \\ \\cdot\\  X
\\end{array}
& \\text{Commutativity（交换律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T7)} & (X + Y) + Z = X + (Y + Z) \\\\
\\enspace\\text{(T7D)} & (X \\ \\cdot\\  Y) \\ \\cdot\\  Z = X \\ \\cdot\\  (Y \\ \\cdot\\  Z)
\\end{array}
& \\text{Associativity（结合律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T8)} & X \\ \\cdot\\  (Y + Z) = \\,\\: X \\ \\cdot\\  Y \\,\\: + \\,\\: X \\ \\cdot\\  Z \\,\\: \\\\
\\enspace\\text{(T8D)} & X + \\,\\: Y \\ \\cdot\\  Z \\,\\: = (X + Y) \\ \\cdot\\  (X + Z)
\\end{array}
& \\text{Distributivity（分配律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T9)} & X + \\,\\: X \\ \\cdot\\  Y \\,\\: = X \\\\
\\enspace\\text{(T9D)} & X \\ \\cdot\\  (X + Y) = X
\\end{array}
& \\text{Covering（吸收律）}
\\\\\\\\

\\begin{array}{rl}
\\text{(T10)} & \\,\\: X \\ \\cdot\\  Y \\,\\: + \\,\\: X \\ \\cdot\\  Y' \\,\\: = X \\\\
\\text{(T10D)} & (X + Y) \\ \\cdot\\  (X + Y') = X
\\end{array}
& \\text{Combining}
\\\\\\\\

\\begin{array}{rl}
\\text{(T11)} & \\begin{aligned} & X \\cdot Y + X' \\cdot Z + Y \\cdot Z \\\\[-0.2em] =\\ & X \\cdot Y + X' \\cdot Z \\end{aligned} \\\\
\\text{(T11D)} & \\begin{aligned} & (X + Y) \\cdot (X' + Z) \\cdot (Y + Z) \\\\[-0.2em] =\\ & (X + Y) \\cdot (X' + Z) \\end{aligned}
\\end{array}
& \\text{Consensus}
\\\\\\\\

\\begin{array}{rl}
\\text{(T12)}  & X + X + \\cdots + X = X \\\\
\\text{(T12D)} & X \\ \\cdot\\  X \\ \\cdot\\ \\cdots\\ \\cdot\\  X = X
\\end{array}
& \\text{Generalized idempotency}
\\\\\\\\

\\begin{array}{rl}
\\text{(T13)} &
\\begin{aligned}
& (X \\ \\ \\cdot\\  X \\ \\ \\cdot\\ \\cdots\\ \\cdot\\  X)' \\\\[-0.2em]
= & \\,\\: X' + X' + \\cdots + X'
\\end{aligned}
\\\\
\\text{(T13D)} &
\\begin{aligned}
& (X + X + \\cdots + X)' \\\\[-0.2em]
= & \\,\\: X' \\cdot\\  X' \\cdot\\  \\cdots \\ \\cdot\\  X'
\\end{aligned}
\\end{array}
& \\begin{array}{c} \\text{DeMorgan’s theorem} \\\\ \\text{（摩根律）} \\end{array}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\ \\text{(T14)} &
\\begin{aligned}
 & [F(X_1, X_2, \\ldots, X_n, +, \\ \\cdot\\ )]' \\\\[-0.2em]
=&\\ F(X_1', X_2', \\ldots, X_n', \\ \\cdot\\ , +)
\\end{aligned}
\\end{array}
& \\begin{array}{c} \\text{Generalized} \\\\ \\text{DeMorgan’s theorem} \\end{array}
\\end{array}
$$

$$
\\begin{array}{rl}
& \\text{Shannon’s expansion theorems} \\\\[0.3em]
\\text{(T15)} & F(X_1, X_2, \\ldots, X_n) = \\ X_1 \\ \\cdot\\  F(1, X_2, \\ldots, X_n) + X_1' \\ \\cdot\\  F(0, X_2, \\ldots, X_n) \\\\
\\text{(T15D)} & F(X_1, X_2, \\ldots, X_n) = [X_1 + F(1, X_2, \\ldots, X_n)] \\cdot [X_1' + F(0, X_2, \\ldots, X_n)]
\\end{array}
$$

（~~草，对齐好累，我为什么要浪费这个时间。~~）

### Duality

将一个等式中所有的 $0$ 换成 $1$、$1$ 换成 $0$、$+$ 换成 $\\cdot$、$\\cdot$ 换成 $+$，等式依然成立。

上面的定理中带 “D” 的都是上一条的对偶。

### Standard Representations of Logic Functions

这里需要翻出来我离散 (1) 写的 [真值表生成器](https://ouuan.github.io/truth-table-generator/)（其实可以去加上 $+$ 和 $\\cdot$ 作为 alias，但如果要加 $'$ 的话会很麻烦所以干脆不加了吧（

logic function 有若干精确的标准表示方法：

-   真值表
-   canonical sum: 主析取范式，极小项 (minterm) 的和
-   使用 $\\sum$ 表示的 minterm list
-   canonical product: 主合取范式，极大项 (maxterm) 的和
-   使用 $\\prod$ 表示的 maxterm list
-   Verilog \`case\` 语句

这里用 $\\prod$ 表示 maxterm list 的下标比离散 (1) 讲的舒服多了：minterm 的 index 就是哪组变量取值下表达式值为 1，maxterm 的 index 就是哪组变量取值下表达式为 0，所以两种范式的下标刚好是补集。例如，有 $X, Y, Z$ 三个变量，$X' \\cdot Y \\cdot Z'$ 的下标是 $2$，$X' + Y + Z'$ 的下标是 $5$；$\\sum_{X,Y,Z}(1,2,6) = X' \\cdot Y' \\cdot Z + X' \\cdot Y \\cdot Z' + X \\cdot Y \\cdot Z' = \\prod_{X,Y,Z}(0,3,4,5,7)$。

Verilog 的 \`case\` 语句大概是这个样子：（虽然还完全没学 Verilog，但我感觉 Shiki 自带的 system-verilog 高亮看起来就比 verilog 正确许多，以后可能也用 system-verilog 的高亮了）

\`\`\`system-verilog
case ({X,Y,Z})
  1,2,6:    F = 1;
  default:  F = 0;
endcase
\`\`\`

## Combinational-Circuit Analysis

这一节就是说给你一个电路图怎么搞出它的 logic function。其实没啥好说的，就（按拓扑序）一个一个 gate 递推就行，可以用真值表也可以用逻辑表达式。

有一个小 trick：DeMorgan’s theorem 在电路图中表现为，将 inversion bubble 换到另一侧（输入 / 输出），并且改变 gate 的类型（AND / OR），这样的话，如果两个 inversion bubble 在一条 wire 上就可以消掉。

## Combinational-Circuit Synthesis

在 digital design 中，“Synthesis” 有若干种含义（例如从 HDL 到 FPGA），而在这一节只是指从 formal description 到 gate-level circuit。

### Circuit Descriptions and Designs

自然语言描述 → 逻辑表达式 / 真值表（canonical sum / product） → 电路

很多时候写出逻辑表达式会比列出真值表简单一些，但在面对较为复杂的逻辑关系时，列出真值表可以强制设计师考虑到每种情况，从而避免漏掉 corner case。

一个输出是某个逻辑表达式的电路被称作 *realize* 了这个表达式，是这个表达式的 *realization* 或者 *implementation*。

### Circuit Manipulations

在多数电路技术（包括 CMOS）中，NAND / NOR 比 AND / OR 效率更高，所以一般会修改电路来尽量使用 inverting gate 而非 noninverting gate：

-   在 wire 上移动 inversion bubble（从上一个输出移到下一个输入）
-   在 wire 的两侧同时加上 inversion bubble（或者 NOT gate）
-   消除同一根 wire 上的两个 inversion bubble
-   将 inversion bubble 换到另一侧（输入 / 输出），并且改变 gate 的类型（AND / OR）

### Combinational-Circuit Minimization

一般情况下，逻辑表达式的化简主要用的是定理 T10（Combining），就是在 sum of products 中找到仅有一项相反的两个 product 将它们合并，最终得到的也是一个 sum of products，实现为 2-level（first-level 计算 product，second-level 计算 sum）的电路。

product of sums 电路是对偶的，就不重复了，下文也是一样。

### Karnaugh Maps

如 DDPP5 Figure 3-23 所示：

![2-variable, 3-variable, and 4-variable Karnaugh maps](ddpp-fig-3-23.png)

在 Karnaugh map 中，每一个表示一个 minterm，相邻（包括跨过边界到另一侧的相邻）的格子仅有一位相反，所以边长为 1 / 2 / 4 的矩形可以合并。

选出若干矩形，恰好覆盖所有输出为 1 的格子，就可以化简逻辑表达式。

如果一个矩形覆盖的全是 1，并且是极大的（在其对应的 product 中减少任何一个输入都会使其覆盖到 0），就称作一个 *prime implicant*。最简的逻辑表达式是若干 prime implicant 的 sum。

有的函数的 Karnaugh map 非常分散（例如 parity function），没有连成一块的 1，就需要多级而非 2-level 的电路来进行化简。

在 FPGA 中，输入数量较少的电路都是通过 lookup table (LUT) 而非 gate-level circuit 来实现，只需真值表就可以。但复杂的电路需要由多个 LUT 组合起来，此时逻辑表达式的化简依然有用。

## Timing Hazards

真实的电路中会有 delay，而上面研究的都是 combinational logic circuit 的 *steady-state behavior*，没有考虑到 *transient behavior*。

因为 delay 的存在，可能会发生这样的情况：输入发生了改变，稳态下的输出不变，但在一瞬间内输出发生了变化（产生了一个 short pulse）。这样的 pulse 被称作 *glitch*。

如果一个电路有产生 glitch 的可能性，则称这个电路存在 *hazard*。实际物理电路的 delay 大小等因素难以控制，所以这里只是考虑产生 glitch 的可能性，而非实际是否有 glitch 产生（有点类似于并发编程中要保证所有可能的执行顺序下都不出错）。

### Static Hazards

*static-1 hazard*：稳态输出是 1，改变某一个输入后稳态输出还是 1，但这一个输入改变时可能会短暂地输出 0。static-0 hazard 是类似的。

书上给了个例子，但这个其实很好理解，就是电路的一个输入作为多个 gate 的输入，而这些 gate 的输出变化得有快有慢。

### Finding Static Hazards Using Maps

正常的 sum of products 电路中不会有 static-0 hazard，可能有 static-1 hazard。

可以用 Karnaugh map 来找到 hazard：如果两个相邻的 1 没有被同一个 gate 覆盖，从其中一个变为另一个时就可能产生 glitch。（因为极端情况下可能所有覆盖原来那一格的 gate 先全部变为 0，覆盖后来那一格的 gate 才变为 1。）

消除 hazard 就是用冗余的 gate 来覆盖这样的相邻的 1，类似于定理 T11（Consensus）。

### Dynamic Hazards

如果变化一个输入时可能产生不止一次 glitch，就称作 *dynamic hazard*。

一个正常的 2-level sum of products / product of sums 电路中不会有 dynamic hazard。

### Designing Hazard-Free Circuits

在多数电路中（尤其是 synchronous digital system 中），hazard 不会造成什么影响。但在某些电路（asynchronous sequential circuits）中，需要避免 hazard 的存在。

在一般的电路中消除 hazard 是复杂的，而在 sum of products 中，可以用 Karnaugh map 或者取遍所有 prime implicant（称作 *complete sum*）来消除 hazard。
`},{title:$,tags:r,content:`[DDPP5](https://wakerly.org/DDPP/) 第四章 “Digital Design Practices” 的学习笔记。

本章的主要内容为数字设计的文档规范、初步认识 circuit timing、基于 HDL 的数字设计所使用的工具与设计流程。



## Documentation Standards

一个 <dfn>document package</dfn> 通常至少包含以下内容：

specification (*spec*)
:   准确地描述系统的所有输入和输出以及功能。

block diagram
:   大致描述系统的主要模块之间的连接。

logic-device description
:   分别描述每个 “custom” logic device 的功能，这里 “custom” 是与现成的、由其他制造商生产的相对，例如 ASIC、FPGA、CPLD 等都是 custom 的。

schematic diagram
:   对每个模块的细节描述，比 *logic diagram* 更加细致，在 board-level design 中是包括 IC type、reference designator、signal name、pin number 等细节信息的电路图，在 FPGA、CPLD 中则由 HDL model 来充当这一角色。

timing diagram
:   展示各个信号随时间的变化情况。

circuit description
:   解释电路的工作原理以及注意事项。

test plan
:   如何对系统进行测试。

感觉大致上来说，与软件进行类比的话，logic-device description 像是组件的 API 文档，circuit description 像是代码内的注释，block diagram 像是整个程序的结构图，schematic 则是“代码”。总之，这个 document package 和软件的文档不一样，还包含 schematic 这种具体实现。

### Block Diagrams

大概就是 DDPP5 Fig.4-1 这种感觉：

![block diagram for a shift-and-add multiplier](ddpp-fig-4-1.png)

整个系统被划分为若干 component，block diagram 展示它们之间最主要的一些连线而略去细节。

在 block diagram 中，信号的流动可以是任意方向的，不需要都沿一个方向。

### Gate Symbols

根据 generalized DeMorgan’s theorem，AND、OR、NAND、NOR、NOT (inverter)、BUFFER (non-inverting buffer) 各自都有两种不同的画法，如 DDPP5 Fig.4-4 所示：

![在 generalized DeMorgan's theorem 下等价的 gate symbols](ddpp-fig-4-4.png)

### Signal Names and Active Levels

为了兼容更多的 HDL 和 EDA，signal name 最好不要有特殊字符，而是只使用字母、数字、下划线，以字母开头。

signal name 往往代表某种状态或某种操作，但并不总是在位于 HIGH 时表示相应的意思。每个 signal name 会有一个 <dfn>active level</dfn>，<dfn>active-high</dfn> 意味着这个 signal 位于 HIGH 时（在 positive-logic 中即为 1 时）表示这某种状态或某种操作，<dfn>active-low</dfn> 则与之相反。一个 signal 位于其 active level 时，我们说它 is <dfn>asserted</dfn>，反之则说它 is <dfn>negated</dfn> (*deasserted*)。

signal name 会以某种 naming convention 来表示其 active level，DDPP5 采用的 convention 是 active-high 保持不变，而 active-low 加上 \`_L\` 后缀。例如，\`READY\` 为 1 / \`READY_L\` 为 0 表示 ready，\`READY\` 为 0 / \`READY_L\` 为 1 表示没有 ready。

一般来说 active-high 理解起来相对容易，但由于性能、兼容性等原因也经常会需要 active-low。

### Active Levels for Pins

gate 或其他 logic element 的 pin 上有 inversion bubble 时，除了理解成不同的逻辑函数，也可以理解成 active-low 的输入/输出。

例如，AND、NAND、NOR、OR 可以表示四种不同 active level 的 AND：（DDPP5 Fig.4-6）

![四种不同 active level 的 AND: AND, NAND, NOR, OR](ddpp-fig-4-6.png)

因为 inverting gate 往往性能更好，可以将 noninverting gate 替换为 inverting gate，而理解成输入输出的 active level 相反的 noninverting gate。

### Bubble-to-Bubble Logic Design

在画电路图时，尽量将 active-low 的信号连接到 inversion bubble 上，在理解电路时就可以少一些 logical negation（本质上是因为 active-low 信号的两侧都有 inversion bubble，从而能够消去），使电路更好理解。

### Constant Logic Signals

电路设计中偶尔会用到 constant 0 （*ground*） 和 constant 1 （*power-supply voltage*），在电路图中它们的记号如下图所示：（DDPP5 Fig.4-9 (b))

![constant 0 and 1 inputs with individual gates](ddpp-fig-4-9-b.png)

### Drawing Layout

logic diagram 和 schematic 一般要从左到右画，所有输入都在最左侧，所有输出都在最右侧。

在线路发生交叉时，有两种区分重叠和连接的方法：

-   连接处打点，重叠不打点
-   连接都形如 ⟂ / ⊤，重叠则形如 +

由于 schematic 需要很多细节，一张图可能画不下，有两种处理方式：

-   分为多张并列的图，标注出跨越两张图的连线。
-   将图组织为树状（与 Web 前端的 component 类似），树根与 block diagram 类似。图中的 component 可以是另一张 schematic，也可以是 standard logic device 或者 HDL model。

### Buses

为了方便画图，多个并列的信号可以画成一个 <dfn>bus</dfn>。

bus 的名字一般形如 \`ADDR[15:0]\`，表示 \`ADDR15\`、\`ADDR14\`、……、\`ADDR1\`、\`ADDR0\`。

在图上 bus 用一条较粗的线表示，从这条粗线上连出一条细线表示从中 “pull” 出单独一个信号。

### Additional Schematic Information

在 board-level design 中，一个 schematic 在电路图的基础上还需要标明 IC type、reference designator、pin number 等信息，用来精确地描述电路。

其中，IC type 描述了 IC 的功能，<dfn>reference designator</dfn> 用来在一类 IC 中指定特定的一个实例，<dfn>pin number</dfn> 用来指定从哪连到哪。

全都标上长这样：（DDPP5 Fig.4-18）

![schematic diagram for a circuit using several SSI parts](ddpp-fig-4-18.png)

## Circuit Timing

在时序电路中，电路由一个 clock 控制，而 clock 的频率会根据完成一步操作在最坏情况下的用时来制订，所以计算、优化电路的 timing 对电路的性能和正确性都非常重要。

### Timing Diagrams

*timing diagram* 用来展示电路里各个信号随时间变化的情况，如 DDPP5 Fig.4-19 (b)(c) 所示：

![(b) 展示 causality 和 propagation delay 的 timing diagram (c) 展示 minimum / maximum delay 的 timing diagram](ddpp-fig-4-19-bc.png)

信号的转变不是瞬间发生的，从一个状态到另一个状态的用时称作 <dfn>transition time</dfn>，从 LOW 到 HIGH 的用时叫做 <dfn>rise time</dfn>，从 HIGH 到 LOW 的用时叫做 <dfn>fall time</dfn>。

在图 (b) 中，不同的箭头用来表示 transition 之间的 causality （因果关系）。

有因果关系的 transition 并不是立刻一个接着一个发生，而是会有 *delay*，不同的信号、路径会有不同的 delay。delay 一般是指两个 transition 各自中点的距离。

很多因素都会对 delay 造成影响，所以 delay 一般不是单个数字，而是一个区间。图 (c) 中标明了 minimum delay 和 maximum delay。

有时候 timing diagram 不需要区分 rise 和 fall，例如用来存储数据的信号，就可以如 DDPP5 Fig.4-20 (a) 这样画：

![不区分 rise 和 fall 的 timing diagram](ddpp-fig-4-20-a.png)

可以将一个 bus 画在一起，也可以用数字标注 bus 的取值，如 DDPP5 Fig.4-20 (b) 所示：

![将 bus 画在一起的 timing diagram](ddpp-fig-4-20-b.png)

### Propagation Delay

<dfn>propagation delay</dfn> 指的是电路的某个输入发生改变后沿着某个路径产生某个输出的 delay，一般记作 $t_{\\mathrm{pX}}$，其中 $\\mathrm{X}$ 用来标识这个路径。

影响 propagation delay 的因素有很多，例如：

-   Power-supply voltage: 包括标定的电压，以及小的电压波动
-   Temperature: 包括环境温度和电路工作产生的热量
-   Output loading: 电路的输出可能与后续电路的很多个输入相连，连接到的输入越多，将信号传递过去就用时越长
-   Input rise and fall times: 如果输入的 transition 慢，也会计入 propagation delay
-   Transition direction: 有时 rise 和 fall 的用时会不同
-   Speed-of-light delays: 如果电路的物理尺寸大，或者电路速度非常快，光速的限制就不能忽略
-   Noise and crosstalk: 环境中的各种干扰，以及相邻线路之间的干扰
-   Manufacturing tolerances: 元件被制造出来的时候可能有细微的差异

一般来说，计算 propagation delay 可以不考虑这么多因素，而只需根据生产商提供的元件的 “maximum” “typical” “minimum” propagation delay 来进行计算。

如果电路有多个输入输出，就会有很多条路径需要计算 delay。

<Card title="glitch 与 delay">

第三章中提到的 [glitch](/post/2023/01/ddpp-3#timing-hazards) 是否实际发生，与电路的 delay 密切相关。

</Card>

### Timing Specifications

生产商一般会提供元件在某种条件下每个路径、每种 transition 方向的 propagation delay 的范围，一般会提供 maximum delay 和 minimum delay，也可能提供一个 “typical” delay。

一般情况下，maximum delay 是最重要的，minimum delay 只在少数情况下需要考虑，而依赖于 typical delay 是不靠谱的。

### Timing Analysis Tools

在复杂的电路中，往往需要借助 EDA tool 来计算 timing。比起手动计算，EDA 可能会利用元件附带的比 min/max delay 更加详细的信息来更加精确地计算 delay。可以使用模拟器，手动设计输入，来计算 delay。也可以使用 timing analysis program，来自动计算出所有可能的 delay。

在设计的不同阶段可能会对 timing 进行多次估计和计算，在设计基本完成时如果发现 propagation delay 不符合设计要求，可能需要进行调整，例如针对 critical path 进行线路优化，将 critical path 上的元件尽量放在相邻的位置，将 high-fanout 的信号复制几分来减轻 output load……这样对 timing 进行调整的过程可能会反复进行很多遍，被称作 <dfn>timing closure</dfn>。

## HDL-Based Digital Design

### EDA Tool Suites for HDLs

text editor
:   包含代码高亮等功能的 HDL source file 编辑器。

compiler
:   检查代码中的语法错误，将 HDL 编译为 RTL （register-transfer language）。

synthesizer (synthesis tool)
:   将 RTL design synthesis 到某个具体的 hardware technology 上，通常分为若干步骤：
    1.  mapping: 将 RTL design 对应到具体的 hardware element
    2.  placement: 在 FPGA / CPLD 设计中，为每个 element 选择具体的 programmable resource instance；在 ASIC 设计中，为各种 basic building block 安排位置
    3.  routing: 在 FPGA / ASIC 设计中，在 element 之间连线（CPLD 中连线是固定的，要根据连线选择 programmable resource）

simulator
:   对给定的 HDL model 和随时间变化的输入，计算出随时间变化的输出。输入可以是手动编辑的，由 *test bench* 生成的，或者通过 *waveform editor* 编辑的。输出可以是波形图或者列表，还可能包含警告。

template generator
:   生成常用的代码模板。

schematic viewer
:   由 HDL model （RTL） 或 synthesized result 生成 schematic diagram，synthesis 前后的 schematic diagram 可能会有很大的不同，但功能是一致的。

chip viewer
:   查看 synthesized result 中的物理布局和连线。

constraints editor
:   给 synthesizer 调参，例如设置 timing 要求，调整优化目标。

timing analyzer
:   计算某些或全部路径的 delay。

back annotator
:   将 timing analyzer 的计算结果插入到 HDL model 中，以在 simulation 中展现出 timing。

### HDL-Based Design Flow

1.  specification / hierarchy / block diagram
2.  coding
3.  compilation
4.  simulation / functional verification / pre-fitting timing verification
5.  mapping
6.  fitting / place & route
7.  post-fitting timing verification

其中，前四步被称作 <dfn>front-end steps</dfn>，后三步被称作 <dfn>back-end steps</dfn>。

设计过程一般不会是一步一步顺着来的，而是会不断反复。为了少折腾，第一步中总体设计的合理性，以及第四步中进入 back-end steps 前的测试，都非常重要。由于精确的 timing 计算依赖于具体的 fitting，在第七步发现 timing 不符合要求而推倒重来也是很有可能的。
`},{title:I,tags:r,content:`[Digital Design Principles and Practices](https://wakerly.org/DDPP/) 5th edition 的学习笔记。



---

下学期要选数电或数设，听说数电是纯考试，数设是考试 + 大作业，又听说数设助教全是 tuna 群友，就选了数设，还好没掉课（

虽然不知道讲课内容和 DDPP 有多少是正交的，但看一看 ~~除了没时间学缓考的课有挂科风险~~ 也没啥坏处。

上学期 [在上课期间学 CS:APP](/post/2022/09/csapp) 还是挺痛苦的，希望这次寒假能多学一点。本来想寒假补完一下 CS:APP，但大概是没时间了。先学 DDPP 可能对 CS:APP 的第四章也会有些帮助 (?)。

看了下 preface 和 chapter 1 开头，感觉这个作者说话挺有意思的，joke 含量很高。下面这句摘自 chapter 1 开头，两词三义，~~[<span class="text-aisan">爱姐</span>](https://zh.moegirl.org.cn/宫下爱)[<span class="text-mia">秀酱</span>](https://zh.moegirl.org.cn/内田秀)狂喜~~，~~又多了一个不读中文翻译的理由~~，~~让技术书籍的翻译也来体验一下<span class="text-nijigasaki">虹咲</span>烤肉 man 的痛苦吧~~。

> Or perhaps you’re an electrical engineering student who already knows something about analog electronics and circuit design, but you wouldn’t know a bit if it bit you.

P.S. 为什么不是 “DD:PP” 呢 🤔 ~~是不是作者学 CS:APP 的时候觉得冒号打起来太麻烦了，就想着一定要为自己的读者省去这个麻烦~~。

UPD: 终于读完第一章了。drill problem 第一题是，“Give three different definitions for the word ‘bit’ as used in this chapter”（
`},{title:N,tags:"blog Web 项目开发",content:`当你看到 [一种很新的中文字体网页嵌入方案](https://ayu.land/webfont)，但是懒得优化 DP，也不会进化算法，你可以……

整一个[<em>另</em>一种很新的中文字体网页嵌入方案](https://github.com/ouuan/glyph-segregator)（



~~这就是你 [开坑 DDPP](/post/2023/01/ddpp) 不填的理由吗~~

## 背景

前不久看到 [一种很新的中文字体网页嵌入方案](https://ayu.land/webfont)，还想着没必要做这种优化，毕竟按 Google Fonts 进行子集化就可以做到每页 1MB 左右，按现代的网速不会有太大问题，用 devtools 开节流试了下看起来也还行。

然后我回家了，离开了校园网。虽然自定义域名的 Cloudflare Pages 还能访问，但速度暂且不论，丢包率就很有点恐怖，经常页面加载一半就卡住了。

再然后，Google Fonts 里 Noto Serif SC 的 unicode range 不含单引号（和撇号是同一个字符），导致 [DDPP 序](/post/2023/01/ddpp) 里引用的那段话的撇号在我的手机上显示成了很宽的另一种字体，才让我[发现这个问题](https://github.com/ouuan/iles-blog/commit/080bd7112f88d2eae1e86594f8820c0c517e37ce)。为了以后能及时发现这种问题，我就设置了不使用本地字体直接使用 web font 的 Stylus。

恐怖的丢包率，加上自己亲身体验 web font 加载，让我意识到了，在国内普通网络环境下，如果你的设备没有安装思源宋体，访问我的博客会是多么难受（

## 主体思路

“另一种”的主体思路[和“一种”是一样的](https://ayu.land/webfont#principle)，就是把字体划分成常用字和非常用字。但是“一种”在这之后选择了使用动态规划 + 进化算法来对常用字进行进一步的拆分，“另一种”所做的优化则基于这样一个观察：虽然一个博客有一堆页面，但 80% 的人只会访问 20% 的页面（，一个字体是否常用，不仅要看出现在几个页面，还要看出现在哪些页面。

这时候，~~一直充当[不蒜子](https://busuanzi.ibruce.info/)平替（哪平价了啊）的~~ Plausible Analytics 就发挥作用了：近段时间的页面访问量可以用来估计每个页面被访问的概率，为常用字的划分提供可靠的数据支撑。

一旦估计出了每个页面的被访问概率，就可以对每个 glyph 分别计算出，如果在每一个使用了它的页面上都加载一遍，期望代价是多少，也就是使用了它的所有页面的被访问概率之和。如果这个数大于 1，就设为常用，否则设为不常用。

这个思路还是非常简单的，可以说只是“结合实际，采取启发式方法”，也称不上是一种新的方案（

## 具体实现

虽然思路简单，但实现起来还是有点复杂的，坑有点多。

### 获取页面使用的字体

如果整个页面都使用一种字体，直接看 HTML 里有哪些中文就差不多了，但我不仅<span class="font-sans">非正文用的是黑体</span>，<span class="font-kai">引用块还是楷体</span>，说不定在哪冒出来个\`等宽\`或者 $\\LaTeX\\text{公式}$，有时候还会**加粗**，更别提心情好的时候会像这段一样直接塞 \`<span class="">\` 来修改样式。

一开始我通过 [subfont](https://github.com/Munter/subfont) 找到了 [assetgraph/font-tracer](https://github.com/assetgraph/font-tracer)，但这个 font-tracer 就两个 star，没有文档，[AssetGraph](https://github.com/assetgraph/assetgraph) 又是一个 12 年前的老项目，连 Definitely Typed 都没有，试了一下完全用不会。

想了想，最靠谱的还是直接交给浏览器来处理，所以就用 [puppeteer](https://github.com/puppeteer/puppeteer) 了。目前采用的算法是：遍历 \`<body>\`，跳过 \`<script>\` 和 \`<style>\` 子树，找到所有 [Text 节点](https://developer.mozilla.org/docs/Web/API/Text)，再加上所有 \`<img>\` 的 \`alt\` 属性。找到节点后，可以用 [\`getComputedStyle\`](https://developer.mozilla.org/docs/Web/API/Window/getComputedStyle) 获取 \`font-family\` 和 \`font-weight\` 等信息。

因为要处理很多页面，也要花一点时间，所以用了 [puppeteer-cluster](https://github.com/thomasdondorf/puppeteer-cluster) 来并行处理。（不知道为什么，在 vitest 和 iles 中运行时，不加参数会报错，而加了 \`--no-sandbox --no-zygote\` 之后并行的优化效果就差一些。）

代码：[\`getPagesFontInfo.ts\`](https://github.com/ouuan/glyph-segregator/blob/master/src/getPagesFontInfo.ts)

### 字体匹配

[完整的字体匹配](https://www.w3.org/TR/css-fonts-4/#font-style-matching)是非常复杂的，我也没找到相关的库，就自己写了一个简陋的只匹配完整 \`font-family\` 和 \`font-weight\` 的算法。

其实一般 \`font-weight\` 也就 400 和 700，但我还是实现了一个 [完整的 \`font-weight\` fallback](https://developer.mozilla.org/docs/Web/CSS/font-weight#fallback_weights)。

代码：[\`matchFonts.ts\`](https://github.com/ouuan/glyph-segregator/blob/master/src/matchFonts.ts)

### 常用字体划分

最关键的这一步实现起来是最简单的，因为是纯算法的，不涉及到可怕的 Web（

代码：[\`getCommonGlyphs.ts\`](https://github.com/ouuan/glyph-segregator/blob/master/src/getCommonGlyphs.ts)

### 生成字体文件和 @font-face

我使用的是 [subset-font](https://github.com/papandreou/subset-font) 来生成字体子集文件。

这一步最大的困难，是正确地写出 \`@font-face\`。

一开始我是给常用字 (common) 和非常用字 (unique) 不同的 \`font-family\`，然后发现，在特殊情况下（幸好我的博客文章列表就触发了这个问题，不然真没想到），某个字的常规样式属于 common 而粗体属于 unique，由于 \`font-family\` 里 common 排在 unique 前面，就会匹配到常规样式，而加载不出粗体。

为了解决这个问题，common 和 unique 需要使用同一个 \`font-family\`。因为用过 Google Fonts 子集划分方案，我知道有不同 \`unicode-range\` 的 \`@font-face\` 是可以组合在一起的，难道我需要计算出精确的 \`unicode-range\` 写在 CSS 里？

为此，我粗略地读了半天（~~这两个词不冲突~~）[CSS Fonts Module Level 4 W3C Working Draft](https://www.w3.org/TR/css-fonts-4/)，发现它说，\`unicode-range\` 可以比真实的 character map 大很多，若干 \`@font-face\` 的 \`unicode-range\` 也可以相交。但是，它没说两个 \`@font-face\` 能不能除了 \`src\` 啥都一样，[而只说了](https://www.w3.org/TR/css-fonts-4/#composite-fonts)：

> Multiple @font-face rules with different unicode ranges for the same family and style descriptor values can be used to create composite fonts that mix the glyphs from different fonts for different scripts.

我也不敢依赖于实验结果，就没做实验，直接加上了粗略但是保证 common 和 unique 不相同的 \`unicode-range\`，具体来说就是 0 到最大的 code point。

这里从 0 开始也是有一定原因的：我在看 specification 的时候注意到一个奇怪的东西叫 [_first available font_](https://www.w3.org/TR/css-fonts-4/#first-available-font)，虽然没太看懂具体是什么意思，但大致上感觉最好是让 \`unicode-range\` 包含空格，为了保险就从 0 开始了。

最后还有一个坑：如果 composite font 中两个 \`@font-face\` 的 \`unicode-range\` 相交，给交集内的字符匹配字体时，会按出现位置的逆序进行匹配。

这能有什么坑呢（，如果不动手试一试真的很难想到.. 按照整体的设计，访问一个页面时很有可能是 common 字体已经缓存好了，需要下载 unique 字体，如果 unique 的 \`@font-face\` 放在 common 的后面，就会优先匹配，从而阻塞住已经缓存的 common 字体，整个页面都要等 unique 下载好才切换字体，而不是先显示 common 再显示剩下的 unique。当然，反过来的话，unique 也会等 common，但这样一般来说是更好的。

还有一些细节优化：

-   生成 unique 字体文件时，文件名里有 hash 就够了，不要再添加和页面有关的信息，这样的话如果两个页面刚好 unique glyph 集合相同就可以共用一个字体文件。
-   如果一个页面一个 common glyph 都没用，就可以不添加 common font 的 \`@font-face\`。

代码：[\`generateFontFiles.ts\`](https://github.com/ouuan/glyph-segregator/blob/master/src/generateFontFiles.ts)

### 将 CSS 写入 HTML 文件

虽然也有想过直接找到 \`</head>\` 文本替换，但为了靠谱还是用的 [\`jsdom\`](https://github.com/jsdom/jsdom)。

这部分的代码是最短的：[\`injectCSS.ts\`](https://github.com/ouuan/glyph-segregator/blob/master/src/injectCSS.ts)

### 给项目起名

主体思路是把 glyph 分成两类分别对待，就很有 segregate 的感觉（

主要还是因为刚写了一个 [segregated fit](/post/2022/11/csapp-9#segregated-fit) 印象比较深刻，所以就取了这么个名字。

### 在博客中使用

就是 [从 iles 获取页面信息](https://iles-docs.netlify.app/config#ssg-onsiterendered)，从 [Plausible Stats API](https://plausible.io/docs/stats-api#get-apiv1statsbreakdown) 获取访问量，调用 [Vite API](https://vitejs.dev/guide/api-javascript.html#preview) 跑一个 preview server，然后调用 \`glyph-segregator\`。直接看[代码](https://github.com/ouuan/iles-blog/commit/695f8b22ca3a791ceeb5440e81a6fa377b50bb3b#diff-ca899b3bf20a893bb3dfb058072a2b279953ce008f562727ad74a76d520be662)吧。

访问概率的计算方式是，看每个页面近 90 天的访客数，加一后除以其中最高的加二（其实这个加一加二基本没啥用）。用最高页面访客数而非实际总访客数作分母，是想在算法的基础上更加偏向于划分到常用字一些，稍微优化一点访问页面较多的访客的体验，也可以少一次 API 查询。

更新常用字集合用的是 [scheduled GitHub Actions](https://github.com/ouuan/iles-blog/blob/master/.github/workflows/update-fonts.yml)，在 Docker 里跑是因为 [Connection refused for local server in github actions workflow](https://stackoverflow.com/questions/74332455/connection-refused-for-local-server-in-github-actions-workflow/74341376)。

## 实际效果

整个 \`glyphSegregator\` 用时 40s 左右，glyph 数量和 common font file size (woff2) 如表所示：

|                                               | Noto Serif SC Regular | Noto Serif SC Bold | LXGW WenKai Regular | LXGW WenKai Bold |
| :-------------------------------------------: | :-------------------: | :----------------: | :-----------------: | :--------------: |
| <span class="whitespace-nowrap">common</span> |    575 (162.7KiB)     |    25 (8.5KiB)     |     37 (5.2KiB)     |        0         |
|                    unique                     |         2311          |        1536        |         161         |        0         |

首页只需加载两个 Regular 的 common font，每个页面需要加载的字体文件总大小缩减到了原来使用子集化的 1/4 左右，并且加载的字体文件数量从 10\\~30 个缩减到了 2\\~6 个。

作为对比，如果出现在两个页面就设为常用字，Noto Serif SC Regular 的 common 有 299KiB，出现在三个页面则是 227KiB。

## 后记：font subsetting 与 kerning

因为通过 Stylus 设置了不使用本地字体，我可以轻松地在本地字体和 web font 之间切换。然后我就偶然发现，切换时一些标题发生了字符的偏移。原因也很简单，就是相邻的两个字符本来有 kerning (字距调整)，但它们被划分到了不同的子集中，生成字体子集时就丢失了 kerning 信息。

我在 glyph-segregator 中 [添加了 \`alwaysCommonGlyphs\` 选项](https://github.com/ouuan/glyph-segregator/commit/ae3ddd5cbb91f0eb6bbfec7071ee408c28b36dec)（ASCII 字符总是设为 common，如果需要处理非 ASCII 字符的 kerning 也可以修改设置，但我的博客就假设只有 ASCII 字符会遇到这个问题）来解决这一问题。最好的解决方案是真的去看一下字体里有哪些 kerning 信息然后相应地处理，但是差不多得了（

<Card title="font kerning 示例">

-   有 kerning: <span style="font-kerning: normal; font-size: 2rem;">TAVeYoW</span>
-   没 kerning: <span style="font-kerning: none; font-size: 2rem;">TAVeYoW</span>

</Card>

后记的后记：还是改成了[即使未被使用也添加进 common glyph set](https://github.com/ouuan/glyph-segregator/commit/e955eb1c935d77adf0e4bcb5c870fee0614801b6)，否则如果新加一个 always common 的 glyph，为了让它 common，就会改变 common glyph set，导致 cache 失效。这里有一定的 trade-off，要在 cache 失效 / 多塞一些未被使用的 glyph / kerning 挂掉之间进行选择，我还是选择了多塞一些未被使用的 glyph，毕竟整个 ASCII 也没多大。最好是借助人类智慧来预测一下哪些 glyph 更有可能在未来被添加而放进 common glyph set 里，其他 glyph 就只有使用了才放，但是差不多得了（
`},{title:L,tags:"JavaScript 问题解决记录",content:`tl;dr: \`replace\` 的第二个参数应当使用字面量或函数，不应使用带变量的字符串表达式，否则可能发生意想不到的错误替换。



## String.prototype.replace 的第二个参数

(reference: [\`String.prototype.replace()\` - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_the_replacement))

\`\`\`javascript
replace(pattern, replacement);
\`\`\`

第二个参数 \`replacement\` 可以是字符串或函数，如果是函数，则由匹配信息作为参数计算出 replacement，如果是字符串，则可以使用一些 special replacement pattern：

|                          Pattern                           |                                           Inserts                                            |
| :--------------------------------------------------------: | :------------------------------------------------------------------------------------------: |
|                            \`$$\`                            |                                       Inserts a \`"$"\`.                                       |
|                            \`$&\`                            |                                Inserts the matched substring.                                |
|                          \`\` $\` \`\`                          |            Inserts the portion of the string that precedes the matched substring.            |
|                            \`$'\`                            |            Inserts the portion of the string that follows the matched substring.             |
|                            \`$n\`                            | Inserts the \`n\`th (1-indexed) capturing group where \`n\` is a positive integer less than 100. |
| <code class="important-whitespace-nowrap">$\\<Name\\></code> |              Inserts the named capturing group where \`Name\` is the group name.               |

## 使用变量作为 replacement 带来的问题

我实际遇到的问题是 [iles#224](https://github.com/ElMassimo/iles/issues/224)，由于使用了模板字符串作为 replacement，在变量中包含上面这些 special replacement pattern 时，就会错误地替换。

解决方法也很简单，将含变量的表达式改成函数（前面加上 \`() => \`）就可以了：[regex - javascript - Better Way to Escape Dollar Signs in the String Used By \`String.prototype.replace\` - Stack Overflow](https://stackoverflow.com/questions/28102491/javascript-better-way-to-escape-dollar-signs-in-the-string-used-by-string-prot)。

因为解决的代价非常小，虽然有的时候根据代码逻辑可以推断出 replacement 不含 \`$\`，依然可以认为，凡是 replacement 需要用到变量的，都应当替换成函数。

## 使用 ESLint 检测这一问题

[写了个](https://github.com/ouuan/eslint-config/commit/166e332dbdf8dc2ab9ff918302ada13fbd487ead) [\`no-restricted-syntax\`](https://eslint.org/docs/latest/rules/no-restricted-syntax) 的配置：

\`\`\`javascript
{
  rules: {
    'no-restricted-syntax': [
      'error',
      {
        selector: "CallExpression[callee.property.name='replace'] > .arguments:nth-child(2):not(Literal):not(ArrowFunctionExpression):not(FunctionExpression)",
        message: 'Only literals and functions are permitted as the 2nd argument of String.prototype.replace. Use a function that returns the expression instead.',
      },
    ],
  },
}
\`\`\`

因为只是分析 AST，有很多情况会误报，例如 replacement 是一个函数名，但实际代码应该很少出现这样的情况，真遇到了的话再套一层函数就 ok 了，实在不行还能用注释 disable 掉 lint。

没研究过，不知道写 ESLint plugin 能不能更加准确地检测，~~但是差不多得了~~（
`},{title:M,tags:"blog CSS Web 经验分享",content:`我的博客好像还用了不少奇怪的小 trick 来优化 （~~hopefully~~） 排版，在这整理一下，分享出来，也是怕几年（~~几天~~）后想不起来这些奇怪的东西是在干什么。

主要是 text justify 相关和标点挤压相关。



我博客的 Markdown 渲染基于 [unified](https://github.com/unifiedjs/unified)，所以下面的一些优化是以 unified 插件（remark / remark-rehype / rehype 插件）的形式实现的。

<Card type="warn">
为了直观地进行演示，本文可能会在提到一个问题的段落通过设置文本和 CSS 特意制造出相应的问题，并禁用对这个问题的处理措施以将问题展示出来。
</Card>

## text justify 相关

在每行的宽度略有差异时，[使用两端对齐会让中文排版更加美观](https://www.w3.org/TR/2022/DNOTE-clreq-20221009/#line_adjustment)，这一般通过 [\`text-align\` CSS 属性](https://developer.mozilla.org/docs/Web/CSS/text-align) 的 \`justify\` 选项实现。但由于网页排版的不确定性，每行的宽度可能不是略有差异而是有很大差异，这时使用 text justify 就会造成过大的空隙，所以需要避免出现过短的行，或者在有必要时禁用 text justify。

### lang="zh-CN" 对 text justify 的影响

这个并不是 trick，是基操，但挺重要的，还是写在这。

如果没有将 HTML 的 [\`lang\` 属性](https://developer.mozilla.org/docs/Web/HTML/Global_attributes/lang) 设为中文，在 Firefox 109（以及其他版本 / 其他浏览器，但不包括 Chrome 109）中就会按照英文的规则，将连续的汉字视作一个单词，而只在词与词之间增大间距，不改变汉字之间的间距，如下所示：

<p lang="en" style="margin: auto; width: 12em; border: gray solid 1px;">这是一个设置了 \`lang="en"\` 和固定宽度的段落，这是一个 loooooooooooooooong word。</p>

![上面的 lang 设为 en 的段落在 Firefox 109 中的渲染效果](firefox-text-justify-en.png)

其中，第一行没有两端对齐，而第三行只在逗号后面增加了间距。

如果设置了 \`lang="zh-CN"\` 则会在汉字间添加间距：

<p lang="zh-CN" style="margin: auto; width: 12em; border: gray solid 1px;">这是一个设置了 \`lang="zh-CN"\` 和固定宽度的段落，这是一个 loooooooooooooooong word。</p>

![上面的 lang 设为 zh-CN 的段落在 Firefox 109 中的渲染效果](firefox-text-justify-zh-CN.png)

当然，设置 HTML 的 \`lang\` 属性还有其他作用，不管怎么样总是得设一个的。

### 断开过长的行内代码

有时候会遇到一些 <code style="word-break: normal;">veryLoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooongInlineCode</code>，为了让它不断开，前面的一行就会非常短，justify 后间隙就非常大。当然，这样的问题不局限于行内代码，但正常的英文很少会遇到特别长的单词，代码则经常遇到，所以我选择对代码进行处理（主要是因为不需要分词套 \`<span>\`）。

思路很简单，就是把过长的 \`:not(pre) > code\` 通过 [\`<wbr>\`](https://developer.mozilla.org/docs/Web/HTML/Element/wbr) 或者 [\`word-break: break-all\`](https://developer.mozilla.org/docs/Web/CSS/word-break) 断开，让它不可断开的部分没那么长。例如：\`<code>word<wbr>-<wbr>break<wbr>: <wbr>break<wbr>-<wbr>all</code>\`、\`<code>&lt;<wbr>code<wbr>&gt;<wbr>word<wbr>&lt;<wbr>wbr<wbr>&gt;-&lt;<wbr>wbr<wbr>&gt;<wbr>break<wbr>&lt;<wbr>wbr<wbr>&gt;: &lt;<wbr>wbr<wbr>&gt;<wbr>break<wbr>&lt;<wbr>wbr<wbr>&gt;-&lt;<wbr>wbr<wbr>&gt;<wbr>all<wbr>&lt;/<wbr>code<wbr>&gt;</code>\`……（~~禁止禁止套娃~~）。

具体实现：[\`breakLongCode.ts\`](https://github.com/ouuan/iles-blog/blob/master/src/rehype/breakLongCode.ts)

1.  如果按空格分开没有超过 10 个字符的部分，不进行处理；
2.  如果按正则表达式的 \`\\b\` 分开没有超过 12 个字符的部分，则在 \`\\b\` 处插入 \`<wbr>\`；
3.  如果按 \`\\b\` 以及下划线分开没有超过 15 个字符的部分，则在相应位置插入 \`<wbr>\`；
4.  否则，没救了，直接 \`word-break: break-all\`。

当然这个粗糙的处理方式还是有一些问题，比如从上面的示例就可以看出来，期望结果可能是 \`<wbr>\` / \`<code>\` 不被断开，但实际上会在 \`<\` 后 / \`>\` 前断开。

UPD：链接也可以用同样的方法进行处理。

### 在小屏幕上对窄的元素禁用 text justify

<p style="margin: auto; width: 7em; border: gray solid 1px;">有的时候容器宽度太小，即使是正常的普通文本也不适合进行 text justify。</p>

我选择了一个非常简单粗暴的处理方法：认为窄的元素 = 小屏幕上嵌套了多级的元素。

\`\`\`css
.article-style {
  text-align: justify;
}
.article-style > * > * {
  text-align: initial;
}
@media (min-width: 40em) {
  .article-style > * > * {
    text-align: inherit;
  }
}
\`\`\`

（上面放的是编译出来的 CSS，[源码](https://github.com/ouuan/iles-blog/blob/master/src/styles/article.scss)是使用 UnoCSS 的 SCSS。）

一些细节：

-   使用 \`*\` 选择器，[specificity](https://developer.mozilla.org/docs/Web/CSS/Specificity) 很低，便于 override。
-   只选择 \`> * > *\` 而非 \` * *\`，这样的话嵌套更深的元素依然从 parent 继承 \`text-align\`，就可以设置 CSS override 掉一整个子树。（之前我一度以为 katex 不自带行间公式居中，后来发现是被我的 CSS 改掉了 \`text-align\`。）
-   使用 \`inherit\` 而非 \`justify\` 进行撤销。

### 对包含过长行内公式的元素禁用 text justify

除了 \`行内代码\`，$\\text{行内公式}$ 也是常见的过长的不可断元素。这里我采用了一个本文最 dirty 的处理方式：在客户端通过 JavaScript 检测宽度过大的行内公式。

具体实现：[\`TextJustifyFix.vue\`](https://github.com/ouuan/iles-blog/blob/master/src/components/TextJustifyFix.vue)

-   只修改 \`text-align: justify\` 的元素，如果已经设置为其他对齐方式（例如表格中的居中对齐），就不应修改。
-   使用了 [\`document.fonts.ready\`](https://developer.mozilla.org/docs/Web/API/FontFaceSet/ready) 来等待字体全部加载好再检查宽度。

## 标点挤压

代码实现：[\`mojikumi.ts\`](https://github.com/ouuan/iles-blog/blob/master/src/remark/mojikumi.ts)、[\`mojikumi.scss\`](https://github.com/ouuan/iles-blog/blob/master/src/styles/mojikumi.scss)。

### 相邻标点的挤压

例如：「<span class="no-mojikumi">：“。”（。）</span>」→「<span>：“。”（。）</span>」。当然本页其他地方也有一些例子。

具体规则 [clreq](https://www.w3.org/TR/2022/DNOTE-clreq-20221009/#compression_rules_for_consecutive_punctuation_marks) 中说的比较模糊，可以参考 [jlreq](https://www.w3.org/TR/2020/NOTE-jlreq-20200811/#positioning_of_consecutive_opening_brackets_closing_brackets_comma_full_stops_and_middle_dots)。

### 使用 CSS 去除标点的一半空白

CSS 实现标点挤压有两种方式：

-   使用 [\`letter-spacing: -0.5em\`](https://developer.mozilla.org/docs/Web/CSS/letter-spacing) 去掉右侧空白，\`margin-left: -0.5em\` 去掉左侧空白。
-   使用 [\`font-feature-settings:\`](https://developer.mozilla.org/docs/Web/CSS/font-feature-settings) [\`"halt"\`](https://learn.microsoft.com/typography/opentype/spec/features_fj#halt) 将支持 halt 特性的字体变为半宽。

使用 \`letter-spacing\` 是有讲究的，比 \`margin-right\` 靠谱，因为字符真的会只占半宽，而不是占全宽但一半和下一个字符重叠，甚至造成 overflow，可能导致滚动条出现。但 \`letter-spacing\` 不能去掉左侧空白，就只能使用 \`margin-left\` 了。

通过 halt 特性变为半宽是更加靠谱的做法，但不是所有字体都支持这一特性，思源宋体是支持的，<span class="font-kai">霞鹜文楷</span> 不支持。并且，halt 只能变为半宽，不能变成其他宽度。

### 行首行尾标点的挤压

这里参考了 [Han.css](https://github.com/ethantw/Han) 的实现，就是把全宽的标点改成半宽标点和一个通过 \`::before\` 或 \`::end\` 添加的半宽的空格：

-   因为是 pseudo element，所以不影响文本内容（例如复制出来的文本）。
-   因为是空格，所以位于行首或行尾时就会发生[空格塌陷](https://www.w3.org/TR/2023/CRD-css-text-3-20230127/#white-space-phase-2)。

### 英文标点的处理

我采用了一个比较简单的判断英文标点的方法：

-   空白一侧（左括号、左引号等是左侧，其他一般是右侧）是空格时是英文标点；
-   右单引号右侧是字母时是撇号。

英文标点一般调为半宽即可，但撇号半宽还是有些太宽了，应该（根据字体而定）调成大约三分之一宽，单引号也可以调窄一点，所以可以特判一下单引号，使用 \`letter-spacing\` 和 \`margin-left\`。

### 给霞鹜文楷添加 halt 特性

因为 [添加 halt 特性的 issue](https://github.com/lxgw/LxgwWenKai/issues/104) 被拒了，我就自己改了一个 [标点字体](https://github.com/ouuan/XiaWu-Punctuations)，顺便把引号改成了和思源宋体一致的全宽以方便一起处理（也可以理解为改引号宽度顺便添加 halt 特性，毕竟没有 halt 也可以用 \`letter-spacing\` 和 \`margin-left\` 凑合一下），具体可以看仓库里的 patch 文件。

### 关于 chws 特性

[chws 特性](https://learn.microsoft.com/typography/opentype/spec/features_ae#chws) 可以根据上下文自动挤压连续标点，一眼看上去似乎比 halt 更好用。

思源宋体不支持这一特性，只不过有 [chws_tool](https://github.com/googlefonts/chws_tool) 可以用来转换。

但是，chws 不支持行首行尾标点挤压，而如果要支持行首行尾挤压，就得把支持连续标点挤压的工作做一遍（因为要知道哪些标点已经被挤成了半宽哪些只在行首行尾挤成半宽），这样一来 chws 就没多大意义了。

### Yet another mojikumi？

有一些现成的支持标点挤压的库，例如 [heti](https://github.com/sivan/heti) 和 [Han.css](https://github.com/ethantw/Han)。但是我有一些需求：

-   要能 SSG （SSR），不能在客户端运行。最好是能在 remark / rehype 中进行处理。
-   最好是尽量使用 halt 而非 \`letter-spacing\` 和 \`margin-left\`。
-   要能添加一些自定义的规则，比如对单引号特殊处理。
-   我只需要标点挤压，不想要一个 CSS 全家桶，或者带有其他功能的 JS。

现有的库难以同时满足上面这些需求，所以我就自己写了。

本来想写一个通用的库，但通用的逻辑貌似没多少代码，不值得写成一个库。而我的整个 remark 插件又有点 opinionated，可能不太适合做成库（~~懒得做成库~~），想用的话可以在遵守 [AGPL 3.0](https://github.com/ouuan/iles-blog/blob/master/LICENSE) 的前提下直接复制（本文提到的其他代码也是一样，当然，如果是两三行的代码片段就不至于 AGPL 了，简单标一下出处就 OK）。

## 代码中的 Unicode（CJK）的字体

~~为什么马上要考抽代了你在这更新博客，我也很想知道（~~ 其实是在一个群里看到有人在聊博客的等宽字体，然后看了一眼自己的等宽字体，差点没想起来这个 trick 在干什么。

很多等宽字体是没有 CJK 字形的，在 Windows 的默认字体下，fallback 到 \`monospace\` 时中文会显示为<code style="font-family: NSimSun, SimSun, serif;">宋体</code>，而一般来说应当是\`黑体\`。所以可以为 Unicode 部分专门指定一个 fallback font，通过指定 \`unicode-range\` 来让 ASCII 字符依然 fallback 到 \`monospace\`。

\`\`\`css
@font-face {
  font-family: "Monospace Unicode Fallback";
  src: local("Noto Sans Mono CJK SC"),
       local("Source Han Mono SC"),
       local("Noto Sans CJK SC"),
       local("Source Han Sans SC"),
       local("Microsoft YaHei");
  unicode-range: U+1000-fffff;
}

:root {
  --default-mono-font: ui-monospace, DejaVu Sans Mono, Noto Sans Mono, SFMono-Regular, Menlo, Monaco, Consolas, "Monospace Unicode Fallback", monospace, var(--default-emoji-font);
}
\`\`\`
`},{title:_,tags:"digital-design 学习记录",content:`谁会愿意天天用一个课六个字的全名来叫它呢，但是数字逻辑电路是数电，数字逻辑设计是数设，数字逻辑实验总不能是 \`/数[字逻]?实验?/\`，但叫它数电实验或者数设实验好像都不太对，草（

上课的时候也是，老师一会儿一个“如果你是数设的同学”，一会儿一个“如果你没报上数设但想把数电学成数设”，这课也太乱了（

我写游记都得把两个课放一起写，课就不能合成一个吗（



写了一会儿后发现，还是得两个课分开写，dbqwcl（

这篇就是个游记，具体学的内容如果我有时间的话会放在 [DDPP 学习笔记](/tag/ddpp)，没时间（没时间写笔记 or 没时间学 DDPP 只能跟着上课）的话大概就不会放上来了（

~~某些人学都学不完了，还有空写游记？（~~

## 数字逻辑实验

### sv 班的开设

DDPP5 讲的是 Verilog，以后造机应该也是用 Verilog，但数字逻辑实验似乎是 VHDL。就像软工强迫我把技术栈全换一遍一样，多学一门语言也可以称作“技多不压身”，而且说到底我也还没学 Verilog（，但终究是有些难受的。所以看到第一节课的课件上说可以选择报 SystemVerilog 小班我还是很开心的，顿时感觉这个课科学了许多（

>   优势：对后续课程有帮助
>
>   劣势：花时间，费精力。。。

课件上是这么写的，但 Verilog 本身应该不会比 VHDL 费精力，课程内容的区别是多了个内存实验，我猜这个 warning 的主要意义在于，这是个新开的课，可能各种出锅，要让大家做好心理准备（同样是新开的 [Rust](/post/2022/08/learn-rust) 就非常科学（~~起码完全自学人感觉很科学~~），我似乎反而更希望课是新开的，而且这个 sv 班似乎也是 tuna 群友当助教（

但这个 sv 班的开设实在是有些坎坷，说起来也有些冗长，就折起来了。

<Card title="sv 班坎坷的开设过程" fold>

简单来说，数字逻辑实验有 5-1、5-3、5-4 三个班，其中 5-1、5-3 有开设 sv 班的机会，但要求是 5-1 报名人数在 25\\~28 之间，5-3 报名人数在 27\\~28 之间，才分别能开班。

是不是感觉非常神秘（，这确实很神秘，但它背后竟然真的能有确切的原因（

-   数字逻辑实验的课容量是 85，5-1、5-3、5-4 分别有 85、87（草，听说可能是因为重修？）、69 人（印象中当时的数据，现在有点小变化）
-   因为设备、实验室等资源限制，一个普通班只能容纳 30 人，一个 sv 班只能容纳 28 人，一个时间段只能有三个班

虽然说在这些限制下似乎也能在 5-4 开一个班（9\\~28 人即可，满足人数限制且不影响该时间段分班数量），但不知道是不是懒得再开一个班还是什么原因，5-4 想报 sv 班的同学只能遗憾离场（

同学们当然觉得这样搞很毒瘤，但老师似乎也知道这样很毒瘤，说是之前申请过搞成二级选课，但没通过。

一开始我担心的是很快报满报不上，后来发现完全担心错了（，真正的问题在于人数不够，而且这个是先报先得，我是通知发出来 7min 就报了，~~虽然在选课系统里 7s 可能就慢了，但是~~ 最后看名单我是第一个报的（

前两天大家都不吭声，到了报名的 ddl 当天下午我才在群里问了下人数，当时是 5-1 22 人 5-3 21 人。于是我开始在班群推销，也看到有人在课程群推销，反正主要就是以后总得学 Verilog，报 sv 班可以少学一门语言（

晚上 6 点 5-1 就开班了，但 5-3 只有 24 个人报。到了 23:44 还是 24（实际上是 25，我室友报了结果因未知原因被漏掉了，草），就很崩溃。

当时我想了两个备选方案：

-   改成 5-4 开 sv 班，但我提出后被否了，说是不方便再调整。
-   去 5-1 的 sv 班，结果得知 5-1 已经报了 31 人。~~早知道不推销了~~

好在第二天又说报名 ddl 延长半天，然后中午的时候竟然就报满了。5-3 的 28 人有 10 个是信计的，~~简单估计一下，信计有 28/30 想报 sv~~，实际上 5-1 的 sv 班只有两个信计，只不过群里 5-4 求换课的还有好几个信计，可惜都没换上，~~再简单估计一下，sv 班 12/56 是信计，信计应该一共有 52 人~~（

</Card>

### sv 班课程文档

#### 本课程只有一学分！！

![本课程只有一学分！！](1-credit.png)

开头第一句，绷不住了（

#### 按钮详细功能

一般来说 admonition 经常是比较长的会折叠起来防止刷屏，但在示波器的“按钮详细功能”一节，被折叠的都是最短的那些，比如：

> <Card title="电源开关" fold>
> 按一次打开电源，再按一次关闭电源。
> </Card>

非常地理所当然，但感觉这个事实莫名地很有意思（~~而且把电源开关写出来再折起来就莫名喜感（按一次打开 \`<details>\`，再按一次关闭 \`<details>\`~~

#### git conflict

虽说是敏捷开发课程文档，但这个 git conflict 也太（

![课程文档中出现了 git conflict 标记](git-conflict-in-doc.png)

### ~~把人忽悠进来之后~~

下面是两个课件的 diff，虽然这个优势的意思实际上没变，从 sv 班苛刻的开设条件基本上就能猜到没法随时退出，但是（

>   -   SystemVerilog
>   -   为后续课程实验提供支撑
>       -   增加内存实验<del>，其他实验不变</del>
>       -   课程成绩不与普通课堂区分，评分标准，比例与普通课堂一致
>   -   优势：<del>对后续课程有帮助</del><ins>当前学期无</ins>
>   -   劣势：花时间，费精力。<del>。。</del>
>   -   可随时退出<ins>？</ins>

### 示波器实验

上学期物理实验用过示波器，感到了这个课除了 [学习 TeX 和 R](/post/2022/10/basic-tex-and-r-for-physics-lab) 之外竟然还稍微有点用，虽然也只有那么一点点用，不知道和电子学基础相比哪个的一点点大一些（

整个实验中卡壳最久的一步是，从一坨绑得十分整齐的导线中抽出一根，草（

### 与非门电路测试实验

预习的时候对着文档里的电路图和芯片引脚图把怎么接线、怎么接地写清楚，就很容易了。

本来想半小时速通，失败了，感觉最大的问题还是抽不出导线（

### 简单组合逻辑电路实验

上午十点半才开始预习，两小时把 2 位全加器和补码减法器接好了，在课上半个小时把原码减法器接好，但是加上排队等待验收和收拾东西还是快 3 点才走。

-   三个运算器放在同一个电路里是非常容易的。补码减法器就是全加器的基础上有几个东西要取反，只要把一个开关和这些东西异或在一起就可以控制是否取反了。原码是在补码的基础上进行转换，用开关控制会稍微麻烦一些，但如果是用两个数码管分别显示补码和原码就非常容易。
-   文档上给的补码转原码不知道为什么用了五个门，实际上只要 $F_2' = \\overline{\\overline{C_2 F_1}} \\oplus F_2$ 就好了。（一开始我还对着卡诺图发呆，后来看了一眼真值表，发现这个东西用人类智慧一下就化简出来了。）最后三合一的电路我只用了 8 个与非门和 9 个异或门，就不需要用 16 pin 的模块了。
-   如果是分步骤（模块）接线（比如先接全加器，再改成减法器），过程中需要改线，在两根线叠在一起时，最好是把“模块内部”的线放在下面，和“外部”连接的线放在上面，这样的话修改和外部的连接时不用把两根线一起拔掉。
-   把接好的线带到实验室是有一定难度的，可以先只接 6 个模块，就能放进实验箱了，课上接剩下的两个模块。接上线之后体积会变大，可以把用不到的模块留在寝室。（这节课上还发了 FPGA 模块，为了能装下，大家都上交了一些多余的模块，我装得下而且本来就是把多余的放在寝室了，就没上交；但是这样一来我就长期有几个模块放不进实验箱了 🌚）

~~如果你不知道怎么接线的话可以尝试对着下面这张图复刻~~

![电路连接实物图](adder-circuit.jpg)

后来看到有同学上面的线统一朝上，下面的线统一朝下，就整齐一些。

最后收拾东西的时候分三次发现地上掉了 5 根线，除此之外前后两排也能看到好多根线，不知道哪些是我的，哪些是隔壁的，哪些是上午的（

还听到助教吐槽同学，然后老师说，这都是正常的，现在我们去搞大模型就可以了，不用在意数电（

### 点亮数码管实验

本来想在寝室搞完直接去验收，结果去搞智能体了（

现场才开始做，一直连不上芯片，还以为是因为我用的 Arch 所以驱动有什么神秘问题，到处查了半天，最后问老师才知道是我 USB Type C 的线没插紧，绷不住了。它这个接口比一般的手机充电线要紧一些（插上一次之后复现不出来了，但在我印象中插上第一次之前不是紧一点而是紧 ~~super 多~~），插进去一半灯就亮了，所以我还以为接好了。后来想起来数设课上还提到过，USB 为了支持热插拔，电源接口比数据接口略长一些，我看到的灯大概是电源线连上了的灯，而数据线还没连上。

最后速通彻底失败了，还是第一次做到只剩几个人了才走。

### 四位全加器实验

这次真的在寝室 1.5h 搞完直接去验收，成功在上课之前验收完了，但还是得听完课才能走（

于是干脆写完了实验报告才走，实际上只是把代码复制出来，再截几张图，不知道为什么没能在讲完课之前写完（

### 计数器实验

这次有好几个人课前查，助教表示我们太急了（

之前感觉 DDPP 第五章学了几年都没学完（，但有点像当时 CS:APP 第三章，学一周能顶上课讲好几周（

### 串行密码锁实验

感觉 undefined behavior 非常多，而且作为一个密码锁竟然能在没开锁时改密码，非常神秘，但它毕竟只是个小实验而不是数设（

上课前同学聊到了游泳课，老师一进来听到了，说当年他有个同学因为游泳没过没能保研，但是现在开公司，过得比他爽，绷不住了（

听说助教因为昨晚答疑到太晚，今天没吃早饭，早八还一直搞到 11:30，还蛮惨的。下午助教是准点到的教室，于是没能在课前查完，但其实一讲完课就查也没差太多。

老师：你们是不是觉得提高要求就是必做的？明年干脆把提高要求取消了，解决不了问题可以让问题消失（

### ~~耳机线收纳测验~~

40min 速通了考试，但考完上交实验箱，收拾了半小时导线，成了最后几个走的（

~~真不懂线为啥要捆起来，白费力气，到时候抽出来也麻烦（~~

## 数设

### 数设第二次课

这节课讲了一堆数电背后的模电原理，而且还是 TTL 电路，不是 DDPP5 放在第 14 章的 CMOS。感觉完全没听懂，只不过说到底这一节是物理课不是计算机课（，后面又说讲的大部分东西不考，讲这些是为了补充一些数字电路发展的历史，弥补思维上的跳跃。

我是完全没听懂，其他同学大概也是没完全听懂。老师吐槽说，现在我们培养方案里电路知识几乎为零，数设要从头开始讲，不像他们那时候，本科上五年，什么物理都学了。本来我还在想，为什么我们只能上四年甚至三年，要学这么多东西，结果老师说他五年修了双学位 600+ 学分，而且学分是和现在一样的学时，震撼全班。

### 数设与数电

在软工课上被数电同学问了作业，先是被问了没学清楚的，后面又被问了数设没讲的内容。没想到这么早就体验到了被数电同学问懵（

### 关于 DDPP

其实我开学后有看一点 DDPP，感觉还是比上课讲的科学许多（~~比如说上课的时候去写软工了，课后看一下 DDPP 会感觉比上课讲的易懂很多，比中文教材易懂 [super 多](https://mp.weixin.qq.com/s/8qZ2bEIVyUGQYmNt6kCicg)~~），但没有从头到尾看全，也没写笔记。一方面是时间都被软工占了（，还有就是 DDPP 和上课讲的内容多少有一些差异，要是学多了感觉会搞混（

### 考前

《我怕你们都考 100 分学校找我麻烦》

《实验做的最好的两个组直接 A+，就算考试交白卷都还有拿 A+ 的机会》

《不要 15min 就做完了》

### 考试

难度还好，有一题的题意理解有点神秘，但老师说只要能说得通都算对 🤔 考完大家都在吐槽一个考课件细节的填空题（分不多），幸好我是上午刚看的课件，要是前一天看的估计就不会做了（

### 第一次实验课

这次又在连上板子这一步出了问题，又是线的问题，但幸好不是没插好，而是线真的坏了（

成功把 VGA 显示的样例跑起来之后就开始啥都不懂但是魔改参数，很难不想起小学第一次去上机器人课的时候也是这样（

不能把板子带回寝室，要在板子上调都得跑来东主楼，稍微有点难顶（

《不要在实验室过夜》，绷不住了（

### 折腾外设

background：我们组想做的是腿部动作控制（类似健身环）的 Chrome 小恐龙。

外设太难了，下次让我选一定只用键盘（

一开始先是排针没焊接，接触非常不良（几乎没有），等到五一结束老师回学校了才焊。老师帮忙焊了一个，让我自己焊了剩下两个，结果焊了三回 ~~啊三回~~ 才焊好。yysy 要是能有一些电子垃圾用来练手的话，还挺简单的，但直接在生产环境上练习实在是有点可怕（

然后是 USB 转 TTL 模块忘接地了，毕竟它不用连电源，于是就忘了（

最后是纽扣电池电流太小，带不动传感器和无线模块，还是只能换成充电宝供电，纽扣电池、电池盒、稳压模块通通白买了（

说起来还挺简单的，但要发现问题在哪真的好难，一会儿怀疑模块烧了，一会儿怀疑是面包板不行，一会儿怀疑是线不行，发现是带不动了还以为是电压没到 3.2V，还得查各个模块的规格，以及想到去查纽扣电池的规格。

最后终于调通了，试着绑在腿上跑跑跳跳，看着凌乱的数据图，还是决定放弃跑动的检测以及跳跃高度的计算，只保留固定高度的跳以及下蹲，有时间再说（

连到板子上时还遇到一个神秘的坑，Pmod 接口有编号为 1~12 的接口，其中 5、6、11、12 是电源和地，1、2、3、4、7、8、9、10 分别是 IO0\\~IO7，结果我以为 1 是 IO1，调了半天，绷不住了（

来张图：（~~电源的四根线的颜色请不要在意~~）

![外设效果图](dino-peripheral.jpg)

这个连接就非常不稳定，跳几下就会松，~~抚摸~~ 一下这些线就又好了，过段时间还得按一下充电宝开关，之后再看怎么解决。

UPD：~~每次都要抚摸实在是太不乖了，给它捆绑了一下就老实多了（（~~ <span class="heimu">虽然这么开玩笑，我其实挺讨厌捆绑的，哪怕是二次元捆绑图也生理上就感到厌恶，~~这是可以说的吗~~</span>

![外设绑胶带](dino-peripheral-with-tape.jpg)

UPD2：刚绑上的时候还挺好的，过了几天又寄了。

UPD3：最后还是焊上了，永远不要相信没有焊上的连线（

### 调教 VGA

时序好难调（

Quartus 报的时序错误不要无视。

时钟频率太高容易寄，可以调低点。

信号跨域要处理好。

如果信号偏了两三个周期，不用管它为什么会偏，把它偏回来就行（

尽量不要用组合逻辑输出，可以加个 buffer。

### 展示

最后一天改 slide 的时候一大半的时间花在了 p 这个图标，好想用 StyleDrop（

（这是个 \`<iframe>\`，可以翻页）

<iframe class="w-full aspect-video" style="color-scheme: light;" src="/static/digital-design/index.html" />

### 视频

https://www.bilibili.com/video/av230053693
`},{title:R,tags:"Web 学习记录",content:`很好，你已经学会了 Vue、Rust、Actix、GitHub Actions、pnpm、Vitest、Caddy

现在你可以使用 React、Python、Django、GitLab CI、yarn、Jest、Nginx 来完成软工作业了（



![技术栈交集为空的 meme](tech-stack.jpg)

（其实这里面比较有问题的就只有 React，其他都还好，~~只是数量多凑一点 meme 效果更好~~）

## 小作业

### Django 后端小作业

每一处需要修改的代码都列出来了，还有详细的注释告诉你要干什么。Django 完全没学，就根据提示查了一处文档，代码的整体逻辑也没搞清楚。

感觉写完之后理解了 ChatGPT，看着注释和示例补全代码根本就不需要学会如何写代码嘛（

### 学 React

小作业应该不需要怎么学 React，但还是把 [Learn React (Beta)](https://beta.reactjs.org/learn) 完整过了一遍。

之前都在 Twitter 上云 React，学了之后终于有喜欢 Vue 的自信了（~~所以说 X 自信就是要允许 Y 才能有，以 X 自信为名打压 Y 到底是什么操作~~

<Card title="Vue 用户初学 React 感到不适的一些点" fold>

-   我希望 HTML 放在统一、独立的位置，不分散在多处，不和 JS 代码在结构上混在一起。
-   \`v-if\` 要用 if-else / \`?:\` / \`&&\` 实现：我不希望在 JSX 外部写 if-else；表达式的括号可能引入额外的缩进；\`?:\` 实现多级 else if 可能看不清；修改代码时不像 \`v-if\` 只需要添加一行不影响其他行。总之就是感觉很丑（
-   \`v-for\` 要自己使用 JS 计算得到。
-   不支持 named slot（可以用 prop 替代但感觉不是很优雅）。
-   event handler 不能 \`count += 1\` 必须 \`() => count += 1\`。
-   虽然只是个语法糖，但似乎没有 \`v-model\` 等价物。
-   没有 event modifier (\`@click.stop\`)，需要手动 \`e.stopPropagation()\`。
-   需要用 setter function 来修改 state，\`useState\` 返回两个变量。
-   state 是 snapshot，反直觉。教程里说这样可以避免一些 timing mistake，但我感觉在 Vue 里一般只要传值而不是 ref 就行？确实有一定意义但我还是更希望符合直觉。
-   修改 object / array state 很麻烦，使用 Immer 的话似乎就和 Vue 差不多了。
-   state 绑定在树的每个位置上，而非存在 component 里。
-   \`useMemo\` 需要手动指定依赖，\`computed\` 不需要。

本来想把 \`useEffect\` 也列出来，但 React 的 [这种设计思路](https://beta.reactjs.org/learn/lifecycle-of-reactive-effects#thinking-from-the-effects-perspective) 似乎也有一定道理。

但当我写出 \`useEffect(() => () => clearInterval(timerRef.current), [])\` 的时候我还是不明白了，这也能“从 Effect 的角度思考”吗，给个 \`onUnmounted\` 不好吗。

</Card>

<Card title="高情商与低情商" fold>

我在群里问了个问题，结果助教全都跑来加我好友，草（

那我也不客气了，上来就问为什么换成 React，bksw（

![和助教的消息记录](eq.png)

~~不难看出，这里面情商最低的是我~~

</Card>

### React (Next.js) 前端小作业

上来就看到 ESLint 是 4 空格缩进、优先双引号，这能忍吗（。特意去确认了一下，除了前端助教参与的几个项目，随便找一个项目都是 2 空格缩进、优先单引号（

再一写代码，发现不对劲，这个 ESLint 有啥 rule 啊，怎么怎么写都没 lint error，给我整不会了（

于是直接上了 [\`@ouuan/eslint-config-ts\`](https://github.com/ouuan/eslint-config)，理论上来说我应该整一个给 tsx 用的 config，但 ts 的 config 配合上小作业模板原有的应该也凑合着能用吧（

写完后的感觉和 Django 小作业差不多，React 都白学了，啥都不会就能写完（

> 这是你前端小作业的最后一个 Step 了，如果你已经完成了，我相信你已经充分掌握了 Next.js 的入门知识。
> 
> 事实上这份前端小作业几乎可以作为大作业的起始框架。除了 Next.js 框架本身，其包含了：
>
> - 代码风格检查与修正插件 ESLint，配置文件为 \`.eslintrc.json\`
> - 单元测试框架 Jest

不是，你是认真的吗，先不谈学会多少能算是《充分掌握了入门知识》，这个 eslintrc 真的能用吗（

第二天早上起来再看了下代码，发现组件 unmount 时没有 \`clearInterval\`，而这需要在允许（推荐）的代码范围之外进行修改，怎么回事（

网络请求也是，unmount 时没有 abort / ignore，但要改的话交互逻辑也会有些变化，就懒得修了，一个简陋的小作业而已（

### CI/CD 小作业

[前一天的 Power TUNA](https://tuna.moe/event/2023/welcome-and-ipsec/) 上还有人问为什么 TUNA 有很多海外流量，第二天就看到了在 Dockerfile 里硬编码 TUNA（

### 为子目录设置 commit 邮箱

作业经常会需要（或者说最好需要）使用一些与平时不同的 commit 邮箱，而 SECoder 的邮箱验证似乎还坏了，就更需要了。

以前碰到这种需求我都在每个 repo 设 local git config，但在软工可能有好几个 repo，不仅麻烦而且可能忘记，就需要更好的解决方案。

其实简单搜一下就很容易搜到，毕竟这是个很常见的需求：

-   在 \`~/.gitconfig\` 中添加

    \`\`\`
    [includeIf "gitdir:~/some/path/**"]
        path = ~/some/path/.gitconfig
    \`\`\`

-   在 \`~/some/path/.gitconfig\` 中添加

    \`\`\`
    [user]
        email = 2021000000@secoder.net
    \`\`\`

### 小作业的一些锅

deploy 之后发现一堆锅，它们不影响我的小作业得分，只会影响我能不能交上数学课作业，但我还是修了，数学课作业则是没写完就交了（

说到这就得怀念程设训练了，还有 5 分的“课堂参与”，额外加在 100 分之外，回答几个同学的提问、开一些 issue 帮忙修锅就拿满了，~~虽然最后这 5 分对 A+ 毫无帮助，要是能移到软工就好了~~。

#### Next.js static HTML export 有 dynamic route 时报错

在 Next.js 13.0.7 之前，具体来说是 [13.0.7-canary.5](https://github.com/vercel/next.js/releases/tag/v13.0.7-canary.5) 之前，通过 \`next export\` 得到 static HTML export 后，如果访问一个能匹配上 dynamic route 的 static route，会报“Application error: a client-side exception has occurred”。例如，有 \`pages/[id].tsx\` 和 \`pages/list.tsx\` 时，访问 \`/list.html\` 就会报错。

简单看了一下这个版本的 changelog，有几个疑似和这个 bug 相关的，但我没能确认具体是哪个。本来想在本地 build Next.js 来进一步确认，但我一 build 就报一万个类型错误，搞了半天也没搞好，就放弃了。反正 bump 一下就修好了，~~开课前为啥不 bump 一下啊~~。

#### Next.js static HTML export 的 Nginx 路由配置

感觉网上搜到的一些 Nginx 路由配置都很迷惑：\`$uri\` 是匹配不到 HTML 文件的，需要 \`$uri.html\`；\`$uri/\` 则可能匹配到目录，导致 403；动态路由如果不专门写路由配置的话，就不能直接访问到正确的 HTML，static HTML export 的作用就没有了，而且，fallback 到 \`/index.html\` 可能导致加载一些不需要的页面内容和 JS，实际上比直接 SPA 更劣。

#### 用户名格式检查

说来惭愧，我一开始也没意识到用户名没校验格式的问题，还是配路由的时候才想到用户名里会不会有 slash。

现在要修的话确实麻烦，所以只要归结为《由于小作业的简化》就好了（

#### ~~忘记关测试用 Docker container~~

第二天早上起来一看，Plausible 特别卡，再一看，load avg 都快两位数了，原来是在 VPS 上测试后端部署忘关了 🌚 不要随便在生产环境顺便测小作业（

### 玩小作业

把 game of life 当成冬日绘板画画，动态更新时钟，从 LifeWiki 获取随机 pattern，这是一个作业写不完的人能干的出来的吗，共享后端是这样用的吗（

第二天早上起来一看（~~怎么每段都有个第二天早上起来~~），大家都在画些啥，我还是太保守了（

### 回答同学提问

软工的公开提问貌似只能在微信群，而且助教有十几个，回复速度实在是太快了。程设训练的时候我还能偶尔抢在助教之前回答问题，现在根本做不到（

### 偷窥同学代码

偶然间发现 SonarQube 上可以看到同学的代码，因为我的小作业已经交了而且分都给了，所以我就放心大胆地偷窥了（

本来想给助教报告一下问题等权限修复，结果说是懒得修了，《希望没多少人发现》，~~导致我甚至不能在迟交 ddl 之前在博客吐槽~~（要是下学期还不修，大家都学会了这个操作，那只能说不是我的锅了），那我只好趁机来认真看一看同学们都写了一些什么奇妙代码（

-   冗余的类型标注（看到文档里讲 TS 的时候举例全是冗余类型标注时，我就知道同学们肯定会写一万个 \`let count: number = 0\`）

-   只需条件修改 prop 时，条件渲染 prop 不同的两个组件

-   手写八遍而不是使用 \`for\` 来遍历网格的邻居

-   更新 React state 时即使结果是常量依然使用回调函数

-   回调函数写成 \`() => { foo(); }\` 而不是 \`foo\`

-   冗余的 \`flex-direction: row\`

-   复制二维数组，有看到用 \`for\` 一个个 \`push\` 的，也有看到直接 \`JSON.parse(JSON.stringify)\` 的；正确写法应该是 \`old.map((row) => row.slice())\`。数组大小为 1000x1000 时，在 Firefox 中，这两种写法的用时都大约是 \`map\` & \`slice\` 的 10 倍，在 Chrome 中，一个个 \`push\` 的用时是 \`map\` & \`slice\` 的 3 倍，\`JSON.parse(JSON.stringify)\` 的用时是 40 倍。而且，由于小作业中需要的是复制其他所有，但修改一个，很多同学在 \`for\` 里面写 \`if\`，这样效率更低，应该把 \`if\` 写在 \`for\` 外面。

    但是还看到一种写法，只深复制修改了的那一行，其他行浅复制。草，这样确实性能更好。

-   依赖于效果为 toggle 的按钮不会在 toggle 完成前被点击两次：
    
    -   问题背景：一个 start 按钮和一个 stop 按钮，修改一个 \`playing\` 的 state，处于 playing 状态时需要一个 \`setInterval\`
    -   问题 1：在 start / stop 时将 \`playing\` 修改为 \`!playing\` 而非 \`true\`/\`false\`
    -   问题 2：只在 stop 时 \`clearInterval\`，没有在 start 时 \`clearInterval\`
    
    正常的交互很难做到 toggle 完成前被点击两次，基本上只能通过在 console 连续调用两次 \`click\` 实现，但最好还是不要依赖于这一点。

### Node.js 和浏览器的不同 timer

队友问了一个神奇的 bug，说是 \`clearInterval\` clear 不掉，我看了半天都没发现问题，最后发现开头有个 \`import { setInterval } from 'timers'\`。

之前还真没注意过，timer 有 Node.js 和浏览器两个版本，Node.js 的 \`setInterval\` 返回的是一个 object，浏览器返回的是一个 \`number\`。

-   直接写 \`setInterval\` 时，在 TypeScript 中会被认为返回 \`NodeJS.Timer\`，而实际运行时在哪运行就用哪个版本的函数。
-   如果写的是 \`window.setInterval\`，在 TypeScript 中会被认为返回 \`number\`，在 Node.js 中运行会报错。
-   如果是 \`import { setInterval } from 'timers'\`，即使是在浏览器中运行也会使用 Node.js 版本的函数。

这里比较重要的是 \`setInterval\` 和 \`clearInterval\` 要配套，不能一个用 Node.js 的一个用浏览器的，否则会 clear 不掉甚至报错。

一般来说直接写（不 \`window.\` 也不 \`import from 'timers'\`）就是最好的，虽然看起来 TypeScript 会将 \`number\` 误认为是 \`NodeJS.Timer\`，但这个 \`number\` 本来就不该被当作一个 \`number\` 来使用，这样的 typing 反而是好的。

这里如果再仔细研究一下可以单独写一篇博客了，但还是算了吧（

### 小作业即将截止

> 小作业 将于 3 月 16 日（周四）23:59 截止。
>
> 请注意截止时间不是 21:55。
>
> ……

后面省略的几句也是模仿的 DSA，~~DNS~~ <span class="heimu">前几天某位助教答疑的时候把 dns typo 成了 dna</span> DNA 动了，好评，但开头这个对偶的 ddl 绷不住了（

## 大作业

### 组队

在另外一个通识课上体验了一下差点没组上队（虽然后来得知还有不少人比我更晚组上队），最后完全 rand 组队。所以真的很感谢上学期就找我来组队的队友。

### 起队名

> HardToName / 起个名好难队

~~这是什么引用啊~~

队友提出了三个队名：啊对对队、BUG 全调队、\\[redacted\\] 队。前两个都被占了，后一个太魔幻了，于是最后还是用的我提出的队名：lazy / 这个队特别懒，什么都没留下~

（这 SECoder 怎么还在用这个很有年代感的个人描述 placeholder 啊。）

![学生列表，满屏都是“这个人特别懒，什么都没留下~”](lazy-placeholder.png)

俗话说得好，贱名好养活，~~取名叫 lazy 一定摆不起来（~~

其实本来还想过利用五个人的名字缩写之类的组一个队名，但人脑去想一个符合要求且有意思的队名太难了，输入法给出的候选词也没啥意思，所以我还尝试了用 ChatGPT 来生成，本来只是以为它会生成一些没意思的队名，没想到它生成出来的队名不仅没意思，而且拼音首字母甚至字数都完全不符合要求，无论怎么拷打都认错不改 🌚

### 分工 & 技术栈

听说代码可能要求有队友审核，所以放弃了一个人写前端（可能来个人写测试）的想法（

几乎是理所当然地就决定了用 Vue，没有一点反对，感觉这个不需要学 React 的 React 小作业~~没有九分也有十分的功劳~~。

给队友布置学习任务的时候感觉，我好像也不会多少东西，像是前端的测试以及 Nuxt 都还得学，JS/TS/Vue 说到底也就那么点东西，我的优势可能主要还是在经验方面，但其实也没写过什么复杂的前后端交互，大作业和博客 / Codle 这种东西还是差别挺大，写这个博客的时候很多时间也是花在一些 blog-specific 的不重要的细节上。~~说的我都有点慌了（~~

[咕了一周](https://archive.ph/6o0gs)的 Nuxt 3.3 终于在大作业开始前发出来了，避免了刚开始写不久就要 bump minor version。yysy 我选的这些技术栈还是挺最新最热的，~~要是真的出锅了都不知道怎么向队友交代（~~

紧接着就看到 TypeScript 5.0 也发了，更新更热了，害怕（

### 摇号

> 3月14日24:00后进行项目志愿的摇号

结果还真是“24:00**后**”，手动 ddl 🌚

本来晚上 11 点还看到我们队的一志愿的一志愿数量从 7 变成了 6，就是 2/3 的概率抽上，结果早上起来一看还是掉了，寄。这下和不是队友的室友一个选题了。好在例会还是 4-3，要是 4-4 的话整个下午就消失了（

### 大例会 1

第一次例会竟然就要写分工以及完整的进度安排，虽然说是随便画饼也没事，但还是感觉不太敏捷（

顺便练习了一下 [Slidev](https://sli.dev/)，在本机莫名 export 失败了，结果扔到 VPS 上就成功了，神秘。但在 VPS 上还得装上中文字体，并且配字体设置。

无奖竞猜，下面这些队名都是啥：（

> 下午的展示顺序是
> 
> 0. 我
> 1. 蛋白质
> 2. 迷
> 3. 对对对
> 4. 懒

<Card type="info" title="答案" fold>

<Card type="info" title="<s>给你一次再想一想的机会</s>" fold>

1.  青蛙补充蛋白质
2.  迷失分析LAS
3.  阿对对队
4.  这个队特别懒，什么都没留下~

</Card>

</Card>

感觉这个第一次例会总体上传达的意思就是，看起来难的功能要想简单点，差不多得了（

### 大作业第一周

#### 需求细化

第一次例会上是我提的问题最多，之后也基本上只有我在群里问需求细节问题。回答大部分都是两种之一，要么是“这样也可以，但那样也可以”，要么是“这样更好，但没分”。程设训练的时候也是这样，似乎是我的问题（，正常的想法是不是应该是只要不说清楚就可以混过去，而不是害怕没搞清楚而写错（

#### 四个阶段

第一周总体上分成四个阶段：

1.  设计任务计划，编写让队友知道要干什么的文档和 issue
2.  ping & push 队友
3.  回答队友提问 & 指出队友代码里的问题
4.  马上就要例会了，放弃指导队友，上手自己写（

感觉最后总的工作量还是超过了自己一个人把所有活干完（，希望以后能好一点，要一直是这样其他课真寄了。而且我本来就没打算管后端，就没学 Django，结果不仅要搞一点后端的规划设计，回答队友提问，还得赶着 ddl 硬上写代码，开发环境都没配好。

#### 数据库配置

你见过只能挂载目录，不能设置环境变量，也不能挂载单个文件的 Docker 容器管理吗（

这个 SECoder 实在是有些过于离谱，最后只能把环境变量写在 Dockerfile 里，用 build 出来的数据库镜像。

#### 小例会 1

主要就是聊了一下数据库和 API 的设计，也没检查 CI/CD，结束之后才想起来架构设计也没说。毕竟是小例会，确实比较轻松，感觉上午白着急把数据库跑起来了（

### 大作业第二周

#### SECoder SSH 卡住

之前就偶尔碰到 SECoder SSH 卡住的情况，今天发现是回了寝室连有线网就卡住，换成 Tsinghua Secure 就不卡了，怀疑和 IP 切换有关，不是很懂。

#### Nuxt 与 TypeScript 5.0

之前还说有点太新太热了，果然一堆锅。

之前一直随机报错 \`The "path" argument must be of type string. Received an instance of Array\`，后来发现是我直接用了最新最热的 [tsconfig 里 \`extends\` 写数组](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#supporting-multiple-configuration-files-in-extends)，然后 Nuxt 读取 tsconfig 的时候寄了。改成单个 \`extends\` 或者把 Nuxt 更新到 edge channel 就 ok 了。

另外还碰到 [一个 bug](https://github.com/nuxt/nuxt/issues/15113)，只能把路径改成英文。

#### npmmirror 更新不及时

CI 挂在了奇怪的地方，是 npmmirror 更新不及时，一个刚更新几分钟的包下不下来。npmmirror 的首页写的是每 10min 更新一次，但我等了它半小时还没更新。然后看到 npmmirror 上每个包的页面上有一个“SYNC”按钮，点一下就可以更新，草（

#### pnpm v8

感觉这个软工就和最新最热扯不开关系了（

碰到一个非常神秘的，一个 up-to-date with master 的 MR 在合并之后挂 CI，说是 lock file 有问题。本来我都没想管了，结果晚上发现博客也挂 CI 了，再一看，原来是 pnpm 发布 v8 了，草。

#### nuxt dev 报错 “Body is unusable”

[Body is unusable (undici) · Issue #19245 · nuxt/nuxt](https://github.com/nuxt/nuxt/issues/19245) 是一个非常玄学的 issue，我在部署到 SECoder 的时候遇到了，队友在 WSL2 上遇到了，但我在本地（Arch Linux）没遇到过。我让队友试着在 Docker 里跑 dev，似乎和 issue 里描述的一样，偶尔会遇到，但重试一下就好了；而且 WSL2 里加载非常慢，直接在 Windows 上运行 Docker 会快很多。

HMR 需要 WebSocket，于是在 Docker 里跑 dev 的时候发现 Vite 默认的 ws 端口是 24678，唤醒了一些远古的回忆（；结果去搜索引擎确认 ~~自己的 DNA 没有刻错~~ 的时候搜到的全是“原神‘港口驶过几艘船，二四六七八’任务攻略”，绷不住了（

#### 大例会 2

例会前 CI 一直在排长队，一开始还只用多等一会儿，后来甚至会等待超时而直接挂掉，差点没部署上（

最后发现我们部署的 dev 环境可用 prod 环境不可用，直接用的 dev 环境做演示，没人问为什么地址里有个 dev（；后来发现确实是暴力改掉 migration 后数据库没重启的问题，但我是一开始试图重启了但还是挂，以为是其他问题，但实际上是 SECoder 的容器重启需要等待，而且不知道为什么有时候等好久也没重启成功，非常玄学。

其他队都看上去做了很多功能，我们能演示的只有注册登录。虽然我们的注册登录确实相对来说更加完善，而其他队的其他功能也一堆问题，但感觉在差不多得了的氛围下，似乎还是赶上进度更重要。

### 大作业第三周

#### Nitro proxy 与 set-cookie

说来实在是绷不住。

我在一个未登录时返回 403 的 API 设置 CSRF cookie，在前后端对接测试时发现这个 \`set-cookie\` 在经过前端 proxy 之后就没了，于是我以为是 Nitro 的 proxy 不转发 \`set-cookie\`，又马上要例会了，就赶紧换成了 Nginx 反代。

例会结束后，我从 Nitro 源码翻到 h3 源码，再翻到 undici 的 issue，发现 [Undici strips out set-cookie headers, even when "credentials: 'include'" is set](https://github.com/nodejs/undici/issues/1262)，又用 https://httpbin.org/cookies/set/cookie/test 进行测试发现真的没有 \`set-cookie\`，还以为找到原因了。但又发现 [feat: remove headers filtering](https://github.com/nodejs/undici/pull/1469)，感觉很奇怪。

于是我再仔细看了一下，发现 https://httpbin.org/cookies/set/cookie/test 返回的是 302，而重定向之后就没有 \`set-cookie\` 了。而一开始那个 API 没有返回 \`set-cookie\` 则是因为它返回的不是 200，改成 200 就正常了。但凡我测试了一个返回 200 的也不至于..

上午因为这个问题差点没在例会前部署好，例会后一直研究到晚上，几乎是搞了一整天，破防了（

#### ~~姓游就要用尤大的 Vue，yóu だけにっ！~~

突然发现另一个队长姓游的队也用的 Vue，而其他队暂时没发现有用 Vue 的（我暂时只找到了 1/4 队伍的域名，剩下有找不到的也有懒得找的）。~~难道是因为和尤大一样姓 yóu 吗，这下[<span class="text-aisan">爱姐</span>](https://zh.moegirl.org.cn/宫下爱)狂喜了（~~

#### undici 发送带 \`Content-Length: 0\` 的 DELETE 请求

这是第 114514 次被 undici 背刺了，具体请看 [Sending a DELETE request with "Content-Length: 0" fails with a RequestContentLengthMismatchError · Issue #2046 · nodejs/undici](https://github.com/nodejs/undici/issues/2046)。

而这个 \`Content-Length: 0\` 是由已经没在维护的 [\`http-proxy\`](https://github.com/http-party/node-http-proxy) 加上的。不知为何，甚至不是给其他 method 加 Content-Length 的时候忘记排除 DELETE 了，而是专门给 DELETE 加的。更神秘的是，这段代码是在十年前只有一百多行的 [initial commit](https://github.com/http-party/node-http-proxy/commit/4d131567211bcefc6ef0b0592d374fef7bd5abd8#diff-0855adca187963032d89850159dc18eacfb9f206c036887e19b1877e69cc0ac1R20) 就加上了。反正给这段打个 patch 就好了。

#### SECoder commit 统计

之前还在想 SECoder 的数据统计什么时候开，没想到一开吓一跳（

它似乎是统计了所有 commit，包括没 merge 到 master 的以及被 force-push 覆盖掉的，结果我差不多到了 rk2 的两倍（，但要是只算 master 的话其实进 top10 都还差一点。应该主要是搭前端代码框架的时候，有 20 多个 commit rebase 了好几次，后来也经常 force-push 修小的 typo。这么说来 GitHub 只统计 master 还是挺好的，虽然我个人项目也经常会在 master 上疯狂 force-push（

但是 SECoder 没有 MR 评论数量的统计，其实我觉得这个才是我应该霸榜的地方（

### 大作业第四周

期中周事比较多，稍微有点拖，于是寄了。

> 整体开发过程中存在大量开发进度不协调的问题：前后端对接不协调，开发新功能与审核、测试之间不协调，没有按测试需要的拓扑顺序进行开发导致先开发的功能要等着后面的功能才能测试，对开发计划认识不统一，还没修完当周计划的锅就开始写之后的功能……

我本来以为后端搭起基本框架之后我就不用管了，可以让队友自己搞，结果到了最后才发现全是锅。虽然队友有各种奇妙操作，但不得不说很多都是我可以提早发现来避免的，还有很多是沟通上出了问题，并且我自己的活也干得有点晚。这毕竟是软工而不是大号程设训练，只能承认，我软工是真的菜，做好规划安排以及与人沟通协作的基本能力非常欠缺。

~~要是有万能的[喵森](https://zh.moegirl.org.cn/宫森葵)来协调大家的开发进度就好了~~；<span class="heimu">软工中的总集篇：要是部署挂了赶紧换一个旧版镜像，可以说是没写完而不是部署挂了，就可以只扣 1 分而不是 2 分了。</span> 突然想到的，但这么一想，好想在软工结束后的暑假二周目一下白箱，~~现在先拜一拜喵森吧（~~

只不过还有一个问题，Python 实在是，真的能比 Rust 写的快吗（，虽然看队友写了很多奇妙错误，但要是没有类型检查之类的（Python 可以一定程度上检查，但看起来队友并没有做）我大概也能写出不少 🌚

### 大作业第五周

#### Nuxt v3.3.3 起 nuxt-vitest 报错

[Nuxt v3.3.3 causes tests to fail (Unhandled Errors) · Issue #122 · danielroe/nuxt-vitest](https://github.com/danielroe/nuxt-vitest/issues/122)

想着大例会结束后是升级依赖的好时机，结果一 bump 测试挂了。去 git bisect 了一下 Nuxt，Nuxt 的构建比 Next 轻松多了，又快又不报错。bisect 出来之后本来还在想没时间也没头绪继续研究下去了，这个 issue 也已经一周了，不知道作者会不会继续咕着。结果晚上一看，被点了个心，开了个 PR，再一看，原来 bisect 出来的那个 PR 就是 nuxt-vitest 的作者写的，我都没发现（

#### NSpace 内 key 会失效

[\`<n-space>\`](https://www.naiveui.com/zh-CN/os-theme/components/space) 会给每个 child 套一个 \`<div>\`，于是 \`key\` 都失效了，如果在 \`<n-space>\` 里面用 \`v-for\` 就可能不停地 remount，调了一晚上（

这东西是真不如手写 flex。

#### 小例会 3

比较水，只不过助教说他当年搞了个云服务器，出问题了就把反代换成云服务器，感觉很有道理（

### 大作业第六周

大家这周都比较摆，我还去修了不少后端的锅。太久没管后端，对代码复用、测试的完善程度、QuerySet 的编写、请求参数的校验等问题感到了一些震惊（，但确实是没力气去修（

响应式设计还作为自选需求被提了出来，要是打算加这个需求一开始不就应该有吗，这也不是什么需要由同学想到的功能，我看需求列表没有就默认也不会作为自选需求了，刚开课的时候还找助教吐槽没有响应式分数。响应式设计要 mobile first，能这么晚加吗。

劝大家还是别太信需求列表，该卷还得卷，自己提自选需求总比快结束了被别人提强太多。

### 大作业第 7\\~9 周

草，我有软工，没有能加分的课，为什么要打智能体（

#### 《GIF 图片搜索网站》

来点 PRJ2 笑话：GIF 图片搜索网站，每个队都是最后两三周才开始写搜索功能（

### 大作业后面几周

没力气写游记了，这个课快从世界上消失吧（
`},{title:z,tags:r,content:`[DDPP5](https://wakerly.org/DDPP/) 第五章 “Verilog Hardware Description Language” 的学习笔记。

也就是初学 (System)Verilog 的笔记。



本来想寒假学，结果还是拖到了数字逻辑实验开始用 FPGA，只不过手上有模块了再来学也挺好的。

虽然从创建到发布拖了很久，但其实大部分内容都是新建文件后一周内写的，只是后来感觉学的东西已经差不多能应付上课了，就一直咕着没把最后一点学完 & 写完（

<Card title="SystemVerilog" type="info">

DDPP5 中讲的是 Verilog 而不是 SystemVerilog，我根据在其他地方找到的一些资料补充了少量 SystemVerilog 的内容。

</Card>

## neovim 配置

用的是老师推荐的 Vivado 2019.2 WebPack，而它自带的文本编辑器多少有点拉胯，所以研究了一下配 neovim。

最后选择的是 [veridian](https://github.com/vivekmalneedi/veridian) + 通过 [null-ls](https://github.com/jose-elias-alvarez/null-ls.nvim) 使用 Vivado 的 \`xvlog\`。一开始我还看 veridian 没在维护而且 star 少（~~但它好歹最后更新是在 2021，Vivado 还在用 2019~~），先试了另外几个，后来发现，不说别的，只有 veridian 支持 hover。同时使用 \`xvlog\` 是觉得还是 Vivado 自带的 lint 比较靠谱。

veridian 就是用 [lspconfig](https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#veridian)，记得同时装 [verible](https://github.com/chipsalliance/verible) 才能使用某些 feature（在 lspconfig 里只需启用 veridian）。可以把 \`root_dir\` 设为 \`util.root_pattern('*.xpr', '.git')\` 来检测 Vivado 项目的根目录。

null-ls 的配置如下，因为 \`xvlog\` 实际上是一个不能禁用文件输出的 simulator，采取了一些措施来防止它到处倒垃圾。

\`\`\`lua
local null_ls = require "null-ls"
local utils = require "null-ls.utils"
local helpers = require "null-ls.helpers"

local xvlog_sv = {
  name = "xvlog",
  method = null_ls.methods.DIAGNOSTICS,
  filetypes = { "systemverilog" },
  generator = null_ls.generator {
    command = "bwrap", -- only permit writing in /tmp
    args = {
      "--ro-bind", "/", "/",
      "--bind", "/tmp/xvlog", "/tmp/xvlog",
      "--dev", "/dev",
      "/home/ouuan/Xilinx/Vivado/2019.2/bin/xvlog",
      "--sv", "$FILENAME",
    },
    cwd = function(params)
      -- output in /tmp
      local dir = '/tmp/xvlog/' .. params.bufnr
      vim.fn.mkdir(dir, 'p')
      return dir
    end,
    to_temp_file = true,
    format = "line",
    check_exit_code = { 0, 1 },
    on_output = helpers.diagnostics.from_patterns {
      {
        pattern = '(.+): %[.+%] (.+) %[.+:(%d+)%]',
        groups = { "severity", "message", "row" },
        overrides = {
          severities = {
            ["ERROR"] = 1,
            ["WARNING"] = 2,
            ["INFO"] = 3,
          },
        },
      },
    },
  },
}

null_ls.setup {
  sources = {
    xvlog_sv,
  },
  root_dir = utils.root_pattern("*.xpr", ".git")
}
\`\`\`

另外可以用 [vim-xdc-syntax](https://github.com/amal-khailtash/vim-xdc-syntax) 添加管脚约束文件的高亮。

Vivado 的 custom text editor 使用下面的脚本。是针对 [i3](https://i3wm.org/) 配的，给 konsole 设了 name 参数，i3 设成 \`assign [instance="konsole"]\`（\`instance\` 而非 \`class\`）就可以不把这个 konsole 挪到其他 konsole 所在的 workspace，并且可以在打开新文件时 focus 过去。

\`\`\`bash
#!/bin/bash

# vivado-nvim.sh "[file name]" [line number]

set -euo pipefail

unset LD_LIBRARY_PATH

NVIM_LISTEN_ADDRESS=/tmp/vivado-nvim.pipe

if [[ ! -e $NVIM_LISTEN_ADDRESS ]]; then
    exec konsole --name "vivado-nvim" -e nvim --listen $NVIM_LISTEN_ADDRESS "$1" "+$2"
else
    nvim --server $NVIM_LISTEN_ADDRESS --remote "$1"
    nvim --server $NVIM_LISTEN_ADDRESS --remote-send ":$2<CR>"
    i3-msg '[instance="vivado-nvim"] focus'
fi
\`\`\`

## 基础语法

### module

Verilog 以 module 为基本单位（和前端的 component 有点类似）。

例子：

\`\`\`system-verilog
module inhibit (
    input  in,
    input  invin,
    output out
);
  assign out = in & ~invin;
endmodule
\`\`\`

convention 是每个文件只写一个 module。

### signal (net & variable)

一个 1-bit 的 signal 有四种取值：0、1、x（未知）、z（高阻抗）。

位运算：\`&\`、\`|\`、\`~\`、\`^\`、\`~^\`/\`^~\`。

signal 有两大类：*net* 和 *variable*：

-   net 表示线路，一般是 \`wire\`，还可以是 \`supply0\`、\`supply1\` 等（我用 \`supply1\` 的时候出现了神秘的问题，没细究，反正用恒为 1 的 \`logic\` 也差不多）。
-   variable 用于 procedural statement 中，不一定对应到物理上的线路，可以是 \`reg\` 或者 \`integer\`。其中 \`reg\` 就是变量的意思（名字取得不太好），表示单个 bit 或者 vector，与基于 flip-flop 的寄存器无关。\`integer\` 是有符号整型，一般不用来存储数据或信号，而是用于 for 循环之类的地方。

input 只能是 net，而 output 可以是 net 或 \`reg\`。不写 \`wire\` / \`reg\` 时默认是 \`wire\`。

在 SystemVerilog 中推荐用 \`logic\` 来代替 \`reg\`。

### 数字字面量 & parameter

直接写十进制数会得到一个 signed number。

可以指定位数和进制：\`1'b0\` 是 1 bit 的 0，\`4'ha\` 是 4 bit 的 10（十六进制的 A），\`8'b01x0z1x1\` 的一些 bit 是未知 / 高阻抗。如果后面写的值的位数超过前面指定的位数，高位会被扔掉，如果少了则会高位补零（或者补 \`x\` 或 \`z\`，如果最高位是 \`x\` 或 \`z\`）。这样得到的会是一个 unsigned vector，可以加上 \`s\` 得到 signed vector：\`4'sb1101\`。

\`parameter\` 用来设置带默认值的参数：\`parameter SIZE = 32, MSB = SIZE - 1, LSB = 0\`，\`parameter ESC = 7'h1b\`。 \`parameter\` 一般用作常量，而在 [instance statement](#structural-model) 中可以被修改。

### vector & 算术运算

多个 bit 可以组成一个 vector，net、\`reg\`、\`parameter\` 都可以是 vector。

vector 的下标可以是左边（MSB）大（\`reg [7:0] byte1, byte2\`）也可以是右边（LSB）大（\`reg [1:16] bus\`），起止的下标都可以指定。左边的下标对应字面量中左边的 bit。\`byte1[7]\` 是 \`byte1\` 最左边的 bit，\`bus[16]\` 是 \`bus\` 最右边的 bit。\`bus[1:8]\` 和 \`bus[9:16]\` 是 \`bus\` 的左右两边。读取越界会读到 \`x\`，写入会忽略越界的部分。

\`{}\` 用来连接 vector，例如 \`{2'b10, 2'b01}\` 等于 \`4'b1001\`，\`{2{byte1}, 2{byte2}}\` 等于 \`{byte1, byte1, byte2, byte2}\`。

vector 可以按位进行位运算，在二元运算中短的会高位补零后进行运算。

二元位运算符也有一元的版本，表示将 vector 内所有 bit 运算在一起得到 1-bit 的结果，例如 \`&byte1\` 是 \`1'b1\` 表示 \`byte1\` 的所有 bit 都是 1。

vector 之间进行赋值时会截低位或高位补零。

vector 之间可以进行算术：\`+\`、\`-\`、\`*\`、\`/\`、\`%\`、\`**\`、\`<<\`、\`>>\`、\`<<<\`（算术左移）、\`>>>\`（算术右移）。

算术的高位和低位基于左右而与下标大小无关。

除法和取模在某些情况下可能不 synthesizable，除非除数是 2 的次幂。synthesizable 时也可能会生成除法器的电路而非常昂贵。

逻辑移位得到 unsigned，算术移位保持原来的 signed/unsigned，算术右移高位补符号位。二元算术中只要有一个是 unsigned 就会将另一个转成 unsigned 再计算。signal 可以声明为 signed：\`reg signed [15:0] a\`。

### array

array 是相同类型的一列东西（一列 \`reg\`、\`integer\`、\`wire\` 等）。array 也可以指定下标范围，而与 vector 相反，声明 array 时框放在右边，例如 \`reg [7:0] byte1, mem1[0:255]\` 表示一个 8-bit \`reg\` 和一个由 256 个 8-bit \`reg\` 组成的 array。

array 可以嵌套为高维数组，而访问只能访问单个下标，不能像 vector 一样一下访问一个区间。总之除了能指定下标范围都和 C 的数组差不多。

### 逻辑运算

含 \`x\` / \`z\` 或者全 0 的 vector（或者 \`1'b0\`）是 false，不含 \`x\` / \`z\` 且含 1 的 vector（或者 \`1'b1\`）是 true。false 的值是 \`1'b0\`，true 的值是 \`1'b1\`。

逻辑运算符和比较运算符和 C 是一样的。比较时如果一侧是 unsigned 则会按 unsigned 比较。比较运算在电路中可能需要比较器（尤其是两侧都不是常量时），所以可能是昂贵的。

三目运算符 \`?:\` 和 C 是一样的。

在 test bench 中，带 \`x\` / \`z\` 的值在比较时结果为 \`x\`（用在条件判断时即为 false），可以使用 \`===\` / \`!==\` 来逐位比较（\`x === x\`, \`z === z\`），但它们不能用在 synthesizable module 中。

### compiler directives

\`\`\` \`include \`\`\` 和 \`\`\` \`define \`\`\`，和 C 是一样的。

## model

### structural model

可以使用 *instance statement* 来写 structural model，说白了就是将其他 module 实例化并连线。

built-in gate 有：

-   \`and\`、\`nand\`、\`or\`、\`nor\`、\`xor\`、\`xnor\`，接受任意个输入
-   \`buf\`、\`not\`，接受单个输入
-   \`bufif0\`、\`bufif1\`、\`notif0\`、\`notif1\`，三态门，接受一个 data input 和一个 enable input（data input 在前，enable input 在后），if 表示 enable 的 active level

使用 built-in gate 的例子：（built-in gate 的 port 没有名字，只能通过顺序指定，output 在前）

\`\`\`system-verilog
module inhibit (
    input  in,
    input  invin,
    output out
);
  wire notinvin;
  not U1 (notinvin, invin);
  and U2 (out, in, notinvin);
endmodule
\`\`\`

使用其他 module 的例子：（可以指定每个 port 的名字从而不依赖于顺序）

\`\`\`system-verilog
module silly_xor (
    input  in1,
    input in2,
    output out
);
  wire inh1, inh2, notinh2, notout;
  inhibit U1 (
      .out(inh1),
      .in(in1),
      .invin(in2)
  );
  inhibit U2 (
      .out(inh2),
      .in(in2),
      .invin(in1)
  );
  not U3 (notinh2, inh2);
  inhibit U4 (
      .out(notout),
      .in(notinh2),
      .invin(inh1)
  );
  not U5 (out, notout);
endmodule
\`\`\`

修改 \`parameter\` 的例子：

\`\`\`system-verilog
module maj #(
    WID = 1
) (
    output [WID-1:0] out,
    input  [WID-1:0] i0,
    input  [WID-1:0] i1,
    input  [WID-1:0] i2
);
  assign out = i0 & i1 | i0 & i2 | i1 & i2;
endmodule
\`\`\`

然后就可以 \`maj #(8) U1 (.out(W), .i0(X), .i1(Y), .i2(Z))\` 或者 \`maj #(.WID(8)) U1 (.out(W), .i0(X), .i1(Y), .i2(Z))\` 了。

不指定 \`parameter\` 时会使用其默认值，\`parameter\` 只能在 instance statement 也就是 structural model 中被修改，在其他类型的 model 中只能使用默认值。

可以使用 \`generate\` block，作用类似于 \`v-for\`、\`v-if\`，里面可以用 \`for\`（循环变量需要是 \`genvar\`）、\`if\`、\`case\`（被判断的要是 parameter），例如：

\`\`\`system-verilog
genvar i;
generate
  for (i = 0; i < N; i = i + 1) begin
    half_adder u0 (a[i], b[i], sum[i], cout[i]);
  end
endgenerate
\`\`\`

### dataflow model

可以使用 *continuous-assignment statement* 来写 dataflow model，也就是 \`assign\`，例如：

\`\`\`system-verilog
module is_prime (
    input [3:0] N,
    output F
);
  assign F = N[3] ? (N[0] & (N[1] ^ N[2])) : (N[0] | (~N[2] & N[1]));
endmodule
\`\`\`

### behavioral model

#### \`always\` & \`begin\`-\`end\` block

\`always\` statement 用来执行一句 procedural statement，begin-end block 用来将若干 procedural statement 合成一句。begin-end block 里的语句是顺序执行的，而 \`always\` 是和 module 中的其他语句一起并行执行的。

在 SystemVerilog 中，推荐使用 \`always_comb\`、\`always_ff\`、\`always_latch\` 来代替 \`always\`，分别用于组合逻辑、ff 和 latch（但一般不会特意去写 latch）。\`always_comb\` 会检查条件判断语句没有漏情况，避免意外生成 latch。\`always_ff\` 需要加形如 \`always_ff @(posedge clk)\` 的 sensitivity list。

如果 begin-end 里有 local \`logic\` 则需要给 block 起名字（在 \`begin\` 的后面写上 \`: name\`）才能在 simulation 之类的地方看到可读的变量名。

\`\`\`system-verilog
module alarm_circuit (
    input panic,
    input enable,
    input exiting,
    input window,
    input door,
    input garage,
    output logic alarm
);
  always_comb begin : blk
    logic secure;
    secure = window & door & garage;
    alarm  = panic | (enable & ~exiting & ~secure);
  end
endmodule
\`\`\`

#### 赋值

procedural statement 中有两种赋值，blocking 的 \`=\` 和 non-blocking 的 \`<=\`。\`=\` 表示立即赋值，而 \`<=\` 会将赋值推迟至整个 \`always\` 的结尾（右侧表达式的计算是立刻进行的），从而在 \`always\` 剩下的部分中左侧变量的值依然是赋值前的。

赋值最好遵循下面的规则：

-   在组合逻辑中，只使用 \`=\`
-   在时序逻辑中，只使用 \`<=\`
-   不要在同一个 block 中混合使用两种赋值
-   不要在不同的 \`always\` 中对同一个变量赋值

#### \`if\`-\`else\` 语句

和 C 的语法是一样的，唯一的不同就是大括号变成 \`begin\` - \`end\`。

#### \`case\` 语句

\`\`\`system-verilog
module prime (
    input [3:0] n,
    output logic f
);
  always_comb
    case (n)
      4'd2, 4'd3, 4'd5, 4'd7, 4'd11, 4'd13: f = 1;
      default: f = 0;
    endcase
endmodule
\`\`\`

虽然并非必须，但一般来说，选项应当是不重复且指定了宽度的字面量。

即使选项覆盖了所有可能，加上一个 \`default\` 可以在 simulation 中正确处理带 \`x\` 的值。

\`casez\` 是允许使用通配符 \`?\` 的匹配，例如选项可以是 \`4'b10??\`。

#### 循环语句

有很多种循环语句，但推荐使用的只有一种，就是 \`for (integer i = 0; i <= 7; i = i + 1)\`。

#### function 和 task

function 和 task 是一段可复用的 procedural statement，写起来和 module 差不多，需要定义在 module 内部（可以通过 \`\`\` \`include \`\`\` 来在不同 module 中复用）。

function 有单个返回值（可以在函数名的前面给返回值设置类型，也可以省略，默认类型是 1-bit），但不能有 \`output\` / \`inout\` port，而是以 function 自身的名字作为返回值的名字，代码中需要对这个函数名进行赋值。function 中不能设置延时。

\`\`\`system-verilog
module sillier_xor (
    input in1,
    input in2,
    output logic out
);
  function inhibit(input in, input inv_in);
    inhibit = in & ~inv_in;
  endfunction

  always_comb begin
    logic inh1, inh2;
    inh1 = inhibit(in1, in2);
    inh2 = inhibit(in2, in1);
    out  = ~inhibit(~inh2, inh1);
  end
endmodule
\`\`\`

task 没有返回值，但可以有 \`output\` / \`inout\` port，（用于 simulation 时）可以设置延时。

\`\`\`system-verilog
module lock_sim;

  ...

  task clock();
    #500;
    clk = 1;
    #500;
    clk = 0;
  endtask

  ...

endmodule
\`\`\`

有一些内置的 task 和 function，用于 simulation：

-   \`$write\`：和 \`printf\` 差不多。
-   \`$display\`：在 \`$write\` 的基础上多个换行。
-   \`$monitor\`：每次信号发生改变时都输出，后指定的 monitor 会覆盖之前的。
-   \`$monitoroff\` / \`$monitoron\`
-   \`$fflush\`：flush 输出。
-   \`$time\`：输出当前的 simulated time。
-   \`$random\`：返回一个随机数，接受种子作为参数，不指定种子的话初次运行的种子是固定的。
-   \`$stop\`：停止模拟，如果传参 \`(1)\` 则会显示当前的 simulated time 和代码位置。

## timescale & 指定延迟

\`\`\` \`timescale 1ns / 10ps \`\`\` 指定以 1ns 作为延时的单位，以 10ps 作为模拟的精度。

\`assign\` 时可以指定延迟：\`assign #5 a = b & c;\`

procedural model 中可以用 delay statement (\`#500;\`) 来暂停。

## simulation (test bench)

语法上和 synthesizable module 没有区别（只不过有个 \`initial\`，就是只执行一遍的 \`always\`，一般不用于 synthesizable module）。写起来一般是一个没有输入输出、有一个被测试 module 的实例、有一个 \`initial\` block 的 module，看看例子就行。

懒得改 DDPP 上的代码了，直接复制一份数字逻辑实验的代码（

\`\`\`system-verilog
\`timescale 1ns / 1ps

module lock_sim;
  logic clk = 0;
  logic rst = 0;
  logic mode = 1;
  logic [3:0] digit_input = 0;
  wire unlocked, incorrect, alert;

  lock #(
      .ADMIN_PASSWORD(16'ha73f)
  ) lock_inst (
      .clk(clk),
      .rst(rst),
      .mode(mode),
      .digit_input(digit_input),
      .unlocked(unlocked),
      .incorrect(incorrect),
      .alert(alert)
  );

  task clock();
    #500;
    clk = 1;
    #500;
    clk = 0;
  endtask

  task reset();
    rst = 1;
    #500;
    rst = 0;
    #500;
  endtask

  task input_password(input [15:0] password);
    reset();
    digit_input = password[15:12];
    clock();
    digit_input = password[11:8];
    clock();
    digit_input = password[7:4];
    clock();
    digit_input = password[3:0];
    clock();
  endtask

  initial begin
    input_password(16'ha73f);  // admin password
    input_password(16'h1234);  // incorrect

    mode = 0;
    input_password(16'h1234);  // set password

    mode = 1;
    input_password(16'h4321);  // incorrect
    input_password(16'h1234);  // correct
    input_password(16'ha73f);  // admin password

    // incorrect three times
    input_password(16'h4321);
    input_password(16'h4321);
    input_password(16'h4321);

    input_password(16'h1234);  // locked

    mode = 0;
    input_password(16'h4321);  // cannot set password

    mode = 1;
    input_password(16'h1234);  // locked
    input_password(16'h4321);  // incorrect
    input_password(16'ha73f);  // admin password
    input_password(16'h1234);  // correct
    input_password(16'h4321);  // incorrect
  end
endmodule
\`\`\`

通过使用 \`$display\`，可以更直观地输出结果，从而不需要对着波形图看；或者自动检查结果是否正确，在出错时输出。

有时可以通过文件读写来更方便地编写测试数据、检查输出结果。

## 有关 synthesize 的一些注意事项

-   长串的 \`if\`、\`else if\`、\`else if\`……可能导致电路也有一长串，使用 \`case\` 可能会更优。
-   组合逻辑中的循环可能会创建同一套电路的多个副本，如果要用同一个电路，可能需要改写成时序逻辑。
-   根据具体使用的 tool，有些 language feature 是不能被 synthesize 的。
-   为了更好的 synthesize 结果而需要把代码写成什么样，需要依具体使用的 tool 而定。
`},{title:j,tags:o,content:`《Computer Networking: A Top-Down Approach (8th Edition)》第二章 “Application Layer” 的学习笔记。



## Principles of Network Applications

application architecture 主要分为 client-server 和 P2P 两种。

*process* 即在某个 end system 上运行的程序（进程），不同 end system 上的 process 在网络上互相发送 message 以进行通信（注：message 即 application-layer packet）。

在一次通信中，发起通信的一方被称作 *client*，等待接收消息的一方被称作 *server*。（注：在 P2P 中，client 和 server 的身份不是固定的。）

process 和网络，或者说和 transport layer 之间以 *socket* 作为 API。

host 由 IP 地址识别，而 process 由 IP 地址 + 端口识别。

一个 application 可以选择 TCP 或者 UDP 来提供 transport service。TCP 提供 connection-oriented service（需要通过 handshaking 建立 TCP connection）和 reliable data transfer service（保证接收到 & 保序），以及 congestion control。UDP 则这些都不提供。一般会根据是否 loss-tolerant（是否允许丢失部分数据）以及对延时的敏感度来进行选择。

TLS (Transport Layer Security) 可以在 TCP 的基础上提供 encryption、data integrity、end-point authentication。它自身位于 application layer（或者可以说是 application 与 transport layer 之间 🤔），不与 TCP、UDP 并列。

application-layer protocol 决定了 message 的结构以及相应的行为。常见的 application-layer protocol 包括 HTTP、SMTP、Telnet、FTP、SIP、RTP、DASH 等。有的 application 会使用专有而非 public domain 的 application-layer protocol。

## The Web and HTTP

HTTP (HyperText Transfer Protocol) 是 Web 的 application-layer protocol，定义了 client (browser) 如何向 server 请求文件（web page）、server 如何将文件传输给 client。

HTTP 的默认端口是 80。

HTTP 不存储 client 的信息，是一个 *stateless protocol*。

HTTP（1.0、1.1、2）基于 TCP，有 persistent connection 和 non-persistent connection 两种工作方式：

-   non-persistent connection：每次 request-response 都会建立一个新的 TCP connection，收到 response 后立刻关闭 TCP connection。
-   persistent connection：同一对 client-server 的多次 request-response（例如一个页面引用的多个资源）可以共用同一个 TCP connection（在闲置一段时间后自动关闭），并且无需等待 response 就可以连续发送多个 request（被称作 *pipelining*），从而省下每次建立 TCP connection 耗费的 RTT (round-trip time)。

HTTP message 是纯文本，格式如下。

HTTP request:[^fig2.8]

[^fig2.8]: p103, Figure 2.8: General format of an HTTP request message

![General format of an HTTP request message](cnatda-fig-2.8.png)

\`\`\`http
GET /wireshark-labs/INTRO-wireshark-file1.html HTTP/1.1
Host: gaia.cs.umass.edu
User-Agent: curl/8.1.2
Accept: */*
\`\`\`

HTTP response:[^fig2.9]

[^fig2.9]: p104, Figure 2.9: General format of an HTTP response message

![General format of an HTTP response message](cnatda-fig-2.9.png)

\`\`\`http
HTTP/1.1 200 OK
Date: Tue, 13 Jun 2023 11:14:57 GMT
Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.33 mod_perl/2.0.11 Perl/v5.16.3
Last-Modified: Tue, 13 Jun 2023 05:59:01 GMT
ETag: "51-5fdfc882a3e6f"
Accept-Ranges: bytes
Content-Length: 81
Content-Type: text/html; charset=UTF-8

<html>
Congratulations!  You've downloaded the first Wireshark lab file!
</html>
\`\`\`

server 可以通过 Cookie 识别用户，cookie 通过 response 中的 \`Set-Cookie\` header 设置，在之后的每次 request 中通过 \`Cookie\` header 发给 server。

机构可以设置 Web cache，使用户先向 Web cache 发送请求，若 cache hit 则直接由 Web cache 发给用户，若 cache miss 则 Web cache 向 origin server 发送请求再返回给用户。Web cache 可以减小延迟，降低带宽压力。（与之类似的 CDN 则在[后文](#content-distribution-networks)有详细讲解。）

可以通过 \`If-Modified-Since\` header 进行 *conditional GET*，若没有修改则会返回 body 为空的 304 Not Modified。

HTTP/2 提供了 request and response multiplexing、prioritization、server push 来优化性能：

-   multiplexing：persistent connection 减少了建立 TCP connection 带来的 RTT，但又引入了 Head of Line (HOL) blocking，即共用一个 TCP connection 时较小的资源需要等待较大的资源加载完毕，所以在 HTTP/1.1 中浏览器经常还是会建立多个 TCP 连接，除了解决 HOL blocking，也可以在 TCP 的 congestion control 中取得更多带宽。HTTP/2 则将每个 message 划分成了多个小的 frame，并交替发送不同 message 的 frame（frame interleaving），从而小的资源无需等待大的资源发送完毕。
-   prioritization：同时发送多个请求时，可以为每个 response 设置优先级，让 server 优先发送高优先级的 response。除此之外，还可以设置 response 之间的依赖关系。
-   server push：一个 request 可以有多个 response，即除了对应于 request 的 response，server 还可以额外 *push*，例如在返回一个 HTML 页面时可以 push 这个页面引用的其他资源。

HTTP/3 使用基于 UDP 的 QUIC 代替了 TCP。

## Electronic Mail in the Internet

e-mail 系统有三个主要组件：user agent、mail server 和 SMTP (Simple Mail Transfer Protocol)。

发送邮件时，Alice 写完邮件后由她的 user agent 发送到她的 mail server，她的 mail server 再发到 Bob 的 mail server 中属于 Bob 的 mailbox，之后 Bob 再通过他的 user agent 从他的 mail server 获取他的 mailbox 中的邮件并阅读。

发送方的 mail server 会维护一个待发送邮件列表，如果接收方的 mail server 在当时不可用，则会等待一段时间后再次尝试，多次失败则会退回。

mail server 使用 SMTP 向其他 mail server 发送邮件，发送方作为 SMTP client，接收方作为 SMTP server。

SMTP 的默认端口是 25。

SMTP 是一个比 HTTP 还古老的协议，带来的后果之一是它整个 message 都只能包含 ASCII。

一次 SMTP 通信如下所示：[^smtp-example]

[^smtp-example]: [SMTP transport example - Simple Mail Transfer Protocol - Wikipedia](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol#SMTP_transport_example)

\`\`\`plain
S: 220 smtp.example.com ESMTP Postfix
C: HELO relay.example.org
S: 250 Hello relay.example.org, I am glad to meet you
C: MAIL FROM:<bob@example.org>
S: 250 Ok
C: RCPT TO:<alice@example.com>
S: 250 Ok
C: RCPT TO:<theboss@example.com>
S: 250 Ok
C: DATA
S: 354 End data with <CR><LF>.<CR><LF>
C: From: "Bob Example" <bob@example.org>
C: To: "Alice Example" <alice@example.com>
C: Cc: theboss@example.com
C: Date: Tue, 15 Jan 2008 16:02:43 -0500
C: Subject: Test message
C:
C: Hello Alice.
C: This is a test message with 5 header fields and 4 lines in the message body.
C: Your friend,
C: Bob
C: .
S: 250 Ok: queued as 12345
C: QUIT
S: 221 Bye
\`\`\`

其中 \`HELO\`、\`MAIL FROM\`、\`RCPT TO\`、\`DATA\`、\`QUIT\` 等是 *command*，用来进行 handshake 等操作。如果要向同一个 mail server 连续发送多封邮件，可以只 \`HELO\`、\`QUIT\` 一次（但要 \`MAIL FROM\`、\`RCPT TO\` 多次）从而共用一个 TCP 连接。\`DATA\` 后是邮件的内容，这一内容的开头是邮件的 header，结尾是仅包含 \`.\` 的一行。

email 是 user agent → mail server → mail server → user agent 而非 user agent → user agent，一大原因是如果 user agent 经常不在线则直接发很可能收不到邮件，需要用 mail server 来提高在线率以及提供对方不在线时重试的机制。

从 user agent 发到 mail server 时可以使用 SMTP 或 HTTP，从 mail server 拉取到 user agent 时可以使用 HTTP 或 IMAP (Internet Mail Access Protocol)（不能用 SMTP，因为 SMTP 是 push protocol，不能用来 pull）。

## DNS—The Internet’s Directory Service

### Services Provided by DNS

host 由 hostname 或 IP 地址识别，hostname 对人类更友好，而 IP 地址对路由器更友好。

将 hostname 翻译为 IP 地址是 DNS 的主要任务。DNS 是由多个层级的 DNS server 共同构成的 distributed database，也是使得 application 能够查询这个 distributed database 的 application-layer protocol。

DNS 被很多其他 application-layer protocol 所使用，例如在 HTTP/SMTP 中，可以使用 hostname 来访问网站 / mail server，这时就会调用 DNS。

DNS 在提供 hostname 到 IP 地址的翻译的同时，还提供了下列功能：

-   host aliasing: 可以让一个 host 在有 canonical hostname 的同时还有其他 alias。
-   mail server aliasing: 可以让同一个 hostname 在作为 Web server 和作为 mail server 时指向不同的 host。
-   load distribution: 可以让同一个 hostname 指向多个 host，在返回查询结果时进行 rotate（即改变位于首位的 IP 地址）。

### Overview of How DNS Works

由于下列原因，DNS 必须是分布式的，单点式的 DNS 无法 scale：

-   single point of failure
-   traffic volume 过大
-   离部分用户距离过远，带来较大的延时
-   难以维护（数据总量大，更新频繁）

一般来说，DNS 分为以下几层：

1.  root DNS server: 分散在世界各地的 13 个不同 root server 各自的共上千个 copy，用来查询 TLD server
2.  top-level domain (TLD) server: 每个 TLD 有自己的 TLD server (or server cluster)，用来查询 authoritative DNS server
3.  authoritative DNS server: 每个 subdomain 有自己的 authoritative DNS server，可以是组织自己维护的或者由服务商提供的，用来查询 hostname 到 IP 地址的映射

除此之外，TLD server 和 authoritative DNS server 之间还可能有 intermediate DNS server。

在上述 DNS server 的 hierarchy 之外，还有 local DNS server（就是电脑的网络设置里设的 DNS 服务器），作为 proxy 来代替 requesting host 向 DNS server 进行查询。

从逻辑上来说，向一个 DNS server 进行查询时，如果它自己不知道最终的 answer (IP 地址)，它可以让你换一个 DNS server 继续查 (iterative query)，或者帮你向其他 DNS server 发送查询 (recursive query) 然后返回最终的结果。而在实际中，如上文所述，一般是向 local DNS server 查询时会进行 recursive query，而 local DNS server 再从 root DNS server 向下直到 authoritative DNS server 进行 iterative query。

为了减少查询的数量，DNS 设有 caching。每个查询的发起者（requesting host 或者 local DNS server）会将收到的查询结果保存一段时间，cache miss 才会向其他 DNS server 发起查询。例如，常用的 TLD server 的 IP 地址往往都在 cache 中，大大减少了 root DNS server 收到的请求数量。

### DNS Records

DNS distributed database 存储的信息单元是 *resource record* (RR)。

每个 RR 包含 type、name、value、TTL 四项信息，其中 TTL 表示 cache 多久过期。常见的 type 包括以下几个：

-   A: name 是 hostname，value 是 IP 地址，表示一个 hostname 到 IP 地址的映射。
-   NS: name 是 domain，value 是其 name server 的 hostname，表示可以在这个 name server 进行这个 domain 的进一步查询。
-   CNAME: name 是 alias hostname，value 是 canonical hostname，用来提供 host aliasing。
-   MX: name 是 alias hostname，value 是 canonical hostname，用来提供 mail server aliasing。

对一个 hostname 来说 authoritative 的 DNS server 会包含被查询的 host 的 A record。不 authoritative 的 DNS server 则会包含相应的 NS record，以及这个 name server 的 A record。

下面是一个例子：

| type |           name            |           value           |
| :--: | :-----------------------: | :-----------------------: |
|  NS  |            \`.\`            |   \`a.root-servers.net.\`   |
|  A   |   \`a.root-servers.net.\`   |       \`198.41.0.4\`        |
|  NS  |          \`moe.\`           |    \`ns1.dns.nic.moe.\`     |
|  A   |    \`ns1.dns.nic.moe.\`     |     \`156.154.144.114\`     |
|  NS  |       \`ouuan.moe.\`        | \`amos.ns.cloudflare.com.\` |
|  A   | \`amos.ns.cloudflare.com.\` |      \`172.64.35.120\`      |
|  A   |       \`ouuan.moe.\`        |     \`172.67.181.123\`      |

在 registar 购买域名时可以填写 name server 的信息，由 registar 负责将相应的 NS 以及 A record 添加到 TLD server。可以使用域名商的 DNS server、其他服务商（例如 Cloudflare）的 DNS server 或者自己搭建的 DNS server 作为 authoritative DNS server。

DNS 最初只能静态更新（通过配置文件等方式），后来有了 DDNS 来通过 DNS message 动态更新。

### DNS Messages

DNS message 通过 UDP 发送到 port 53。

DNS message 的结构如下图所示：[^fig-2.21]

[^fig-2.21]: p133, Figure 2.21: DNS message format

![DNS message format](cnatda-fig-2.21.png)

identification 由 client 设置，即用来识别 query 和 reply 对应关系的 ID。

flags 包括以下几个：

-   query or reply: 这条 message 是 query 还是 reply
-   authoritative or not: 返回的结果是否是最终的答案
-   recursion desired: client 是否希望 server 进行 recursive query
-   recursion available: server 是否可以进行 recursive query

4 个 section 中都包含若干 RR。

在 query 中，question section 里会包含 name 和 type。

对于 type A 的查询：

-   如果 reply 是 authoritative 的（向 authoritative DNS server 查询，或者进行了 recursive query），则会在 answer section 中列出所查询的 A record。
-   如果不是 authoritative 的，则会在 authority section 中列出 NS record，在 additional section 中列出这些 name server 的 A record。

在 additional section 中，还可能列出 canonical hostname 的 A record 之类的。

## Peer-to-Peer File Distribution

在传输大文件时，client-server 的架构在用户数量增多时需要更大的 server bandwidth 才能保证用户的下载速度，而 P2P 的架构则是 self-scalable 的。（书中有简化模型的定量计算。）

BitTorrent 是较为流行的 P2P file distribution protocol。在 BitTorrent 中，以 chunk 为下载文件的基本单位。一个 peer 刚加入 torrent 时没有 trunk 所以只能下载，在获取到一些 trunk 后就会开始上传给其他 peer，下载完成后可以自私地离开或者无私地保种。

每个 torrent 会有（至少）一个 tracker，peer 在加入/离开时会通知 tracker，并在过程中定期告知 tracker 自己仍在活动。tracker 会给每个 peer 提供一些其他 peer 的 IP 地址和端口。

在下载过程中，每个 peer 拥有一部分 chunk，并向其他 peer 请求 chunk。每个 peer 需要决定优先下载哪个 trunk 以及上传给谁。

优先下载的 trunk 可以采用 *rarest first* 的策略，即优先下载已知的 peer 中拥有人数最少的 chunk，这样的话就能使得各个 trunk 较为均匀地在 peer 间分布。

在下载过程中，会采用被称作“tit-for-tat”的策略决定上传给谁：上传给自己（即从他那下载）的速度最快的几个 peer 被称作“unchoked”，除此之外还会每隔一段时间随机选择一个 peer 被称作“optimistically unchoked”，最后做出的选择就是上传给“unchoked”和“optimistically unchoked”的这些 peer。这个策略实际上可以被绕过，但不被绕过时它提供了一个激励大家上传的机制。（注：在下载完毕后保种时，会使用另外的策略。[^seed-choking]）

[^seed-choking]: [seed_choking_algorithm - libtorrent](https://www.libtorrent.org/reference-Settings.html#seed_choking_algorithm_t)

除了通过 tracker，还可以通过 Distributed Hash Table (DHT，一种 P2P 架构的 distributed database) 来获取 peer。

## Video Streaming and Content Distribution Networks

### HTTP Streaming and DASH

视频需要耗费大量的流量（以及存储空间），而 streaming 时需要保证至少有视频 bitrate 这么多的带宽才能避免卡顿，所以一般会根据可用的带宽选择不同质量的视频版本。

最基础的 streaming 方式是 HTTP streaming，即通过 HTTP GET 获取视频文件至缓冲区并播放，但这样无法适应不同用户的不同带宽，更无法适应同一个用户随时间变化的带宽。

在 Dynamic Adaptive Streaming over HTTP (DASH) 中，视频被编码为多个不同质量的版本，client 每次获取一个几秒的视频片段，并根据可用带宽动态调整选择的版本。

在开始播放之前，client 首先会获取 manifest file 来得到各个视频版本的 URL 以及 bitrate。在播放过程中，通过 HTTP GET 请求以及 byte range header 获取视频片段，同时计算可用带宽，决定接下来选择的视频版本。

### Content Distribution Networks

和 DNS 类似，video streaming 往往也不能仅通过单个 data center 实现，因为：

-   离部分用户过远，虽然 streaming 对延时要求不高，但更多的 communication link 很可能意味着更低的 bottleneck bandwidth。
-   同一个视频会在同一个 communication link 上被传输多次，造成网络资源以及资费的浪费。
-   single point of failure

为了解决这些问题，video-streaming company 往往会使用 Content Distribution Networks (CDN) 来分发视频。

CDN 会在全球各地放置 server (cluster)，在每个节点存放一份 content 的 copy，在处理 user request 时尽量由最好（最近）的节点负责响应。

CDN 可以是 private CDN（例如 Google 的 CDN）或者 third-party CDN（例如 Akamai、Limelight、Level-3，~~书中竟然没提到 Cloudflare~~）。

CDN 通常有两种放置策略：

-   Enter Deep: 放在 access ISP，cluster 数量多，性能更好，维护成本更高。
-   Bring Home: 放在 IXP，cluster 数量少，维护成本更低，性能相对差。

CDN 的更新有 push 和 pull 两种方式，push 就是内容更新时 push 到各个 cluster，pull 则与 cache 类似，在 cache miss 时再从上游获取并（在 stream 给用户的同时）保存下来。

将用户重定向到 CDN 节点的一种方式是通过 DNS：authoritative DNS server 返回 CDN 的 DNS server 的 NS record，然后再由 CDN 的 DNS server 进行节点选择并返回节点的 IP 地址。

（基于 DNS 进行 CDN 重定向时），选择节点的两种方式是：

-   geographically closest: 由 local DNS server 的 IP 确定地理位置，然后选择最近的节点。这样做的主要问题在于，地理位置近不一定意味着网络距离近/带宽高，并且 local DNS server 有可能离用户很远。

-   real-time measurements: 可以每隔一段时间向各个 local DNS server 发送探测信号来检测网络性能，这样做的主要问题在于 DNS server 可能会拒绝响应这样的探测。

### Case Studies: Netflix and YouTube

Netflix 和 YouTube 都是大型 video streaming 服务商，但它们的架构有很大不同，这很大程度上是由于它们视频类型的不同（剧 vs UGC）。

#### Netflix

Netflix 使用 Amazon cloud 运行 Web server 以及视频处理，而使用私有的 CDN 分发视频。

Netflix 的私有 CDN cluster 安装在 ISP 和 IXP 中，其中 IXP 的 cluster 往往容量较大，可以装下整个 Netflix 的所有视频的各个版本，而 ISP 的 cluster 往往容量较小，只存放最热门的视频。

Netflix 不使用 pull-caching，而是在每天的低峰期采用 push 进行更新。

因为 Netflix 的私有 CDN 只负责分发视频，它不需要使用 DNS redirect，直接由 Web server 告诉 client IP 地址即可。

#### YouTube

<Card title="Google 的 network infrastructure">

Google 部署了一个庞大的 private network and CDN infrastructure，包含以下三级 server clusters：

1.  约 20 个“mega data center”，分布在北美、欧洲和亚洲，每个 cluster 有数十万服务器，用来 serve dynamic content。
2.  约 90 个部署在 IXP 的 cluster，每个 cluster 有数百个服务器，用来 serve 包括 YouTube 视频在内的 static content。
3.  数百个部署在 access ISP 的 cluster，每个 cluster 有数十个服务器，用来进行 TCP splitting 以及 server static content，例如网页上的静态资源。

在访问 Google 的服务时，不同内容往往会来自不同层级的 cluster。

这些 cluster 通过 Google 的 private network 连接，使得它们之间的很多通信都不依赖于 public Internet，与用户的通信也往往只涉及到 access ISP 这一层。

</Card>

YouTube 使用 Google 的私有 CDN 分发视频，并且使用 pull-caching 和 DNS redirect。在选择节点时，会综合考虑 client 到 cluster 的 RTT 以及负载均衡。

在用户上传视频时，会在 Google 的 data center 进行处理。

## Socket Programming: Creating Network Applications

一般来说，编写 network application 需要编写 client program 和 server program。

### Socket Programming with UDP

使用 UDP 时，每次发送 datagram 都需要指定 address（IP 地址 & 端口），接收 datagram 时也会收到对方的 address。

~~一看就懂但书上解释了半天的~~ 例子：

\`\`\`python
from socket import *
serverName = 'hostname'
serverPort = 12000
clientSocket = socket(AF_INET, SOCK_DGRAM) # AF_INET 表示 IPv4 地址，SOCK_DGRAM 表示 UDP
message = input('Input lowercase sentence:')
clientSocket.sendto(message.encode(), (serverName, serverPort))
modifiedMessage, serverAddress = clientSocket.recvfrom(2048) # 2048 是 buffer size
print(modifiedMessage.decode())
clientSocket.close()
\`\`\`

\`\`\`python
from socket import *
serverPort = 12000
serverSocket = socket(AF_INET, SOCK_DGRAM)
serverSocket.bind(('', serverPort))
print('The server is ready to receive')
while True:
    message, clientAddress = serverSocket.recvfrom(2048)
    modifiedMessage = message.decode().upper()
    serverSocket.sendto(modifiedMessage.encode(), clientAddress)
\`\`\`

### Socket Programming with TCP

TCP 是一个 connection-oriented protocol，在 server 上分为 welcoming socket 和 connection socket，一开始需要通过 welcoming socket 建立 connection 并得到 connection socket，而在建立了 connection 之后就无需再指定对方的 address。

（下面的代码除了换成 TCP 还对上面的 UDP 代码有若干没有本质区别的修改，要是我写肯定会避免，但是从书上复制就懒得改了。）

\`\`\`python
from socket import *
serverName = 'servername'
serverPort = 12000
clientSocket = socket(AF_INET, SOCK_STREAM) # SOCK_STREAM 是 TCP
clientSocket.connect((serverName, serverPort))
sentence = input('Input lowercase sentence:')
clientSocket.send(sentence.encode())
modifiedSentence = clientSocket.recv(1024)
print('From Server: ', modifiedSentence.decode())
clientSocket.close()
\`\`\`

\`\`\`python
from socket import *
serverPort = 12000
serverSocket = socket(AF_INET, SOCK_STREAM)
serverSocket.bind(('', serverPort))
serverSocket.listen(1) # 1 是 connection queue 的最大长度
print('The server is ready to receive')
while True:
    connectionSocket, addr = serverSocket.accept()
    sentence = connectionSocket.recv(1024).decode()
    capitalizedSentence = sentence.upper()
    connectionSocket.send(capitalizedSentence.encode())
    connectionSocket.close()
\`\`\`
`},{title:q,tags:o,content:`《Computer Networking: A Top-Down Approach (8th Edition)》第三章 “Transport Layer” 的学习笔记。



## Introduction and Transport-Layer Services

transport layer 将 application-layer message 封装于 transport-layer segment，然后交给 network layer 进行传输，将 network layer 提供的 host-to-host logical communication 扩展为了 process-to-process (application-to-application) logical communication。

Internet 的 network-layer protocol 是 Internet Protocol (IP)，IP 提供的是 “best-effort delivery service”，就是说它会尽力但并不保证 datagram 能成功传输，也不保证传输到的顺序以及数据的完整性、正确性。

UDP 仅提供 process-to-process delivery 和 error checking，同样是一个 unreliable service。TCP 在 UDP 的基础上还提供 reliable data transfer 和 congestion control。

<Card title="segment or datagram?">

在 CNATDA 中，network layer packet 被统称为 “segment”，但一般应当是 TCP 的 packet 被称作 “segment”，而 UDP 的 packet 被称作 “datagram”（UDP 名字中的 “D” 就是 “datagram”）。为了方便，我也将 network layer packet 统称为 “segment”，但在特指时，称作 “TCP segment”、“UDP datagram” 和 “IP datagram”，语境明确时也可能略去协议名。

</Card>

## Multiplexing and Demultiplexing

<dfn>multiplexing</dfn> 指的是将多个信道的信息合并到一个信道进行传输，而 <dfn>demultiplexing</dfn> 指的是将这个合并后的信息再拆分到多个信道去。

一般来说，一个 host 会有很多 application 从而有很多 socket，但只有一个 transport layer 以及一个 network layer。

-   在发送方，transport layer 从多个 socket 收集 message 并发送给 network layer 的过程被称作 multiplexing；
-   在接收方，transport layer 从 network layer 接收到 message 后传递给正确的 socket 的过程被称作 demultiplexing。

multiplexing 以及 demultiplexing 需要每个 socket 有 unique identifier：

-   在 UDP 中，只以 port 作为 socket identifier
-   在 TCP 中，以 destination port 和 source IP 作为 socket identifier

## Connectionless Transport: UDP

UDP 仅提供 multiplexing and demultiplexing 以及 error checking，但在一些 application 中它比 TCP 更加适合，主要因为下列原因：

-   更好地控制何时发送数据、发送什么数据：TCP 有 congestion control，可能会延迟发送的时间；在传输失败时会重新发送，可能耗时很久才传输成功。
-   无需建立连接：建立 TCP connection 会产生 delay。
-   无连接状态：保存 TCP connection state 需要占用系统资源。
-   small header overhead：TCP segment header 有 20 byte 的 overhead，UDP 只有 8 byte。

一些使用 UDP 的例子：

-   DNS 使用 UDP 来避免建立 TCP 连接的 delay。
-   在 HTTP/3 中，使用基于 UDP 的 application-layer protocol QUIC 来提供 reliable data transfer 并避免建立 TCP 连接的 delay。
-   在 network management (SNMP) 中，使用 UDP 以在网络非常拥堵时发送消息。
-   在 multimedia application 尤其是即时通话中经常会使用 UDP，因为对延时敏感而 loss-tolerant。

但是，尤其是传输 multimedia 时，在没有 congestion control 的情况下传输大量数据可能导致网络拥堵，进而导致 UDP 大量丢包而 TCP 传输缓慢。

UDP datagram 的结构为：

-   source port (16 bits)
-   destination port (16 bits)
-   length (16 bits): 整个 datagram（包含 header 和 data）的 byte 数
-   checksum (16 bits)：将 UDP datagram 以及 IP header 的一些 field 以 16 bits 为单位视作 ones’ complement integer 加在一起（即在进位时加 1），最后取反（即按位取反）；校验时只需检查 sum 是否全 1
-   application data (message)

UDP 的 checksum 只能用来进行 error detecting，不能用来进行 error correcting，错误时可以直接扔掉或者通知 application。

虽然在很多 link-layer protocol 中也有 error checking，但并不能保证一路上所有 link 都有 error checking；并且，error 可能不是在 link-to-link 的传输过程中产生的，例如可能是存储在 router 中时产生的。所以，UDP 要提供 checksum，这也是体现了 end-to-end principle 的一个例子。

## Principles of Reliable Data Transfer

<Card type="info" title="关于这部分的详细程度">

这部分我写的比较简略，仅作为摘要，更循序渐进的讲解以及实现细节等需要看书。

</Card>

### Stop-And-Wait

在 stop-and-wait protocol 中，sender 每次确认 receiver 收到了 packet 才会发下一个 packet。

1.  checksum: 传输过程中可能出错，需要进行 error detection
2.  acknowledgment (ACK):
    -   需要告诉 sender 没有丢包
    -   收到 packet 时需要告诉 sender 是否出错
3.  retransmission: 未收到 ACK 或收到 negative acknowledgment (NAK) 时需要重新传输
4.  sequence number: retransmission 可能是因为 ACK 的传输出了问题，这会导致 duplicate packet，sequence number 的作用之一是识别 duplicate packet；在 stop-and-wait protocol 中，用 0/1 作为 sequence number 即可，这也被称作 *alternating-bit protocol*
5.  timeout: 丢包需要通过超时来检测，超时了就 retransmit；如果等待太久性能会受影响，所以 timeout 一般被设为较有可能是丢包的值而非几乎能确定是丢包的值
6.  ACK with sequence number: 通过超时检测丢包可能带来 duplicate packet（ACK 传输出错或用时过长），需要通过在 ACK 中加入 sequence number 来标识 acknowledge 的是哪个 packet，以此也可以通过上一个 packet 的 ACK 代替表示当前 packet 出错的 NAK

### Pipelined Reliable Data Transfer

stop-and-wait 虽然 work，但每次都要等上一个 packet 成功传输才能传下一个，性能太差。

同时传输多个 packet 被称作 *pipelining*，这意味着：

-   sequence number 需要更大的值域（不止是 1 bit 的 0/1），至少正在传输的这些 packet 需要互不相同的 sequence number
-   sender 需要 buffer 以支持多个 packet 的 retransmission，receiver 也可能需要 buffer

有两种基础的实现方法：go-back-n (GBN) 和 selective repeat (SR)。

### Go-Back-N

receiver: 只接受按正确顺序依次收到的 packet，顺序错误的 packet 直接扔掉（顺序正确但有 error 的 packet 通过发送上一个 packet 的 ACK 进行 negative acknowledgment）。

sender:

-   有一个 sliding window 表示当前有效的 sequence number 范围
-   window 内前一半已发送尚未收到 ACK，后一半 sequence number 尚未使用
-   如果 window 内所有 sequence number 均已被使用，将不能发送新的 packet
-   收到的 ACK 被视作 *cumulative acknowledgment*，即在这个 ACK 的 sequence number 之前的 packet 也被视作已 ACK
-   收到 ACK 时将 window 滑动到这个 ACK 之后
-   所有未 ACK 的 packet 共用一个 timer
-   retransmit 时发送 window 内所有尚未 ACK 的 packet

GBN 的好处是 receiver 不需要 buffer，坏处是一个 packet 出错就要把整个 window 内的 packet 重新发送。

### Selective Repeat

sender:

-   sliding window 与 GBN 类似，但前一半中除了开头（如果有）一定未 ACK，后面的可能已 ACK 也可能没有
-   ACK、timer、retransmission 都是每个 packet 独立的
-   收到 window 开头的 ACK 时滑动到首个未 ACK 处（如果均已 ACK 则是未使用处）

receiver:

-   也需要维护一个 sliding window，但这个 window 和 sender 的不保证一致，其开头是尚未收到的最小的 sequence number
-   收到非 window 开头的 packet 时需要 buffer 下来
-   收到 window 开头的 packet 时将已 buffer 的 packet 连续段按顺序传给 application，并滑动 window
-   收到 window 开头减去 window 大小到 window 开头减一这个范围内的 packet 时（这表示之前对这个 packet 的 ACK 的传输出了问题或者耗时过长），也需要 ACK
-   无论收到的是哪个 packet，如果有 error 则直接不管（因为 ACK 对每个 packet 独立，不能通过设置 ACK 的 sequence number 来表示 negative acknowledgment；也可以选择引入 NAK，若不引入则只能不管）

需要注意的是，由于 sender 和 receiver 的 window 可能不同，window 大小不能超过 sequence number 值域的一半。

最后，（无论是 GBN 还是 SR），因为 sequence number 的值域有限（循环使用），如果一个 duplicate packet (duplicate ACK) 的传输耗时太久，可能会占用重复的 sequence number，在实践中采取的解决方法一般是在一个 packet 传输了几分钟后便认为它已经没了。

## Connection-Oriented Transport: TCP

### The TCP Connection

TCP connection 在两个 end system 中都建立了一些 state variable，但它只是 logical connection，并没有在 network core 中建立 circuit（与 circuit-switched network 不同）。

TCP connection 是 full-duplex 的，即建立连接后双方都可以向对方发送信息；是 point-to-point 的，即不能 multicasting。

TCP connection 是通过 *three-way handshake* 建立的。通过 TCP 发送 message 时会先放入 send buffer，接收到 message 时会先放入 receive buffer。

TCP 会根据 maximum transmission unit (MTU，link-layer frame 的最大 size) 计算出合适的 maximum segment size (MSS，segment 包含的 data (application message) 的最大 size) 使得 data 加上 TCP header 和 IP header 后不超过 MTU。

### TCP Segment Structure

TCP segment 的结构如下图所示：[^fig-3.29]

[^fig-3.29]: p231, Figure 3.29: TCP segment structure

![TCP segment structure](cnatda-fig-3.29.png)

其中 “options” 是可选且可变长的，所以 TCP header 是可变长的，但一般是 20 byte。

各项的含义（部分）见下文。

### Sequence Numbers and Acknowledgment Numbers

TCP 将发送的所有 message 连在一起视作一个无结构但有序的 byte stream，segment 的 sequence number 表示的是 message 的第一个 byte 在 byte stream 中的位置。双方（client 和 server）的 sequence number 是分别计算的。

为了尽量避免 sequence number 与留存在网络中的其他 segment 发生冲突，以及其他安全原因，一次连接中的首个 byte 的 sequence number 一般不是 0，而是随机选择。

acknowledgment number 是期待收到的下个（尚未收到的首个）byte 的 sequence number，是 cumulative acknowledgment。

收到顺序错误的 segment 时，TCP 没有规定如何处理，但一般都会 buffer 下来。

一个 segment 中可以同时包含 acknowledgment 和 data，这时 acknowledgment 被称作 “piggybacked on the data segment”。也可以只有 acknowledgment 没有 data，此时 segment 仍有 sequence number，设为下一个 byte 的 sequence number。

### Round-Trip Time Estimation and Timeout

一个 segment 的 sample RTT ($s$) 指的是 segment 进入 network layer 直到 acknowledgment 被接收的用时。

在多数 TCP implementation 中，在计算一个 segment 的 sample RTT 时不会再去计算正在同时传输的其他 segment 的 sample RTT，并且只会计算一次就传输成功的 segment 的 sample RTT，不会计算 retransmission 的 sample RTT。

estimated RTT ($e$) 是计算出的这些 sample RTT 的 exponential weighted moving average (EWMA)，用来平缓 RTT 的波动：$e \\gets \\frac 78 e + \\frac 18 s$

dev RTT ($d$) 用来衡量 RTT 波动的大小：$d \\gets \\frac 34 d + \\frac 14 |s - e|$

timeout interval ($t$) 在 estimated RTT 的基础上根据 dev RTT 提供了一定的冗余：$t = e + 4d$

timeout interval 的初始值一般是 1 秒。在发生 retransmission 时，timeout interval 会翻倍，而在得到新的 sample RTT 后（即某个 segment 一次就传输成功后）又会回到正常的计算方式。

### Reliable Data Transfer

TCP 一般只使用一个 retransmission timer，用来给 oldest segment 计时。

虽然 TCP 和 GBN 有些类似，但 TCP 在 retransmit 时一次只传一个 segment，而 receiver 往往也会 buffer 顺序错误的 segment。

retransmission 在两种情况下发生：timeout 或者收到三个 duplicate ACK（即相同 sequence number 的第四个 ACK；这被称作 *fast retransmit*）。这意味着只收到一个或两个 duplicate ACK 的时候还是会等到 timeout 才 retransmit，因为这往往意味着只是顺序错误而不是丢包。[^fast-retransmit]

[^fast-retransmit]: [3 Fast Retransmit - RFC2001](https://datatracker.ietf.org/doc/html/rfc2001#section-3)

一般还会实现 delayed ACK，即只 ACK 一个 segment 时会尝试等到下一个 segment 一起 ACK（但不会等超过 500ms）。这样可以减少通信量，尤其是经过等待后 ACK 可以被 piggyback 时。[^delayed-ack]但是 cumulative ACK 以及 duplicate ACK 都会立即发送不会等待。

[^delayed-ack]: [4.2.3.2  When to Send an ACK Segment - RFC1122](https://datatracker.ietf.org/doc/html/rfc1122#page-97)

### Flow Control

receiver 有一个 buffer，但 application 不一定会立刻从 buffer 中读取，如果 application 读得太慢，就需要 sender 不要发太快来避免 buffer overflow。

TCP header 中包含 receive window ($\\mathrm{rwnd}$) 表示 buffer 的剩余空间，而 sender 需要保证已发送未被 ACK 的数据总量不超过 $\\mathrm{rwnd}$。

$\\mathrm{rwnd}$ 为 0 会阻断 sender 发送更多 segment，而为了让 receiver 有机会告诉 sender 更新后的 $\\mathrm{rwnd}$，防止通信被一直阻断下去，sender 需要发送 probing of zero window，即 1 byte 的 data，可以以以指数上升的间隔发送。[^zero-window-probing-793] [^zero-window-probing-1122]（~~好多以~~）

[^zero-window-probing-793]: [Managing the Window - RFC793](https://datatracker.ietf.org/doc/html/rfc793#page-42)
[^zero-window-probing-1122]: [4.2.2.17 Probing Zero Windows - RFC1122](https://datatracker.ietf.org/doc/html/rfc1122#page-92)

### TCP Connection Management

书上只讲了最基本的情况，没有讲各种 corner case，说是可以去看《TCP/IP Illustrated》（

建立 TCP connection：

1.  client 向 server 发 SYN segment: SYN flag set，sequence number 是 client ISN（initial sequence number，第一个 byte 的 sequence number 是 client ISN + 1）
2.  server 收到 SYN segment，建立 buffer 和 state，向 client 发 SYNACK segment: SYN flag set，ACK 了 SYN segment，sequence number 是 server ISN
3.  client 收到 SYNACK segment，建立 buffer 和 state，向 server 发 SYNACK 的 ACK，可以携带 application data

或者也可以拆开看：

-   client 和 server 互发 SYN，client 先发，SYN 不携带 application data，sequence number 用来表示 ISN
-   收到 SYN 要 ACK，ACK 可以 piggyback 到 SYN 或者 application data 上
-   收到 SYN 时会建立 buffer 以及 state variable

在断开连接时，双方会互相发送 FIN package (FIN flag set)，以及相应的 ACK。首先提出断开连接的一方在发送最后一个 ACK 后会等待一段时间（一般是 30s）再真的断开连接，以给对方机会 retransmit FIN segment，防止这最后一个 ACK 丢包导致对方一直等着。

如果尝试连接到一个不接受 TCP 连接的端口，会返回 RST flag set 的 segment。

<Card title="SYN flood attack">

如果 server 在收到 SYN 时就建立 buffer 以及 state 会带来遭受 SYN flood attack 的可能，即向 server 发送大量 SYN segment 而不发送后续的 ACK，从而占用 server 的大量资源。

SYN flood attack 的一个防范方式是使用 SYN cookie：在收到 SYN segment 时不建立 buffer 以及 state variable 等，而是计算 low resolution timestamp + 双方 IP + 双方 port + server secret 的 hash，将 timestamp (5 bits) + MSS (encoded to 3 bits) + hash (24 bits) 作为 server ISN，在收到 SYN segment 时不建立 buffer 和 state，而在收到 ACK 时根据 ACK number 得到 server ISN，检查 hash 是否正确并得到 MSS 然后再建立 buffer 和 state。

</Card>

## Principles of Congestion Control

congestion 会导致：

-   large queue delay
-   router buffer overflow 会导致丢包以及 retransmission
-   large delay 会导致 premature timeout 以及 unneeded retransmission
-   在传输路径上如果在一个 router 处发生了丢包，在此之前的 router 的 work 都浪费了

congestion control 分为两大类：

-   end-to-end: 不依赖于 network layer，依靠 retransmission 或 delay 增大等现象推断出 congestion。
-   network-assisted: router 提供 congestion feedback（一个 bit 表示 link 是否 congested，或者更复杂的信息，例如 available bit rate），可以是由 router 发一个新的 packet，或者修改正在传输的其他 packet，一方收到 feedback 后再发给另一方。

## TCP Congestion Control

### Classic TCP Congestion Control

classic TCP congestion control 是 end-to-end 的。

TCP 使用 congestion window ($\\mathrm{cwnd}$) 来限制发送速率。$\\mathrm{cwnd}$ 的效果与 receive window ($\\mathrm{rwnd}$) 类似，会将 unacknowledged 的数据总量限制在 $\\min(\\mathrm{cwnd}, \\mathrm{rwnd})$ 之内，从而将发送速率限制在约 $\\mathrm{cwnd} / \\mathrm{RTT}$。

classic TCP congestion control 的基本原则：

-   retransmission 是 congestion 的征兆，需要减小 $\\mathrm{cwnd}$
-   segment 被 acknowledge 是没有 congestion 的征兆，可以增大 $\\mathrm{cwnd}$
-   增大 $\\mathrm{cwnd}$ 相当于是在进行试探，即不断增大发送速率来试探增大到多大会发生 congestion

具体分为三种模式：

-   slow start: 初始状态以及 timeout 后转移到的状态，从 $\\mathrm{cwnd} = 1\\ \\mathrm{MSS}$ 开始，每个 RTT $\\mathrm{cwnd}$ 翻倍，直到 $\\mathrm{cwnd \\geqslant \\mathrm{ssthresh}}$，转移到 congestion avoidance。
-   congestion avoidance: 每个 RTT 内 $\\mathrm{cwnd}$ 增大 $1\\ \\mathrm{MSS}$。
-   fast recovery: fast retransmit 后转移到的状态，从 $\\mathrm{cwnd} = \\mathrm{ssthresh} + 3\\ \\mathrm{MSS}$ 开始，每个 duplicate ACK 都让 $\\mathrm{cwnd}$ 增大 $1\\ \\mathrm{MSS}$，直到收到非 duplicate 的新的 ACK，转移到 congestion avoidance。
    
具体细节如下图所示：[^fig-3.51]

[^fig-3.51]: p268, Figure 3.51: FSM description of TCP congestion control

![FSM description of TCP congestion control](cnatda-fig-3.51.png)

正常情况下会在 congestion avoidance 和 fast recovery 之间反复切换，此时 $\\mathrm{cwnd}$ 的增长是线性的，降低是减半，称其是 *additive-increase, multiplicative-decrease* (AIMD) 的。AIMD congestion control 会导致 $\\mathrm{cwnd}$ 呈锯齿状变化。

TCP congestion control 有多个版本，上文描述的是 TCP Reno，如果用 slow start 来代替 fast recovery 则是更古老的 TCP Tahoe。

TCP Reno 的锯齿状 $\\mathrm{cwnd}$ 变化曲线实际上没能快速恢复到导致 congestion 的临界值，会产生较大的浪费。一个优化后的版本是 TCP CUBIC，它修改了 congestion avoidance 阶段的上升曲线，使其是一个三次函数曲线，如下图所示：[^fig-3.54]

[^fig-3.54]: p272, Figure 3.54: TCP congestion avoidance sending rates: TCP Reno and TCP CUBIC

![TCP congestion avoidance sending rates: TCP Reno and TCP CUBIC](cnatda-fig-3.54.png)

<Card title="TCP splitting">

如果 RTT 过大，slow start 可能导致初次连接时 response time 较大（一般会有 $4 \\cdot \\mathrm{RTT}$ 左右）。TCP splitting 在 client 和 data center 之间增设了一个 frontend server 作为代理，frontend server 与 data center 之间建立了 persistent TCP connection 来避免 slow start，而 client 和 frontend server 之间的 RTT 较小，slow start 的影响就较小。

</Card>

### Network-Assisted Explicit Congestion Notification

[Explicit Congestion Notification (ECN)](https://datatracker.ietf.org/doc/html/rfc3168) 是 network-assisted congestion control 的一种手段，它对 TCP 和 IP 都进行了扩展。

ECN 使用了 IP datagram header 的两个 bit，一个用来告诉 router 通信双方是 ECN-capable 的，另一个由 router 设置，表示自己处于 congestion（一般会在丢包实际发生前就设置）。

在一方收到 router 的 congestion 信息后，会在发给另一方的 ACK segment 里设置 ECE (explicit congestion notification echo) flag，另一方收到 ECE 后会将 congestion window 减半，并在下一个 segment 里设置 CWR (congestion window reduced) flag。

除了 TCP，还有其他 transport-layer protocol 利用了 ECN，例如与 UDP 类似但提供了 congestion control 的 DCCP，为 data center 设计的 DCTCP、DCQCN 等。

### Delayed-based Congestion Control

delay-based congestion control 也能在丢包发生前就检测到 congestion。

TCP Vegas 会检测历史最大的 throughput（$\\mathrm{cwnd} / \\mathrm{RTT}$），若当前的 throughput 明显小于历史最大值，则说明发生了 congestion。

BBR 的思路类似，并采用了一些机制使其在与非 delay-based 的 congestion control 竞争时保持 fair。Google 在 2016 年已经在内部的 B4 网络中采用 BBR 替换了 TCP CUBIC。

此外，还有 TIMELY、Compound TCP、FAST 等 delay-based congestion control protocol。

### Fairness

假设有 $K$ 个 TCP 连接共用一个 transmission rate 为 $R$ 的 bottleneck link，并且这个 link 上没有其他数据传输。如果每个连接的 throughput 都大约是 $R/K$，则称所使用的 congestion control mechanism 是 fair 的。

在各方的 RTT 相同且只有 TCP 连接时，AIMD congestion control 是 fair 的，如下图所示[^fig-3.57]，addictive increase 是沿 45 度方向的，multiplicative decrease 是朝着原点的，所以会趋向 fair。

但是，在各方 RTT 不同时，RTT 小的往往能获得更大的 throughput。

[^fig-3.57]: p278, Figure 3.57: Throughput realized by TCP connections 1 and 2

![Throughput realized by two TCP connections](cnatda-fig-3.57.png)

在有 UDP 连接参与时，由于 UDP 没有 congestion control，可能会导致 unfair。

上面讨论的 fairness 是对于 connection 而言的，而对于 application / host 就不一定 fair 了，因为可以建立多个 parallel TCP connection，例如浏览器一般就会这样做。

## Evolution of Transport-Layer Functionality

虽然 Internet 只有 TCP 和 UDP 两个 transport-layer protocol，但 transport-layer functionality 依然在不断演化。

现在有非常多不同版本的 TCP 实现（例如上文提到的 TCP CUBIC、BBR 等），或是解决了旧版实现中的一些问题，或是更适配于特定的应用场景（网络环境）。

QUIC 是一个基于 UDP 的 application-layer protocol，有下列 feature：

-   需要 handshake 建立连接，且所有数据都是加密的。connection-establishment handshake 和 authentication and encryption handshake 被合并在了一起，从而比 TLS 更快。
-   以 stream 为单位传输 application data，而多个 stream 可以放在单个 packet 中传输。
-   reliable data transfer，其中 in-order delivery 是对每个 stream 分别保序，所以不同 stream 之间不会带来阻塞 (HOL blocking)。
-   与 TCP 类似的 congestion control。

作为一个 application-level protocol，QUIC 可以比 transport-layer protocol 更频繁地更新。
`},{title:O,tags:o,content:`《Computer Networking: A Top-Down Approach (8th Edition)》第四章 “The Network Layer: Data Plane” 的学习笔记。



## Overview of Network Layer

Network Layer 可以被细分为 data plane 和 control plane 两部分。

data plane 的主要功能是 *forwarding*（也称作 *switching*），即一个 router 将 input link 收到的数据转发到正确的 output link。

control plane 的主要功能是 *routing*，即决定从 sending host 到 receiving host 的路径。

router 中会有一个 *forwarding table*，从 packet header 中选取某些 field 用来 index forwarding table，得到 outgoing link interface。

计算 forwarding table 则是 control plane 的任务，有两种实现方式：

-   the traditional approach: router 之间根据 routing protocol 互相通信，根据 routing algorithm 计算得到 forwarding table。
-   the SDN approach: router 只实现 forwarding，而 routing 由一个 remote controller 完成：router 向 remote controller 发送信息，由 remote controller 计算得到 forwarding table 发给 router。这个 remote controller 通常是由软件实现的，所以这种方法被称作 *software-defined networking* (SDN)。

## What’s Inside a Router?

router 一般包含以下部分：

-   input ports
    -   incoming link 的 physical layer 和 link layer
    -   input queue
    -   lookup:
        -   从 forwarding table 查 output port
        -   将 control packet（例如包含 routing protocol information 的 packet）forward 到 routing processor

-   switching fabric: 连接 input ports 和 output ports

-   output ports
    -   outgoing link 的 link layer 和 physical layer
    -   output queue

-   routing processor: 得到 forwarding table，进行 network management
    -   traditional: 执行 routing protocol
    -   SDN: 与 remote controller 通信

为了保证通信速度，forwarding 的用时需要在 ns 级，所以要用硬件实现；而 control plane 的用时一般在 ms 或 s 级，可以用软件实现。

### Input Port Processing and Destination-Based Forwarding

多个 input port 可以合并到一个 line card 上。

forwarding table 会从 routing processor 给每个 line card 都复制一份，从而可以在每个局部分别计算，不需要集中计算。

对于 destination-based forwarding，forwarding table 一般是 index 为 IP 地址前缀，value 为 link interface，采用 longest prefix matching。

lookup 通常要在 ns 级别的时间内完成，而 forwarding table 很大，不仅需要通过硬件实现，还需要使用特殊的算法或存储器，例如使用 TCAM。

input port processing 除了 lookup 还有 physical-layer 和 link-layer processing，还需要检查/更新 packet version、checksum、TTL，更新 network management 的 counter。

### Switching

switching 有多种形式：

-   via memory: packet 从 input port 复制到 memory 再复制到 output port，如果使用集中的 memory 而非每个 line card 分别的 memory，则传输速率会受 memory 的速率限制。
-   via bus: 将 packet 加上一个 switch-internal label 再通过 bus 发送给所有 output port，收到后根据 label 决定是否保留这个 packet，传输速率会受 bus 的速率限制。
-   via interconnection network: 每个 input port 对应一个 bus，每个 output port 对应一个 bus，每对 input port bus 和 output port bus 之间都有 crosspoint，通过控制 crosspoint 来控制从哪传到哪（结构和 ROM 类似）。这是 non-blocking 的，只要两个 packet 的 output port 不同就可以同时传输。

### Input Queuing

如果 switching fabric 的速率达到了所有 input port 的速率之和，则不会发生 input queuing，否则可能要等待其他 packet 在 switching fabric 上传输。

以 switching via interconnection network 为例，只有多个 packet 传输到同一个 output port 才会发生 input queuing，但是一个 packet 即使没有和它 output port 相同的 packet 也可能因为 input queue 中在它前面的其他 packet 而被 block，即 HOL blocking。

### Output Queuing

如果 packet 到达 output port 的速率超过了 output line 的速率，则会发生 output queuing。

若 packet 到达时 buffer 已经满了，则需要决定 drop 哪个 packet。在 buffer 满之前进行 packet dropping 或 marking 称作 active queue management (AQM)，例如 [ECN](/post/2023/06/cnatda-3#network-assisted-explicit-congestion-notification)、random early detection (RED) 等。

### How Much Buffering Is “Enough”?

有 $N$ 个 independent TCP flow 经过一个带宽为 $C$ 的 link 时，buffer 需要有 $\\mathrm{RTT} \\cdot C / \\sqrt N$。

更大的 buffer 能减少 packet loss，但可能会增加 delay。TCP 可能会使得 buffer 一直不被清空，从而导致 queuing delay 是 constant 且 persistent 的，这被称作 *bufferbloat*，可以通过一些 AQM 措施来缓解。

### Packet Scheduling

-   FIFO (FCFS)
-   priority queuing  
    （在 non-preemptive priority queuing 中，如果低优先级的 packet 已经开始传输，高优先级的 packet 再到来不会打断传输。）
-   weighted fair queuing (WFQ): 给每种 packet 类型一个 weight，决定选择这种类型的频率。

packet scheduling 可以根据 IP datagram header 中的各种信息优先传输或 block 某一类 packet。*Order on Protecting and Promoting an Open Internet* (2015) 规定了 net neutrality 的三条原则：no blocking、no throttling、no paid prioritization。而 *Restoring Internet Freedom Order* (2017) 则收回了这些限制，而是注重于 ISP transparency。

## The Internet Protocol (IP)

### IPv4 Datagram Format

IPv4 datagram 的格式如下图所示：[^fig-4.17]

[^fig-4.17]: p331, Figure 4.17: IPv4 datagram format

![IPv4 datagram format](cnatda-fig-4.17.png)

-   version: 例如 IPv4、IPv6
-   header length: 因为可能有 options，header 是不定长的
-   type of service (TOS): 用来识别各种类型的流量，例如 real-time datagram (对延时敏感)，其中有 2 个 bit 用于 [ECN](/post/2023/06/cnatda-3#network-assisted-explicit-congestion-notification)
-   datagram length: header + data 的长度，为放入 Ethernet frame，一般不超过 1500 bytes
-   identifier、flags、fragmentation offset: 用于 IP fragmentation，在 IPv6 中已被弃用
-   TTL: 为了防止死循环，TTL 每经过一个 router 会减一，到 0 就会被 drop
-   protocol: transport-layer protocol，用来连接 network layer 和 transport layer
-   header checksum: 只计算 header 不计算 data，使用 ones’ complement sum；header 每经过一个 router 都会更新，checksum 也要相应地更新
-   source and destination IP address
-   options: 由于会影响性能，在 IPv6 中已被弃用
-   data: 一般是 transport-layer segment，但也可能是 ICMP message 之类的其他数据

### IPv4 Addressing

一般来说，每个 host 有至少一个 interface 来接入网络，每个 router 有多个 interface 来与其他 router 或 host 连接。每个（接入 Internet 而不在 NAT 后的）interface 都有一个 IP address。

多个 host 和 router 之间可以通过 Ethernet switch、wireless access point 等方式互相连接，构成一个 routerless network。在 IP 中，这被称作一个 *subnet*，即 interface 之间由 link 连接、不经过 router 和 host 而构成的连通块。

一个 subnet 会有一个 subnet address，例如 223.1.1.0/24，而其中的 IP address 包括 223.1.1.1、223.1.1.2、223.1.1.3 等。

Internet 分配 IP address 的方案是 classless interdomain routing (CIDR)，其规定了 subnet address 的格式，例如 \`/24\` 表示前 24 位是这个 subnet 的地址（network prefix），这个 subnet 中的 IP address 的后 8 位可以取其他值。这样的地址分配方案和 router lookup 使用的 longest prefix matching 配合在一起可以减少 lookup table 的表项。

在 CIDR 之前，曾使用过 classful addressing，相当于是 mask length 只能是 8、16、24，分别被称作 class A, B, C network，这使得不同 class 之间的 address 数量相差过大，难以按需选择，容易造成浪费，最终促成了 classless 的 CIDR。

longest prefix matching 也使得 address aggregation 成为可能：可以在 lookup table 中将多个有 common prefix 的 subnet 合并为一个更大的 subnet address，即使这些 subnet 并没有覆盖这个大的 subnet address 中的所有 address，没覆盖到的部分还可以由更小的 subnet address（更长的 prefix）override。

255.255.255.255 是一个特殊的 IP address，表示 broadcast，destination address 为 broadcast address 的 datagram 会发送给整个 subnet 内的所有 host，还有可能发送给 neighbour。

### Obtaining Addresses

#### Obtaining a Block of Addresses

IP address 由 ICANN 管理，ISP 以及 organization 可以从由 ICANN 管理的 Internet registry (Address Supporting Organization) 处获得 IP address block。 

ISP 可以将其拥有的 IP address block 再进行细分来提供给用户。

#### Obtaining a Host Address: DHCP

router 的 IP address 一般是手动（半自动）配置的，而 host 的 IP address 通常是通过 Dynamic Host Configuration Protocol (DHCP) 自动进行的。

使用 DHCP 能减少手动配置的工作量，尤其是在 host 经常移动时（例如笔记本电脑在教室和寝室之间移动），手动配置几乎是不可能的。

DHCP 可以给 host 提供一个固定或临时的 IP address，除此之外还能提供 subnet mask、first-hop router address (default gateway)、local DNS server address 等信息。

每个 subnet 一般都会有至少一个 DHCP server，或者一个知道 DHCP server address 的 DHCP relay agent（一个 router）。

使用 DHCP 获取 IP address 的步骤如下：

1.  host 发送 DHCP discover message：通过 UDP 发送到 255.255.255.255、port 67，包含一个 transaction ID（由于 DHCP 使用 broadcast，需要通过 transaction ID 区分不同 host）。
2.  DHCP server 收到 DHCP discover message 后发送 DHCP offer message，是一个发送到 port 68 的 broadcast，包含 transaction ID、proposed IP address、IP address lease time（proposed IP address 的有效时间，一般是几个小时或几天）、DHCP server address 等信息。
3.  host 收到 DHCP offer message 后，选择其中一个（如果收到了多个）发送 DHCP request message，包含和 DHCP offer message 类似的信息，也是一个 broadcast（虽然此时已知 DHCP server address，但可能有多个 DHCP server，broadcast 可以让其他 server 知道可以取消 address reservation 了[^dhcp-request-broadcast]）。
4.  DHCP server 收到 DHCP request message 后回应 DHCP ACK message。

（实际上，DHCP offer 和 ACK 也可能不是 broadcast。[^dhcp-offer-ack-broadcast]）

[^dhcp-request-broadcast]: [Why is broadcast used at the DHCPREQUEST step? - Network Engineering Stack Exchange](https://networkengineering.stackexchange.com/a/48881)
[^dhcp-offer-ack-broadcast]: [Why are DHCP Offer and Ack broadcasted? - Stack Overflow](https://stackoverflow.com/a/10757849)

host 收到 DHCP ACK message 后就可以在 lease time 内使用这个 IP address 了。DHCP 还提供了延长 lease time 的机制。

### Network Address Translation (NAT)

subnet 需要一段连续的 IP address，如果设备数量增长超过了原来的 IP address block 大小，新地址的分配将会变得困难。而且，每个设备都有一个 globally unique address 对于 IPv4 来说难以承担。Network Address Translation (NAT) 可以解决（缓解）这些问题。

使用 NAT 时，subnet 内使用 IP address space reserved for private network（10.0.0.0/8、172.16.0.0/12、192.168.0.0/16），有一个 router 与外界连接并进行 NAT，这个 router 对外界表现为 a single device with a single IP address，通过 NAT translation table 在 private address + port 和 WAN-side address + port 之间进行转换（使用不同的 NAT port 来区分不同的 host 以及 application port）。这个 router 的 public address 从 ISP（可以通过 DHCP）获得，而它作为 DHCP server 为 subnet 内部提供 private address。

NAT 一般会改变 port，而有时需要使用特定的 port 不能改变，可以通过 NAT traversal 来实现。<span class="heimu">（勾起了一些远古的 MC 联机回忆，虽然当时并没成功（</span>

### IPv6

为了解决 IPv4 address 即将耗尽的问题，IPv6 被研发了出来。除了将 IP address 从 32 bits 扩展到 128 bits，IPv6 还顺带解决了 IPv4 中的一些其他问题。

IPv6 datagram 的格式如下图所示：[^fig-4.26]

[^fig-4.26]: p349, Figure 4.26: IPv6 datagram format

![IPv6 datagram format](cnatda-fig-4.26.png)

IPv6 的主要变化：

-   在 unicast 和 broadcast 的基础上引入了 anycast，即向多个地址之一发送信息，例如可以用来向多个有相同内容的 server 发送 anycast 来获取其中最近的一个的 response。
-   使用定长 (40 bytes) 的 header。
-   引入了 *flow label* 使得 router 可以对 flow 进行特殊处理。
-   删除了 fragmentation 功能以提高性能。
-   删除了 checksum，因为 transport-layer segment 一般已经有 checksum 了，每次修改 TTL 都更新 checksum 也非常耗时。
-   删除了 options，而 next header 不一定是 transport-layer protocol，也可以是 option。
-   TOS 改为 traffic class，TTL 改为 hop limit，datagram length 改为 payload length（不含 header length），protocol 改为 next header。

network-layer protocol 的改动非常困难，IPv4 到 IPv6 的转换至今仍在进行中。

新的设备（router）可以同时支持 IPv4 和 IPv6，但旧的设备只能支持 IPv4，为了使它们共存，可以采用 *tunneling*，即将 IPv6 datagram 作为 IPv4 的 payload 进行传输，两个 IPv6 router 之间的一系列 IPv4 router 被称作 *tunnel*。

### Generalized Forwarding and SDN

generalized forwarding 基于“match-plus-action”的原则，比起 destination-based forwarding，“match”时可以考虑 IP header 中 destination 以外的其他 field，也可以考虑 link-layer header、transport-layer header、ingress port 等；“action”除了 forward 还可以是 drop、修改 header field 等。

OpenFlow 是一个 generalized forwarding 的协议，规定了 match 时可以/不能使用哪些 field，以及可以采取哪些 action。设计一个 flow table，就可以实现各种功能，例如 forwarding、load balancing、NAT、firewall 等。

P4 (Programming Protocol-independent Packet Processors) 是一个用来实现 generalized forwarding 的 programming language，可以比 flow table 更加灵活。

## Middleboxes

在 network 中，除了基础的 forwarding，还有一些用来实现其他功能的设施，称作 *middlebox*：

-   NAT translation
-   security services，例如 firewall、email filter
-   performance enhancement，例如 Web cache、load balancing、TCP splitter

为了降低运营维护的成本，有的 middlebox 用软件甚至云服务代替硬件来实现，称作 network function virtualization (NFV)。

middlebox 在一定程度上破坏了 network 的 layered architecture：很多 middlebox 位于 network layer，却依赖于 transport layer 甚至 application layer 的信息。例如 NAT 会修改 IP address 和 port，firewall 可能依赖于 application message 的内容。

Internet architecture 的基本原则是“the goal is connectivity, the tool is the Internet Protocol, and the intelligence is end to end rather than hidden in the network”。[^rfc-1958]在 network layer 中只有 IP 一个 protocol、将 complexity 放在 end system，可以简化 network layer 的功能，保证 connectivity，而 middlebox 在一定程度上破坏了这样的原则。

[^rfc-1958]: [2. Is there an Internet Architecture? - RFC1958](https://datatracker.ietf.org/doc/html/rfc1958#section-2)

尽管在架构上有些不完美，但 middlebox 承担着非常重要的功能，并不会消亡。
`},{title:U,tags:o,content:`《Computer Networking: A Top-Down Approach (8th Edition)》第五章 “The Network Layer: Control Plane” 的学习笔记。



## Introduction

control plane 需要计算出 forwarding table / flow table，有两种方式：

-   per-router control: router 之间互相发送信息，分别进行计算
-   logicially centralized control: 使用 remote controller 集中地获取信息、计算、分发结果

## Routing Algorithms

在 routing algorithm 中，网络被抽象为一张图，考虑 physical length、link speed、monetary cost 等因素作为边权。

routing algorithm 可以分为：

-   centralized / decentralized：计算过程中是否知道整个图的信息
-   static / dynamic：是否对网络负载、拓扑结构等的改变即时做出响应
-   load-sensitive/insensitive: 是否考虑 congestion 状况

### The Link-State (LS) Routing Algorithm

LS 是一个 centralized routing algorithm，需要每个 node 将其 attached links 的信息进行广播（link-state broadcast），使得每个 node 都有整张图的信息，再用 Dijkstra 等算法计算最短路。

在 load-sensitive routing algorithm 中，traffic load 的改变可能导致 oscillation，要么改为 load-insensitive，要么设法保证各个 router 不同时运行 routing algorithm。

### The Distance-Vector (DV) Routing Algorithm

每个 node 维护一个到其他每个 node 的 distance vector，告诉 neighbor 自己的 distance vector，通过 neighbor 的 distance vector 更新自己的 distance vector。link state 发生改变时，会经过多轮迭代进行传播并最终收敛。

在 link cost 减小时，收敛是较快的。

但是在 link cost 增大时，收敛可能需要边权值域大小轮次的迭代（称作 *count-to-infinity problem*），并在过程中产生 routing loop，例如下图所示的情况：[^fig-5.7-b]

[^fig-5.7-b]: p393, Figure 5.7: Changes in link cost, b.

![Changes in link cost](cnatda-fig-5.7-b.png)

使用 *poisoned reverse* 可以避免出现二元环：如果 $u$ 使用了 $(u, v)$ 这条边来走向 $w$，则在 $u$ 告诉 $v$ 的 distance vector 中，$u$ 到 $w$ 的距离是 $\\infty$。

但是 poisoned reverse 不能避免多元环的出现。

### Comparison of LS and DV Routing Algorithms

-   message complexity: LS 需要让每个 node 都获取到全局的 link state，要传送大量信息，且信息需要发送到很远的地方；DV 只需要从 neighbor 获取信息。
-   speed of convergence: LS 有 Dijkstra 的低复杂度，DV 则较慢，而且过程中可能出现 routing loop，还有 count-to-infinity problem。
-   robustness: 在 LS 中，每个 node 可以提供错误的 link state，但影响有限，每个 node 只为自己计算 forwarding table；在 DV 中，每个 node 的计算结果都是其他 node 的计算的一部分，影响可以很大。

实际上，Internet 同时使用了这两种算法。

## Intra-AS Routing in the Internet: OSPF

如果统一管理所有 router，一方面规模过大性能无法接受，另一方面无法满足自治的需求。所以，实际上 router 被分成了很多个 autonomous system (AS)，每个 AS 有一个 ICANN 赋予的编号。例如，每个 ISP 可能管理着一个或多个 AS。

每个 AS 内使用同一个 intra-AS routing protocol，例如 OSPF (Open Shortest Path First) ，它非常复杂，书中只有简要介绍。

OSPF 使用的是 LS routing algorithm，边权由管理员设置，每个 router 都会向整个 AS 内的其他所有 router（在 link state 发生变化时 & 周期性地）broadcast link state。

-   OSPF message 直接通过 IP 传输，不使用 transport-layer protocol。
-   支持 authentication。
-   有多条最短路时，可以同时使用。
-   有 MOSPF 扩展来支持 multicast。
-   可以将 AS 划分为多个 area 形成 AS 内部的 hierarchy，每个 area 内部走最短路，不同 area 之间通过每个 area 的 border router 走 backbone area。

## Routing Among the ISPs: BGP

### The Role of BGP

BGP (Border Gateway Protocol) 是所有 AS 共用的 inter-AS routing protocol，将各个 AS 连接在一起。

在 BGP 中，destination 不是特定的 IP address，而是 CIDR prefix。BGP 使得一个 AS 可以向其他 AS advertise prefix，并计算出到达各个 prefix 的 route。

### Advertising BGP Route Information

不同 router 之间会建立称作 BGP connection 的 TCP connection（不是 physical link），一般来说负责连接两个 AS 的 gateway router 之间会建立 external BGP (eBGP) connection；而 AS 内部的 router 两两之间建立 internal BGP (iBGP) connection。

一条 BGP advertisement（称作一个 *route*）包含 AS-PATH 和 NEXT-HOP 等信息：

-   AS-PATH 即经过哪几个 AS 能到达目的地，一个 AS 收到来自其他 AS 的 route 后，可以在 AS-PATH 中加上自己，继续向 neighbor 发送；
-   NEXT-HOP 是从当前 AS 出发向目的地走，走出当前 AS 遇到的第一个 router 的 IP address。

### Determining the Best Routes

从一个 AS 出发到达某个 prefix 可能有很多条路径，BGP 按照下面的顺序来决定 best route（平局则使用下一条规则）：

1.  由管理员设置或从其他 AS 获取的 local preference
2.  shortest AS-PATH（经过最少个 AS）
3.  在 AS 内走最短路（通过 intra-AS protocol 以及 NEXT-HOP 得到）到达 gateway router
4.  根据 BGP identifier 选

### IP-anycast

BGP 可以计算出到达某个 prefix (IP address) 的 best route，如果为多个 host 设置相同的 IP address，则可以实现 IP-anycast，例如在 CDN 中可以让用户从多个内容相同的 server 中挑选最适合的一个，而这一挑选是在 router 处通过 BGP 实现的。

但是 IP-anycast 如果用于 TCP 可能导致同一个 TCP connection 发给不同 host，所以 CDN 一般不采用 IP-anycast，而 DNS root server 则采用了 IP-anycast（DNS 使用 UDP）。

### Routing Policy

BGP 通过 local preference 给管理员提供了决定如何选择 route 的自由，以实现某些 policy。

例如，当一个 access ISP 连接到多个 backbone ISP（即 multi-home）时，access ISP 不应该作为中介在不同 backbone ISP 之间进行传输。一般来说，一个 ISP 只会在通信双方至少有一方是其 customer 时提供服务。

## The SDN Control Plane

SDN 分为 SDN controller、network management applications（例如 routing、access control、load balancing）、controlled devices 三个部分。其中 SDN controller 连接了 network management applications 和 controlled devices。

SDN 使用 generalized forwarding，将 data plane 和 control plane 分开，通过 network management applications 提供 network control functions，实现了 programmable network。

SDN 将 network functionality 进行了 unbundle，使得 packet switches、SDN controller、network management applications 可以来自不同的供应商，各自发展。

-   communication layer (*northbound API*): controlled devices 和 SDN controller 进行通信。SDN controller 向 controlled device 发送信息（例如 flow table），从 controlled device 获取 link state 等信息，并在 network state 发生改变时被通知。可以使用 OpenFlow、SNMP 等协议。
-   network-wide state-management layer: SDN controller 存储了一些信息，包括 network state、flow table、统计数据等。
-   interface to the network-control application layer (*southbound API*): network management applications 可以从 SDN controller 获取 network state，订阅状态发生改变的 event。通过 RESTful API 等方式通信。

在 OpenFlow 中，SDN controller 可以向 controlled device 发送：

-   configuration，修改配置参数
-   modify-state，例如修改 flow table
-   read-state，例如获取统计信息
-   send-packet，让 router 发出一个 packet

controlled device 可以向 SDN controller 发送：

-   flow-removed: 通知一个 flow table entry 已被移除（timeout 或者被 modify-state 删除）
-   port-status: 例如一个 link up/down 了
-   packet-in: 如果一个 packet 在 flow table 中没有 match，或者 action 为发送到 controller

## ICMP: The Internet Control Message Protocol

ICMP 用来进行 router 和 host 之间的通信，作为 IP payload 进行传输。

ICMP message 有很多种，例如：

-   用来 ping 的 echo request 和 echo reply
-   destination network/host/protocol/port unreachable
-   router advertisement
-   router discovery
-   TTL expired
-   IP header bad

Traceroute 就是通过 ICMP 实现的：向一个 unlikely port number 发送 TTL 递增的 UDP datagram，通过 TTL expired 得到每个 router 的信息，通过 port unreachable 得到终点的信息。

## Network Management and SNMP, NETCONF/YANG

> Network management involves the deployment, integration and coordination of all the hardware, software and human elements to monitor, test, poll, configure, analyze, evaluate, and control the network and element resources to meet the real-time, operational performance and quality-of-service (QoS) requirements at reasonable cost.[^saydam-1996]

[^saydam-1996]: Saydam, T., Magedanz, T. From networks and network management into service and service management. J Netw Syst Manage 4, 345–348 (1996). https://doi.org/10.1007/BF02283158

network management 包括 managing server (以及 network manager)、managed device、data（每个 device 有 configuration、operational data、device statistics，而 managing server 有每个 device 以及整个 network 的 data）、network management agent、network management protocol。

network management 有若干方式：

-   CLI: error-prone，难以 scale。
-   SNMP/MIB: 每个 device 有 management information base (MIB) objects，可以通过 simple network management protocol (SNMP) 来获取/设置 MIB objects 中的 data，device 也可以通过 trap message 向 managing server 通知状态变化。SNMP/MIB 是针对单个 device 的，也难以 scale。
-   NETCONF/YANG: NETCONF 比起 SNMP 更注重于配置管理，可以一次性操控多个 device (atomic network management transaction)，可以设置 constraint 检查配置的正确性，使用 YANG 作为 data modeling language，以 XML 格式通过 TLS 进行通信。
`},{title:H,tags:o,content:`《Computer Networking: A Top-Down Approach (8th Edition)》第六章 “The Link Layer and LANs” 的学习笔记。



## Introduction to the Link Layer

link layer 的主要功能是将 datagram 从一个 node 传输到另一个 node，还可以提供下列 service：

-   framing: 将 network-layer datagram 封装在 link-layer frame 中进行传输。
-   link access: 通过 medium access control (MAC) protocol 控制 frame 在 link 上如何传输。这对于 point-to-point link 来说是简单的，但在 broadcast link 中会遇到 multiple access problem，需要 MAC protocol 来进行协调。
-   reliable delivery: 通过与 TCP 类似的方式（acknowledgement、retransmission）来保证单个 link 上的 reliable delivery。这在出错率较高时可以避免单个 link 的传输错误导致 end-to-end retransmission，而在出错率较低时会造成不必要的 overhead，所以一般是出错率较高的 wireless link 才会提供 reliable delivery。
-   error detection and correction

在 host 中，link layer 一般实现于外接的 network adapter (network interface controller, NIC) 中，由硬件实现。host 中还会有软件用来连接 link layer 和 network layer。

## Error-Detection and -Correction Techniques

参见 [DDPP 第二章的相关内容](/post/2023/01/ddpp-2#codes-for-detecting-and-correcting-errors)。

## Multiple Access Links and Protocols

在 broadcast link 中，同时只能有一方发送信息。如果多方同时发送，则会产生 collision，每一方发送的信息都会丢失。为了解决 multiple access problem，需要使用 multiple access protocol 来进行协调。

一个理想的 multiple access protocol 能做到：

-   只有一方发送时，完全利用带宽
-   多方同时发送时，均分全部的带宽
-   decentralized，没有 single point of failure
-   simple, inexpensive to implement

multiple access protocol 有非常多，总体可以分为三大类：channel partitioning protocols、ramdom access protocols、taking-turns protocols。

### Channel Partitioning Protocols

将单个 channel 分成多个 channel。

TDM (time-division multiplexing) 将时间分成 time frames，将每个 time frame 分成 time slots，将每个 time frame 内的各个 time slot 分配给各个 node。

FDM (frequency-division multiplexing) 利用不同的频率作为不同的 channel。

TDM 和 FDM 都能完全避免 collision，但在只有一方发送时效率非常低：唯一的 active sender 不能使用分配给其他 node 的 channel。

CDMA (code-division multiple access) 通过给每个 node 分配一个 code 来允许各方同时发送，在 wireless channel 中较为常用。

### Random Access Protocols

通过随机的等待时间来在 collision 发生后错开发送时机。

#### ALOHA

假设传输每个 frame 的用时相同，将时间划分为长度为这一用时的 slots，所有 node 是同步的，只在 slot 的开头发送信息，发生 collision 后能在这一 slot 内检测到。

slotted ALOHA 在没有 collision 时在每个 slot 开头发送 frame，在发生了 collision 后在每个 slot 开头以 $p$ 的概率进行 retransmission 直到发送成功为止。

如果一个 slot 中没有任何一方发送信息或者有多方同时发送信息则这个 slot 就浪费掉了，只有恰好有一方发送信息的 slot 才是 successful slot。

其 efficiency 就是 successful slot 的占比，有 $n$ 个 active slot 时，efficiency 为 $np(1-p)^{n-1}$，在 $n$ 很大时，其最大值是 $1/e \\approx 0.37$。

pure ALOHA 不进行 time slot 的划分，或者说是每一方的 time slot 不是同步的，这样更加去中心化，但 efficiency 只有 slotted ALOHA 的一半。

#### CSMA(/CD)

CSMA (carrier sense multiple access) 基于 “listen before speaking” 的原则，进行 *carrier sensing*。

如果再加上 “If someone else begins talking at the same time, stop talking” 的原则，即 *collision detection*，则是 CSMA/CD。

在理想状态下，carrier sensing 可以完全消除 collision。但实际上，由于 propagation delay，一方开始发送到另一方收到需要时间，在这段时间内可能另一方也发送了信息。

在 CSMA/CD 中，遇到 collision 需要等待一段时间再 retransmit，等待时间通常由 binary exponential backoff 得到：在一个范围内随机选择等待时间，每多 retransmit 一次这个范围就加倍。在 Ethernet 中，第 $n$ 次 retransmission 会在 $0, 1, \\ldots, 2^{n-1}$ 中随机选择一个数 $k$，然后等待传输 $512 \\cdot k$ bits 的用时，而 $n$ 超过 $10$ 时也取 $10$。这里 retransmission 次数是每个 frame 分别计算的，新的 frame 会从 $0$ 开始。

CSMA/CD 的 efficiency 约为 $\\dfrac{1}{1 + 5 d_{\\mathrm{prop}} / d_{\\mathrm{trans}}}$，其中 $d_{\\mathrm{prop}}$ 表示 propagation delay，$d_{\\mathrm{trans}}$ 表示一个 maximum-size frame 的传输用时。

### Taking-Turns Protocols

轮流让各方发送信息，如果一方不想发送则交给下一位。

在 polling protocol 中，设有一个 master node，它轮流 poll 每个 node 来让它发送至多若干个 frame，发完再 poll 下一个。polling protocol 是 centralized 的，有 single point of failure；并且，对 inactive node 的 poll 会造成浪费。

token-passing protocol 是 decentralized 的，有一个 token 在各个 node 之间环状地传递，拿着 token 就可以发送至多若干个 frame，发送完（或者不想发送）就把 token 交给下一个。token-passing protocol 在有任何一个 node 出错时就会卡住，需要采取一些 recovery procedure。

### DOCSIS: The Link-Layer Protocol for Cable Internet Access

DOCSIS 用于 cable access network，将 residential cable modems 连接到 cable modem termination system (CMTS)。它同时用到了多种 multiple access protocol，是一个很好的例子。

使用 FDM 分为 downstream 和 upstream 两个 channel，其中 downstream channel 由 CMTS 向 cable modem 发送，sender 唯一，比较简单。

upstream channel 被分成了若干 mini-slots（与 TDM 类似），而这些 mini-slots 是由 CMTS 动态分配的，需要由 cable modem 发送 mini-slot-request frame，这些 request 在一些特殊的 mini-slots 以 random access 的方式发送，通过是否收到来自 CMTS 的 mini-slot 分配来判断 request 是否成功发送，使用 binary exponential backoff。

## Switched Local Area Networks

### Link-Layer Addressing

host 和 router 的每个 interface (adapter) 都有一个 link-layer address：MAC address (physical address / LAN address)。

MAC address 的长度为 6 bytes，与 IP address 不同，物理上的每个 interface 的 MAC address 是固定的，不会因移动而变化。MAC address 由 IEEE 管理，在全球范围内是唯一的。

如果使用 broadcast link，多个 interface 都会收到同样的 frame。只有 MAC address 符合时才会接收，否则会丢弃（不会传递给 network layer）。

MAC broadcast address 是 \`ff:ff:ff:ff:ff:ff\`。

### Address Resolution Protocol

ARP 用来将 subnet 内部的 IP address 翻译为 MAC address。

每个 host / router 会维护一张 ARP table，用来记录 IP address 和 MAC address 的对应关系。表项有过期时间，到期自动删除。

如果在 ARP table 内没有查询到需要的 IP address，则会发送一个 ARP query（一个 broadcast packet），具有这个 IP address 的 interface 在收到 ARP query 后会回复 ARP response（一般不是 broadcast，因为此时 broadcast 可能造成浪费；但是若采用 broadcast 也有助于发现 address conflict[^arp-response-broadcast]），收到 ARP response 后更新 ARP table。通过这样的机制，ARP table 可以自动建立，不需要任何手动配置。

[^arp-response-broadcast]: [ethernet - ARP Replies can they be Broadcast - Network Engineering Stack Exchange](https://networkengineering.stackexchange.com/questions/7136/arp-replies-can-they-be-broadcast)

如果要向 subnet 外发送信息，则需要向 gateway (first-hop router) 发送信息，所以需要查询的是 gateway 的 MAC address。

### Ethernet

Ethernet 是现在最常用的 wired LAN。

Ethernet 通常使用 hub 或 switch 来连接各个 interface。hub 会将收到的每个 bit 转发给其他所有 interface，可能产生 collision。switch 则根据 MAC address 进行转发，不会产生 collision。

Ethernet frame 包含：

1.  preamble (8 bytes): 31 个 “10” 和 1 个 “11”，用来标识 frame 的开头，并同步时钟。
2.  destination MAC address (6 bytes)
3.  source MAC address (6 bytes)
4.  type (2 bytes): upper layer protocol，例如 IP、ARP。
5.  data (46 \\~ 1500 bytes): 如果需要传送的数据不足 46 bytes 需要进行填充。通过 type 以及 data 中的 header（例如 IP header）来判断 data 的长度。
6.  CRC checksum (4 bytes)

Ethernet 是 connectionless、unreliable 的。

Ethernet 既是 link-layer protocol，也是 physical layer protocol，而且实际上是一类而非一个 protocol。例如，10BASE-T、10BASE-2、100BASE-T、1000BASE-LX、10GBASE-T、40GBASE-T 是不同的 Ethernet technology。开头表示 10Mbps、100Mbps、1Gbps、10Gbps、40Gbps 的传输速度，BASE 表示 media 只传送 Ethernet traffic，最后是不同的 physical media。

### Link-Layer Switches

switch 和 router 的功能类似，但它工作于 link layer，而且是 *transparent* 的，其他设备感受不到 switch 的存在，也不需要手动进行任何配置。

switch 的每个 interface 都有一个 output buffer，与 router 类似。

switch 维护了一张 switch table，表示每个 MAC address 对应的 switch 的 interface，以及表项的过期时间。

对于从 interface $x$ 收到的 destination MAC address 为 $\\alpha$ 的 frame：

1.  若 $\\alpha$ 不在 switch table 中，broadcast；
2.  若 switch table 中 $\\alpha$ 对应 interface $x$，discard；
3.  若 switch table 中 $\\alpha$ 对应 interface $y \\ne x$，forward to $y$。

switch 是 *self-learning* 的：如果在 interface $x$ 收到 source MAC address 为 $\\alpha$ 的 frame，则会在 switch table 中记录 $\\alpha$ 到 $x$ 的对应关系。

相对于 hub，switch 的优点有：

-   没有 collision，可以优化性能。
-   可以将不同 technology 的 link (media) 连接在一起。
-   switch 还提供了一些 network management 功能，例如自动检测异常的 adapter 并禁用、对流量进行统计。

switch 减少了 broadcast，在提升性能的同时也增强了安全性。但是 attacker 可以设法用 bogus entries 将 switch table 填满，使得大部分 frame 被 broadcast，这被称作 *switch poisoning*。

switch 和 router 都可以将多个 host 连接在一起：

-   switch 不需要手动配置；性能一般更好。只能连成生成树，不能连出环；如果同一个 subnet 内有太多 host 可能影响性能；可能遭受 broadcast storm。
-   router 需要手动配置；性能可能略差。可以随便连，从而可以提供多条 route 供 routing protocol 选择；提供 firewall 来防止遭受 broadcast storm。

一般来说多至数百个 host 时用 switch 即可，有更多 host 的话则需要适当使用 router 来进行中转。

### Virtual Local Area Networks (VLANs)

有时，物理上的 switch 会对网络管理造成一些限制：

-   一个 switch 一般有很多 port，但希望设置的 subnet 大小（为了安全等原因想分成不同的 subnet）可能和 port 数量不符。
-   如果要在不同 subnet 之间移动 host，需要更改物理连线。

VLAN 可以用来解决这些问题。

VLAN 通过软件控制一个 switch 上哪些 port 属于同一个 subnet。为了将两个 subnet 相连，需要将它们连到同一个 router 上，为了方便这样操作，支持 VLAN 的 switch 往往自带一个 router。

可以使用 VLAN trunking 来将多个 switch 上的 port 合并为一个 VLAN：每个 switch 上有一个 trunk port，将需要 trunking 的 switch 的 trunk port 相连，发送到 VLAN 的 frame 会被 forward 到 trunk port。trunking 时所属 VLAN 的识别通过扩展的 Ethernet frame format 802.1Q 来实现，在 header 中添加 VLAN tag 来表示所属的 VLAN。

除了基于 switch port 的 VLAN，还有基于 MAC address 的 VLAN，以及基于 network-layer protocol 的 VLAN。

## Multiprotocol Label Switching (MPLS)

MPLS 基于 fixed-length label 进行 switch，在 link-layer header 和 IP header 之间添加 MPLS header，需要在支持 MPLS 的 router 之间进行传输，switch 时不需要管 IP header。

MPLS 有 switch 速度快、便于进行 traffic management 等优点。

（书中对它的介绍过于简略，感觉说了和没说差不多，我就在此基础上再简略一点（（

## Data Center Networking

很多大型互联网公司都有由数万台 server 组成的 data center。data center 对外接入 Internet，而其内部又有一套 data center network。

data center 主要提供三部分的功能：向终端用户 serve content，进行 distributed computation，对外提供 cloud computing 服务。

data center 中的 host 被称作 *blade*，一般数十个 blade 会放在一起组成一个 *rack*，连到同一个 switch（top of rack, TOR switch）上，而整个 data center 通过多级 router 和 switch 构成一个 hierarchy，其中 access router 的下方可以分为多个 VLAN。如下图所示：[^fig-6.30]

[^fig-6.30]: p506, Figure 6.30: A data center network with a hierarchical topology

![A data center network with a hierarchical topology](cnatda-fig-6.30.png)

在 data center 中，一个 application 通常由很多 host 来提供同样的服务，而对外只提供一个 IP address。load balancer 通过类似 NAT 的方式，将 request 均衡地分配给各个 host 进行处理。

树状的网络结构使得一个 data center 可以有数万台 server，但 host-to-host capacity 还是会受限，尤其是两个 host 的 LCA 位于较高层级时。为了解决这一问题，可以：

-   使用更高速的 router 和 switch，但这会大大增加开销。
-   尽量将需要互相通信的 host 放在较低的同一棵子树内，但这不一定做得到（可能大量 host 都需要互相通信），也会影响 host 位置的灵活性。
-   增加 interconnection 的数量，从而增加 host-to-host 的路径数量，在优化性能的同时也可以提升系统的可靠性。例如，每个 TOR switch 连接到 8 个 tier-2 switch，每个 tier-2 switch 连接到 16 个 tier-1 switch…… 这也被称作 *Clos network*。

data center 通常使用 SDN 来对网络进行集中管理。

为了支持 cloud computing、更方便地进行管理，通常会使用 virtual machine (VM) 等技术将 software 和 hardware 解耦。为了让 VM 能方便地在不同 host 之间移动，可以将 ARP 的 broadcast 机制改为类似于 DNS 的机制，存储 VM 的 IP address 到 TOR switch 的映射关系。

data center network 通常具有极低的延迟以及较小的 buffer size，而 congestion control 需要快速作出反应，传统的 TCP 不再适用，通常会使用为 data center 设计的 TCP 等方式来进行优化。

modular data center (MDC) 是一个内有至多数千个 host 的 container，用来作为 data center 的组成部分。在 MDC 的部分 component 坏掉时，MDC 可以继续以 degraded performance 工作，而在坏掉的 component 过多时则会报废。

很多公司会自己定制 data center 中的各个组成部分，包括 network adapter、switch、router、software、networking protocol。

Amazon 通过 “availability zone” 提高了服务的可靠性，即将 data center 在邻近但不同的地理位置上进行复刻，从而提供 fault tolerance，而地理位置上的邻近保证了 low latency，便于同步。
`},{title:G,tags:"cnatda 学习笔记 WIP",content:`《Computer Networking: A Top-Down Approach (8th Edition)》第八章 “Security in Computer Networks” 的学习笔记。



## What Is Network Security?

*secure communication* 有下列性质：

-   confidentiality: 由于通信可以被拦截，保密意味着需要以某种方式加密
-   message integrity: 保证消息未被修改
-   end-point authentication: 能够确认对方的身份
-   operational security: 保护 organization network 不被攻击

intruder 可以对 message 进行 eavesdropping、modification、insertion、deletion，进而实现各种攻击。

在网络中，需要进行 secure communication 的双方可能是两个人类用户、可能是 client 和 server、可能是两个 router……

security functionality 可以在网络的各个 layer 提供。虽然底层的 security 看起来覆盖了高层的 security，但并非完全如此，例如 IP-layer security 不能区分 IP address 相同的多个用户。并且，底层协议的更新、普及相对更慢，在上层采取措施可以更快生效。

## Principles of Cryptography

plaintext (cleartext) 经 encryption algorithm 得到 ciphertext，由 decryption algorithm 回到 plaintext。

encryption algorithm 一般是公开的，为了达到保密的效果，还需要使用 key。设 plaintext 是 $m$，sender 使用 key $K_A$ 进行 encrypt 得到 $K_A(m)$，receiver 使用 key $K_B$ 进行 decrypt 得到 $K_B(K_A(m)) = m$。

在 symmetric key system 中，$K_A = K_B$，是保密的；在 public key system 中，$K_A$ 是公开的，$K_B$ 是保密的。

### Symmetric Key Cryptography

在现代密码所使用的 block cipher 中，plaintext 被划分为若干个 block，例如在 AES 中每 128 bit 是一个 block，cipher 会构建一个 $2^{128} \\to 2^{128}$ 的 plaintext 到 ciphertext 的一一对应，而 key 用来生成这个对应关系，AES 的 key length 可以是 128/192/256 bit。太小的 block size / key length 会导致安全性不够；将整个对应关系存下来 key 会过长，所以只能用没那么长的 key 来生成对应关系；太大的 block size / key length 可能会影响性能。

如果 plaintext 中有多个相同的 block，它们对应的 ciphertext 也相同，就会暴露出一定的信息。为了避免这样的风险，可以给每个 block 异或上一个随机数再加密。

如果真的每个 block 都独立地生成一个随机数，则传输时需要附上这一堆随机数，整个 message 的长度会翻倍。所以实际上并不会这样做，而是会使用称作 cipher block chaining (CBC) 的技术：每条 message 只生成一个随机数，称作 initialization vector (IV)，记作 $c_0$，而 plaintext 的第一块记作 $m_1$，对 $c_{i-1} \\oplus m_i$ 加密得到 $c_i$，即每个 block 异或的是上一个 block 的加密结果，这样传输时的 overhead 就只有一个 block size 的 IV 了。

### Public Key Encryption

symmetric key cryptography 需要双方以某种方式事先做到共享 key，而这本身就需要 secure communication。以前这可以通过线下之类的方式进行，而在网络中则需要另外的方式。

在 public key encryption 中，接收方有一对 key，public key 用来加密，private key 用来解密。public key 是公开的，从而不需要事先依赖于 secure communication 进行 key exchange。

public key encryption 带来身份认证的问题：在 symmetric key cryptography 中，知道 key 隐含了身份，但知道 public key 则不代表身份，所以需要额外的机制来进行认证。

RSA 是目前最流行的 public key encryption algorithm:

1.  选两个大质数 $p$ 和 $q$（一般要达到 1024\\~4096 bit 长）
2.  令 $n = pq$，$z = (p-1)(q-1)$
3.  选一个比 $n$ 小、和 $z$ 互质的数 $e$
4.  算出 $e$ 的乘法逆元 $d = e^{-1} \\bmod z$
5.  public key 是 $(n, e)$，private key 是 $(n, d)$
6.  encryption: 设 plaintext 是 $m$ ($m < n$)，则 ciphertext 是 $c = m^e \\bmod n$
7.  decryption: $m = c^d \\bmod n$

RSA 的计算比 AES 慢，为了性能，通常会结合 symmetric key cryptography 一起使用：每次生成一个用于 symmetric key cipher 的 session key，通过 public key encryption 来进行 key exchange，实际的通信则使用 symmetric key cipher。

RSA 的安全性依赖于大数分解的困难性，这受到量子计算的挑战。

## Message Integrity and Digital Signatures

message integrity 即 sender 身份真实，message 未遭篡改。

cryptographic hash function 在一般的 hash 的基础上要求难以构造 collision，从而可以用来验证消息未被篡改。

可以用 message authentication code (MAC) 来验证 message integrity：双方共享保密的 authentication key，设 message 是 $m$，cryptographic hash function 是 $H$，最终传输的是 $(m, H(m + s))$（具体实现可能有所不同，例如 HMAC 会 hash 两次）。可以使用 public key encryption 或者其他方式来 exchange authentication key。MAC 本身可以不涉及 encryption，如果只需保证 message integrity 而不在意 confidentiality 则无需付出 encryption 的性能代价。

digital signature 相当于 MAC 的 “public key 版本”，可以用来验证 sender 的身份，而验证者只需知道 public key，可以保持 private key 的私密。RSA 的 encryption 和 decryption 其实是可交换的，即先 public key 再 private key 或者先 private key 再 public key 都可以得到原来的 plaintext。digital signature 即使用 private key 进行“加密”，而使用 public key 进行“解密”。RSA 计算慢，所以可以对 cryptographic hash 而非 message 本身计算 digital signature。

虽然 MAC 和 digital signature 功能有一定的类似，但 MAC 可以完全不涉及 encryption，digital signature 则依赖于 public key infrastructure (PKI)。

digital signature 验证的是 message 和 public key 的对应关系，还需要额外的措施来保证 public key 和 entity (sender) 的对应关系。certification authority (CA) 提供了这一服务，通过某些手段认证 public key 和 entity 的对应关系，并颁发 certificate，certificate 包含 entity 和 public key 的相关信息（以及有效期）以及使用 CA 的 public key 对这些信息创建的 digital signature。有了 certificate，对 public key 和 entity 之间关联的信任取决于对 CA 的信任。

## End-Point Authentication

书上说了很多，但感觉本质上就是，Alice 要向 Bob 证明自己的身份，则 Bob 提供一个一次性的随机数 *nonce*，Alice 通过某种方式（例如 symmetric key cryptography / MAC）发回 nonce 并保证 message integrity。nonce 用来防止 playback attack。

## Securing E-Mail

### Secure E-Mail

就是上面这些东西的一个实例，没啥新东西：结合 digital signature 和使用 session key 的 encryption 即可；需要双方互相知道对方的 public key（分别用于 digital signature 的验证和 session key 的传输），public key 可以由 CA 认证。

（好怪，为啥不讲 SPF、DKIM、DMARC。）

### PGP

PGP 提供了 sign、encrypt、sign and encrypt 等功能，public key 通过用户之间的 web of trust 而非 CA 来 certify，可以线下举办 key-signing party 来互相 sign[^sign]。

[^sign]: P.S. 我有幸在 [第一次参加 tunight](https://tuna.moe/event/2021/welcome-and-debian/) 时获得了续老师的 signing，当时还完全不懂这些（~~现在也不是很懂（~~

## Securing TCP Connections: TLS

TLS (Transport Layer Security) 为 TCP 提供了 security services，是 SSL (Secure Sockets Layer) 标准化后的升级版（只不过现在人们有时仍会把 TLS 误称为 SSL，OpenSSL 的名字也有一定的误导性[^opentls]）。

[^opentls]: See [Rename OpenSSL to OpenTLS To Comply with RFC7568 · Issue #6384 · openssl/openssl](https://github.com/openssl/openssl/issues/6384) & [Celebrating 20 Years of OpenSSL - OpenSSL Blog](https://www.openssl.org/blog/blog/2018/12/20/20years/)

TLS 通常用于 HTTP，表现为网址开头是 \`https://\`，但它实际上可以用于任何基于 TCP 的 application。TLS 位于 application layer，但它提供了类似 TCP 的 API，对于 application developer 来说就像是 transport layer 的一部分。

### TLS Handshake

1.  TCP 3-way handshake
2.  client 发送 TLS version、supported cipher suites (symmetric algorithm、public key algorithm、HMAC algorithm)、client nonce。
3.  server 发送 selected cipher suite、certificate、server nonce。
4.  client 验证 certificate，得到 server 的 public key；随机生成 pre-master secret (PMS)，发送经 server 的 public key 加密的 PMS。
5.  由 PMS、client nonce、server nonce 可以计算得到 master key，由 master key 可以得到一系列用于后续加密的 key：client 和 server 各有用于 symmetric key encryption 的 key 和用于 HMAC 的 key，如果使用 CBC 则还有双方的 IV。
6.  client 发送上面这些 handshake message 的 HMAC（可以和 encrypted PMS 一同发送）。
7.  server 发送上面这些 handshake message 的 HMAC。

其中，一开始的 nonce 用来防止 replay attack，并且 server nonce 参与 master key 的计算，可以防止 key 完全由 client 决定。而最后的 HMAC 用来防止篡改 handshake message，例如将 supported cipher suites 改为只有 weak algorithm。

TLS 1.3 对 handshake 过程进行了简化。

### TLS Data Transfer

在 TLS 中，TCP byte stream 被切分为 records，为每个 record 计算 HMAC，并将 record + HMAC 进行 encrypt。这只保证了每个 record 的 integrity，为了保证整个 byte stream 的 integrity，每个 record 还有一个 sequence number，参与 HMAC 的计算，来防止攻击者对 record 进行 reorder / replay / remove。

TLS record 包含：

1.  type: handshake / data
2.  TLS version
3.  length: 用来标记 record 的结尾
4.  data + HMAC, encrypted

### TLS Connection Closure

为了防止 truncation attack，即伪造 TCP FIN segment，在 TLS 中需要先发送保证了 integrity 的 closure TLS record 再发送 TCP FIN segment 来结束连接。

## Network-Layer Security: IPsec and Virtual Private Networks

### IPsec and Virtual Private Networks (VPNs)

如果一个 institution 位于多个地理位置而想保证 institution 内通信的私密，一种选择是建立一个 private network，在物理上与 Internet 进行隔离，但这样需要自己搭建整套网络基础设施，开销非常大。

另一种选择是使用 virtual private network。在 VPN 内，通过 Internet 传输数据时会进行加密，具体来说是在内网的 gateway router 或直接连到公网的 host 处（例如学校连到 Internet 的 gateway router / 回家了的学生的设备上；为了叙述方便，下文中都假设是 gateway router 而不是 host）在 payload 前加上 IPsec header。

### The AH and ESP Protocols

IPsec 可以使用 Authentication Header (AH) protocol 或者 Encapsulation Security Payload (ESP) protocol。其中 AH 只提供了 source authentication 和 data integrity，ESP 在此基础上还提供了 confidentiality。使用 IPsec 的场景中通常需要保证 confidentiality，所以 ESP 用得更多，书中只讲 ESP。

### Security Associations

两个 entity (gateway router) 通过 IPsec 通信时需要建立称作 *security association* (SA) 的 logical connection。SA 是单向的，如果要互发消息则需要建立两个 SA。

SA 有下列 state information：

-   *security parameter index* (SPI)，一个 32-bit identifier
-   source & destination IP address
-   encryption algorithm, encryption key
-   integrity check algorithm, authentication key

一个 IPsec entity 可能同时 maintain 着很多 SA 的 state information，存储在 security association database (SAD) 中。

### The IPsec Datagram

IPsec 有两种 packet form，分别用于 tunnel mode 和 transport mode，其中 tunnel mode 更常用，书中只讲 tunnel mode。

一个 IPsec datagram 的结构如下：

-   new IP header (source / destination 是 gateway router，protocol 是 ESP)
-   “enchilada” (authenticated)
    -   ESP header
        -   SPI
        -   sequence number
    -   (encrypted)
        -   original IP header
        -   original IP payload
        -   ESP trailer
            -   padding (for encryption block size requirement)
            -   padding length
            -   next header （“4” for “IP Encapsulation within IP” in tunnel mode）[^esp-next-header]
-   ESP MAC （for authentication of the “enchilada”）

[^esp-next-header]: 可以参考 http://www.tcpipguide.com/free/t_IPSecEncapsulatingSecurityPayloadESP-2.htm

gateway router 会维护一个 security policy database (SPD)，当其接收到一个待转发的 IP datagram 时，会查询 SPD，根据 source IP address、destination IP address、protocol 来决定是否使用 IPsec 进行处理。

### IKE: Key Management in IPsec

IPsec 可以手动配置 key，但大型的 VPN 往往需要使用 Internet Key Exchange (IKE) protocol 来自动建立 SA。

（书中对 IKE 的描述太简陋了，说了跟没说差不多，以后再说吧（

## Securing Wireless LANs and 4G/5G Cellular Networks

<Card type="wip">

未完待续…… 🕊️

</Card>

## Operational Security: Firewalls and Intrusion Detection Systems

### Firewalls

firewall 用来控置哪些流量可以进入 internal network / host，一般要保证所有出入的流量都经过 firewall，并且 firewall 自身不会被攻击者控制。

#### Traditional Packet Filters

通过 packet header 来控制是否允许 packet 通过。例如根据 IP address、protocol type、port、TCP flags、ICMP message type、router interface 等进行控制。

一些 packet filter 可以实现的 policy 的例子：

-   drop outgoing 的对 port 80/443 的访问：禁止访问外部 Web。
-   drop incoming TCP SYN segment：禁止从外界创建 TCP connection。
-   drop 除了外界 port 是 53 的所有 UDP traffic：禁止其他 UDP traffic，只允许 DNS。
-   drop 发向 broadcast address 的 ICMP ping packets：避免遭受 smurf DoS attack。
-   drop outgoing ICMP TTL expired packets：避免被 traceroute。

#### Stateful Packet Filters

stateful packet filter 可以通过记录状态信息来实现更复杂的控制，例如跟踪 TCP connection，从而更加精准地只允许从内部建立的 TCP connection 而拒绝从外部建立的 TCP connection。

#### Application Gateway

packet filter 只根据 header 中的信息进行控制，而不管 application data。

application gateway 是一个 application-specific server，所有 application data 都需要通过它。一个 host 可以同时运行多个 application gateway。

application gateway 可以根据 application data 进行控制，提供例如 authorization 的高级 filter 功能，还可以提供除了 filter 外的其他功能，例如 proxy。

### Intrusion Detection Systems

和 application gateway 类似，intrusion detection system (IDS) 不止查看 header，还会查看 application data，这称作 deep packet inspection。

与 application gateway 不同，IDS 不是 application-specific 的，而是会检测到各种各样的 suspicious packet / series of packets，例如 network mapping、port scan、TCP stack scan、DoS attack、worm / virus、OS / application vulnerability attack。检测到时，IDS 会向管理员发送警告，而 intrustion prevention system (IPS) 则会 filter out 这些 packet。

因为 deep packet inspection 需要一定的算力，当流量过大时，一个 organization 往往需要多个 IDS，分散在网络中，而非只设置一个在整个网络的入口。

IDS 分为 signature-based 和 anomaly-based 两种。

signature 即 packet 的特征，例如 header 的某些项以及 application data 包含某一内容。IDS 维护了一个 signature database 用来进行匹配。signature-based IDS 需要事先知道 attack 的特征，所以无法防范新型 attack。signature 的匹配容易出现 false alarm，而且性能开销较大。

anomaly-based IDS 基于平时的 traffic 来检测 statistically unusual 的 traffic，例如检测到突然增多的 ICMP packets。anomaly-based IDS 不依赖于实现对攻击的了解，所以有可能检测到新型的攻击。但是区分 normal traffic 和 statistically unusual traffic 是困难的，现在的 IDS 通常还是以 signature-based 为主。

Snort 是一款 open-source IDS，有一个活跃的 community 维护着 signature database。
`}],meta:[{frontmatter:{title:d,date:new Date(1543988421e3),tags:B,lastUpdated:new Date(1690728591e3),published:new Date(1658482129e3),visitor:2892},href:"/about",filename:"src/pages/about.mdx"},{frontmatter:{title:m,date:new Date(1658549297e3),tags:["btrfs","Arch Linux",a],image:"/images/2022/07/btrfs-quota-timeshift-message-screenshot.png",lastUpdated:new Date(1658586466e3),published:new Date(1658552603e3),visitor:186},href:"/post/2022/07/btrfs-quota-timeshift-freeze",filename:"src/pages/post/2022/07/btrfs-quota-timeshift-freeze.mdx"},{frontmatter:{title:p,date:new Date(1658582944e3),image:"/images/2022/07/comments-loading-light.png",tags:[X,s,a],lastUpdated:new Date(1659536455e3),published:new Date(1658587665e3),visitor:93},href:"/post/2022/07/display-none-and-lazy-load",filename:"src/pages/post/2022/07/display-none-and-lazy-load.mdx"},{frontmatter:{title:g,date:new Date(1658728987e3),image:"/images/2022/07/all-in-wl.png",tags:["选课","THU",c],lastUpdated:new Date(1685025943e3),published:new Date(1658754332e3),visitor:782},href:"/post/2022/07/thu-course-selection-tips",filename:"src/pages/post/2022/07/thu-course-selection-tips.mdx"},{frontmatter:{title:F,date:new Date(1659161767e3),image:"/images/2022/07/uptime-kuma-list.png",tags:["caddy-security","uptime-kuma","caddy","server",a],lastUpdated:new Date(1659165466e3),published:new Date(1659165466e3),visitor:V},href:"/post/2022/07/uptime-monitoring-under-caddy-security",filename:"src/pages/post/2022/07/uptime-monitoring-under-caddy-security.mdx"},{frontmatter:{title:h,date:new Date(165966831e4),image:"/images/2022/08/busuanzi-and-live2d.png",tags:["busuanzi","live2d",W,s,a],lastUpdated:new Date(1659678915e3),published:new Date(1659678915e3),visitor:K},href:"/post/2022/08/busuanzi-and-live2d",filename:"src/pages/post/2022/08/busuanzi-and-live2d.mdx"},{frontmatter:{title:b,date:new Date(1660492135e3),image:"https://www.rust-lang.org/static/images/rust-social-wide.jpg",tags:["Rust",l],lastUpdated:new Date(168856745e4),published:new Date(1660576305e3),visitor:288},href:"/post/2022/08/learn-rust",filename:"src/pages/post/2022/08/learn-rust.mdx"},{frontmatter:{title:f,date:new Date(1663478897e3),image:"/images/2022/09/csapp-2.png",tags:[e,n],lastUpdated:new Date(166399937e4),published:new Date(166351913e4),visitor:125},href:"/post/2022/09/csapp-2",filename:"src/pages/post/2022/09/csapp-2.mdx"},{frontmatter:{title:y,date:new Date(1663553588e3),image:"/images/2022/09/csapp-3.png",tags:[e,n],lastUpdated:new Date(1673269583e3),published:new Date(166399937e4),visitor:K},href:"/post/2022/09/csapp-3",filename:"src/pages/post/2022/09/csapp-3.mdx"},{frontmatter:{title:v,date:new Date(1663478888e3),image:"https://csapp.cs.cmu.edu/3e/images/csapp3e-cover.jpg",tags:[e,n],lastUpdated:new Date(1665973845e3),published:new Date(166351913e4),visitor:161},href:"/post/2022/09/csapp",filename:"src/pages/post/2022/09/csapp.mdx"},{frontmatter:{title:C,date:new Date(1667202147e3),tags:["TeX","R","物理实验",c],lastUpdated:new Date(1679113234e3),published:new Date(1667211348e3),visitor:Y},href:"/post/2022/10/basic-tex-and-r-for-physics-lab",filename:"src/pages/post/2022/10/basic-tex-and-R-for-physics-lab.mdx"},{frontmatter:{title:w,date:new Date(1664805493e3),image:"/images/2022/10/csapp-4.png",copyrightNotice:"本文包含截自 CS:APP 中的图片，文章作者对其不拥有版权。",tags:[e,n,Q],lastUpdated:new Date(1673710372e3),published:new Date(1665973845e3),visitor:92},href:"/post/2022/10/csapp-4",filename:"src/pages/post/2022/10/csapp-4.mdx"},{frontmatter:{title:x,date:new Date(1665975415e3),image:"/images/2022/10/csapp-7.png",copyrightNotice:"本文包含少量直接从 CS:APP 中复制的代码、图片，本文作者对其不拥有版权。",tags:[e,n],lastUpdated:new Date(1671291937e3),published:new Date(1667212746e3),visitor:101},href:"/post/2022/10/csapp-7",filename:"src/pages/post/2022/10/csapp-7.mdx"},{frontmatter:{title:k,date:new Date(1666077048e3),image:"/images/2022/10/use_vector_fp_converts-test-results.png",tags:["gcc","性能优化",a],lastUpdated:new Date(166625156e4),published:new Date(1666197777e3),visitor:122},href:"/post/2022/10/gcc-use_vector_fp_converts",filename:"src/pages/post/2022/10/gcc-use_vector_fp_converts.mdx"},{frontmatter:{title:S,date:new Date(1668736861e3),image:"/images/2022/11/csapp-8.png",tags:[e,n],lastUpdated:new Date(1671350958e3),published:new Date(1671258446e3),visitor:J},href:"/post/2022/11/csapp-8",filename:"src/pages/post/2022/11/csapp-8.mdx"},{frontmatter:{title:P,date:new Date(1669198242e3),image:"/images/2022/11/csapp-9.png",copyrightNotice:Z,tags:[e,n],lastUpdated:new Date(1688567467e3),published:new Date(1672037059e3),visitor:V},href:"/post/2022/11/csapp-9",filename:"src/pages/post/2022/11/csapp-9.mdx"},{frontmatter:{title:E,date:new Date(1668050758e3),image:"/images/2022/11/swim.jpg",tags:["游泳",c],lastUpdated:new Date(1668053703e3),published:new Date(1668053703e3),visitor:193},href:"/post/2022/11/pitfalls-of-breaststroke-breathing",filename:"src/pages/post/2022/11/pitfalls-of-breaststroke-breathing.mdx"},{frontmatter:{title:A,date:new Date(1670046303e3),image:"/images/2022/12/csapp-6.png",copyrightNotice:Z,tags:[e,n],lastUpdated:new Date(1670226463e3),published:new Date(1670226463e3),visitor:159},href:"/post/2022/12/csapp-6",filename:"src/pages/post/2022/12/csapp-6.mdx"},{frontmatter:{title:T,date:new Date(1674304358e3),image:"/images/2023/01/ddpp-2.png",copyrightNotice:"本文包含若干截自 DDPP 的图片，本文作者对其不拥有版权。",tags:[u,n],lastUpdated:new Date(1674571032e3),published:new Date(1674571032e3),visitor:nn},href:"/post/2023/01/ddpp-2",filename:"src/pages/post/2023/01/ddpp-2.mdx"},{frontmatter:{title:D,date:new Date(167461137e4),image:"/images/2023/01/ddpp-3.png",tags:[u,n],lastUpdated:new Date(1674978752e3),published:new Date(1674978752e3),visitor:nn},href:"/post/2023/01/ddpp-3",filename:"src/pages/post/2023/01/ddpp-3.mdx"},{frontmatter:{title:$,date:new Date(167513277e4),copyrightNotice:"本文包含若干截自 DDPP 的图片，本文作者对它们不拥有版权。",image:"/images/2023/01/ddpp-4.png",tags:[u,n],lastUpdated:new Date(1675756712e3),published:new Date(1675756712e3),visitor:105},href:"/post/2023/01/ddpp-4",filename:"src/pages/post/2023/01/ddpp-4.mdx"},{frontmatter:{title:I,date:new Date(1673779818e3),image:"/images/2023/01/ddpp-cover.png",tags:[u,n],lastUpdated:new Date(1674297595e3),published:new Date(1673783362e3),visitor:120},href:"/post/2023/01/ddpp",filename:"src/pages/post/2023/01/ddpp.mdx"},{frontmatter:{title:N,date:new Date(1674119026e3),image:"/images/2023/01/glyph-segregator.png",tags:[en,s,"项目开发"],lastUpdated:new Date(1675319173e3),published:new Date(1674134105e3),visitor:Y},href:"/post/2023/01/glyph-segregator",filename:"src/pages/post/2023/01/glyph-segregator.mdx"},{frontmatter:{title:L,date:new Date(1674981968e3),image:B,tags:[W,a],lastUpdated:new Date(1674994592e3),published:new Date(1674994592e3),visitor:61},href:"/post/2023/01/string-prototype-replace",filename:"src/pages/post/2023/01/string-prototype-replace.mdx"},{frontmatter:{title:M,date:new Date(1675942597e3),image:"/images/2023/02/css-is-awesome.jpeg",tags:[en,X,s,c],lastUpdated:new Date(1686240934e3),published:new Date(1675955985e3),visitor:240},href:"/post/2023/02/typography-tricks",filename:"src/pages/post/2023/02/typography-tricks.mdx"},{frontmatter:{title:_,date:new Date(1677723446e3),image:"/images/2023/03/dd-dc.jpg",tags:["digital-design",l],lastUpdated:new Date(1687442019e3),published:new Date(1677728814e3),visitor:278},href:"/post/2023/03/digital-logic",filename:"src/pages/post/2023/03/digital-logic.mdx"},{frontmatter:{title:R,date:new Date(1677762549e3),image:"/images/2023/03/tech-stack.jpg",tags:[s,l],lastUpdated:new Date(1685286644e3),published:new Date(1677901349e3),visitor:559},href:"/post/2023/03/thuse",filename:"src/pages/post/2023/03/thuse.mdx"},{frontmatter:{title:z,date:new Date(1680771173e3),image:"/images/2023/04/ddpp-5.png",tags:[u,n],lastUpdated:new Date(1682785476e3),published:new Date(1682785476e3),visitor:113},href:"/post/2023/04/ddpp-5",filename:"src/pages/post/2023/04/ddpp-5.mdx"},{frontmatter:{title:j,date:new Date(1686573752e3),image:"/images/2023/06/cnatda-2.png",tags:[i,n],lastUpdated:new Date(1687606195e3),published:new Date(1686929074e3),visitor:42},href:"/post/2023/06/cnatda-2",filename:"src/pages/post/2023/06/cnatda-2.mdx"},{frontmatter:{title:q,date:new Date(1687265458e3),image:"/images/2023/06/cnatda-3.png",tags:[i,n],lastUpdated:new Date(1688567345e3),published:new Date(1687606195e3),visitor:J},href:"/post/2023/06/cnatda-3",filename:"src/pages/post/2023/06/cnatda-3.mdx"},{frontmatter:{title:O,date:new Date(1687764599e3),image:"/images/2023/06/cnatda-4.png",tags:[i,n],lastUpdated:new Date(1688567493e3),published:new Date(1688567493e3),visitor:14},href:"/post/2023/06/cnatda-4",filename:"src/pages/post/2023/06/cnatda-4.mdx"},{frontmatter:{title:U,date:new Date(1688696796e3),image:"/images/2023/07/cnatda-5.png",tags:[i,n],lastUpdated:new Date(1688819869e3),published:new Date(1688819869e3),visitor:23},href:"/post/2023/07/cnatda-5",filename:"src/pages/post/2023/07/cnatda-5.mdx"},{frontmatter:{title:H,date:new Date(168905167e4),image:"/images/2023/07/cnatda-6.png",tags:[i,n],lastUpdated:new Date(168941271e4),published:new Date(168941271e4),visitor:25},href:"/post/2023/07/cnatda-6",filename:"src/pages/post/2023/07/cnatda-6.mdx"},{frontmatter:{title:G,date:new Date(168959447e4),image:"/images/2023/07/cnatda-8.png",tags:[i,n,Q],lastUpdated:new Date(1690211468e3),published:new Date(1689690764e3),visitor:33},href:"/post/2023/07/cnatda-8",filename:"src/pages/post/2023/07/cnatda-8.mdx"}]}}("学习笔记","csapp","csapp 学习笔记","问题解决记录","cnatda","ddpp 学习笔记","cnatda 学习笔记","Web","ddpp","经验分享","学习记录","关于","Btrfs Quota 以及 Timeshift 导致的系统无响应问题解决过程记录",'display: none 与 loading="lazy"',"有关 THU 选课的一些常见问题与注意事项","使用 Caddy Security 时的 Uptime 监控","busuanzi 访问量统计与 live2d 插件同时使用导致 busuanzi 不显示的根本原因以及解决方法","初学 Rust","CS:APP 第二章学习笔记","CS:APP 第三章学习笔记","CS:APP 学习笔记系列 序","普物实验 TeX & R 急救指北","CS:APP 第四章学习笔记","CS:APP 第七章学习笔记","探究 gcc 浮点数精度转换所使用的指令 —— use_vector_fp_converts 优化","CS:APP 第八章学习笔记","CS:APP 第九章学习笔记","蛙泳换气踩坑记录","CS:APP 第六章学习笔记","DDPP 第二章学习笔记","DDPP 第三章学习笔记","DDPP 第四章学习笔记","DDPP 学习笔记系列 序","另一种很新的中文字体网页嵌入方案","String.prototype.replace 与隐藏的“$”","一些博客排版优化小 trick","数字逻辑实验到底是数电实验还是数设实验（x","当你的技术栈与软工交集为空（x","DDPP 第五章学习笔记","CNATDA 第二章学习笔记","CNATDA 第三章学习笔记","CNATDA 第四章学习笔记","CNATDA 第五章学习笔记","CNATDA 第六章学习笔记","CNATDA 第八章学习笔记",null,"CSS",82,"JavaScript",179,266,"WIP",40,"本文包含若干截自 CS:APP 中的图片，本文作者对其不拥有版权。",56,"blog"),{});
</script></main><footer class="flex flex-col gap-1 bg-card p-6 text-footer" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPFooter"><div class="flex flex-wrap items-center justify-center gap-x-1"><span>Copyright ©</span><span>2022 - 2023</span><a class="flex items-center" href="/sponsor" title="赞赏支持"><span class="i-mdi-heart text-red dark:text-red-7"></span></a><span>ouuan</span></div><div class="flex flex-wrap items-center justify-center gap-x-1"><span> 当前有 <ile-root id="ile-3"><span><span class="i-mdi-loading motion-safe:animate-spin"></span><span class="sr-only">加载中</span></span></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(o=>o.v),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/VisitorCountRealtime.4d85595f.js"),["assets/VisitorCountRealtime.4d85595f.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-3",{},{})});export default E();
</script> 人在线 </span><span class="i-mdi-circle-small"></span><span title="实际上，为了保护用户隐私，同一用户的多次访问只有在同一天内使用同一浏览器在同一ip下才会被算作同一人"> 共有 <ile-root id="ile-4"><span><span class="i-mdi-loading motion-safe:animate-spin"></span><span class="sr-only">加载中</span></span></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(o=>o.v),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/VisitorCount.11a0e95f.js"),["assets/VisitorCount.11a0e95f.js","assets/VisitorCount.065e72b2.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-4",{},{})});export default E();
</script> 人到访过这里 </span></div><div class="flex flex-wrap items-center justify-center gap-x-1"> 基于 <a class="underline" href="https://github.com/ElMassimo/iles">îles</a><a class="underline" href="https://github.com/ouuan/iles-blog/blob/master/package.json">等项目</a><span class="i-mdi-circle-small"></span><span>由 ouuan 设计/制作</span><span class="i-mdi-circle-small"></span><a class="underline" href="https://github.com/ouuan/iles-blog">源代码</a></div></footer><meta itemprop="copyrightYear" content="2022 - 2023"><div class="hidden" itemscope="" itemtype="https://schema.org/Person" itemprop="copyrightHolder"><meta itemprop="name" content="ouuan"><meta itemprop="givenName" content="Yufan"><meta itemprop="familyName" content="You"><meta itemprop="url" content="https://github.com/ouuan"><link itemprop="gender" href="https://schema.org/Male"><meta itemprop="image" content="/android-chrome-512x512.png"></div><ile-root id="ile-5"><button class="group bottom-10 flex-col floating-button" title="前往底部"><div aria-hidden="true" class="flex justify-center"><span class="i-mdi-chevron-double-up motion-safe:transition-font-size text-0"></span></div><div aria-hidden="true" class="text-0 group-hover:text-3.5 motion-safe:transition-font-size"></div><div aria-hidden="false" class="flex justify-center"><span class="i-mdi-chevron-double-down motion-safe:transition-font-size text-5 group-hover:text-3"></span></div></button></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(o=>o.v),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/BackToTop.b700b311.js"),["assets/BackToTop.b700b311.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-5",{},{})});export default E();
</script><div class="hidden"></div><ile-root id="ile-6"></ile-root><script></script><script type="module" async="">var p=(t,a)=>()=>(a||t((a={exports:{}}).exports,a),a.exports);var e=(t,a,_)=>new Promise((c,n)=>{var f=o=>{try{i(_.next(o))}catch(r){n(r)}},l=o=>{try{i(_.throw(o))}catch(r){n(r)}},i=o=>o.done?c(o.value):Promise.resolve(o.value).then(f,l);i((_=_.apply(t,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var u=p(m=>{const E=()=>e(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(t=>t.d),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),h=()=>e(m,null,function*(){return(yield d(()=>import("/assets/PlausibleTrigger.097a6894.js"),["assets/PlausibleTrigger.097a6894.js","assets/plausible.72e01c7c.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).onLoad});s(E,h,"ile-6",{},{})});export default u();
</script><div></div><ile-root id="ile-7"></ile-root><script></script><script type="module" async="">var p=(t,a)=>()=>(a||t((a={exports:{}}).exports,a),a.exports);var e=(t,a,_)=>new Promise((c,n)=>{var f=o=>{try{i(_.next(o))}catch(r){n(r)}},l=o=>{try{i(_.throw(o))}catch(r){n(r)}},i=o=>o.done?c(o.value):Promise.resolve(o.value).then(f,l);i((_=_.apply(t,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.e381640b.js";import"/assets/vendor-vue.bda4d3d4.js";var u=p(m=>{const E=()=>e(m,null,function*(){return(yield d(()=>import("/assets/iles.e381640b.js").then(t=>t.d),["assets/iles.e381640b.js","assets/vendor-vue.bda4d3d4.js","assets/vite.5ce4fca4.js"])).default}),h=()=>e(m,null,function*(){return(yield d(()=>import("/assets/TextJustifyFix.4fa5e997.js"),[])).onLoad});s(E,h,"ile-7",{},{})});export default u();
</script><meta itemprop="inLanguage" content="zh-CN"></div>
  
</body></html>