<!DOCTYPE html><html lang="zh-CN"><head>
    <meta charset="UTF-8">
<title>搜索 - ouuan's blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="ouuan 的博客：以技术向内容为主，包括 Web、系统、Linux 等方面的学习笔记和经验分享。">
<meta property="og:url" content="https://ouuan.moe/search">
<meta property="og:site_name" content="ouuan's blog">
<meta property="og:title" content="搜索 · ouuan's blog">
<meta property="og:description" content="ouuan 的博客：以技术向内容为主，包括 Web、系统、Linux 等方面的学习笔记和经验分享。">
<meta property="twitter:domain" content="ouuan.moe">
<meta property="twitter:title" content="搜索 · ouuan's blog">
<meta property="twitter:description" content="ouuan 的博客：以技术向内容为主，包括 Web、系统、Linux 等方面的学习笔记和经验分享。">
<meta property="twitter:url" content="https://ouuan.moe/search">
<link rel="sitemap" href="https://ouuan.moe/sitemap.xml">
<style>html:not(.dark):not(.light) { visibility: hidden; } body { visibility: hidden; }</style>
<script>(() => { let dark; try { const theme = localStorage && localStorage.getItem('vueuse-color-scheme'); if (theme === 'dark') dark = true; else if (theme === 'light') dark = false; else dark = window.matchMedia('(prefers-color-scheme: dark)').matches; } catch (e) { dark = false; } document.documentElement.classList.add(dark ? 'dark' : 'light'); })()</script>
<noscript><style>@media (prefers-color-scheme: light) { :root:not(.dark):not(.light) { --text-color: #232637; --bg-color: #DEE6EE; --card-color: #EFF3F7; --link-color: #1E66B8; --hover-color: #2E80DD; --active-color: #164C89; --bghover-color: #D6E0EA; --popup-color: #F7F9FB; --footer-color: #5F627B; --area-color: #E1E2E8; --nested-color: #F0F0F3; } } @media (prefers-color-scheme: dark) { :root:not(.dark):not(.light) { --text-color: #E6EDF2; --bg-color: #0D0E15; --card-color: #1F2130; --link-color: #8BB8EC; --hover-color: #A2C6F0; --active-color: #74AAE8; --bghover-color: #353853; --popup-color: #2C2F45; --footer-color: #9699AE; --area-color: #2F313D; --nested-color: #3C3E4E; } } html { visibility:visible !important; }</style></noscript>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#a07e5b">
<link rel="canonical" href="https://ouuan.moe/search">
<link rel="alternate" type="application/rss+xml" href="/feed.xml" title="RSS Feed - ouuan's blog">
<link rel="alternate" type="application/atom+xml" href="/feed.atom" title="Atom Feed - ouuan's blog">
<link rel="alternate" type="application/json" href="/feed.json" title="JSON Feed - ouuan's blog">
<link rel="dns-prefetch" href="https://plausible.ouuan.moe">
<link rel="preconnect" href="https://blog-visitor-count.ouuan.moe">
<link rel="stylesheet" href="/vendors/katex/katex.css">
<meta name="author" content="ouuan">
<meta name="keywords" content="blog">
<meta name="twitter:creator" content="@ouuan">
<meta name="twitter:card" content="summary">
<meta property="og:image" content="https://ouuan.moe/android-chrome-512x512.png">
<meta property="generator" content="îles">
    <link rel="stylesheet" href="/assets/style-e72c93d4.css">
    
  <link rel="modulepreload" href="/assets/iles.5e82acba.js" crossorigin=""><link rel="modulepreload" href="/assets/vendor-vue.075573a8.js" crossorigin=""><link rel="modulepreload" href="/assets/vite.5ce4fca4.js" crossorigin=""><link rel="modulepreload" href="/assets/SearchBar.5e1dcbf6.js" crossorigin=""><link rel="modulepreload" href="/assets/PlausibleTrigger.bafee336.js" crossorigin=""><link rel="modulepreload" href="/assets/FuseSearch.10a5495e.js" crossorigin=""><link rel="modulepreload" href="/assets/PostHead.e82ef423.js" crossorigin=""><link rel="modulepreload" href="/assets/VisitorCount.c343552a.js" crossorigin=""><link rel="modulepreload" href="/assets/site.1441102a.js" crossorigin=""><link rel="modulepreload" href="/assets/fuse-js.6ab03eb8.js" crossorigin=""><style>@font-face { font-family: "Noto Serif SC Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Regular.unique.ad634666.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Regular.unique.411bd579.woff') format('woff'); unicode-range: U+0-2019; } @font-face { font-family: "Noto Serif SC Web Font"; font-weight: 400; font-style: normal; font-display: swap; src: url('/assets/fonts/NotoSerifSC-Regular.common.3e148809.woff2') format('woff2'), url('/assets/fonts/NotoSerifSC-Regular.common.af590d95.woff') format('woff'); unicode-range: U+0-ff1b; }</style></head>
  <body itemscope="" itemtype="https://schema.org/SearchResultsPage">
    <div id="app"><header class="bg-card shadow print:hidden" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPHeader"><div class="page-container px-4 whitespace-nowrap flex flex-wrap sm:flex-nowrap justify-center"><div class="flex basis-full sm:basis-auto items-stretch justify-center sm:mr-3"><a class="p-3 bghover font-serif text-xl flex items-center" href="/"><span>ouuan<span class="mojikumi-narrow-left">’</span>s blog</span></a></div><nav class="flex"><ul class="flex"><li class="flex-1 flex items-stretch justify-center"><a class="p-3 bghover flex items-center" href="/"><span>首页</span></a></li><li class="flex-1 flex items-stretch justify-center"><a class="p-3 bghover flex items-center" href="/posts"><span>文章</span></a></li><li class="flex-1 flex items-stretch justify-center"><a class="p-3 bghover flex items-center" href="/tags"><span>标签</span></a></li><li class="flex-1 flex items-stretch justify-center"><a class="p-3 bghover flex items-center" href="/about"><span>关于</span></a></li></ul></nav><div class="sm:basis-full"></div><ul class="flex"><li class="flex"><ile-root id="ile-1"><div class="lg:hidden flex items-stretch"><a class="p-2 bghover flex items-center" href="/search" title="全站搜索"><span class="text-xl i-mdi-magnify"></span></a></div><form role="search" class="hidden lg:flex items-stretch justify-center"><div class="flex items-center"><input value="" class="w-48 px-3 py-1 bg-area rd-full" type="search" placeholder="关键词" aria-label="全站搜索"></div><a class="p-2 bghover flex items-center" href="/search?q=" title="全站搜索"><span class="text-xl i-mdi-magnify"></span></a></form></ile-root><script></script><script type="module" async="">import{h as r,c as a}from"/assets/iles.5e82acba.js";import{_ as m}from"/assets/SearchBar.5e1dcbf6.js";import"/assets/vendor-vue.075573a8.js";import"/assets/vite.5ce4fca4.js";r(a,m,"ile-1",{},{});
</script></li><li class="flex items-stretch"><a class="p-2 bghover flex items-center" href="/feed.xml" title="RSS 订阅"><span class="text-xl i-mdi-rss"></span></a></li><li class="flex"><ile-root id="ile-2"><div class="relative flex items-stretch"><button title="暗色模式设置" class="p-2 bghover flex items-center" aria-haspopup="menu" aria-controls="__theme-switcher" aria-expanded="false"><span class="text-xl i-mdi-theme-light-dark"></span></button><ul style="display:none;" id="__theme-switcher" class="absolute z-20 top-full right-0 bg-popup shadow-md rd-1 whitespace-nowrap" role="menu" aria-label="暗色模式选项"><li class="bghover" role="menuitemradio" aria-checked="true"><button class="flex items-center p-1 text-hover"><span class="i-mdi-cellphone md:i-mdi-tablet lg:i-mdi-monitor mr-1"></span><span>跟随系统</span></button></li><li class="bghover" role="menuitemradio" aria-checked="false"><button class="flex items-center p-1"><span class="i-mdi-white-balance-sunny mr-1"></span><span>总是亮色</span></button></li><li class="bghover" role="menuitemradio" aria-checked="false"><button class="flex items-center p-1"><span class="i-mdi-weather-night mr-1"></span><span>总是暗色</span></button></li></ul></div></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.5e82acba.js";import"/assets/vendor-vue.075573a8.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.5e82acba.js").then(o=>o.v),["assets/iles.5e82acba.js","assets/vendor-vue.075573a8.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/ThemeSwitcher.3f8d4c7e.js"),["assets/ThemeSwitcher.3f8d4c7e.js","assets/vendor-vue.075573a8.js","assets/vite.5ce4fca4.js","assets/useTheme.f1d4e689.js"])).default});s(u,v,"ile-2",{},{})});export default E();
</script></li></ul></div></header><main class="page-container py-6 min-h-100vh" itemprop="mainContentOfPage" itemscope="" itemtype="https://schema.org/WebPageElement"><ile-root id="ile-7"><div class="m-4 flex flex-col gap-6"><div class="flex flex-wrap gap-x-5 gap-y-2"><form role="search" class="grow max-w-100 flex items-center gap-2"><label class="i-mdi-magnify text-xl" aria-label="搜索关键词" for="__search_keywords"></label><input id="__search_keywords" class="w-full p-1 bg-card rd-1" type="search" placeholder="关键词"></form><a class="flex items-center text-link" href="https://fusejs.io/examples.html#extended-search"> 高级搜索语法 </a><div class="flex items-center gap-1"><input id="__search_showmore" type="checkbox"><label for="__search_showmore">显示匹配程度较低的结果</label></div></div><div class="standard-card"><p class="my-3"> 请输入关键词进行搜索 </p></div></div></ile-root><script></script><script type="module" async="">import{h as O,c as q}from"/assets/iles.5e82acba.js";import{_ as U}from"/assets/FuseSearch.10a5495e.js";import"/assets/vendor-vue.075573a8.js";import"/assets/vite.5ce4fca4.js";import"/assets/PostHead.e82ef423.js";import"/assets/VisitorCount.c343552a.js";import"/assets/site.1441102a.js";import"/assets/fuse-js.6ab03eb8.js";O(q,U,"ile-7",function(n,e,t,a,i,u,s,o,r,c,l,m,d,p,F,g,b,h,f,x,v,y,C,w,E,k,S,A,P,$,D,L,_,T,M,z,R,I,j,N){return{data:[{title:r,tags:"",content:`## 关于我

你好，我是 ouuan， I’m from China. 下面是关于我的一些信息。

---

-   祖籍是 & 出生于江西，但不到一岁就来到了武汉。
-   曾经是一名现役的 OIer。
-   现在是位于 THU 的一名本科生，班上只有两位同学不（曾经）是 OIer ~~，但学的都是数学~~，培养方案里既有大量数学系核心课，又有大量贵系核心课 ~~，但我的数分可能还没有上微 A 的人学的好~~。
-   如果你有幸 (?) 需要在线下作为赛博朋友称呼我，出于顺口的考虑 (?)，可以叫我“欧元”（~~为什么是 yuan 不是 wan 呢，因为从出处来说正确的写法应该是 ouüan（~~，但如果你不介意拗口的话 (?)，也可以读成 O-U-U-A-N，~~甚至 óu yǔ án~~（

---

-   从 2020 年初开始使用 Linux 作为主力操作系统，现在是 [Arch Linux](https://wiki.archlinux.org/title/Arch_Linux) / [i3-wm](https://i3wm.org/) / [Neovim](https://neovim.io/) / [nnn](https://github.com/jarun/nnn) / [yadm](https://github.com/TheLocehiliosan/yadm) 等软件/项目的用户。
-   GitHub: [ouuan](https://github.com/ouuan)，参与维护/开发了一些或不大或很小的项目，例如 [CP Editor](https://github.com/cpeditor/cpeditor), [OI Wiki](https://github.com/OI-wiki/OI-wiki), [pacwatch](https://github.com/ouuan/pacwatch) 等。
-   写了一个代码语法树猜谜游戏 [Codle](https://codle.ouuan.moe/)，可是没多少人玩（

---

-   最喜欢的番剧（以及原作漫画）目前是 [3月のライオン](https://bgm.tv/subject/147068)，曾经是 [CLANNAD](https://bgm.tv/subject/51)。
-   [《月がきれい》](https://bgm.tv/subject/207573)[《荒ぶる季節の乙女どもよ。》](https://bgm.tv/subject/268070)[《風が強く吹いている》](https://bgm.tv/subject/248154)[《BEASTARS》](https://bgm.tv/subject/273843)[《ピンポン》](https://bgm.tv/subject/93739)[《SHIROBAKO》](https://bgm.tv/subject/110467)这几部番也很棒。
-   在 [<span class="text-muse">μ's Final LoveLive!</span>](https://zh.moegirl.org.cn/μ's_Final_LoveLive!_~μ'sic_Forever~) 的两个月前被同学安利由动画入坑 [<span class="text-muse">LL</span>](https://zh.moegirl.org.cn/LoveLive!)，这也是我的入宅番。之后有玩过一段时间 [sif](https://zh.moegirl.org.cn/zh-cn/LoveLive!学园偶像祭)，但缪的三次元活动（广播生放 live 之类）都看的很少，后面也逐渐淡坑，直到星团。
-   [<span class="text-liella">星</span>](https://zh.moegirl.org.cn/LoveLive!Superstar!!) 是在一期动画结束后开始看的；[<span class="text-nijigasaki">虹</span>](https://zh.moegirl.org.cn/LoveLive!虹咲学园学园偶像同好会) 是二期动画放送中开始看的；[<span class="text-aqours">水</span>](https://zh.moegirl.org.cn/LoveLive!Sunshine!!) 没太关注，动画只追到一期的一半，但开始看虹星后也多少看了一点切片。主推大概是 [<span class="text-kanon">sayu</span>/<span class="text-kanon">合</span>](https://zh.moegirl.org.cn/伊达小百合)[<span class="text-keke">鲤</span>](https://zh.moegirl.org.cn/Liyuu)/[<span class="text-mia">秀酱</span>](https://zh.moegirl.org.cn/内田秀)/[<span class="text-emma">麻圆</span>](https://zh.moegirl.org.cn/指出毬亚)。
-   [《罗小黑战记》](https://bgm.tv/subject/13603) 是除了动画电影以及小时候看的动画片，唯一一部较为完整地看过的国漫。
-   有在用 [bangumi](https://bgm.tv/user/ouuan)，但是用的较晚，所以（早期的）时间胶囊会比较乱，早期看的番的评分大概也比较乱来（说的好像最近看的番评分就有多正确一样x）
-   听的最多的是日语歌，目前[歌单](https://music.163.com/#/playlist?id=5091819419)的前六名有三首[匹老板](https://space.bilibili.com/203655966/)的歌和三首[花譜](https://space.bilibili.com/488970166/)的歌。

    P.S. 感觉找不到一个满意的歌单管理解决方案，以至于懒得更新歌单。想以后自己写一个。
-   大概是一名[轴芯](https://space.bilibili.com/61639371)。只不过看 [v](https://zh.moegirl.org.cn/虚拟UP主) 看的多的还是 2020 年，曾经还看过很多其他 v，现在看得少了。
-   偶尔（~~曾经~~）会[在 b 站上发一些视频](https://space.bilibili.com/11067182)。感觉除了 [av65924361](https://www.bilibili.com/video/av65924361) 和 [av79877987](https://www.bilibili.com/video/av79877987) 基本上都是划水或者黑历史（
-   不喜欢 BV 号，所以写了个 [bv2av](https://greasyfork.org/zh-CN/scripts/398535-bv2av) 的 userscript。

---

-   在[十六型人格测试](https://www.16personalities.com/ch/)中稳定获得[“逻辑学家”人格 (INTP)](https://www.16personalities.com/ch/intp-人格) 的测试结果（有时会在 INTP-A 和 INTP-T 之间摇摆）。但由于 MBTI 越来越火，而且经常受到非理性看待、过度解读，其实是有点不想公开结果的。
-   不擅言辞，不会交际。常有语出冒犯的时候。虽希望善良待人，但不会为人处事。([origin](http://web.archive.org/web/20210123202817/https://blog.yuuta.moe/about/))
-   我相信人与人之间的误解远多于分歧。
-   > 「没有人是怪物」「理解不等于赞同」  

    引自《〈和陌生人说话〉：越汹涌，越平静》，Vista 看天下 2021.12.18
    （其实应该是“越平静，越汹涌”；原标题如此）
-   高三的时候同学带了很多《Vista 看天下》到班上供大家借阅，就利用晚自习和考前“复习”看了很多；高中毕业后自己订阅了电子版的看天下，现在也一直在看，可以说是除了社交媒体外的主要信息来源。
-   幻想有一天用户为开源/[自由软件](https://www.gnu.org/philosophy/free-sw.html)付费能成为常态，就像观众为能免费看的直播打赏成为常态一样。现在越来越觉得这只能是个幻想，而且或许会有比用户不愿付费更大的阻碍。

---

-   GPG key: [\`863A0F9FA8127FA4\`](https://github.com/ouuan.gpg)

---

## 关于本博客

这是我继博客园、hexo-theme-next、hugo-theme-even 后的第四代博客。博客园和 Hexo 的文章已全部移至 Hugo 博客，但 Hugo 博客的文章（以 OI 相关内容为主）将不会移至本博客，可在 [原 Hugo 博客](https://ouuan.github.io/) 查看。

本博客由 ouuan 自己设计、制作，主要基于 [îles](https://github.com/ElMassimo/iles)（[Vue](https://vuejs.org/)、[Vite](https://vitejs.dev/)）和 [UnoCSS](https://github.com/unocss/unocss)。设计有在一定程度上借鉴 [hugo-theme-even](https://github.com/olOwOlo/hugo-theme-even)、[hexo-theme-next](https://github.com/next-theme/hexo-theme-next)、[Sukka's Blog](https://blog.skk.moe/)、GitHub 的 Markdown 显示，但大部分是原创设计，且借鉴部分的代码基本都是自己写的。

博客正文部分使用的字体是 [思源宋体](https://github.com/adobe-fonts/source-han-serif)，引用块部分使用的是 [<span class="font-kai">霞鹜文楷</span>](https://github.com/lxgw/LxgwWenKai)，二者均以 OFL 授权。web font 的划分、生成可以参考[《另一种很新的中文字体网页嵌入方案》](/post/2023/01/glyph-segregator)，可以在本地安装这两个字体来避免下载 web font。其他排版优化（包括标点挤压的实现）详见[《一些博客排版优化小 trick》](/post/2023/02/typography-tricks)。

代码高亮使用的是 [Shiki](https://github.com/shikijs/shiki/)，主题是 [Night Owl](https://github.com/sdras/night-owl-vscode-theme)（选了一个用的人较多，有暗色和亮色，配色整体偏蓝、和博客主题比较贴合的；我自己的 neovim 还是用的 [gruvbox](https://github.com/ellisonleao/gruvbox.nvim)）。[remark](https://github.com/remarkjs/remark) 插件和 Vue component 是自己写的，可以参考 [remarkShiki.ts](https://github.com/ouuan/iles-blog/blob/master/src/remark/remarkShiki.ts)、[CodeBlock.vue](https://github.com/ouuan/iles-blog/blob/master/src/components/CodeBlock.vue)、[CopyButton.vue](https://github.com/ouuan/iles-blog/blob/master/src/components/CopyButton.vue)（如果用的不是 iles 大概不能直接照抄）。

可以在遵循 [AGPL v3](https://github.com/ouuan/iles-blog/blob/master/LICENSE)（或其更新的版本）的条件下参考/使用 [本博客代码](https://github.com/ouuan/iles-blog) 的 **片段**，但请 **尽量不要** 直接在整个代码的基础上进行修改，因为并没有按照人人可以拿来用的模板进行设计，很多地方会硬编码一些东西，修改比较困难，如果我这里有更新要同步也很麻烦，也可能在某些系统环境无法正常构建之类的。如果真的直接使用，也需要遵循 [AGPL v3](https://github.com/ouuan/iles-blog/blob/master/LICENSE)，并且请务必小心，一切后果自负。

本博客使用 ouuan 自行搭建的 [Plausible Analytics](https://plausible.io/) 实例进行访问量统计，不使用 Cookies 且满足 GDPR 等条例要求。使用 [giscus](https://giscus.app/) 提供评论服务，发表评论需要登录 GitHub 帐号，除了发表评论也可以给文章点赞/点踩。网站托管于 [Cloudflare Pages](https://pages.cloudflare.com/)。

<Card type="info" fold title="RSS 订阅">

<Card type="question" fold title="什么是 RSS？">

-   [高效获取信息，你需要这份 RSS 入门指南 - 少数派](https://sspai.com/post/56391)
-   [我有特别的 RSS 使用技巧 | Hi, DIYgod](https://diygod.me/ohmyrss/)
-   [RSS - Wikipedia](https://en.wikipedia.org/wiki/RSS)

</Card>

-   一些 RSS 阅读器：
    <div class="inline-img mb-2">
    -   [![Follow on Inoreader](https://shields.ouuan.moe/static/v1?label=Inoreader&message=follow&style=social&logo=data:image/webp;base64,UklGRlICAABXRUJQVlA4IEYCAADwDQCdASpIAEgAPpFCmkolo6Ihp7gKGLASCWYA05nA/qumqeI8zavP3naz1m+oDbAc9Hpne9AL91aqgA91zGCWx8nzKx0FkaT+q4k67MyE2/hZym+6Qlfro/6nbI7vMhtFzlbdteFFMPzGJSH6DzATVS/YBx+Pv1gA/tYx/G8ZLrdlf+Ur43bsXBh+7KArqPth0CslagD4VKOmauUvNe1dhwxpfrDwqRKvSQEviUNf9AoDJ89/8dEHpu/J/vIsQVr8/SLJPEy8MGcw3ZV+gyLplT/tqzDYluRQ9IQKj9PPk/ExqxMI98/ACDXEYrdimUzsiz7qxRCKQ81JCgKiZTVeMiujTknatA6miOW2wTG1KSEoCa+6eyuzyo1puxJMM8ZbYt3aayIQAQ1DhjYxtMb/RD1SZZtmsBl9puxniEDqgnw2hIPekG5SatAlFeiJJw6A5B+dDCTeP+0Tir6PRDuQVXCzNBmtLFHXyBO/YYYsVq8ifCYlqn5bFEyJ4NHidwPWyf4NmVmquIwYbyxd/253wVwQQQig9oO9zHFMW8erqf9qk9N7V0yU5VOEHYGqmcWVB1cvOQuvja7SX3aoiGVMMsEelV0sH0USncQ7lx9aI6DTfLjQJyQ3Hl91g6JEcEjv4TCh0KewAnNpCM4PuEvn1kWgGusR2kcUUDZxn+pJLv8XJUbA2PkZ3O2e6eySmglzu8+ytxDe+TzGrAGF/SCcLth5IuX4eeBVDVjn0TqDEjOncMk0AIzNDD8Wdw/1aAAB4oAAAAA=)](https://www.inoreader.com/feed/https%3A%2F%2Fouuan.moe%2Ffeed.xml)
    -   [![Follow on Feedly](https://shields.ouuan.moe/static/v1?label=Feedly&message=follow&style=social&logo=data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTExLjU1LjY1MmEyLjE3NCAyLjE3NCAwIDAgMC0zLjEwNSAwTC42NCA4LjZhMi4yNzQgMi4yNzQgMCAwIDAgMCAzLjE2M2w1LjU3IDUuNjczYy4zODguMzQzLjg5NC41NTMgMS40NS41NTNoNC42NzdhMi4xOCAyLjE4IDAgMCAwIDEuNTYtLjY1OWw1LjQ2Mi01LjU2MmEyLjI3MiAyLjI3MiAwIDAgMCAwLTMuMTYzTDExLjU1MS42NTJ6bS0uMjE2IDE0LjUxOGwtLjc4Ljc5MmEuMzEuMzEgMCAwIDEtLjIyMy4wOTVoLS42NjdhLjMxMy4zMTMgMCAwIDEtLjIwNi0uMDhsLS43OTUtLjgwOGEuMzI1LjMyNSAwIDAgMSAwLS40NTJsMS4xMTQtMS4xMzRhLjMwOS4zMDkgMCAwIDEgLjQ0MyAwbDEuMTE0IDEuMTM1YS4zMjQuMzI0IDAgMCAxIDAgLjQ1MnptMC00Ljc1OWwtMy4xMTUgMy4xNzNhLjMxMi4zMTIgMCAwIDEtLjIyMy4wOTNINy4zM2EuMzEzLjMxMyAwIDAgMS0uMjA4LS4wNzhsLS43OTMtLjgwOGEuMzI2LjMyNiAwIDAgMSAwLS40NTNsMy40NDktMy41MTJhLjMxLjMxIDAgMCAxIC40NDMgMGwxLjExNCAxLjEzNWEuMzIyLjMyMiAwIDAgMSAwIC40NXptMC00Ljc1NmwtNS40NSA1LjU1YS4zMS4zMSAwIDAgMS0uMjI0LjA5NGgtLjY2N2EuMzExLjMxMSAwIDAgMS0uMjA3LS4wNzhsLS43OTQtLjgxYS4zMjMuMzIzIDAgMCAxIDAtLjQ1bDUuNzg1LTUuODkyYS4zMS4zMSAwIDAgMSAuNDQzIDBsMS4xMTQgMS4xMzRhLjMyNC4zMjQgMCAwIDEgMCAuNDUyeiIgZmlsbD0iIzJBQjE0QyIvPjwvc3ZnPg==)](https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fouuan.moe%2Ffeed.xml)
    -   [![Follow on follow.it](https://shields.ouuan.moe/static/v1?label=follow.it&message=follow&style=social&logo=data:image/webp;base64,UklGRtABAABXRUJQVlA4IMQBAAAQDgCdASpkAGQAPpFGnkqlpCMhp9aocLASCUASsGppds4Y7itw+9LtpfMBz//pVdQBvNb5erWMAKna+qj/c5jfNiyUrDFqi3eD6AyfUe6ISt9zmrlUv2UAjxTG+eKE7qwoJNK39PMAcA69EnBUL63cyqTxw+B6YhgAAP7E7/m0mB7/+fmfzv87bYAa20JIb/DcScQ/QlgNi1R1d5K3VmoCDeADr6/SZMY4nBAdm0CaZ2RpgiVkoynHcHSonLrL/PnqPiR3/roVeiudb9EaMEQ/p3uAQRL25vUE9YaeovyxgRWMK+sTdmazKTpHlERAxIvOpyWnv3md3AXnpxETXCkcXS5IqWNh/+qsybjBIt9SS8eaCh1cPh/I7u3oCgzciiwhUCke8PuElhuW7eM5tgCiULVgkIo2ewuVHLZcUBPd7XVNU7QfwXwFAWPx7EesLRyGgVZat672D6n79nFnjydEgAjPgFSGGgdZKy+a9DxKClQ6UtEep9nj5APCAaqS7lTJNx63XEWvY5/qQCSaRUPTHdgmpJVAEK/963VJXfgPGJzy5dDei7IkCP9WAA5IfaQ7jHVP4fUCd6v2Jj7x7kMWAAAAAA==)](https://follow.it/ouuan)
    -   [![Follow on Feeds Pub](https://shields.ouuan.moe/static/v1?label=Feeds%20Pub&message=follow&style=social&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEUAAABFCAYAAAAcjSspAAAACXBIWXMAAAInAAACJwG+ElQIAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAASkSURBVHgB7Ztdcts2EMf/oDyeNO5MnBOUN4hzAtNvrZ0H8QSimwPEPoHlE9g5gZkTSJ46mU77YPYEVd/6yN5AnWkzrVNxuxAhN3UA0YL46eA3Y30AkDT8c7FY7MKAw+FwlIfAAyAafe2rl/w8m8bhjxOsQedEiUbBNrAVeQLPCBTwJfiaYROiWRiH36ewYAMdIBfiUV+I3oDfBrKN5j3Ge7rDYy/4eQ8WtFoUOS08zxsQiSN+u73ap7EDS1opCosR8J0+4ZcBEWyZwpJWiRKN9tnsxRnUFFkHIjqFJa1wtNJneN7WCVvFEexgqyD+E1MBkWaUXcbhuxiWNC7Ky8sXrzKiIVbzGVO2hDeANwb+mMRhYj1VdDQmytw6xJcXvKz2V/hYwk73NA6vElRII6Io3zHCPNgqhK1CvGaLOC/bIkzU7mij0TccbwgZQxRNl9rFWFCrpby8PBhkhLhoHPsLFuP9sG4xFtQmioo9rguGcXgujqv2GUX0UAMyMmVBpA8xThllHYdx+MOvaJhafIqyEN/Qzb7DY+v4LkZLqFwUFYf4hm4Zb+yxIGtt9cumUp+ipo3RSliQ5xx5tkoQiYdK8QIYBcFxGwWRVCoKxyMnhi4Ozd+eo6VUJopKEfq6PqKbQ7SYCh3txs4iP3aHqRCbZ4fjA16eSS3RIp0/CkyyjH4BssQ2lVgGFYqS7Rj8uBQiyF/e9vvygf0MB3iyrYdvxwdxRrPTJsSpZPrkq47YxRqwjUW8cv0sN4+omdJFkXGJvBiUkD1jtlnc649KGLVQ2vTJ8yOPzzhQi1AuPN08mZGzzcqtTCmWIgURYuuaICJUAFvLADWydkS7EAT3LClwFPsT3wuOUbIU2OTUwI20BOl85WrEuRYM9J/782lnkkwq4XxvZ8h3/auL/tXY0D0+HO/v6qp+vc3HT7BG2WIV1po+vDJEFhl4P6/4mRDaC5/dfHiKmlhLlCVhvIw5ONtOqb73i0DXGo36UiyD1X1IURPWokgrgXn3+5r3NlHuPzQ/anCcPe8fk0NN60xNWouyxEr4At6pKSUS3QBepYK7U0jGIqr+oxmPBDViJYqKMn1dH+dYP9rsbUqHqrvD84rgf993m3fR+xoSb1AjVktyNDo44qXzTNM1uei/ff7/sfvnbFWvdN8jRG4ZBacKEv5OqyMVtlgtyewTdkmzAybKNHc045ikpxWFxRiiAKJZ7WkGq+lDt1v+u/Q+yaTJXW5e1LL4nXl2rjO7ZFMi+m/DCrEx5IcUq/zCvGbcTHbOUhTh61pNB/DicMxZ+5n0CynuQW4hV0M0xMqiqABLx9I4Ip9Gsz1ejsdLhiV5hr/Z/K2Fo/1r21BYLAyulH8Io9GLgB2wLLQ/ExzWZ5T9Js+aNF0uXdDI8S518Qlaio1P8Q3tKR4IFRfDuokTRYONKKmh3ccDwVmKBieKBieKBgtRHpmCtKLTjp1hZVHkPsbQ9fmK8jlgK4rWWpaXLrqDbT5FK4oqWHUeN300OFE0OFE02KYjU13r7Ob973gA2GXziY5xZwXKE83N/NdF2VifT8mPXHlHXAN6knEFry2pRIfD4XA4usm//qauBcoh1b8AAAAASUVORK5CYII=)](https://feeds.pub/feed/https%3A%2F%2Fouuan.moe%2Ffeed.xml)
    </div>
-   最新文章: [RSS 订阅](https://ouuan.moe/feed.xml) / [Atom 订阅](https://ouuan.moe/feed.atom) / [JSON 订阅](https://ouuan.moe/feed.json)
-   某个 tag 的最新文章: 在 tag URL 的后面加上 \`/feed.xml\`/\`.atom\`/\`.json\`，例如 [csapp 标签的 RSS 订阅](https://ouuan.moe/tag/csapp/feed.xml)

Tips: 可以使用 [RSSHub Radar](https://github.com/DIYgod/RSSHub-Radar) 等插件自动发现这些订阅。

</Card>

## 关于我在一些其他地方的 profile

> 如果奇迹有颜色的话，那么其中之一必是<span class="text-honoka">橙色</span>的吧。

这是 [我在 b 站上](https://space.bilibili.com/11067182) 的个性签名，应该是 16 或 17 年就开始在用了。[出自 Snow Halation](https://zh.moegirl.org.cn/如果奇迹有颜色，那一定是橙色) 但把“那”改成了“其中之一”。
[在洛谷上](https://www.luogu.com.cn/user/49742)，因为当时洛谷换了新 UI 后个人空间和 b 站长得有点像，我就特意用头图和个性签名模仿了 b 站个人空间。

> この道行きの最後が 天国か そこらじゃあないとしても  
> 这条路的尽头会是天国吗 就算不是也没有关系
>
> ただの君と笑って立っていたいよ  
> 单纯的想和你相视而笑并肩而立
>
> 誇らしさとか 願いとか 希望とか  
> 我的骄傲 愿望 希望
>
> もっと ずっと 持ち合わせとくよ  
> 愿能永久地伴我同行

这是 [3 狮 OP2](https://music.163.com/#/song?id=456185218) 的一段歌词，我把它设为了一些地方的个人空间头图。

> 生き方は 無限にある。  
> 生活的方法有无限种。

这是 [No.1](https://music.163.com/#/song?id=1416874718) 的一句歌词，是我现在的 QQ 个性签名。
`},{title:c,tags:"btrfs Arch Linux 问题解决记录",content:`记录一下之前困扰我近一年的 [Btrfs](https://wiki.archlinux.org/title/Btrfs) 快照导致的系统无响应问题。



## 系统无响应的具体表现

每次整点时有概率出现，在一分钟左右的时间内，和磁盘写入相关的操作都会卡死，例如直接和文件操作相关的保存文件，或者会写入 \`~/.zsh_history\` 的在终端输入命令，以及打开新的 GUI 应用等等，基本上就是整个系统完全卡死。

另外，我有观察到，在笔记本不使用外接电源时这一问题表现地更为严重，即更容易被察觉到、每次卡住的时间更长。

## 最初解决问题的尝试

遇到问题后不久，我就怀疑上了一些每小时自动运行的任务，包括 [Timeshift](https://github.com/linuxmint/timeshift) 的快照以及一些自己写的 crontab。

最值得怀疑的就是 Timeshift 的快照了，然而，当时我曾经尝试过暂时关闭自动快照，但问题似乎没有得到解决，具体原因已不可考了。当时我还在一个群里提出了这个猜想，然后群友说快照是原子级操作，不应该卡住，我感觉很有道理，就在很长时间内没有怀疑自动快照的问题了。

后来我又尝试着关闭各种 crontab，当然也没有解决问题。

有想过在整点时用 \`htop\` 查看进程信息，但由于卡住时运行不了命令（当然可以关闭终端的历史记录，但关了也不见得不卡，而且我懒啊x），需要提前打开 \`htop\`，而且也不是每小时都会遇到这个问题，看到了进程信息也不一定能找到问题所在，最后也没有成功。

当时自然也尝试过各种搜索，至于为什么没有搜索到或者注意到 [Freeze issues with BTRFS and Timeshift](https://forum.manjaro.org/t/freeze-issues-with-btrfs-and-timeshift/22005) 也不可考了，可能是搜索关键词不对吧，毕竟当时我一定程度上排除了对快照的怀疑。

由于问题的严重程度和是否外接电源有关，我甚至一度怀疑过是硬件问题，想换电脑（

## 最终问题的解决

在被这一问题困扰了大半年后，我又忍不住想搜索解决方法，这一次很快就搜到了 [Freeze issues with BTRFS and Timeshift](https://forum.manjaro.org/t/freeze-issues-with-btrfs-and-timeshift/22005)，然后按里面说的禁用了 quota: \`sudo btrfs quota disable /\`。

但过了几天，我发现问题又出现了，以为这个方法不管用。

后来又过了一段时间，我又忍不了了，再仔细阅读了一下，发现这个 thread 里有提到 Timeshift 会自动打开 quota，要修改 Timeshift 的设置才行。至此，问题解决。

<Card title="关于 Brtfs Quota">

[Btrfs quota](https://wiki.archlinux.org/title/Btrfs#Quota) 主要用于快速查看每个 subvolume 的磁盘用量（可以用 [btrfs-du](https://github.com/nachoparker/btrfs-du) 查看），如果没有启用的话，每次查看就需要几十秒的时间来重新扫描。

但是，这一功能有很多 [已知问题](https://btrfs.wiki.kernel.org/index.php/Quota_support#Known_issues)（当然也包括本文描述的这个），所以目前不建议启用。

</Card>

## 后记: Timeshift 已修复此问题

实际上，Timeshift 已在我自己解决问题前不久就修复了这一问题: [Fix #865, #839, #680: Do not create or remove Qgroups when snapshots are created or removed](https://github.com/linuxmint/timeshift/commit/8d77b18fe7b725c11baefe721633561d755b3630)

虽然 [Timeshift 在 5 月 29 日就发布了修复](https://github.com/linuxmint/timeshift/releases/tag/v22.06.1)，但是 [archlinuxcn 在 7 月 1 日才更新](https://github.com/archlinuxcn/repo/commits/master/archlinuxcn/timeshift)，于是我“有幸”在 Timeshift 更新的前一天自己解决了问题 🙃...

![消息记录，发于 6 月 30 日: 前段时间听说关 quota 可以解决这个问题，但关了之后还是经常卡。今天才发现 timeshift 里设置了开 quota，得把 timeshift 的自动开 quota 关了才行 🌚 需要观察几天是否还会整点卡](btrfs-quota-timeshift-message-screenshot.png)

其实我还是写这篇博客的时候想看一眼 Timeshift 的 quota 设置发现没有这个设置项了才知道 Timeshift 已经修了...
`},{title:l,tags:"CSS Web 问题解决记录",content:`同时使用 \`display: none\` 和 \`loading="lazy"\` 可能会让内容永远加载不出来。

<p class="dark:hidden">![截图：评论加载中](comments-loading-light.png)</p>
<p class="hidden dark:block">![截图：评论加载中](comments-loading-dark.png)</p>



## 问题背景

虽然 [giscus](https://giscus.app/) 自带一个加载页面，但首先这个加载页面自身就有可能加载很久才显示，而且这个自带的加载页面没有任何有效信息，所以我自己写了一个加载页面，附上了 Discussions 链接。

我使用的是 giscus 的 [giscus-to-parent \`message\` events](https://github.com/giscus/giscus/blob/main/ADVANCED-USAGE.md#giscus-to-parent-message-events) 功能来检测 giscus 已加载，而这和 giscus 显示在页面上有一定的时间间隔，所以在检测到加载好之前需要先把 giscus 隐藏起来。因为是用的 Vue，很自然地就是用 \`v-show\` 让 giscus 加载好再显示。

除此之外，本着“不用白不用”的精神，我还启用了 giscus 的 lazy load（本质上是 \`<iframe>\` 的 \`loading="lazy"\`）。

并且，我使用的是 Firefox，上述配置在 Firefox 上是没有问题的。

## 问题的发现与解决

一位群友告诉我评论加载不出来，于是我试了一下各个浏览器，在第二次（为什么是第二次呢，不懂）试 Chrome 的时候发现没加载出来。

console 没有任何报错；查看 DOM，发现 \`<iframe>\` 里面是空的，幸好我还记得自己用了 lazy load，所以很快就明白了问题所在：Chrome 比较“聪明”，看到 \`display: none;\` 就懒了，没加载这个 \`<iframe>\`。

把 \`v-show\` 换成 \`opacity-0 absolute\` 就解决了问题。

但最后还有点小插曲，因为这个 \`opacity-0\` 在 SSR 的时候是没有的，没被 [UnoCSS](https://github.com/unocss/unocss) 扫描到，就挂了，最后换成了 inline style。

## 后记

这件事告诉我们，~~有好的群友~~在不同浏览器上多测试几遍是非常重要的。

~~这点事值得发博客吗；当然是博客太空了随便水一篇~~

P.S. 虽然问题的解决很简单，但还是浅搜了一下看看有没有什么 best practice。倒是没搜到什么有用的，但是搜到[一个有趣的](https://developers.weixin.qq.com/community/develop/doc/0006ec11c48ec072b6e7b79975b000)（

![论坛截图：麻烦提供下代码片段。你们已经是成熟的开发团队了，要学会自己复现bug。](reproduce-yourself.png)

## 再后记

发现加载中的 \`<iframe>\` 虽然看不见但点的到..需要加一个 \`z-index: -1\`。

## 再后记的后记

这个东西虽然怎么都看不见了，但宽度会让整个页面出现水平滚动条，所以要加 \`width: 0; height: 0;\`。
`},{title:m,tags:"选课 THU 经验分享",content:`还记得刚入学的时候，我一开始完全没弄明白要怎么选课，当时就想着弄明白了要写一篇选课指南。

后来，我弄明白之后发现不记得自己以前为什么不明白了，写不出来了（

再后来，我发现一些身边的同学到了选大二的课的时候还没弄明白选课流程（

所以，虽然选课指南是写不出来了，姑且是列举一些常见问题与注意事项，供参考。



因为选课相关问题错综复杂，下面的内容按顺序阅读可能会有困难，因为有后文才介绍的概念前文已经出现的情况。（这也是为什么我说这篇不是“指南”而是“常见问题与注意事项”（

<Card type="warn">

本文内容仅供参考，可能因为规则具有时效性、不同院系之间存在差别、笔者的认识错误或笔误而与实际选课不符，还请以实际的选课规则为准，必要时向老师或辅导员咨询。

</Card>

当然如果发现了什么错误可以评论区告诉我。

## 选课入口 —— 在哪选课啊，我找不到

[中文选课入口](https://zhjwxk.cic.tsinghua.edu.cn/xklogin.do)

反正我是每次在地址栏输入 \`xk\`，然后匹配到的第一个历史记录就是选课入口。

除此之外，还可以在 [academic](https://academic.tsinghua.edu.cn) 登录后点击 [“进入本科生选课”](https://zhjw.cic.tsinghua.edu.cn/xkBks.vxkBksXkbBs.do?m=main) 进入。

如果是在校外，就要用 VPN 访问，一般使用 [webvpn](https://webvpn.tsinghua.edu.cn/)，登录进去后就会有选课入口的链接。

在抢课刚开始等热门时段，选课系统一般会非常卡，据说使用 [英文选课系统](https://zhjwxkyw.cic.tsinghua.edu.cn/xklogin.do) 会不卡一些，但不确定是不是真的。

## 选课流程 —— 什么是预选、正选、补退选？什么是抽签、抢课？

### 选课流程

#### 新生选课流程

刚入学时的第一次选课与后面的选课是有一定差异的，如果不意识到这一点，看到一个对正常选课流程的描述，发现和新生选课不同，就可能被搞晕。

新生选课主要有这些特点：

-   没有正选环节
-   不分一二三志愿
-   老生已在上学期末完成了预选和正选，而新生在入学时才会进行预选
-   一些课程会在老生选课时给新生预留部分课容量（若新生没选满，老生可以在补退选时再抢课）

#### 正常选课流程

在选课系统点击“选课时间安排”就能看到当前学期的完整选课时间安排。

一般来说，选课的主体流程为: 预选 → 正选 → 补退选第一阶段 → 补退选第二阶段 & 特殊原因补选

除此之外，还会有二级选课、重修体育课分项等特殊类型选课，以及记 P/F 和退课。

<Card type="warn" title="记得选课！">

~~你在说啥？我怎么会忘记选课，不会有通知吗~~

可能会和你想象中不同，选课经常是没有通知的，或者，更准确地说，你不一定关注了发布通知的渠道，以及通知可能发布得比选课时间早很多，等到选课时你可能已经忘了。

运气好时，你可能会收到通知，或者看到群里有同学在讨论选课相关的话题。但是，如果你运气不太好，或者是你遇到的是 **二级选课、补退选、记 P/F、退课** 等并非人人关注的选课环节，可能真的没有任何人会来通知你。所以，一定要在选课期间关注选课时间安排，不要错过选课。

</Card>

#### 夏季学期（小学期）选课流程

夏季学期没有预选也没有补退选，也就是不抽签直接抢课。具体差别请在夏季学期选课时查看选课系统中的“选课时间安排”。

### 选课环节

#### 预选

所谓的“抽签” ~~“赌场”~~ 指的就是预选了。

对于每个课，若选课人数超过课容量，就会在预选结束后进行抽签，在选了这个课的人里随机抽取课容量这么多的人，他们就选上这门课了，而其他人则按随机顺序加入 Waiting List。

但是，这里的“随机”不是完全的随机，而是有优先级的 —— 先看课程属性，再看志愿优先级。课程属性分为必修、限选、任选，除新生选课外志愿分为一二三三档，满足特殊条件的话还可以在任选课中拿到“优先志愿”，总的排序就是: 必修一志愿 > 必修二志愿 > 必修三志愿 > 限选一志愿 > 限选二志愿 > 限选三志愿 > 任选优先志愿 > 任选一志愿 > 任选二志愿 > 任选三志愿。

抽签时，会先依次让每个优先级的所有人选上课，如果一个优先级的人数大于当前课余量，就会在这一优先级内随机抽取课余量这么多人选上课，而没有抽到的人以及更低优先级的人则会落选，并按优先级顺序加入 Waiting List。也可以理解为以优先级为第一关键字、随机数为第二关键字进行排序，然后取前课容量这么多的人选上课，余下的人按原序加入 Waiting List。

<Card title="Waiting List 顺序与志愿优先级">
有一个流传甚广的传言，是 Waiting List 顺序与志愿优先级无关。这个传言能流传开来，大概是因为实际抽到的 WL 位置不能 100% 证伪这个传言，而每学期又只有最多那么几门课会进入 WL，也很难收集足够多的数据以在大概率上证伪。而一旦把中午 12:00 的志愿当作最终志愿，把有人退出队列后的队列位置当作抽到的队列位置，或者是怎么算错了，就可能误以为“证实”了这个传言。

实际上 [本科生选课系统Waiting List方案介绍](https://announce.cic.tsinghua.edu.cn/node/26766) 就明确说了：

> 未中签的学生，系统根据抽签级别顺序进入该课程的WL中候选。同一级别的学生随机排序。

但大家看起来都没有看到这个方案介绍，都靠口口相传来了解选课规则（
</Card>

一二三志愿是选课者自行选择的，**每个课程属性**都可以选择至多 1 门一志愿、至多 2 门二志愿、任意门三志愿，而不同课程属性的志愿之间互不影响，也就是说必修一志愿和任选一志愿可以各有一个。优先志愿一般是给相关院系/专业的学生，需要满足的条件会写在“选课文字说明”中，例如，课程“计算机科学基础”的选课文字说明为“优先:计算机类、信息与计算科学专业学生选课”。

在预选期间，可以多次修改所选的课程或志愿等级，也可以在 选课查询 → 志愿填报情况查询 中查到所有课的志愿填报情况。但是，这个志愿填报情况并非实时更新，而是只会在每天 8、12、16、20 点更新，且预选阶段的最后一次更新会在预选结束前四小时左右，所以，你查到的志愿填报情况可能和最终的真实情况差别极大。如何选择填报志愿的时机、如何根据情报调整自己的志愿等级、教师乃至课程选择，都是一场惊心动魄的博弈 ~~，这也是预选被称作“赌场”的重要原因之一~~。（博弈有风险，推荐同学们尽早填报真实志愿，瞒报志愿可能害人害己。）

抽签结果一般在预选结束后好几天才会公布（可能是要安排教室、必要时调整课容量之类的）。

在抽签完成后，可以在选课系统的课表查询中查看抽签情况，选上的课会和预选时一样是 <span style="color:#855512;">棕色</span> 的，而掉了的课则会显示为“候选”并且是 <span style="color:#6684A5;">蓝色</span> 的。

#### 正选、补退选、Waiting List

所谓的“抢课”主要指的就是正选，以及补退选。

这两者在选课操作上基本上是一样的，最大的区别就是正选在上学期末、预选结束后不久进行，而补退选在新学期开始上课后进行，新生选课则没有正选环节。

在这一环节中，选课不再以抽签进行，而是先到先得。

在这一阶段中，除了选课，还可以退选。这里就涉及到了 *Waiting List* 的概念。顾名思义，Waiting List（简称 WL）就是排队等待课程坑位空出来，而空出坑位一般就是有人退选了（也可能是课程扩容了）。当出现新的课余量时，排在 WL 最前端的人就会递补选上这门课。可以选择退出 WL，这也可以看作是退选的一种。

特别地，补退选分为两个阶段，分别位于上课第一周和上课第二周，在第二阶段中只能退选不能补选。

<Card title="退出 WL">

想选的课只要苦苦等待就可能有机会选上，为什么要退出呢？主要有两个原因：

1.  同一个课程号的课只能选一个。例如，你选了 A 老师的数学分析，不幸进入 WL，只有退出 WL 才能再选 B 老师的数学分析。

2.  WL 中的课程不受学分限制，但递补时受学分限制。例如，你已经选择了 24 学分的课程，学分限制为 26，你还有两门 2 学分的课程 A 和 B 在 WL 中，你比起 B 更想选上 A，并且两门课都排在 WL 前端，有希望成功递补。第二天早上，你起来一看，两门课都递补了，但 B 先递补上，占满了学分限制，所以后递补的 A 就直接退出了 WL，如果想选就得再排在 WL 尾部了。

    除了删除不必要的 WL，若学分可能受限而递补希望大，也可以考虑删除已经选上的课来为 WL 中的课留出学分。

如何退出 WL 也是困扰很多同学的一大难题（~~选课系统的 UI 是谁设计的~~）。在 选课查询 → 队列系统查询 里是只能查询队列信息不能退出队列的，要在 选课操作 → 一级选课 → 队列信息 里退出。（知道在哪退 WL 可能让你在新生第一次补退选中抢占先机（~~也可能不止新生那一次，直到选大二的课的时候我室友还在问我怎么退 WL~~

</Card>

#### 二级选课

二级选课也是先到先得，一般是用来做实验之类的，在课程信息中会标明一个课是否有二级选课，但选课前不一定会告诉你有哪些时间段可以选，所以可能需要预留出一些时间给二级课，不能选太满或者太分散以至于没有大段的空余时间（依具体课程而定，可以考虑咨询学长学姐）。

数学课的习题课也可能会被标注成有二级选课，但我目前上过的数学课都不会真的进行二级选课，而是会和同学们一起协商出习题课的时间。

#### 特殊原因补选（手选）

特殊原因补选，也称手选（手动选课），是一种无视其余选课规则的存在（不受课程容量、院系专业限制、甚至上课时间冲突等条件制约），只要任课教师和开课院系同意（~~这是可以“只要”的吗~~ 如果课容量满了，可能需要说明具体原因，但如果只是受到专业限制之类的而课容量没满，还是很可能申请通过的），就能选上课。申请流程详见 [网上特殊原因补选课申请系统操作说明（学生篇）.docx](https://jwcbg.cic.tsinghua.edu.cn/download.jsp?attachSeq=2962)

由于手选一般安排在开学后第二周，最好是通过提前和老师发邮件等方式确定能否手选上，也可以一并了解上课地点以及发布给选上课的同学的相关通知。

#### 记 P/F

记 P/F 即成绩以 P(ass) 或 F(ailure) 记录，不记录具体等级，只要过了就都一样。记 P/F 的课不会有绩点，也不会计入 GPA。

一般情况下，只有任选课可以记 P/F，必修和限选课不能记，并且每学期最多只能选择一门课记 P/F。实际操作中，如果想记 P/F 的课完全是自己感兴趣而选的、不在培养方案中，应该就可以放心记 P/F；而如果在培养方案中的话，最好咨询一下（教务）老师或者辅导员，以免对培养方案的完成或者保研等造成影响。

除了在记 P/F 阶段在选课系统中主动记 P/F，有的课程（一般是通识课、选修课）会自带 P/F，即无需手动选择就以 P/F 记录成绩，这样的 P/F 不会占用每学期一门课的名额，也不会对培养方案的完成造成影响。有的课程会在课程介绍中说明是否自带 P/F，而有的课就需要咨询学长学姐或者等开课后才知道了。

#### 退课

每学期会有两次退课阶段，一般安排在期中附近以及期中后一个月左右。在退课阶段退课，除非退掉的是还没开课的课程（一般是在第一次退课时退掉后八周开课的课程），会在成绩单上记一个 “W”（W ~~onderful~~ ithdrew）。这个 “W” 貌似不会有什么实际的影响，但总之会显示在你的成绩单上。

大家一般会因为对课程不感兴趣、对自己前半学期的学习情况不满意、对期中考试的成绩不满意等原因而选择退课。退课是一件需要慎重考虑的事，如果退掉的是比较重要的课，就要考虑到重修带来的各方面的影响。

<Card title="我到底是在退课，退课，还是退课 😵 —— 删课 vs 退选 vs 退课">

在预选、正选/补退选、退课三个不同的阶段，都有类似“退课”的操作。其实我也不知道这三个阶段中的“退课”分别应当叫做什么，而在实际交谈中，同学们可能会把这三种“退课”混为一谈。

在预选阶段，删除一门课是不会有任何负面影响的，选一门课再删掉和从来没选过完全一样，删掉再选和不删也完全一样（当然，你会需要多操作两次，而且别人看到的志愿填报情况可能会不一样）。

在正选/补退选阶段，如果退选一门课，空出来的位置就随时可能被他人抢走，但成绩单上不会有 “W”。

在退课阶段退课，就是真正的退课了，没有再选课的机会，并且成绩单上也会有一个 “W”。

</Card>

## 课程信息与选课操作 —— 怎么找不到要选的课？怎么知道课在哪上呢？

### 切换学期

选课系统的左上角会有一个学期，选课前需要先确认没有选错学期。

### 查看课程信息

在选课系统的 开课信息 → 一级课开课信息 中可以找到当前学期所有课程的信息，可以在这搜索你想上的通识选修课有没有开课，查看课程简介、上课时间、选课要求，查看教师信息（包括邮箱）。

### 选课操作与课程属性

在 选课操作 → 一级选课 中，首先看到的会是当前学期的必修课。如果在必修课和限选课（以及体育课）中都没有看到想报的课，就要在任选课中手动搜索。

~~这不是废话吗~~ 但是，这里的课程属性可能和你想像中不一样，因为同一个课程在不同地方会有不同的属性：

-   在培养方案中会有课程属性，你认为的课程该有的属性很可能就是培养方案中的课程属性。
-   选课系统中的课程属性取决于当前学期的指导性教学计划，所以下学期的必修课很可能是当前学期的任选课。特别地，外语课总是任选课，大约是因为教学计划中虽然有外语课的位置，但每人要上的外语课具体是哪一门是不一样的。
-   info 上的成绩单以及培养方案完成情况中会另有一套课程属性，大致是限选课变成了必修，任选课变成了限选。

需要注意的是，决定志愿优先级的课程属性也是由教学计划决定的，这也是鼓励大家按教学计划选择必修课，如果错过了必修课在教学计划的学期，之后的志愿等级可能就是任选了。

### 教室位置查看

教室的位置在预选时是尚未安排好的，要在预选结果出来后才能在课表等位置看到教室在哪。

在 [courseX](https://tsinghua.app/courses) 上可以看到他人分享的教室位置信息，但不一定全。这些信息主要是 [learnX](https://tsinghua.app/learn) 在用户主动同意后自动收集的，learnX 是对 [网络学堂](https://learn.tsinghua.edu.cn) 非常好的补充，推荐使用，也希望大家能在设置中开启课程信息共享。

### 关于上课时间

上课时间一般会以大节编号和周数的形式呈现，例如 \`1-1(全周),3-4(全周)\` 表示每周一第一大节和每周三第四大节上课，\`4-6(前八周)\` 表示前八周周四第六大节上课。

每大节的具体时间可以在课表中查看。一大节一般是两小节课各 45min 中间有 5min 休息，但第二大节和第六大节都有三小节，有的课会上满三小节，而有的课会只上两小节，而这一般可以通过课程的学分看出来，每一学分对应全周的一小节课，也就是八周的两小节课。如果一个 4 学分的课在全周的一个第二大节和一个第三大节上，那很有可能就是第二大节只上两小节。特别地，思想道德与法治、中国近现代史纲要、马克思主义基本原理等课程会比学时对应的学分多一分，这三节课分别是 3、3、4 学分，但分别对应全周上 2、2、3 小节。

## 体育课 —— 为什么 26 分的限制 TA 可以报 28 分还不用申请特批学分？

体育课在选课中有一些特殊之处：

1.  体育课是不占用学分限制的
2.  体育课在选课时具有单独的课程属性，算在必限任之外（这也是有人找不到或者忘记报体育课的一大原因）
3.  体育课虽然只能上一门，但预选时可以报很多门，等级高的志愿优先选上，等级低的志愿就会自动取消
4.  如果体育课挂科了，重修选课时会有特殊的流程，详见“选课时间安排”

正因为前三点，可以多报几门体育课，提高选上想上的课的概率，既不会占用学分限制也不会浪费一二志愿。
`},{title:d,tags:"caddy-security uptime-kuma caddy server 问题解决记录",content:`[Caddy Security](https://authp.github.io/) 不仅会将未经认证的访问者拒之门外，也会拦住 [~~可爱的 kuma 酱~~ Uptime Kuma](https://uptime.kuma.pet/)。这里会分享一下我的一个放过 kuma 的小技巧。



~~（P.S. 这是不是应该算“经验分享”而不是“问题解决记录”，这两个 tag 的分界线到底在哪呢）~~

## 问题描述

[Caddy Security](https://authp.github.io/) 可以为 [Caddy](https://caddyserver.com/) 上的路由提供身份认证，而这一认证发生在连接到服务之前，所以如果不通过认证就无法通过网络访问来获知服务是否正常运行，进而影响到 [Uptime Kuma](https://uptime.kuma.pet/) 的运作。

## 初步解决方案，以及存在的问题

一个自然的想法是，可以关闭一些非敏感路由的身份认证，用于 uptime 监控。比如说，一个服务的首页可能是非敏感可以公开的，敏感信息都位于其它路由，则可以：

\`\`\`caddyfile
example.com {
    handle / {
        reverse_proxy localhost:2333
    }
    authenticate with some-auth-policy
    reverse_proxy localhost:2333
}
\`\`\`

这看起来很好，但问题在于，一个网页往往不只是这个路径本身，还有 js、css 等资源需要使用。Caddy Security 只会在访问需要认证的网页时进行认证，而不会在加载需要认证的资源时进行认证。如果访问一个无需认证的网页，但其使用的资源需要认证，这些资源就可能加载不出来。

将这些资源全部列出来会很麻烦，如果处理不当也有泄露敏感信息的风险。

## 解决方案: 给 kuma 一个单独的路由

上面的方案的问题只对人类访问者有影响，而解决了 kuma 的问题。所以可以使用同样的思路，但只影响 kuma 而不影响访问者：

\`\`\`caddyfile
example.com {
    handle /for_uptime_kuma {
        uri replace /for_uptime_kuma /
        reverse_proxy localhost:2333
    }
    authenticate with some-auth-policy
    reverse_proxy localhost:2333
}
\`\`\`

然后在 Uptime Kuma 中把监控网址设成 \`https://example.com/for_uptime_kuma\` 即可。

如果在多个路由都用到这个操作，每次重复会比较繁琐，可以使用 [Caddy 的 snippet 功能](https://caddyserver.com/docs/caddyfile/concepts#snippets)：

\`\`\`caddyfile
(kuma) {
    handle /for_uptime_kuma {
        uri replace /for_uptime_kuma {args.1}
        reverse_proxy localhost:{args.0}
    }
}

homepage-public.example.com {
    import kuma 2333 /
    authenticate with some-auth-policy
    reverse_proxy localhost:2333
}

public-public.example.com {
    import kuma 6666 /public
    authenticate with some-auth-policy
    reverse_proxy localhost:6666
}
\`\`\`

## 另一种解决方案: 使用非网页资源进行监控

既然遇到的问题是网页会需要资源，只放开网页的认证会加载不出资源，另一个思路就是监控资源而非网页（不一定是 js、css 这些，也可以是可以公开的 API，或者几乎不会被访问或访问时一定已经认证了的网页之类的）。这比较简单，就不多讲了。
`},{title:p,tags:"busuanzi live2d JavaScript Web 问题解决记录",content:`昨天在一位网友的 Hexo 博客遇到了很诡异的 busuanzi 访问量统计不显示问题，经过一番研究发现是 busuanzi 代码的一处问题和 live2d 插件的一处问题凑在一起导致的。

今天在写博客之前先搜了一下 “busuanzi live2d”，发现搜出来一堆结果，我还以为我白研究了..结果点进去一看，第一页结果里没有一个指出了问题的根本原因，而且修复方法基本上都是删 feature 或者换组件，但实际上只要知道问题的根本原因就可以在不妨碍正常功能运作的前提下进行修复。所以昨天晚上没白忙活，我这篇博客还是要写的。



当然，我只看了第一页搜索结果，可能有更深入研究的文章被搜索引擎埋没了，我这篇文章说不定也不会被搜到，只不过既然第一页没有，就让我也来成为被搜索引擎埋没的一员，这样的话说不定被搜到的可能性就增加了（

## 问题描述

在一个同时启用了 busuanzi 访问量统计和 live2d 插件的 Hexo 博客里，访问或刷新博客时有大概率 busuanzi 会被隐藏。

被隐藏的具体表现为，刷新的瞬间 id 为 \`busuanzi_container_*\` 的容器是显示的，然后容器的样式很快被设为 \`display: none\`。

查看 F12 的 Network，busuanzi 相关请求正常返回；console 中没有报错。

## 问题定位

注：这个过程中我也走了一些弯路，就不写出来了。

### 设置 \`display: none\` 的定位

查看 [busuanzi.pure.mini.js](https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js)，发现 \`display: none\` 在 \`hides\` 函数中被设置：

\`\`\`javascript
hides: function() {
  this.bszs.map(function(a) {
    var b = document.getElementById("busuanzi_container_" + a);
    b && (b.style.display = "none")
  })
},
\`\`\`

而 hides 函数仅在一处被调用：

\`\`\`javascript
try {
  a(b), scriptTag.parentElement.removeChild(scriptTag)
} catch (c) {
  bszTag.hides()
}
\`\`\`

所以是在 \`a(b), scriptTag.parentElement.removeChild(scriptTag)\` 抛出异常时容器被隐藏。

### 异常原因的定位

由于在其它地方的 busuanzi 不会出现这一问题，而问题的原因还完全不清楚，为了尽可能还原原始环境以复现问题，我选择了使用 [Firefox 的 Header Editor 插件](https://addons.mozilla.org/zh-CN/firefox/addon/header-editor/) 直接在原博客进行测试。具体来说，就是在本地复制一份 busuanzi 的代码，然后跑一个 http server，在 Header Editor 里把 busuanzi 代码的请求重定向到本地的 http server。

首先，在 \`catch\` 中添加 \`console.error(c)\`，得到错误内容 \`TypeError: scriptTag.parentElement is null\`。

查看代码中 \`scriptTag\` 相关的部分：

\`\`\`javascript
scriptTag = document.createElement("SCRIPT"), scriptTag.type = "text/javascript", scriptTag.defer = !0, scriptTag.src = a, scriptTag.referrerPolicy = "no-referrer-when-downgrade", document.getElementsByTagName("HEAD")[0].appendChild(scriptTag)
\`\`\`

所以，再在 \`catch\` 中添加 \`s = document.querySelector("[src*=BusuanziCallback]"); console.log(s.parentElement);\`，发现 \`s.parentElement\` 不是 \`null\`。

再添加 \`console.log(s === scriptTag)\`，发现结果是 \`s\` 和 \`scriptTag\` 不同，所以原因在于此时的 \`scriptTag\` 变量已经不指向 DOM 中的这个元素了。

### 定位到 live2d 插件

此时我原本是没有任何头绪的，但我发现，并不是每次刷新页面都会触发这一问题，所以没有触发问题时和触发问题时的差别就成了问题的突破口。

经过多次刷新，我发现，有一串 console 输出，在出现问题时总位于我在 \`catch\` 中添加的调试信息之前，而在没出现问题时则位于调试信息之后：

\`\`\`
Live2D 2.1.00_1 live2d.core.js:5925:16
profile : Desktop live2d.core.js:5913:16
  [PROFILE_NAME] = Desktop live2d.core.js:5918:20
  [USE_ADJUST_TRANSLATION] = false live2d.core.js:5918:20
  [USE_CACHED_POLYGON_IMAGE] = false live2d.core.js:5918:20
  [EXPAND_W] = 2
\`\`\`

多亏了 live2d 的这串输出，我得以将问题定位到 live2d 插件上。

实际上，如果没有这些 console 输出，也可以通过 \`<head>\` 中 \`L2Dwidget.0.min.js\` 和 \`busuanzi?jsonpCallback=BusuanziCallback\` 两个 \`<script>\` 的相对位置发现问题，只不过这样的话就更隐蔽更难发现了。

### 在 live2d 插件中定位问题

在 \`L2Dwidget.min.js\` 的第一行有源码地址以及时间：\`/*! https://github.com/xiazeyu/live2d-widget.js built@2019-4-6 09:38:17 */\`

因为注释中给出的时间不是最新版本，先查看 git log 并 checkout 到相应时间的版本。

既然问题在于 \`<script>\` 元素被重新创建而导致原变量不指向 DOM 中元素，就在代码中 grep \`head\`，然后发现 [问题代码](https://github.com/xiazeyu/live2d-widget.js/blob/fa8f2d831a1a9e96cd85bd1ef593a3336aeac720/src/dialog/index.js#L4-L38)：\`document.head.innerHTML += ……\`

至此，问题原因已发现，就是 live2d 插件通过修改 \`document.head.innerHTML\` 来添加样式，导致 busuanzi 的 \`scriptTag\` 变量指向的不再是 DOM 中的 \`<script>\` 元素。

实际上，live2d 插件的这一问题 [已经修复](https://github.com/xiazeyu/live2d-widget.js/pull/61)，但需要使用新版才行。

## 解决方法

### 修改 busuanzi 的解决方法

因为 busuanzi 的代码较短，而且本来就是用的外部的代码，改起来比较容易。

把 \`scriptTag.parentElement.removeChild(scriptTag)\` 修改为 \`s=document.querySelector('[src*=BusuanziCallback]'),s.parentElement.removeChild(s)\` 即可。可以把修改后的静态文件放在博客里，然后修改 busuanzi \`<script>\` 的 \`src\`。

<Card title="相关代码" fold>

修改后的 busuanzi 代码（还在 \`catch\` 里加了个 \`console.error\`）：

\`\`\`javascript
var bszCaller,bszTag;!function(){var c,d,e,a=!1,b=[];ready=function(c){return a||"interactive"===document.readyState||"complete"===document.readyState?c.call(document):b.push(function(){return c.call(this)}),this},d=function(){for(var a=0,c=b.length;c>a;a++)b[a].apply(document);b=[]},e=function(){a||(a=!0,d.call(window),document.removeEventListener?document.removeEventListener("DOMContentLoaded",e,!1):document.attachEvent&&(document.detachEvent("onreadystatechange",e),window==window.top&&(clearInterval(c),c=null)))},document.addEventListener?document.addEventListener("DOMContentLoaded",e,!1):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){/loaded|complete/.test(document.readyState)&&e()}),window==window.top&&(c=setInterval(function(){try{a||document.documentElement.doScroll("left")}catch(b){return}e()},5)))}(),bszCaller={fetch:function(a,b){var c="BusuanziCallback_"+Math.floor(1099511627776*Math.random());window[c]=this.evalCall(b),a=a.replace("=BusuanziCallback","="+c),scriptTag=document.createElement("SCRIPT"),scriptTag.type="text/javascript",scriptTag.defer=!0,scriptTag.src=a,scriptTag.referrerPolicy="no-referrer-when-downgrade",document.getElementsByTagName("HEAD")[0].appendChild(scriptTag)},evalCall:function(a){return function(b){ready(function(){try{a(b),s=document.querySelector('[src*=BusuanziCallback]'),s.parentElement.removeChild(s)}catch(c){console.error(c),bszTag.hides()}})}}},bszCaller.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback",function(a){bszTag.texts(a),bszTag.shows()}),bszTag={bszs:["site_pv","page_pv","site_uv"],texts:function(a){this.bszs.map(function(b){var c=document.getElementById("busuanzi_value_"+b);c&&(c.innerHTML=a[b])})},hides:function(){this.bszs.map(function(a){var b=document.getElementById("busuanzi_container_"+a);b&&(b.style.display="none")})},shows:function(){this.bszs.map(function(a){var b=document.getElementById("busuanzi_container_"+a);b&&(b.style.display="inline")})}};
\`\`\`

然后将

\`\`\`html
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"><\/script>
\`\`\`

修改为（如果上面的代码放在了博客的 \`/js/busuanzi.pure.mini.js\`）

\`\`\`html
<script async src="/js/busuanzi.pure.mini.js"><\/script>
\`\`\`

</Card>

网上搜到的很多解决办法是把 \`id="busuanzi_container_*"\` 删掉，这样当然就不会被隐藏了，只不过这个隐藏本意是在出错时不把错误或者无意义的内容显示给访客，保留这一行为还是挺好的。

### 修改 live2d 的解决方法

总之，就是把 \`innerHTML +=\` 换成 \`createElement\` 和 \`appendChild\`，按 [xiazeyu/live2d-widget.js#61](https://github.com/xiazeyu/live2d-widget.js/pull/61/files#diff-61426849230d9976d234f7c4ca195c623d9bb05a91d76b7ae51501e394f81860L10-R43) 改就行。

live2d 的代码还是挺长的，直接修改 minify 后的代码不太好。如果是 hexo 插件的话，要修改应该也蛮麻烦的。总之，如果你知道怎么改比较好的话可以改，不然的话还是推荐改 busuanzi。

## 问题启示

### 不要修改原 DOM 中的 innerHTML

直接修改 DOM 元素的 innerHTML 会让其中的元素都重新渲染（加载？创建？），不仅指向其中元素的变量会失效，也可能导致画面闪烁等问题（例如导致 live2d-widget 修复这一问题的不是 busuanzi 失效而是 [CSS 闪烁](https://github.com/EYHN/hexo-helper-live2d/issues/149)）。

所以，如果是添加 DOM 元素，应当避免修改 \`innerHTML\`，而应当使用 [\`document.createElement\`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) 和 [\`Node.appendChild()\`](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild) 以及 \`removeChild\`、\`replaceChild\`、\`insertBefore\` 等 API。

### 不要依赖于指向 DOM 元素的变量长时间不改变

如果 DOM 因各种原因部分重建，指向 DOM 元素的变量很可能不再指向当前 DOM 中的元素。所以，最好不要在过了一段时间后（例如在 callback 中）再次使用指向 DOM 元素的变量，而应当再次获取这一元素。

### 不要 silently fail

在处理异常，尤其是未知的异常时，即使不 throw 出去，也最好用 \`console.error\` 等方法记录下来。记录在 console 中的错误信息并不会显示给普通用户，但可以给寻找问题所在的用户提供宝贵的提示信息。

### 使用 Header Editor 在对原环境最小修改的情况下进行调试

这次使用 Header Editor 调试还是我临时想到的（~~知道有这么个插件还是以前用 [mahjong-helper](https://github.com/EndlessCheng/mahjong-helper)，当然现在已经没在用了~~）。一开始还用 pastebin 上传代码，效率极低，后来才想起来本地跑个 http server 就可以了..用这个插件来调试还是挺方便的。

### 留心依赖版本

一开始我还在 GitHub 上搜到一个 [busuanzi.pure.js](https://github.com/JoeyBling/busuanzi.pure.js)，调了一会儿才发现这个代码和 https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js 不一样..

live2d 的版本也要注意开头包含时间的注释，因为最新版本已经把问题修复了。
`},{title:F,tags:"Rust 学习记录",content:`早就想学 Rust 了，但一直咕着。这次小学期的程设训练开了 Rust 课堂，就毫不犹豫地选了，也以此为契机学了 Rust。

这篇就是简单记录一下大体上的学习过程，如果有什么心得体会、经验分享之类应该会开新的文章。

顺便也算是程设训练的游记了（“游记”这个词来源于 OI 时期的习惯）。



## 初学 —— The Rust Programming Language

不同于 Python、JavaScript，这次学 Rust 更像是当初学 C++，不是先魔改代码、用啥搜啥、StackOverflow，而是在还没怎么接触过时就直接看书。

虽然没有细看中文翻译的质量如何，但至少术语是不好翻译的，就直接看了英文版的 [The Rust Programming Language](https://doc.rust-lang.org/book/)。

这本书看下来给我的感觉是，很多地方没有按知识点依赖关系的拓扑排序来讲，而似乎是以某种由浅入深的顺序来的，很多后面才学到的概念在前文就出现，而前面学的概念的完全不需要后面知识的扩展又在后面才补充，还有一些零碎的知识是在 project chapter 讲的。

反正，每天看两三章，~~还能有不少时间摸鱼，摸个~~ 一两周就看得差不多了（

## 初步练习 —— 洛谷

看书的同时在 [洛谷](https://www.luogu.com.cn/) 上随便挑了点入门题和板子题写。只不过一开始没学 io 之类的，会再多语法也做不动题，~~但幸好有 GitHub Copilot~~。

在这放个读入的例子：

\`\`\`
6 0
1 1 4 5 1 4
\`\`\`

\`\`\`rust
fn main() {
    let stdin = std::io::stdin();
    let mut input = String::new();

    stdin.read_line(&mut input).unwrap();
    let mut parts = input.split_whitespace();
    let n = parts.next().unwrap().parse::<u32>().unwrap();
    assert_eq!(n, 6);
    let m = parts.next().unwrap().parse::<u32>().unwrap();
    assert_eq!(m, 0);

    input.clear();
    stdin.read_line(&mut input).unwrap();
    let a = input
        .split_whitespace()
        .map(|x| x.parse::<i32>().unwrap())
        .collect::<Vec<_>>();
    assert_eq!(a, vec![1, 1, 4, 5, 1, 4]);
}
\`\`\`

## 复习 —— A half-hour to learn Rust

之前在 Hacker News 上看到了 [A half-hour to learn Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust) 这篇文章。如果真的是看这个东西来学 Rust，不说能不能学会，肯定是学不扎实的。但是，看完书之后很多语法也忘了，看这个用来复习还是非常不错的。（另外，我感觉这个的顺序貌似比书更有条理一些，虽然初学不一定友好 🤔）

## 深入了解 —— The Rust Standard Library

其实看书的时候就感觉到了，很多时候不懂一段代码不是不懂语法，而是不懂 [标准库](https://doc.rust-lang.org/stable/std/) 的实现，而把 API 理解成了没学过的语法。了解标准库，不仅是提升编码和运行的效率，也是能够看懂很多基础代码的关键。

看文档的时候发现，不仅是学到了很多有用的 methods，也学到了很多其它东西。比如说：

-   一般来说都可以用 [\`std::cmp::max\`](https://doc.rust-lang.org/stable/std/cmp/fn.max.html) 来取 max，但 [\`f32\` 专门有一个 \`pub fn max(self, other: f32) -> f32\`](https://doc.rust-lang.org/stable/std/primitive.f32.html#method.max)，这是因为浮点数有 NaN 这个特殊情况导致 \`f32\` 没有 impl [\`Ord\`](https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html)，而 \`std::cmp::max\` 需要 \`Ord\`
-   书里貌似没讲到的 [keyword \`ref\`](https://doc.rust-lang.org/stable/std/keyword.ref.html)（以及在 pattern matching 中和 \`&\` 的区别）
-   引用之间进行比较时会自动转成指向的值，即实际进行比较的是指向的值（可以通过 [\`std::ptr::eq\`](https://doc.rust-lang.org/stable/std/ptr/fn.eq.html) 来比较地址）
-   从标准库的 API 设计能领会到很多 trait 和 generic 的用法，体会到它们组合在一起的强大
-   [\`Iterator\` 自动有 \`IntoIterator\`](https://doc.rust-lang.org/std/iter/index.html#for-loops-and-intoiterator)，所以用 \`IntoIterator\` 代替 \`Iterator\` 作为 trait bound 可以让函数更灵活
-   ……

简单看一看就能知道 the book 里涉及到的真的只是冰山一角，学 Rust 标准库的意义会比学 C++ 的 STL 大得多（个人感觉）（也可能是我 C++ 水平太低 / 没认真学 STL 😢）（或者 Primer Plus 讲的全一些）。

## 上课

### Class 1

因为自学过了，所以上课就基本上是把老师的声音当作 bgm 偶尔听一下，然后继续看标准库文档（

上课的时候老师提到 Rust 编译器可以提示如何修改，于是我顺势在课程群里发了个 [rust 程序员现状](https://twitter.com/st1page/status/1477168761744805891) 的截图（

![rust程序员现状](rust-programmers-be-like.jpg)

课后把 OJ 上的作业速通后发现榜不是公开的 😢

后来还发现自己一道题写了个 \`collect\` 得到的 \`Vec\` 只用在一个 \`for\` 里（就是说可以直接把迭代器用在 \`for\` 不用先 \`collect\`）😵 想改过来，但虽然没有公开榜，还是不想承受可能的罚时（

### Class 2

第二节课前后共一天多的时间，写了 16h 左右，把 Wordle 大作业的基础功能写完了。（~~本来以为 Wordle 挺好写的，没想到需求这么多，需求文档模糊不清的地方还有的要问有的要自己设计。~~）

感觉课上讲的又快，大作业需要的知识又没讲全，很难想象如果不自学该怎么应对这个课（

### Class 3

修了一些文档说明不清导致的 bug，然后研究了一下扩展功能怎么写。

不知道为什么把单词按信息熵排序写了半天，明明挺简单的。可能是听着老师讲课没法专心想算法。

后来试着用 [rayon](https://docs.rs/rayon/latest/rayon/) 把信息熵计算并行化了，在我本机除了第一次猜测基本上都能秒出结果，感觉很爽 ~~，甚至玩了半天意义不明的照着提示输入~~。

再后来发现用 release 模式编译的优化比并行还大 🌚

### 第一次大作业验收

验收在 THUWC 去过的东主楼，但上大学后还是第一次去，结果走错了，迟到了 5min 😵 然后非常慌张地展示提高功能，都没太演示全，~~感觉白写了~~（

### Class 4~8

略（

### 第二次大作业验收

这次真的有比 pretests 强很多的 system test 了，还好没 FST（助教：这个点你为什么能过啊（x

可能是因为这个课不是学前端的，而且助教只简单看了一下界面演示没看代码，槽点很多的前端被夸了很科学（

可能是因为这个课不是学数据库的，而且听说有其他同学数据库里全是 JSON，普普通通的建表被夸了很科学（

### 关于课上的一些翻译

为什么什么都要翻译出来啊（虽然如果英语母语的话看原文应该也很尬 🤣

![trait: 特型；panic: 恐慌；poisoned: 中毒；crate: 箱；library crate: 库箱](rust-translations.jpg)

## Async Rust

先是看了 [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/)，感觉看得一知半解的（尤其是 \`Pin\`），好像大概知道 \`Future\` 在干什么又不完全知道（~~而且这本书好咕啊，\`TODO\` 的章节应该是有生之年了~~

没看完 async book，直接去看 [Tokio Tutorial](https://tokio.rs/tokio/tutorial) 和 [Async programming in Rust with async-std](https://book.async.rs/) 了。作为 async runtime 的教程，它们涉及到的具体原理和实现少一些，更注重怎么实际使用，读起来会容易理解一些。因为 Tokio 更 popular，主要看的是 Tokio 的教程。

## 数据库: Diesel

感觉 [diesel 的教程](https://diesel.rs/guides/) 写的挺简略的，但对着 examples 硬查文档也勉强能看懂基本用法。ORM 看着就很“安全”，只不过实在是太类型体操了，不仅文档查起来有点小麻烦，代码复用也经常因为繁琐的 trait bounds 写不太动（也可能是我没学会）。

[diesel-derive-enum](https://crates.io/crates/diesel-derive-enum) 是好用的。

Sqlite 的 \`RETURNING\` 语句需要启用 \`returning_clauses_for_sqlite_3_35\` feature flag（并且需要至少 3.35 版本的 Sqlite）。没启用的时候对着一堆 trait bound 不满足的错误信息（就和 C++ 模板感觉差不多了..）根本发现不了错误原因，还是翻文档翻半天发现的。

还遇到一个 Sqlite 锁死的坑，通过 [使用 r2d2 设定 \`busy_timeout\`](https://stackoverflow.com/a/57717533) 并 [使用 WAL mode 以及 immediate transaction](https://github.com/the-lean-crate/criner/issues/1) （hopefully）解决了。
`},{title:g,tags:t,content:`[CS:APP](https://csapp.cs.cmu.edu/) 第二章 “Representing and Manipulating Information” 的学习笔记。

这章的主要内容为 byte、整数和浮点数的存储及计算。



## Information Storage

byte 而非 bit 是 memory 的基本单位，memory 可以看作 array of bytes。

一个 byte 常用两个十六进制数码表示。

word size 表示 virtual memory 的位数（大小），所以也是指针的位数。在 C 语言中，word size 也会影响到整型的大小。

### Byte Ordering

很多时候，单个数据需要用多个 byte 表示，于是就有两种可能的 byte ordering: big endian 和 little endian。

如果把每个 byte 看作一个“数位”，而把由多个 byte 组成的单个数据看作一个“256 进制数”，那么 big endian 就是从高位开始“书写”，little endian 就是从低位开始“书写”。也就是说，big endian 看上去是更加符合人类的“书写习惯”的，而 little endian 则像是把 1234 写成 4321。但是，little endian 会把低位存在低地址，从这个角度来说又更加“自然”一些。

由于 byte 是 memory 的基本单位，endian 影响的是 byte 的排列顺序，而不是 bit 的排列顺序。如果把一串 byte 分别用 big endian 和 little endian 写出来，例如 big endian \`0x1234\`，little endian \`0x3412\`，可能会感觉 endian 不影响“byte 内部的顺序”很奇怪，但其实 \`0x12\` 和 \`0x34\` 只是 byte 的一种表示方式，并不代表“byte 内部的顺序”。上面说“把由多个 byte 组成的单个数据看作一个‘256 进制数’”，也是考虑到 10 进制数的“反过来写”是为人熟知的，这样的话用“256 进制数”来作类比会比较好理解且不容易误解。

一般来说，byte ordering 对于程序员来说是无关紧要的。但是，如果要将数据与外界分享（例如通过网络传输），或者需要查看原始的 byte array（在 machine-level program 中），或者需要通过类型转换、union 等方式绕开 C 语言的类型系统，则 byte ordering 会非常重要。

字符串的表示是不受 byte ordering 影响的。

### 位运算

主要是左移、右移，其它是熟知的。

左移时高位会被丢弃，低位会填充零。

右移则有两种: 逻辑右移和算术右移。两者都是丢弃低位，但逻辑右移是高位填零，算术右移是高位填原来最高位的值。

在 C 语言中，unsigned integer 一定是逻辑右移，而 signed integer 则一般是算术右移。

算术右移的行为是为了在使用补码表示负数时得到正确的结果。

在位移过大（超过 word size）时，行为是不确定的，但一般会将位移对 word size 取模。

## Integer Representations

### 整型编码

unsigned integer 的编码就是普通的二进制。

signed integer 一般采用补码 (two’s-complement encoding)，即在 word size 为 $w$ 时最高位表示 $-2^{w-1}$ 而非 $2^{w-1}$。也就是说，最高位为 0 表示非负，为 1 表示负数；在最高位为 0 时和 unsigned integer 是一致的，而在最高位为 1 时是同样编码的 unsigned integer 减去 $2^w$。

### signed unsigned 转换

在 C 语言中，在同样长度的 signed 和 unsigned 之间转换时，虽然不一定，但一般是不改变编码地只进行类型的转换。

若算术运算符的两侧分别是 signed 和 unsigned，则会将 signed 隐式转换为 unsigned，这在运算符为比较运算符时尤其可能导致意外的结果，例如 \`-1 > 0u\`。

<Card type="warn">
由于 signed 与 unsigned 转换可能带来意外的结果，很多时候最好避免使用 unsigned integer。如果要将 signed 和 unsigned 放在同一个表达式中运算一般是会有 warning 的，如果要显式进行转换则要小心。
</Card>

### 整型增长

将某个长度的 unsigned integer 转换为更长的 unsigned integer 时，会在高位补零。

将某个长度的 signed integer 转换为更长的 signed integer 时，会在高位补原来的最高位，类似于 arithmetic right shift，以保证转换后数值不变。

如果一个类型转换既要增长又要转变 signed/unsigned，会先转换长度再转换 signed/unsigned。

### 整型缩短

无论是 signed 还是 unsigned，在缩短整型时会直接将高位截去。在新的整型长度为 $w$ 时，这相当于对 $2^w$ 取模。

## Integer Arithmetic

### 加法和取反

unsigned integer 的加法：模 $2^w$。

判断 unsigned integer 加法是否发生溢出：\`x + y\` 溢出当且仅当 \`x + y < x\`。

unsigned integer 取反：$x \\mapsto \\begin{cases} 0 & x = 0 \\\\ 2^w - x & x > 0 \\end{cases}$

取反有两种计算方式：

-   按位取反后加一；
-   或者找到二进制表示中最低位的 \`1\` 然后将比这一位高的位取反。

signed integer 的加法：把编码当作 unsigned integer 算，就可以实现 positive overflow 和 negative overflow 的效果，即 overflow 后保持模 $2^w$ 不变。

判断 signed integer 加法是否发生溢出：\`x + y\` positive overflow 当且仅当 \`x > 0 && y > 0 && x + y <= 0\`，negative overflow 当且仅当 \`x < 0 && y < 0 && x + y >= 0\`。

signed integer 取反: 把编码当作 unsigned integer 来取反即可，表现为，能表示的最小值取反得到自身，其它值取反就是其相反数。

<Card type="warn">
signed integer 取最小值时取反得到自身而非其相反数，这可能会是被忽视的 corner case 而导致 bug。
</Card>

### 乘法

无论 signed integer 还是 unsigned integer，乘法都是丢弃高位即模 $2^w$，且在编码上是等价的。

如果乘法运算中的某个因数是常数，编译器可能会把乘法优化为位移和加法的组合。是否以及如何进行优化取决于常数的值以及相关指令（加法、位移、乘法，可能还有 \`LEA\` 等指令）的相对速度，与具体机器密切相关。

### 除以 2 的幂

如果除法运算中除数是 2 的幂，编译器会将除法优化为右移。

### 总结

计算机的整数运算总的来说通过取模来处理溢出，而使用补码表示 signed integer 可以使 signed integer 和 unsigned integer 的运算在编码层面上的实现相同。

## Floating Point

### IEEE 浮点表示

浮点数大体上是一个二进制的科学计数法，形如 $(-1)^s \\times M \\times 2^E$。

IEEE 浮点表示的编码包含三部分：

1.  sign bit，表示 $s$
2.  exponent field，表示 $E$，下文中记其表示的 unsigned integer 为 $e$
3.  fraction field，表示 $M$，下文中记 fraction field 为 $f_{n-1} \\cdots f_1 f_0$

如果简单地使用普通整数的表示法来表示 $M$ 和 $E$，会遇到一些问题：

-   $E$ 需要能是负数，以用来表示比较小的数
-   若 $M = 0.f_{n-1} \\cdots f_1 f_0$，那么：
    -   $E$ 不同的编码可能表示同一个值，造成编码的浪费
    -   可能会出现 $E$ 更大但值更小的情况，会给比较两个数造成困难
-   不能表示 $\\pm \\infty$ 和 \`NaN\` 等特殊值

为了解决这些问题，IEEE 浮点表示采取了如下措施。

首先，浮点数被分为三类：normalized values, denormalized values 和 special values。

Normalized values:

-   一个浮点数是 normalized value，当且仅当其 exponent field 既不全零也不全一
-   $E = e - \\mathrm{Bias}$，其中 $\\mathrm{Bias}$ 是一个预先设置的常量
-   $M = 1.f_{n-1} \\cdots f_1 f_0$

Denormalized values:

-   一个浮点数是 denormalized value，当且仅当其 exponent field 全零
-   $E = 1 - \\mathrm{Bias}$
-   $M = 0.f_{n-1} \\cdots f_1 f_0$

Special values:

-   一个浮点数是 special value，当且仅当其 exponent field 全一
-   若 fraction field 全零，则根据 sign bit 表示 $\\pm \\infty$
-   若 fraction field 非全零，则表示 \`NaN\`

现在来看这套编码规则如何解决了上面提出的问题：

1.  设置 $\\mathrm{Bias}$，以表示小于零的 $E$
2.  将 normalized values 的 $M$ 的最高位钦定为 1，以避免不同 $E$ 表示同一个数。这和标准的十进制科学计数法要求小数在 $[1, 10)$ 的范围内是一个道理，在二进制科学计数法中就是要求小数在 $[1, 2)$ 的范围内。
3.  由于 $E$ 的取值范围有限，normalized values 的 $M$ 最高位强制为 1 使其无法表示 $0.0$ 以及接近 $0$ 的数（能够表示 $2^{-\\mathrm{Bias}}$ 和 $(1 + \\varepsilon) \\times 2^{-\\mathrm{Bias}}$，却无法表示位于 $[0, 2^{-\\mathrm{Bias}})$ 内的数），所以增设 denormalized values 这一分类用来表示接近 $0$ 的数以及 $\\pm 0.0$。由于 denormalized values 没有将 $M$ 的最高位设为 $1$，它的 $E$ 设置为 $1 - \\mathrm{Bias}$ 而非 $-\\mathrm{Bias}$ 作为补偿。
4.  通过 special values 的分类，表示了 $\\pm \\infty$ 以及 \`NaN\`。
5.  使用 exponent fields 按照 denormalized -> normalized -> special 的顺序进行分类，对于同一符号的浮点数，只需将 exponent field 和 fraction field 看作无符号整数即可比较大小（实际比较时，除了先比较符号位，可能还要考虑 $\\pm 0.0$、\`NaN\` 等特殊情况）。

IEEE 浮点表示还规定了每个 field 的长度：

-   32 位: exponent field 8 位，fraction field 23 位
-   64 位: exponent field 11 位，fraction field 52 位

记 exponent field 的位数为 $k$，则 $\\mathrm{Bias} = 2^{k-1} - 1$，即 32 位为 $127$，64 位为 $1023$。

### 特殊（标志性）的浮点数

exponent field 和 fraction field 全零表示 $\\pm 0.0$。

exponent field 全零，fraction field 最低位 1 其它位 0，是能够表示的最接近零的数（32 位约为 $1.4 \\times 10^{-45}$，64 位约为 $4.9 \\times 10^{-324}$）。（注意这个数的值为 $2^{2-2^k-n}$，和 $\\varepsilon = 2^{-n}$ 不同。）

exponent field 最高位 0 其它位 1（这得益于 $\\mathrm{Bias}$ 的设定），fraction field 全零，表示 $\\pm 1.0$。

exponent field 最低位 0 其它位 1，fraction field 全一，是能够表示（非 special value）的最大的数（32 位约为 $3.4 \\times 10^{38}$，64 位约为 $1.8 \\times 10^{308}$）。

### 浮点数舍入

浮点数的舍入有四种模式可供选择：

-   round-to-even: 类似于“四舍六入五成双”但是二进制，是默认的舍入模式
-   round-toward-zero
-   round-down
-   round-up

### 浮点数运算

除了一些特殊值（如 \`sqrt(-1.0)\`、\`1/0.0\`），浮点数的运算结果被定义为精确计算后进行舍入得到的结果，但具体计算的实现方式是随意的（不需要真的先精确计算再进行舍入）。

浮点数的加法和乘法会进行舍入、可能溢出，所以不满足结合律、分配律（但是满足交换律）。调换结合顺序可能改变计算结果，意味着编译器无法以改变结合顺序为代价进行优化。

### C 语言中浮点数类型转换

简单来说，整数转成浮点数或不同类型的浮点数之间进行转换可能舍入也可能溢出。浮点数转成整数会向零取整，溢出时行为不确定。
`},{title:b,tags:t,content:'[CS:APP](https://csapp.cs.cmu.edu/) 第三章 “Machine-Level Representation of Programs” 的学习笔记。\n\n这章的主要内容为汇编（machine-level programming）。\n\n\n\n近年来，随着编译器和高级语言的发展，手写汇编、机器码的需求越来越低，但阅读、理解编译器的输出在优化程序性能、避免安全漏洞等方面依然重要。\n\n## Program Encodings\n\n### 汇编/机器码中的程序状态\n\nx86-64 的程序状态包含：\n\n-   program counter，表示待执行的下一条指令的地址，用 `%rip` 表示\n-   [register file](#寄存器)，16 个用来存储整型的寄存器\n-   [status flags](#status-flags)，用来存储最近执行的运算的状态\n-   [vector registers](#ymm-寄存器)，用来存储多个整型或浮点数\n\n### 将 C 代码编译为汇编代码\n\n可以通过 `gcc -S` 生成汇编代码，通过 `gcc -Og` 来启用“以调试体验为目标的优化”（后文中叙述的很多编译行为都是需要一些基本的优化的，如果完全不启用任何优化，可能编译结果会有很大的差别；也就是说，完全不优化和过度优化都会降低汇编代码的可读性）。\n\n为了方便，可以用一条命令编译并不留文件地查看汇编代码: `gcc a.c -Og -S -o - | bat -l asm`。\n\n例如，下面的代码：\n\n```c\nlong mult2(long, long);\n\nvoid multstore(long x, long y, long *dest)\n{\n    long t = mult2(x, y);\n    *dest = t;\n}\n```\n\n编译为如下的汇编代码：\n\n```asm\n	.file	"a.c"\n	.text\n	.globl	multstore\n	.type	multstore, @function\nmultstore:\n.LFB0:\n	.cfi_startproc\n	pushq	%rbx\n	.cfi_def_cfa_offset 16\n	.cfi_offset 3, -16\n	movq	%rdx, %rbx\n	call	mult2@PLT\n	movq	%rax, (%rbx)\n	popq	%rbx\n	.cfi_def_cfa_offset 8\n	ret\n	.cfi_endproc\n.LFE0:\n	.size	multstore, .-multstore\n	.ident	"GCC: (GNU) 12.2.0"\n	.section	.note.GNU-stack,"",@progbits\n```\n\n### 反汇编与机器码\n\n可以通过 `objdump` 反汇编，例如 `gcc a.c -Og -c && objdump -d a.o` 得到：\n\n```asm\na.o：     文件格式 elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 <multstore>:\n   0:	53                   	push   %rbx\n   1:	48 89 d3             	mov    %rdx,%rbx\n   4:	e8 00 00 00 00       	call   9 <multstore+0x9>\n   9:	48 89 03             	mov    %rax,(%rbx)\n   c:	5b                   	pop    %rbx\n   d:	c3                   	ret\n```\n\n可以看出，机器码就是一串 bytes，若干个 bytes 合在一起表示一条指令。而每条指令对应的 bytes 数量不同，与 operands 个数以及指令的常用程度相关（类似摩斯电码、UTF-8）。\n\n<Card title="指令集的 reference；ATT 格式 vs Intel 格式">\nCS:APP 以及 gcc 默认使用的是 ATT 格式的汇编，可以在 [Instruction Set Mapping - Oracle x86 Assembly Language Reference Manual](https://docs.oracle.com/cd/E19253-01/817-5477/enmzx/index.html) 查看 ATT 格式汇编和实际指令之间的对应关系，在 [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)（下文中以 “Intel Manual” 指代）（主要是第 2 卷）查看具体指令的 reference。\n\nATT 格式与 Intel 格式有一些差别，其中在查看 reference 时需要注意的是，Intel 格式的指令没有 `b/w/l/q` 的类型后缀，并且 operands 的顺序和 ATT 格式恰好相反。\n\n</Card>\n\n## Data Formats\n\n由于历史原因，Intel 使用 “word” 表示 16 bits，而用 “double word” 表示 32 bits，用 “quad word” 表示 64 bits。\n\nC 语言类型在 x86-64 中的大小：\n\n| C 语言类型 |  Intel 数据类型  |  汇编后缀   | bytes |\n| :--------: | :--------------: | :---------: | :---: |\n|   `char`   |       byte       |     `b`     |   1   |\n|  `short`   |       word       |     `w`     |   2   |\n|   `int`    |   double word    | `l` (long)  |   4   |\n|   `long`   |    quad word     |     `q`     |   8   |\n|    指针    |    quad word     |     `q`     |   8   |\n|  `float`   | single precision | `s` (short) |   4   |\n|  `double`  | double precision | `l` (long)  |   8   |\n\n每种类型都有一个用在汇编指令中的后缀，表示 operand 的类型，例如 `movb`、`movw`、`movl`、`movq`。`l` 既用于 double word 也用于 double precision，但整数和浮点数涉及的指令不同，所以不会有歧义。（后文中 [Floating-Point Code](#floating-point-code) 用的 AVX2 指令并不使用 `s`/`l` 的浮点数类型后缀。）\n\n## Accessing Information\n\n### 寄存器\n\nx86-64 CPU 有 16 个 general-purpose register，可以用来存整数或指针：\n\n| quad word | double word |  word   |  byte   |     用途      |\n| :-------: | :---------: | :-----: | :-----: | :-----------: |\n|  `%rax`   |   `%eax`    |  `%ax`  |  `%al`  | return value  |\n|  `%rbx`   |   `%ebx`    |  `%bx`  |  `%bl`  | callee saved  |\n|  `%rcx`   |   `%ecx`    |  `%cx`  |  `%cl`  | 4th argument  |\n|  `%rdx`   |   `%edx`    |  `%dx`  |  `%dl`  | 3rd argument  |\n|  `%rsi`   |   `%esi`    |  `%si`  | `%sil`  | 2nd argument  |\n|  `%rdi`   |   `%edi`    |  `%di`  | `%dil`  | 1st argument  |\n|  `%rbp`   |   `%ebp`    |  `%bp`  | `%bpl`  | callee saved  |\n|  `%rsp`   |   `%esp`    |  `%sp`  | `%spl`  | stack pointer |\n|   `%r8`   |   `%r8d`    | `%r8w`  | `%r8b`  | 5th argument  |\n|   `%r9`   |   `%r9d`    | `%r9w`  | `%r9b`  | 6th argument  |\n|  `%r10`   |   `%r10d`   | `%r10w` | `%r10b` | caller saved  |\n|  `%r11`   |   `%r11d`   | `%r11w` | `%r11b` | caller saved  |\n|  `%r12`   |   `%r12d`   | `%r12w` | `%r12b` | callee saved  |\n|  `%r13`   |   `%r13d`   | `%r13w` | `%r13b` | callee saved  |\n|  `%r14`   |   `%r14d`   | `%r14w` | `%r14b` | callee saved  |\n|  `%r15`   |   `%r15d`   | `%r15w` | `%r15b` | callee saved  |\n\n每个 register 可以用四种不同的长度访问，其中短的是长的的低位。修改 byte 或 word 的值时高位不变，修改 double word 的值则会将高位清零。\n\n不同寄存器的用途将在后文说明（主要是在 [Procedures](#procedures) 这一节）。\n\n### Operand 格式\n\n指令的 operand 有三种指定方式：\n\n1.  Immediate，即字面值，代码为 `$Imm`，例如 `$123` 表示 123，`$0x123` 表示 0x123\n2.  Register，代码为寄存器的名称，例如 `%rax`\n3.  Memory，完整形态的代码为 `Imm(rb, ri, s)`，表示 `M[Imm + R[rb] + R[ri] * s]`（其中 `ri` 不为 `%rsp`，$s \\in \\{1, 2, 4, 8\\}$），例如 `2(%rax, %rbx, 4)` 表示 memory 中地址为 `2 + %rax + 4 * %rbx` 的值；`Imm`、`rb`、`, ri, s` 分别可以省略，例如 `Imm`、`(rb)`、`Imm(, ri, s)`；指定了 `ri` 时也可以省略 `s` 表示 `s` 为 1。\n\n在下文中，用 `imm32`、`r64`、`m16`、`r/m64` 等方式表示指令 operand 的类型。\n\n（在 ATT 格式中）有两个 operand 时，第一个是 source，第二个是 destination。\n\n### move 类指令\n\n虽然叫 “move”，但实际上是复制。\n\n#### MOV 指令\n\nsource 和 destination 类型相同。\n\n-   `movb imm/r8, r/m8`\n-   `movb m8, r8`\n-   `movw imm/r16, r/m16`\n-   `movw m16, r16`\n-   `movl imm/r32, r/m32`\n-   `movl m32, r32`\n-   `movq imm32/r64, r/m64`\n-   `movq m64, r64`\n-   `movabsq imm64, r64`\n\n其中，source 和 destination 不能同时是 memory。\n\n特别地，`movq` 不接受 imm64，复制时会在 imm32 的高位补符号位；`movabsq` 可以接受 imm64，但 destination 只能是寄存器。这样设计的原因可以参考 [assembly - why we can\'t move a 64-bit immediate value to memory? - Stack Overflow](https://stackoverflow.com/questions/62771323/why-we-cant-move-a-64-bit-immediate-value-to-memory)。实际上，支持 imm64 作为 operand 的指令是少数，后面还会看到很多不接受 imm64 的指令，一般都是高位补符号位。\n\n#### MOVZ 指令\n\n将高位补零后复制。\n\n-   `movzbw r/m8, r16`\n-   `movzbl r/m8, r32`\n-   `movzwl r/m16, r32`\n-   `movzbq r/m8, r64`\n-   `movzwq r/m16, r64`\n\n没有 `movzlq` 这条指令，因为将寄存器的值修改为一个 double word 时就会将高位清零，所以使用 `movl` 就可以了。\n\n<Card\n    type="question"\n    title="没用的 <code>movzbq</code> 和 <code>movzwq</code> 🤔？"\n>\n    虽然有 `movzbq` 和 `movzwq`，但一般会用 `movzbl` 和 `movzwl`\n    实现相应的功能。没搜到为什么会有这两条指令...\n</Card>\n\n#### MOVS 指令\n\n将高位补符号位后复制。\n\n-   `movsbw r/m8, r16`\n-   `movsbl r/m8, r32`\n-   `movsbq r/m8, r64`\n-   `movswl r/m16, r32`\n-   `movswq r/m16, r64`\n-   `movslq r/m32, r64`\n-   `cltq`: 和 `movslq %eax, %rax` 效果相同（但编码更短）\n\n### push/pop stack\n\n-   `pushq imm32/r/m64`: 将 `R[%rsp]` 减八，然后将 operand 复制到 `M[R[%rsp]]`（`PUSH` 指令不支持 imm64，会将 imm32 高位补符号位）\n-   `popq r/m64`: 将 `M[R[%rsp]]` 复制到 operand，然后将 `R[%rsp]` 加八\n\n可以看出，program stack 是 memory 中连续的一段，每个元素是一个 quad word，top 的地址比 bottom 低，push 时 stack pointer 减小。\n\n由于 stack 不过是由 `%rsp` 标记栈顶的一段 memory，可以通过给 `%rsp` 加上一个 offset 访问非栈顶元素，例如 `8(%rsp)` 为栈顶下面的第一个元素。\n\n<Card title="为什么 top 位于低地址？">\n    top 位于低地址可能看起来很怪，可以参考 [Why does the stack address grow\n    towards decreasing memory addresses? - Stack\n    Overflow](https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses)。简单来说，由于\n    memory layout 和 memory 曾经很小的历史原因，stack 和 heap\n    会往不同的方向增长，总会有一个在增长时减小地址，而 x86-64 选择了 push stack\n    时减小地址，这也使得访问非栈顶元素不需要给 offset 加负号。\n</Card>\n\n<Card title="<code>pushq</code>/<code>popq</code> vs 直接修改 <code>%rsp</code>">\n    除了 `pushq`/`popq`，也可以减小 `%rsp` 来向栈顶压入未初始化的数据，或者增大\n    `%rsp` 来释放栈空间，但这样做和 `pushq`/`popq`\n    相比哪个性能更好是比较复杂的，可以参考 [assembly - What C/C++ compiler can\n    use push pop instructions for creating local variables, instead of just\n    increasing esp once? - Stack\n    Overflow](https://stackoverflow.com/questions/49485395/what-c-c-compiler-can-use-push-pop-instructions-for-creating-local-variables)。\n</Card>\n\n## Arithmetic and Logical Operations\n\n### Load Effective Address\n\n`leaq m, r64`: 将 source operand 的地址复制到 destination operand（只计算 source operand 的地址，与其指向的 memory 中存储的值无关）\n\nLEA 可以用来优化一些简单的算术，例如：\n\n```c\nlong scale(long x, long y, long z)\n{\n    long t = x + 4 * y + 12 * z;\n    return t;\n}\n```\n\n```asm\nscale:\n	leaq	(%rdi,%rsi,4), %rax\n	leaq	(%rdx,%rdx,2), %rdx\n	leaq	(%rax,%rdx,4), %rax\n	ret\n```\n\n这里三个 LEA 分别计算了 $x + 4y$, $z + 2z$ 和 $(x + 4y) + 4 (z + 2z)$。\n\n### 一元运算\n\n每种一元运算都有 b/w/l/q 四个类型，接受一个相应类型的 r/m，将这个 operand 计算后的结果存入这个 operand：\n\n-   `INC`: 加一\n-   `DEC`: 减一\n-   `NEG`: 取反 (negate)\n-   `NOT`: 按位取反 (complement)\n\n### 二元运算\n\n每种二元运算都有 b/w/l/q 四个类型，接受相应类型的 imm/r/m 作为 source（除了 imm64），相应类型的 r/m 作为 destination（source 和 destination 不能同时为 memory），效果为将 source“作用于”destination，将运算结果存入 destination。\n\n-   `ADD`: 加\n-   `SUB`: destination 减去 source\n-   `IMUL`: 乘\n-   `XOR`: 按位异或\n-   `OR`: 按位或\n-   `AND`: 按位与\n\n特别地，类似 `xorl %rdx, %rdx` 的代码可以用来优化 `movl $0, %rdx`，参见 Practice Problem 3.11 以及 [performance - What is the best way to set a register to zero in x86 assembly: xor, mov or and? - Stack Overflow](https://stackoverflow.com/questions/33666617/what-is-the-best-way-to-set-a-register-to-zero-in-x86-assembly-xor-mov-or-and)。\n\n### 位移\n\n位移有 b/w/l/q 四个类型，source 只能是 imm8 或者 `%cl`，destination 是相应类型的 r/m。\n\n-   `SAL`/`SHL`: 左移\n-   `SAR`: 算术右移\n-   `SHR`: 逻辑右移\n\n<Card type="question" title="对过大位移位数的处理">\n    CS:APP 上说位移的位数会对 operand size 取模，但根据 Intel Manual\n    以及我自己实验的结果，应该是 b/w/l 对 32 取模，q 对 64 取模；errata\n    也没看到这一条，不知道是怎么回事。\n</Card>\n\n### 结果是 operand 两倍长度的运算\n\n128 位的整数叫做 oct word，需要存在两个寄存器中，在指令中一般高位放在 `R[%rdx]` 低位放在 `R[%rax]`。\n\n虽然截去高位时是否有符号对编码层面的乘法没有影响，不截去高位时就需要对 signed 和 unsigned 使用不同的指令了：\n\n-   `imulq r/m64`: 计算 operand 和 `R[%rax]` 作为 signed integer 相乘而不截去高位的结果，存在 `R[%rdx]:R[%rax]` 中。（如果有两个 operand 就是上面的 [二元运算](#二元运算) 了。）\n-   `mulq r/m64`: 计算 operand 和 `R[%rax]` 作为 unsigned integer 相乘而不截去高位的结果，存在 `R[%rdx]:R[%rax]` 中。\n\n除法以及取模：\n\n-   `cqto`/`cqtd`: 将 `R[%rax]` 高位填符号位放在 `R[%rdx]:R[%rax]`（也就是用 `R[%rax]` 的符号位填满 `R[%rdx]`）。\n-   `idivq`: 计算 `R[%rdx]:R[%rax]` 有符号地除以 operand，商放在 `R[%rax]`，余数放在 `R[%rdx]`。\n-   `divq`: 计算 `R[%rdx]:R[%rax]` 无符号地除以 operand，商放在 `R[%rax]`，余数放在 `R[%rdx]`。\n\n得到的商都是向 0 取整，所以被除数为负时余数非正。\n\n若商溢出了，则会触发 divide error 异常。所以被除数一般会是 64 位整数（在 `idivq` 之前用 `cqto` 来设置 `R[%rdx]`，在 `divq` 之前将 `R[%rdx]` 置为全零），否则很可能溢出而触发异常。\n\n这些运算也有 operand 为 32 位，结果为 64 位的版本：`imull`、`mull`、`cltd`、`idivl`、`divl`。它们以 `%edx` 和 `%eax` 来代替 128 位运算中的 `%rdx` 和 `%rax`。\n\n## Control\n\n<Card type="hint" title=\'<span class="mojikumi">“</span>status flag<span class="mojikumi">”</span> vs <span class="mojikumi">“</span>condition code<span class="mojikumi">”</span>\'>\n    在 CS:APP 中 `CF`/`ZF`/`SF`/`OF` 等被叫做 “condition code”；而在 Intel Manual\n    中，`CF`/`ZF`/`SF`/`OF` 等被叫做 “status flag”，“condition code” 指的是 status\n    flags 的组合。下文采用 Intel 的叫法。\n</Card>\n\n### Status Flags\n\nstatus flags 中存储了最近一次运算的状态，常用的 status flag 有四个：\n\n-   `CF`: Carry Flag，表示运算过程中发生了超出 operand 长度的进位或借位，即将运算视作 unsigned 发生了溢出。\n-   `ZF`: Zero Flag，表示运算结果为零。\n-   `SF`: Sign Flag，表示运算结果（看作补码）为负，即运算结果的符号位。\n-   `OF`: Overflow Flag，表示若将运算视作 signed 发生了溢出。\n\n<Card title="ARM 中的 carry flag —— carry flag vs borrow flag" fold>\n在 ARM 中，计算减法时，与 x86 相反，carry flag 为 0 表示溢出，为 1 表示没有溢出。\n\n这是因为，计算减法有两种方式，[subtract with borrow 和 subtract with carry](https://en.wikipedia.org/wiki/Carry_flag#Vs._borrow_flag)：\n\n-   subtract with borrow 相当于普通的减法竖式计算，计算过程中记录 borrow flag，最后存储在 carry flag 中，表现为若最后发生借位则 carry flag 为 1。\n-   subtract with carry 利用了 `-x = ~x + 1` 的性质，通过 `a + ~b + 1` 来计算 `a - b`，而和普通加法一样计算 carry flag；而在 subtract with borrow 最后发生借位时，subtract with carry 反而 carry flag 是 0。\n\n可以这么理解这两者间的差异：设计算是 $w$ 位的，最后计算完成时，borrow flag 表示第 $w+1$ 位上是 $-1$，carry flag 表示第 $w+1$ 位上是 $1$，而 subtract with carry 相当于先加上了 $2^w$ 再进行减法，就会将第 $w+1$ 位从 $-1$ 变成 $0$，从 $0$ 变成 $1$。\n</Card>\n\nLEA 不会改变 status flags。\n\n[一元运算](#一元运算) 和 [二元运算](#二元运算) 都会改变 status flags。特别地，`INC` 和 `DEC` 不会改变 `CF`。\n\n位移对 status flags 的影响比较复杂（可以参考 Intel Manual），简单来说 `CF` 会被设为最后一个移出的位，只有位移位数为 1 时才会改变 `OF`。\n\n### Condition Codes\n\ncondition code 是 status flags 的组合，常用的有：\n\n| condition code |               名称 (意义)                |        取值        |\n| :------------: | :--------------------------------------: | :----------------: |\n|    `e`/`z`     |               equal / zero               |        `ZF`        |\n|   `ne`/`nz`    |           not equal / not zero           |       `~ZF`        |\n|      `s`       |             sign (negative)              |        `SF`        |\n|      `ns`      |         not sign (non-negative)          |       `~SF`        |\n|   `g`/`nle`    |  greater / not less equal (signed $>$)   | `~(SF ^ OF) & ~ZF` |\n|   `ge`/`nl`    | greater equal / not less (signed $\\ge$)  |    `~(SF ^ OF)`    |\n|   `l`/`nge`    |  less / not greater equal (signed $<$)   |     `SF ^ OF`      |\n|   `le`/`ng`    | less equal / not greater (signed $\\le$)  | `(SF ^ OF) \\| ZF`  |\n|   `a`/`nbe`    |  above / not below equal (unsigned $>$)  |    `~CF & ~ZF`     |\n|   `ae`/`nb`    | above equal / not below (unsigned $\\ge$) |       `~CF`        |\n|   `b`/`nae`    |  below / not above equal (unsigned $<$)  |        `CF`        |\n|   `be`/`na`    | below equal / not above (unsigned $\\le$) |     `CF \\| ZF`     |\n\n这些 condition code 都是按照减法的结果来命名的，在使用 `CMP` 指令时这些名称是自然的，但如果不是 `CMP`/`SUB` 则要考虑进行的运算是什么以及每个 condition code 实际的取值。\n\n`l`/`nge` 可以理解为，溢出后会变号，所以 `SF ^ OF` 就是如果不溢出的符号；`b`/`nae` 是因为减法发生借位时会标记 `CF`。\n\n### CMP 和 TEST 指令\n\n如果真的进行运算，destination 的值会被覆盖，所以，如果计算结果是不需要的，一般会用 `CMP` 和 `TEST` 来获取 status flags。\n\n`CMP` 和 `TEST` 的 operands 和 [二元运算](#二元运算) 相同。\n\n`CMP` 相当于执行 `SUB` 但只更新 status flags 不更新 destination。常用于比较两个数的大小。\n\n<Card type="warn" title="CMP 的比较顺序">\n    由于 ATT 格式的汇编是 source 在前 destination 在后， `CMP` 的减法是\n    destination 减去 source， 所以比较是看起来是反的，例如 `l` 其实是第二个\n    operand 小于第一个 operand。\n</Card>\n\n`TEST` 相当于执行 `AND` 但只更新 status flags 不更新 destination。常见的用法有两种，一种是两个 operand 为同一个寄存器以判断其符号，另一种是 source 为 bit mask。\n\n### SETcc 指令\n\n`SETcc r/m8`: 将 `cc` 复制到 operand 处。其后缀不是 operand 的长度，而是 condition code，例如 `sete r/m8`、`setne r/m8`、`sets r/m8`...\n\n### Jump 类指令\n\n#### Label\n\n在汇编中 jump 通常会使用 label 作为 jump target，例如（CS:APP P205）：\n\n```asm\n    movq $0, %rax\n    jmp  .L1\n    movq (%rax), %rdx\n.L1:\n    popq %rdx\n```\n\n这里的 `.L1` 就是一个 label。\n\n#### 无条件跳转\n\n-   `jmp Label`: 跳转到 `Label` 处\n-   `jmp *r/m64`: 跳转到 operand 存储的 jump target 处，例如 `jmp *%rax`、`jmp *(%rax)`。\n\n#### 条件跳转\n\n`Jcc Label`: 如果满足 `cc`，则跳转到 `Label` 处。\n\n#### rep; ret\n\n如果 `ret` 会作为某个分支的第一条指令（即 jump 指令的下一条指令或 jump target），一般会把 `ret` 换成 `rep; ret`，效果和 `ret` 一样，但可以避免错误的分支预测，从而优化性能。具体可以参考 [repz ret - repz ret](https://repzret.org/p/repzret/)。\n\n#### jump 指令编码\n\n在进行汇编时，label 会被替换为 _jump 指令的**下一条**指令（其实就是 program counter 的值）到 jump target 的地址差_。而在链接时，虽然指令的地址变了，但指令之间相对的地址差不变，则 jump 指令不用改变。\n\n例如（CS:APP P207）：\n\n```asm\n    movq %rdi, %rax\n    jmp .L2\n.L3:\n    sarq %rax\n.L2:\n    testq %rax, %rax\n    jg .L3\n    rep; ret\n```\n\n汇编后：\n\n```asm\n   0:	48 89 f8             	mov    %rdi,%rax\n   3:	eb 03                	jmp    0x8\n   5:	48 d1 f8             	sar    %rax\n   8:	48 85 c0             	test   %rax,%rax\n   b:	7f f8                	jg     0x5\n   d:	f3 c3                	repz ret\n```\n\n这里 `jmp .L2` 的 operand 编码为 `0x03`，即其下一条指令的地址 `0x5` 到 jump target `0x8` 的距离；`jg .L3` 的 operand 编码为 `0xf8` 即 -8，也就是其下一条指令的地址 `0xd` 到 jump target `0x5` 的距离。\n\n链接后：\n\n```asm\n000000000000112e <foo>:\n    112e:       48 89 f8                mov    %rdi,%rax\n    1131:       eb 03                   jmp    1136 <foo+0x8>\n    1133:       48 d1 f8                sar    %rax\n    1136:       48 85 c0                test   %rax,%rax\n    1139:       7f f8                   jg     1133 <foo+0x5>\n    113b:       f3 c3                   repz ret\n```\n\n### CMOVcc 指令\n\n`CMOVcc` 可以在满足 `cc` 时将 source 复制到 destination。这条指令在 ATT 格式中没有长度类型后缀，通过 destination register 的长度来推断类型。不接受 byte 作为 operand。\n\n-   `CMOVcc r/m16, r16`\n-   `CMOVcc r/m32, r32`\n-   `CMOVcc r/m64, r64`\n\n### 实现 if-else 语句\n\n实现 if-else 语句主要有两种方式：\n\n1.  Conditional control: 即通过 jump 指令更改指令执行的顺序。\n2.  Conditional moves: 即通过 `CMOVcc` 等指令，根据条件决定是否执行这一条指令，但不改变指令执行的顺序。\n\n（具体实现方式可以参考 CS:APP 中的例子。）\n\nconditonal control 是通用的，但 conditonal moves 只在有限的情况下可以使用。一般来说，使用 conditional moves 时需要先将两个分支都算出来，然后根据条件来进行 move，所以要求分支中没有副作用。\n\nconditional moves 有时可以用来优化性能，主要是因为现代处理器的 _pipelining_，即在物理上同时执行多条指令（但在效果上和按顺序执行一致）。条件跳转使得处理器不能确定未来要执行哪些指令，而只能进行分支预测，如果预测失败 pipelining 就白费了。而 conditional move 不会破坏指令执行的顺序，也就不影响 pipelining，所以可以起到优化的效果。但是，conditional moves 除了要求分支无副作用，还需要两个 branch 都执行，所以如果分支过大，就不如 conditional control。\n\n### 实现循环语句\n\n`do while`: 跑完一段代码后进行测试，通过则跳转到开头。\n\n`while`: 在 `do while` 的基础上，要么在开头直接跳转到测试 (jump to middle)，要么在开头进行一次测试，不通过则跳到结尾 (guarded do)。\n\n`for`: 在 `while` 的基础上，开头初始化，测试前更新。\n\n### 实现 switch 语句\n\n具体例子可以参考 CS:APP，重点在于，如果 cases 的值不过于稀疏，可以建一个叫做 jump table 的数组，以 cases 的值作为下标，label 作为值，这样就可以用一次数组访问而非多次条件跳转来实现 `switch` 语句。jump table 也可以和条件跳转结合，以处理 default case 或者个别 cases。\n\n## Procedures\n\nprocedure 的实现主要涉及三个方面：\n\n-   在不同的 procedure 之间转移控制权，即调用 procedure 时交出控制权，procedure 返回时拿回控制权\n-   传递参数和返回值\n-   为局部变量分配/释放内存\n\n调用 procedure 的核心是在 [push/pop stack](#pushpop-stack) 一节中介绍过的 runtime stack。大体上来讲，stack 会分成一堆 frame，栈顶的 frame 为当前 procedure 的相关数据，从栈顶到栈底的各个 frame 依次放着调用链上的各个 procedure，在调用一个 procedure 时会将相关数据压入栈中，返回时再弹出。\n\n这部分会采取“简介-原则-实现”的结构，先简单介绍大概是什么样的，再说明实现需要遵循的原则，再说明具体实现，以及实现是如何满足以及利用原则的。\n\n### 转移控制权\n\n调用 procedure 时，会将当前 program counter 的值存在 stack 中，然后将 program counter 修改为 callee，在返回时再从 stack 中取出 caller 的地址设为 program counter。\n\n<Card type="hint" title="存放 caller 地址的原则">\n进入一个 procedure 时，栈顶放的是 caller 的地址（具体来说，是 `call` 指令的下一条指令的地址）。\n\n返回时，这个 caller 的地址会出栈，即返回后的 `%rsp` 是进入时的 `%rsp` 加 8。\n\n</Card>\n\n具体实现会使用 `CALL` 和 `RET` 两条指令：\n\n-   `call Label`\n-   `call *(r/m64)`\n-   `ret`\n\n其中 `call` 的 operand 和 `jmp` 是一样的，效果相当于先 `pushq %rip` 再 `jmp`。`ret` 则相当于把 `popq` 的结果作为 `jmp` 的 operand。\n\n### 传递参数\n\n寄存器中有 6 个用来存放 procedure 的 arguments，如果参数多于 6 个，则会放在 stack 中。\n\n| bits |   1    |   2    |   3    |   4    |   5    |   6    |\n| :--: | :----: | :----: | :----: | :----: | :----: | :----: |\n|  64  | `%rdi` | `%rsi` | `%rdx` | `%rcx` | `%r8`  | `%r9`  |\n|  32  | `%edi` | `%esi` | `%edx` | `%ecx` | `%r8d` | `%r9d` |\n|  16  | `%di`  | `%si`  | `%dx`  | `%cx`  | `%r8w` | `%r9w` |\n|  8   | `%dil` | `%sil` | `%dl`  | `%cl`  | `%r8b` | `%r9b` |\n\n<Card type="hint" title="存放参数的原则">\n    进入 procedure 时，前 6 个参数（如果有）会被放在相应的寄存器中；其余参数放在\n    stack 中，具体来说，第 $n$ 个参数被放在栈顶下面的第 $n-6$ 个位置，也就是\n    `M[R[%rsp] + 8(n-6)]`。\n</Card>\n\n具体实现为：\n\n-   在 caller 中、`call` 之前：将前 6 个参数放在相应的寄存器，并将其余参数按从后向前的顺序依次压入 stack\n-   在 caller 中、`call` 之后：把 stack 中的参数（如果有）弹出 (`addq $8(n-6), %rsp`)\n-   在 callee 中：从相应的寄存器或 stack 中读取参数\n\n### 传递返回值\n\n<Card type="hint" title="存放返回值的原则">\n    在调用 procedure 并返回后，如果该 procedure 有返回值，`%rax`\n    中存放的是该返回值。\n</Card>\n\n具体实现就是在 `ret` 前确保 `%rax` 中放的是返回值。\n\n### 存储局部变量\n\n局部变量一般会优先放在寄存器中，如果放不下就会放在 stack 中。\n\n特别地，如果代码中涉及到取局部变量的地址，或者局部变量是结构化数据（例如数组或结构体），则必须放在 stack 中。\n\n如果局部变量放在寄存器中，且在使用该局部变量的过程中调用了 procedure，那么该局部变量就会需要先存起来以保证调用 procedure 之后不会改变，而这有两种方式实现：\n\n-   caller saved，即在 caller 中将寄存器里的值存在 stack 里。\n-   callee saved，即在 callee 中存储：有一些特殊的寄存器是 callee-saved register，如果把局部变量存在这些寄存器中，在 caller 中就不用担心它们的值会在调用 procedure 后被修改。\n\n<Card type="hint" title="callee-saved registers 的使用原则">\n有 6 个特殊的寄存器 `%rbx`、`%rbp`、`%r12-15` 是 callee-saved register。\n\n任何 procedure 都要保证，每个 callee-saved register 的值在进入和返回时是相同的。\n\n</Card>\n\ncaller saved 的具体实现：在 `call` 之前（以及压入超过 6 个的参数之前）将局部变量入栈，`call` 之后（以及弹出放在栈中的参数之后）再把栈中存的弹出到寄存器中。\n\ncallee saved 的具体实现：如果一个 procedure 使用了某个 callee-saved register，则要在 procedure 的开头将这个寄存器原本的值入栈，而在 procedure 的结尾将存下来的这个原本的值弹出到相应的寄存器中。\n\n为了尽可能使用（数量尽量少的）寄存器而非 stack，经常会有多个生命周期不交叉的的变量共用一个寄存器，或者临时地把局部变量放在一般用于存放参数或返回值的寄存器中。\n\n### 可变大小的 stack frame\n\n通常情况下一个 procedure 的 stack frame 的大小是确定的，但有时 stack frame 的大小是不能在编译时确定的（例如有非确定大小的数组）。\n\nstack frame 大小确定主要是为了能够通过与 `%rsp` 即栈顶的相对距离来访问局部变量等，在 stack frame 大小不确定时，则可以通过记录 stack frame 底部的地址来访问局部变量。\n\n<Card type="hint" title="stack frame pointer 的原则">\n    在 stack frame 大小不确定时，使用 `%rbp` 作为 frame pointer (base\n    pointer)，其值为刚进入 procedure 时的 `%rsp`。\n</Card>\n\n具体实现为：\n\n```asm\nfunction_name:\n    pushq %rbp\n    movq %rsp, %rbp\n    ……\n    leave\n    ret\n```\n\n设置好 `%rbp` 后，就可以使用 `-8(%rbp)` 等方式访问相对于 stack frame 底端的位置了。\n\n这里有一个新指令 `leave`: 没有 operand，相当于 `move %rbp, %rsp` 然后 `pop %rbp`。\n\n<Card title="<code>leave</code> vs <code>enter</code>">\n    上面的代码中使用了 `leave` 而非 `move %rbp, %rsp`、`pop %rbp`，但没有使用\n    `enter` 指令，简单来说是历史以及性能原因，可以参考 [assembly - "enter" vs\n    "push ebp; mov ebp, esp; sub esp, imm" and "leave" vs "mov esp, ebp; pop\n    ebp" - Stack\n    Overflow](https://stackoverflow.com/questions/5959890/enter-vs-push-ebp-mov-ebp-esp-sub-esp-imm-and-leave-vs-mov-esp-ebp)。\n</Card>\n\n除了使用 `%rbp` 作为 frame pointer，为非确定大小的数组分配栈空间还涉及到 [data alignment](#data-alignment) 的问题，可以参考 CS:APP Practice Problem 3.49。\n\n### Stack Frame Alignment\n\nx86-64 中要求 stack frame 以 16 byte 对齐。具体来说，就是执行 `call` 之前 `%rsp` 的值必须是 16 的倍数，而在进入一个 procedure 时 `%rsp` 的值就模 16 余 8。\n\n为了满足这一对齐要求，有时会在 `call` 之前先 `subq $8, %rsp`，`call` 之后再 `addq $8, %rsp`。\n\n## Array Allocation and Access\n\n简单来说，`Imm(rb, ri, s)` 的 operand 格式使得数组访问变得容易。\n\n而编译器会做很多优化，例如用指针加法代替每次都算一遍乘法。\n\n## Heterogeneous Data Structures\n\n### Struct\n\n结构体也是内存中连续的一段，会在编译时在结构体地址的基础上加上相应的 offset 来访问各个 field。\n\n### Union\n\nunion 的大小是最大的 field 的大小，每个 field 的 offset 都是 0。\n\n在使用 union 时，byte ordering 可能非常重要。\n\n### Data Alignment\n\n在 x86-64 中，进行 data alignment 可以提升程序效率。具体要求为，任何（主要是结构体内的）primitive type 的地址需要是其长度的倍数。\n\n为了满足 alignment 要求，可能需要：\n\n1.  在结构体的不同 field 之间添加 padding\n2.  保证结构体自身的地址是其自身 alignment 的倍数\n3.  在结构体末尾添加 padding，例如在数组中需要保证下一个元素的起始地址为其 alignment 的倍数\n\n汇编代码中会使用 `.align` directive 来指定 data alignment。\n\n## Thwarting Buffer Overflow Attacks\n\n了解了 stack 的构造，就能更加明白数组越界的危害：可以修改 stack 上包括 caller address 在内的数据，导致程序出错或跳转到错误的位置，而攻击者可以利用这一漏洞跳转到设计好的位置以执行攻击代码。\n\n下面是一些无需修改程序代码就能做到的降低 buffer overflow 危害的方法，当然，这些方法也不是万能或总是有效的。\n\n### Stack Randomization\n\n可以修改 stack 的起始地址，以降低指令地址的可预测性，增大攻击难度。这在 Linux 中已经是标准做法了，是 address-space layout randomization (ASLR) 的一部分。\n\n攻击者可以通过 “nop sled”，即通过大量 `nop` 指令来增长攻击代码的长度，来降低猜测指令地址的难度。\n\n### Stack Corruption Detection\n\ngcc 使用 _stack protector_ 来检测 stack corruption，以避免 corrupted stack 造成的危害。\n\n简单来说，使用 stack protector 时，会在 stack frame 中插入一个运行时随机生成的 _canary value_ (_guard value_) ，并在 `ret` 前检查这个值是否被修改。\n\n### Limiting Executable Code Regions\n\n可以限制能够被执行的 memory region，以避免攻击者执行位于 stack 中的、由攻击者注入的指令。\n\n但是，有的语言（例如 Java）可能需要能够执行动态生成的指令，这样的话就不能禁止执行 stack 中的指令。\n\n## Floating-Point Code\n\n这部分内容基于 AVX2 指令集，可以指定 `-mavx2` 选项来让编译器使用 AVX2 指令。\n\n如果不支持 AVX，则可以使用 SSE 指令集，大体上是类似的。简单来说，主要的区别就是 AVX 指令的名称会有一个 `v` 的前缀，而很多 AVX 中三个 operand 的指令在 SSE 中是两个 operand。\n\n### YMM 寄存器\n\n浮点数存放在 16 个 YMM registers 中，每个寄存器有 256 bits，叫做 `%ymm0-15`，而低位 128 bits 叫做 `%xmm0-15`。\n\n这些寄存器可以存多个浮点数 (packed data) 并对它们同时进行操作以加速计算；而如果只对单个浮点数 (scalar) 进行操作，就只涉及到 `%xmm0-15` 的低位。\n\n### 浮点数的移动指令\n\n下面的指令都没有列全可能的 operand 类型，仅列出 CS:APP 里讲到的常用的。\n\n-   `vmovss m32, xmm`\n-   `vmovss xmm, m32`\n-   `vmovsd m64, xmm`\n-   `vmovsd xmm, m64`\n-   `vmovaps xmm, xmm`\n-   `vmovapd xmm, xmm`\n\n其中 `v` 是 AVX 指令的前缀，`ss` 表示 scalar single-precision，`sd` 表示 scalar double-precision，`a` 表示 aligned，`ps` 表示 packed single-precision，`pd` 表示 packed double-precision。也就是说，`s` 结尾的用于 float，`d` 结尾的用于 double。\n\n### 浮点数类型转换\n\n#### 浮点数转为整数\n\n-   `vcvttss2si xmm/m32, r32`\n-   `vcvttsd2si xmm/m64, r32`\n-   `vcvttss2siq xmm/m32, r64`\n-   `vcvttsd2siq xmm/m64, r64`\n\n其中 `cvttss2si` 的意思是: `cvt` -> convert, `t` -> (with) truncation, `ss` -> scalar single-precision, `2` -> to, `si` -> signed integer。\n\n`ss` 用于 float，`sd` 用于 double；结尾为 `q` 的用来转成 64 位整数。\n\n#### 整数转为浮点数\n\n-   `vcvtsi2ss r/m32, xmm, xmm`\n-   `vcvtsi2sd r/m32, xmm, xmm`\n-   `vcvtsi2ssq r/m64, xmm, xmm`\n-   `vcvtsi2sdq r/m64, xmm, xmm`\n\n这里 `cvt` 后少了一个 `t` 是因为整数转为浮点数不会 truncate。\n\n效果是把第一个 operand 转换后放在第三个 operand 处，而第二个 operand 一般不用管，设为和第三个 operand 一样即可。（转换结果会放在 destination 的低位，而第二个 operand 用来设置 destination 的高位。）\n\n#### 浮点数精度转换\n\n-   `vcvtss2sd xmm, xmm, xmm`\n-   `vcvtsd2ss xmm, xmm, xmm`\n\noperand 的作用和上面整数转为浮点数的指令一样。\n\n<Card title="gcc 使用的浮点数精度转换指令">\n    在某些版本的 gcc 中，或针对某些处理器架构进行优化时，gcc\n    可能会使用另外的指令来进行浮点数精度转换。详见\n    [另一篇博客](/post/2022/10/gcc-use_vector_fp_converts)。\n</Card>\n\n### 函数调用中的浮点数\n\n-   前 7 个浮点参数可以存在 `%xmm0-7` 中，其余参数存在 stack 里。\n-   浮点函数返回值存在 `%xmm0` 中。\n-   没有 callee-saved 寄存器（所有寄存器都是 caller-saved）。\n\n看参数是第几个、放在哪个寄存器时，浮点参数和整型参数是分开算的，例如 `double f1(int x, double y, long z)` 和 `double f2(double y, int x, long z)` 的参数寄存器分配是相同的。\n\n### 浮点数算术运算\n\n下面的指令把 `ss` 换成 `sd`、`m32` 换成 `m64` 即为 double-precision 的版本。\n\n#### 浮点数二元运算\n\n记三个 operand 分别为 $S_1, S_2, D$，则效果为计算 $S_2$ 与 $S_1$ 的运算结果，存在 $D$ 中，例如 `vsubss S_1 S_2 D` 是 $D \\gets S_2 - S_1$。\n\n-   `vaddss xmm/m32, xmm, xmm`\n-   `vsubss xmm/m32, xmm, xmm`\n-   `vmulss xmm/m32, xmm, xmm`\n-   `vdivss xmm/m32, xmm, xmm`\n-   `vmaxss xmm/m32, xmm, xmm`\n-   `vminss xmm/m32, xmm, xmm`\n\n#### 浮点数一元运算\n\n`sqrtss xmm/m32, xmm`: 将 source 开方存入 destination\n\n这里 CS:APP 中列出的是 SSE 指令 `sqrtss` 而非 AVX 指令 `vsqrtss`，我自己编译出来也是。可能可以参考 [c++ - Using AVX intrinsics instead of SSE does not improve speed -- why? - Stack Overflow](https://stackoverflow.com/questions/8924729/using-avx-intrinsics-instead-of-sse-does-not-improve-speed-why)。\n\n### 浮点数常量\n\n浮点数相关的指令不接受 immediate value 作为 operand，所以使用常量时需要先存下来，例如：\n\n```c\ndouble foo() { return 1.8; }\n```\n\n```asm\nfoo:\n	vmovsd	.LC0(%rip), %xmm0\n	ret\n.LC0:\n	.long	-858993459\n	.long	1073532108\n```\n\n### 浮点数位运算\n\n位运算都是在整个寄存器上对 packed data 进行的。\n\n-   `vxorps xmm/m128, xmm, xmm`\n-   `vxorpd xmm/m128, xmm, xmm`\n-   `vandps xmm/m128, xmm, xmm`\n-   `vandpd xmm/m128, xmm, xmm`\n\noperands 格式和上面一样。\n\n一些浮点数位运算的实际运用：\n\n-   用 and 运算将 sign bit 置零，以取绝对值\n-   用 xor 运算将 sign bit 取反，以取相反数\n-   将 xor 的两个 source 设为同一个寄存器以得到 0\n\n<Card\n    type="question"\n    title="packed single/double precision 在移动和位运算上的区别？"\n>\n    `vmovaps` 和 `vmovapd`、`vxorps` 和 `vxorpd`、`vandps` 和 `vandpd`\n    看起来效果是一样的，为什么要给 single/double precision 分别一条指令呢 🤔\n</Card>\n\n### 浮点数比较\n\n-   `vucomiss xmm/m32, xmm`\n-   `vucomisd xmm/m64, xmm`\n\n效果为，计算第二个 operand 减去第一个 operand 并设置 status flags。\n\n浮点数的比较是 “unordered” 的，即若某个 operand 是 NaN，则比较结果为 unordered。\n\n不同的比较结果对应的 status flags 以及 condition code 为：\n\n|  比较结果   | CF  | ZF  | PF  | condition code |\n| :---------: | :-: | :-: | :-: | :------------: |\n|  unordered  |  1  |  1  |  1  |      `p`       |\n| $S_2 < S_1$ |  1  |  0  |  0  |      `b`       |\n| $S_2 = S_1$ |  0  |  1  |  0  |      `e`       |\n| $S_2 > S_1$ |  0  |  0  |  0  |      `a`       |\n\n其中 PF 在浮点数比较中用来表示 unordered，在整数计算中也会被设置但几乎没用。\n'},{title:h,tags:t,content:`想开一个 [CS:APP](https://csapp.cs.cmu.edu/) 学习笔记的系列，感觉还是有一些东西需要在系列开头简单说一下，所以有这篇序。



---

这学期要上“计算机系统概论”这门课，其实就是 CS:APP。（只不过老师声称这门课没有教材，CS:APP 只是参考书。）

本来是想暑假自学的，但暑假多少有点摆，就咕了 🕊️

虽然上一学年以数学课为主都挺摆的，但这学期（上（夏季小）学期？）开始也有一些计算机的课了，还是想好好学一下的。尤其是 CS:APP，因为系统这块我了解的不多，相比程设训练、软件工程什么的还是不太有信心。就算暑假摆了，也不能靠听课学吧，~~不会真的有什么东西是听课学能学会的吧（~~

看的书是当前最新的第三版。虽然听说 CS:APP 的中文翻译质量还不错，但我感觉术语翻译应该多少还是会有些奇怪，就还是看的英文版（~~如果有不翻译术语的中文版就好了~~）。一开始看的是 Global Edition，然后发现习题答案错的离谱，[勘误表](https://csapp.cs.cmu.edu/3e/errata.html) 也说放弃 Global Edition 了，就换成了 North American Edition。

因为这本书有很多细节知识点，~~而且废话很多~~，感觉是适合做笔记的，~~正好博客也缺内容~~，就想在博客上写学习笔记。

然后，因为是在上课的“同时”写这些学习笔记，我希望是能在每节课之前写完相应内容的部分，这样的话就不会有课堂内容外泄的嫌疑了（虽然就算是上课记的笔记公开分享也不会有什么问题，吧 🤔）；除去避嫌的原因，也是督促自己跟上进度。（如果只是把上课讲的内容提前自学倒还压力不大，但上课有跳过不讲的（盲猜有的部分会放到大三的组成原理讲 🤔），也有不按书的顺序讲的，我还是想按书的顺序学完，就有点难顶了。）

UPD：因为其他课的作业以及自己的摆烂，还是搞不完了..只能跟着课程的顺序跳着学了，起码保证课上讲的内容提前自学..

书的第一章是总览性的介绍，就跳过不写学习笔记了。

系列目录可以看 [tag: csapp](/tag/csapp)。
`},{title:f,tags:"TeX R 物理实验 经验分享",content:`这学期选了物理实验B。

以前基本上只在 Markdown 里写 LaTeX，没怎么写过 \`.tex\`，R 则完全没有接触过。理论上我应该好好学一学再用，但实际上没时间好好学。总不能用 Word 写实验报告并且手算吧（

这里总结一下我写实验报告用到的 TeX 和 R。



## TeX

### 中文

\`\`\`tex
\\documentclass[UTF8, 11pt, fontset=none]{ctexart}  % 需要禁用默认 fontset 才能自定义字体
\\setCJKmainfont{Source Han Serif SC}
\\usepackage[T1]{fontenc}
\`\`\`

### 基本页面格式

\`\`\`tex
\\ctexset{section/format=\\Large\\bfseries}  % 参照讲义上的格式，标题左对齐
\\usepackage[a4paper, hmargin=1.5cm, vmargin=2cm]{geometry}  % 页面大小和边距
\\usepackage{enumitem}
\\setlist{topsep=0pt,itemsep=-4pt}  % 列表间距
\\pagestyle{plain}                  % ctex 默认的页码在右上角，改成下方
\\setlength{\\parskip}{0.5em}        % 段落间距
\`\`\`

### PDF metadata

\`\`\`tex
\\usepackage[pdfusetitle]{hyperref}
\`\`\`

### 标题

\`\`\`tex
\\title{实验名称\\ 实验报告}
\\author{姓名}
\\makeatletter

\\begin{center}
    \\LARGE
    \\textbf{\\@title}

    \\vspace{0.5cm}
    \\normalsize
    实验者姓名: \\@author\\hspace{15pt}
    学号: 2021000000\\hspace{15pt}
    实验日期: 2202年10月32日\\hspace{15pt}
    实验台号: 1\\hspace{15pt}
    \\vspace{0.5cm}
\\end{center}
\`\`\`

### 章节

\`\`\`tex
\\section{实验目的}

\\subsection{测一下这个东西}
\`\`\`

### 图表

\`\`\`tex
\\usepackage{graphicx}
\\usepackage{float}
\\usepackage[hidelinks]{hyperref}  % 使用 hidelinks 选项来禁用链接的红框
\\usepackage{cleveref}
\\crefname{figure}{图}{图}
\\crefname{table}{表}{表}
\`\`\`

可以用 \`\\label\` 和 \`\\cref\` 来在正文中引用图表，这样就可以避免添加图表时重新标号。

\`\`\`tex
\\begin{figure}[H]
    \\centering
    \\includegraphics[width=0.6\\textwidth]{picture.png}
    \\caption{这是一幅图，老师说图的标题放下面}
    \\label{this-is-a-picture}
\\end{figure}

如\\cref{this-is-a-picture} 所示
\`\`\`

\`\`\`tex
如\\cref{this-is-a-table} 所示

\\begin{table}[H]
    \\centering
    \\caption{这是一张表，老师说表的标题放上面}
    \\vspace{1em}
    \\begin{tabular}{|c|c||c|c|}
        \\hline
        序号 & 值 & 序号 & 值 \\\\
        \\hline
        1  & 1.14 & 6  & 5.14 \\\\ \\hline
        2  & 1.93 & 7  & 5.95 \\\\ \\hline
        3  & 2.74 & 8  & 6.75 \\\\ \\hline
        4  & 3.55 & 9  & 7.53 \\\\ \\hline
        5  & 4.35 & 10 & 8.32 \\\\ \\hline
    \\end{tabular}
    \\label{this-is-a-table}
\\end{table}
\`\`\`

如果想把几张图/表放在单独一页，使得这一页没有其他文字，可以把 \`[H]\` 改成 \`[p]\`。

### 斜线表头

\`\`\`tex
\\usepackage{diagbox}

\\begin{tabular}{|c|}
\\diagbox{左下}{右上}
\\end{tabular}

\\begin{tabular}{|c|}
\\diagbox{左下}{中间}{右上}
\\end{tabular}
\`\`\`

还可以设置其它样式，但应该用不上。

### 多行/多列（合并单元格）

可以参考 [Latex 表格技巧 - 合并单元格\\_TheNetAdmin的博客](https://blog.csdn.net/wzxlovesy/article/details/69063271)。

### 单位、科学计数法、不确定度、角度

\`\`\`tex
\\usepackage[separate-uncertainty=true]{siunitx}[=v2]
\`\`\`

其中 \`[=v2]\` 用来修复使用 \`T1\` 编码时 \`\\micro\` 的样式: [siunitx#619](https://github.com/josephwright/siunitx/issues/619)

\`siunitx\` 这个包解决了若干问题：

-   单位需要用正体，手写的话需要 \`\\mathrm\`
-   数字和单位之间最好有一些间距
-   有的单位会让你纠结怎么写比较好，[例如摄氏度](https://tex.stackexchange.com/questions/258306/how-to-insert-degree-celsius-symbol-in-node-text-in-pgfplots-tikz)
-   科学计数法写 \`\\times 10^\` 比较麻烦
-   比较长的数字不分段的话看不清
-   不确定度和测量结果末位对齐
-   这个包还可以将不确定度写成括号的形式，只不过实验报告的要求是 $\\pm$ 的形式
-   ~~只记得单位的字母，不记得单位的英文名~~

例子：

\`\`\`tex
$t = \\SI{22.5}{\\celsius}$

$v = \\SI{1.91981 \\pm 0.114514 e3}{\\kilo\\metre / \\hour}$
\`\`\`

其中下面那个的渲染效果大概是（没研究这个包的源码，只是看样子大概复刻一下）：

 $v = (1.919\\,810 \\pm 0.114\\,514) \\times 10^3 \\, \\mathrm{km/h}$

\`$v = (1.919\\,810 \\pm 0.114\\,514) \\times 10^3 \\, \\mathrm{km/h}$\`

可以用 \`\\unit\` 来只有单位没有数字，用 \`\\num\` 来只有数字没有单位，或者用 \`\\SI\` 但把一部分留空。

可以用 \`\\ang{1;02;}\` 来显示 $1^\\circ 2'$，用 \`\\ang[parse-numbers=false]{1;02;}\` 来显示 $1^\\circ 02'$，用 \`\\sisetup{parse-numbers=false}\` 来在当前环境（例如表格）内设置 \`parse-numbers=false\`，就不用每条命令单独设置。

更多用法可以参考 siunitx 的文档。

### 模板

<Card fold title="实验报告完整模板">

\`\`\`tex
\\documentclass[UTF8, 11pt, fontset=none]{ctexart}
\\setCJKmainfont{Source Han Serif SC}
\\usepackage[T1]{fontenc}

\\pagestyle{plain}
\\ctexset{section/format=\\Large\\bfseries}
\\usepackage[a4paper, hmargin=1.5cm, vmargin=1.9cm]{geometry}
\\setlength{\\parskip}{0.5em}
\\usepackage{enumitem}
\\setlist{topsep=0pt,itemsep=-4pt}

\\usepackage{amsmath}
\\usepackage[separate-uncertainty=true]{siunitx}[=v2]

\\usepackage{multirow}
\\usepackage{diagbox}

\\usepackage[pdfusetitle, hidelinks]{hyperref}
\\usepackage{graphicx}
\\usepackage{float}
\\usepackage{cleveref}
\\crefname{figure}{图}{图}
\\crefname{table}{表}{表}
\\crefname{page}{页}{页}
\\crefname{section}{节}{节}

\\begin{document}

\\title{XXX\\ 实验报告}
\\author{姓名}
\\makeatletter

\\begin{center}
    \\LARGE
    \\textbf{\\@title}

    \\vspace{0.5cm}
    \\normalsize
    实验者姓名: \\@author\\hspace{15pt}
    学号: 2021000000\\hspace{15pt}
    实验日期: 2022年XX月XX日\\hspace{15pt}
    实验台号: XX\\hspace{15pt}
    \\vspace{0.5cm}
\\end{center}

\\section{实验目的}

\\begin{enumerate}
    \\item
    \\item
    \\item
\\end{enumerate}

\\section{实验仪器}

\\begin{itemize}
    \\item
    \\item
\\end{itemize}

\\newpage

\\section{数据处理及结果}

% \\begin{table}[H]
%     \\centering
%     \\caption{}
%     \\vspace{1em}
%     \\begin{tabular}{|c|c|c|}
%     \\end{tabular}
%     \\label{}
% \\end{table}

% \\begin{figure}[H]
%     \\centering
%     \\includegraphics[width=\\textwidth]{.png}
%     \\caption{}
%     \\label{}
% \\end{figure}

\\newpage

\\section{原始数据记录}

\\begin{center}
\\includegraphics[width=\\textwidth]{data.jpg}
\\end{center}

\\end{document}
\`\`\`

</Card>

## R

### Arch 装 R package

[arch4edu](https://github.com/arch4edu/arch4edu) 有一些 R package，可以减少 AUR 的需求。

### 读取数据

\`\`\`r
data <- readr::read_csv(here::here("data.csv"))
\`\`\`

### 平均数、标准偏差

\`\`\`r
ybar <- mean(data$y)
Sy <- sd(data$y)
\`\`\`

### 线性回归

\`\`\`r
model <- lm(log(y) ~ x, data)
b <- coefficients(model)[2]   # 线性回归系数
r <- cor(log(data$y), data$x) # 相关系数
nu <- df.residual(model)      # 自由度 (n-2)
\`\`\`

### t 因子

\`\`\`r
t <- qt(p=0.025, df=nu, lower.tail=FALSE)
\`\`\`

R 里面有好几个和 student 分布相关的函数，我猜可能有的东西可以直接用这些函数算出来，但我懒得研究了，反正能拿到 t 因子自己代公式就是了（

### 非线性函数的拟合

\`\`\`r
model <- nls(
    y ~ a * cos(2 * pi * (14.5 - x) / lambda),
    data = data,
    start = list(a = 200, lambda = 10)
)
co <- coef(model)
a <- co["a"]
lambda <- co["lambda"]
\`\`\`

如果一个函数长得很奇怪，不能线性拟合，可以用 \`nls\` (Non-linear Least Squares) 来以减小残差平方和为目标进行拟合。

\`nls\` 需要传入 \`start\` 参数作为拟合的起点，可以自己大致估计一下参数大概是多少，如果估计的偏差太大，可能导致最后拟合的结果出错。

### 画图

画出来好像还挺容易的，但要画得好看还得学一学，所以咕了，暂时在用 Excel（

但是画个丑陋的图可以用来检查函数拟合的情况：

\`\`\`r
plot(data)
curve(a * cos(2 * pi * (14.5 - x) / lambda), add = TRUE)
\`\`\`

如果是在 non-interactive 模式下（例如使用 \`R -f foo.R\` 运行），生成的图像默认会放在 \`Rplots.pdf\` 中。
`},{title:x,tags:"csapp 学习笔记 WIP",content:'[CS:APP](https://csapp.cs.cmu.edu/) 第四章 “Processor Architecture” 的学习笔记。\n\n这章的主要内容为一个简化的指令集 Y86-64 的设计以及 Y86-64 处理器的实现（顺序实现和 pipeline 实现）。\n\n\n\n## The Y86-64 Instruction Set Architecture\n\n这部分定义了在这一章中用作演示的名为 “Y86-64” 的玩具 ISA。\n\n### Y86-64 程序状态\n\n-   15 个寄存器（x86-64 的寄存器除去 `%r15`，为了简化编码）\n-   3 个 status flag: `ZF`、`SF`、`OF`\n-   program counter: `PC`\n-   memory\n-   status code: `Stat`，用来表示程序正常运行或发生了异常\n\n### Y86-64 指令\n\nY86-64 指令大致上是 x86-64 的一个子集，但在 operand 等方面有一些简化或区别。\n\noperand 与 x86-64 的区别是：\n\n-   Immediate、Register、Memory 都只有 64 位的版本\n-   Register 只有 15 个\n-   Memory 不支持 `(, ri, s)` 的部分，只能是 `Imm`/`(rb)`/`Imm(rb)`\n\ncondition code 只有六个，即 signed compare: `le`/`l`/`e`/`ne`/`ge`/`g`\n\n指令列表，以及与 x86-64 的区别：\n\n-   `irmovq`/`rrmovq`/`mrmovq`/`rmmovq`，即将 `movq` 按 operand 类型拆成了四个指令\n-   `addq`/`subq`/`andq`/`xorq`，它们只接受寄存器作为 operand，且只设置 `ZF`、`SF`、`OF` 三个 status flag\n-   `jmp`/`jle`/`jl`/`je`/`jne`/`jge`/`jg`，包括 `jmp` 在内都只能跳转到固定的地址，不接受寄存器作为 operand，且这个地址是绝对地址而非相对于 PC 的地址\n-   `cmovle`/`cmovl`/`cmove`/`cmovne`/`cmovge`/`cmovg`，它们只接受寄存器作为 operand\n-   `call`: 地址是绝对地址\n-   `ret`、`pushq`、`popq`、`nop`: 与 x86-64 基本相同\n-   `halt`: 停止运行，将 status code 设为 `HLT`\n\n### Y86-64 指令编码\n\nY86-64 通过对指令的简化，同时也使编码得到了简化，但相应地使得编码不紧凑，会有浪费。\n\nCS:APP Figure 4.2 简明地展示了 Y86-64 的指令编码：\n\n![Y86-64 指令编码示意图](csapp-fig4.2.png)\n\n#### 指令类型的编码\n\n指令编码的第一个 byte 表示指令的类型。这个 byte 的高位叫做 *code*，低位叫做 *function*，其中 function 只在某几个指令有用。特别地，`rrmovq` 和 `cmovXX` 的 code 是相同的，这表示 `rrmovq` 可以看作一种特殊的 `cmovXX`。\n\n算术运算的 function: `add` 0, `sub` 1, `and` 2, `xor` 3\n\ncondition code 的 function: `le` 1, `l` 2, `e` 3, `ne` 4, `ge` 5, `g` 6；`jmp` 的 function 为 0\n\n#### Register Specifier Byte\n\n除了 `jXX` 和 `call`，指令编码的第二个 byte（如果有）的高低位分别表示一个 register identifier。\n\nregister identifier 从 `%rax` 为 `0` 到 `%r14` 为 `E`；`F` 表示不是寄存器。\n\n#### Constant Word\n\n在 `irmovq`、`rmmovq`/`mrmovq`、`jXX`/`call` 中，分别有一个 8-byte 的 constant word，用来表示 immediate value 或地址，byte ordering 是 little endian。\n\n### Y86-64 异常\n\nstatus code `Stat` 有四种可能的取值：\n\n-   `AOK`: 正常\n-   `HLT`: 执行了 `halt` 指令\n-   `ADR`: 访问了不合法的地址\n-   `INS`: 指令编码不合法\n\n在 Y86-64 中，遇到异常后处理器会立即停止运行。\n\n### Y86-64 程序\n\nCS:APP Figure 4.8 展示了一个完整的 Y86-64 程序：\n\n![完整 Y86-64 程序的汇编与机器码](csapp-fig4.8.png)\n\n可以下载 [Y86-64 tools](http://csapp.cs.cmu.edu/3e/sim.tar) 并使用 `yas` 进行汇编，使用 `yis` 模拟运行。编译 `yas` 时 [需要添加 `-fcommon` 编译选项](https://stackoverflow.com/questions/63152352/fail-to-compile-the-y86-simulatur-csapp)。\n\n### 对 %rsp 进行 push/pop\n\n`pushq %rsp`、`popq %rsp` 这两条指令虽然没什么用，但它们的行为可能有歧义，所以在设计 ISA 时明确规定它们的行为是有必要的。\n\nY86-64 遵循和 x86-64 相同的规则：`pushq %rsp` 会将旧的（没有减 8 的）`%rsp` 的值入栈，`popq %rsp` 相当于 `mrmovq (%rsp), %rsp`。\n\n## Logic Design and the Hardware Control Language HCL\n\n这一章中使用玩具语言 HCL (hardware control language) 来描述 Y86-64 处理器的逻辑设计。（与之类似但不是玩具的语言，例如 VHDL、Verilog 等，叫做 “[hardware description language (HDL)](https://en.wikipedia.org/wiki/Hardware_description_language)”。）\n\n### 逻辑门\n\nCSAPP Figure 4.9:\n\n![与或非逻辑门](csapp-fig4.9.png)\n\n-   图中只展示了输入个数为 2 的 AND 和 OR，但可以有更多输入\n-   一旦输入改变，逻辑门的输出很快就会随之改变\n\n### 组合逻辑电路\n\n组合逻辑电路即由若干逻辑门组合而成的电路，它的特点是无状态，输出仅与输入有关，输入改变后输出很快就会随之改变。\n\n在 HCL 中，用逻辑表达式来表示组合逻辑电路，例如 `bool eq = (a && b) || (!a && !b)` 表示计算 `a`、`b` 是否相等的电路。因为它表示的是电路而不是计算，在这条语句之后，一旦 `a`、`b` 的值发生改变，`eq` 的输出也会改变（和 Vue 的 computed 类似）。\n\n### 以 word 为单位进行操作的电路\n\n在处理器的设计中，经常需要对一个 word 而非单个 bit 进行操作。\n\n在 HCL 中，一般使用大写的名称表示 word，例如: `bool Eq = (A == B)` 表示计算 word `A`、`B` 是否相等的电路，可以实现为判断每个 bit 是否相等再 AND。\n\n### Multiplexor (MUX)\n\nmultiplexor (MUX) 的功能是通过信号输入的值来在其它输入中选择一个作为输出，word-level 的 MUX 电路如图 (CSAPP Figure 4.13)：\n\n![word-level MUX 电路](csapp-fig4.13.png)\n\n在 HCL 中，使用 *case expressions* 表示 MUX，例如\n\n```hcl-csapp\nword Mux = [\n    !s1 && !s0: A;\n    !s1: B;\n    !s0: C;\n    1: D;\n];\n```\n\n表示一个由 `s0` 和 `s1` 控制的、在 `A`、`B`、`C`、`D` 中选一个作为输出的 MUX。\n\ncase expression 在逻辑上的语义是依次判断每个条件，以第一个满足的条件作为输出，类似于 Rust 的 match。\n\n下面的 HCL 代码表示计算 `A`、`B`、`C` 中的最小值：\n\n```hcl-csapp\nword Min3 = [\n    A <= B && A <= C: A;\n    B <= C: B;\n    1: C;\n];\n```\n\n### Arithmetic/logic unit (ALU)\n\nALU 是用来进行算术/逻辑运算的组合逻辑电路元件，它接收两个 data input 以及一个表示进行何种运算的 control input，输出运算的结果。\n\n### 测试值是否属于集合\n\n在 HCL 中，可以使用 `in` 来表示测试值是否属于集合的电路，例如: \n\n```hcl-csapp\nbool s1 = code in { 2, 3 };\nbool s0 = code in { 1, 3 };\n```\n\n### Memory and Clocking\n\n组合逻辑电路是无状态且实时更新的；与之相对，memory 可以存储状态，但更新由 clock 控制。\n\n这一章中会用到的 memory 有两大种三小种：\n\n-   clocked register: 存储一个值，有一个输入和一个输出。输出即存储的值，而每次 clock rise 时会将存储的值修改为输入。\n-   random access memory:\n    -   register file: 存储 15 个值（在 Y86-64 处理器中），有两个 read port 和一个 write port：\n        -   每个 read port 有一个输入 `src` 表示 register identifier，有一个输出 `val` 表示这个 register 存储的值，且 `src` 改变后 `val` 会立刻改变。\n        -   write port 有一个输入 `dst` 表示 register identifier，另有一个输入 `val` 用于写入。每次 clock rise 时，如果 `dst` 不是 `F` 就会将 `val` 写入相应的 register。\n    -   data memory: 存储很多个值，用地址进行索引。\n        -   有一个地址输入 `address`。\n        -   有一个信号输入 `write` 表示进行写入而非读取。\n        -   有一个数据输出 `data out`。若 `write` 为 0，`data out` 会立刻输出 `address` 处存储的值。\n        -   有一个数据输入 `data in`。若 `write` 为 1，在 clock rise 时会将 `data in` 写入 `address` 处。\n        -   有一个信号输出 `error`，在 `address` 不是合法地址时输出 1。\n\n可以看到，这几种 memory 的共同点是读取是实时的，但写入由 clock 控制。\n\n在 Y86-64 的程序状态中，寄存器存在 register file 中，status flags、program counter、status code 存在 clocked register 中，memory 存在 data memory 中。\n\nY86-64 处理器还有一个额外的 read-only instruction memory 用来读取指令，而在真实的处理器中这是和内存一体的。\n\n<Card type="question" title="data memory 的 read 信号">\n383 页的图中 data memory 还有一个 `read` 信号，但在文字说明中没有提到它的作用，而对 `write` 信号的说明似乎使得 `read` 信号无用 🤔\n</Card>\n\n## Sequential Y86-64 Implementations\n\n这一节会实现一个名为 SEQ 的顺序执行的处理器。在这个处理器中，指令是按顺序一条接着一条执行的，且每条指令都会在一个 clock cycle 内执行完毕，这要求 clock cycle 很长，会导致处理器的执行很慢，下两节将对此进行优化。\n\n### 指令执行的阶段划分与具体操作\n\n将指令的执行划分为多个阶段，可以使行为有很大差别的不同指令有一定的统一性，方便硬件实现。\n\n本节会将指令执行划分为六个阶段：\n\n1.  Fetch: 将指令编码中不同部分的值读取出来\n2.  Decode: 读取寄存器的值（我感觉 fetch 和 decode 这两个名字互换一下才比较对 🤔）\n3.  Execute: 执行运算\n4.  Memory: 写入或读取内存\n5.  Write back: 写入寄存器\n6.  PC update: 更新 program counter\n\n每个指令每阶段的具体操作如图（CS:APP Figure 4.18~4.21、Solution 4.17）：\n\n![OPq, rrmovq, irmovq](csapp-fig4.18.png)\n\n![rmmovq, mrmovq](csapp-fig4.19.png)\n\n![pushq, popq](csapp-fig4.20.png)\n\n![jXX, call, ret](csapp-fig4.21.png)\n\n![cmovXX](csapp-sol4.17.png)\n\n### SEQ 的主体电路\n\nCS:APP Figure 4.23 大致展示了 SEQ 的主体电路：\n\n![SEQ 主体电路](csapp-fig4.23.png)\n\n其中蓝色的元件是 black box，灰色的元件会在后面进行设计，还有部分电路连接没有画出来。\n\n这个电路大概看着有个印象即可，细节会在后面说明。\n\n### SEQ 的时序控制\n\n在 SEQ 中，每个时钟周期执行一条指令，而时钟控制的只有各种 memory 的写入，memory 的读取和运算都是用组合逻辑电路实现的，虽然在逻辑上有执行顺序，在电路上却是同时执行的，可以看成一个关于 memory 的函数。\n\n也就是说，整个执行过程是：读取 memory 并计算出需要写入 memory 的值，然后在 clock rise 时执行写入，从而读取到新的 memory 的值而执行下一条指令。\n\n为了这个设计能够实现，一条重要的原则是 “No reading back”，即一条指令不能先更新再读取同一个值。例如，在 `pushq` 中，不是先更新 `R[%rsp]` 再写入 `M[R[%rsp]]`，而是先算出 `valE`，再写入 `M[valE]`，最后将 `valE` 写入 `R[%rsp]`。又例如，有的指令会修改 status flags，有的会读取，但没有指令既修改又读取。\n\n因为运算都是同时进行的，执行的六个阶段实际上是六个部分。\n\n### SEQ 的具体实现\n\n\n'},{title:v,tags:t,content:"[CS:APP](https://csapp.cs.cmu.edu/) 第七章 “Linking” 的学习笔记。\n\n这章的主要内容为程序的链接。学习链接有助于：理解链接报错，避免链接相关的 bug，理解变量（函数）的作用域，理解程序运行过程中与链接相关的步骤，了解如何使用共享库（动态链接库）。\n\n\n\n## Compiler Drivers\n\n编译源文件其实分成若干步骤，compiler driver（如 gcc）会依次调用这些步骤，可以用 `gcc -v` 来查看这些步骤的详细信息。\n\n1.  `cpp`: 预处理，源代码 `.c` ->  intermediate file `.i`\n2.  `cc1`: `.i` -> 汇编代码 `.s`\n3.  `as`: `.s` -> relocatable object file `.o`\n4.  `ld`: 链接，多个 `.o` (或 library) -> executable object file\n\nP.S. 中间步骤的文件也可以作为参数传递给 `gcc`，例如 `gcc a.s -o a`。\n\n## Static Linking\n\n静态链接主要有两个任务：\n\n1.  *Symbol resolution*: relocatable object file 中有很多 symbol，包括函数、全局变量、静态变量等，linker 需要将每个 symbol reference 对应到一个 symbol definition。\n2.  *Relocation*: relocatable object file 中地址从 0 开始，linker 需要将每个 symbol definition 重新分配到正确的地址，并相应地修改每个 symbol reference。\n\n## Object Files\n\nobject file 分为三种：\n\n1.  Relocatable object file\n2.  Executable object file\n3.  Shared object file: 一种特殊的 relocatable object file，可以在 load time 或 run time 进行动态链接\n\nobject file 有不同的格式，Windows 使用 Portable Executable (PE) 格式，macOS 使用 Mach-O 格式，现代的 x86-64 Linux/Unix 系统使用 Executable and Linkable Format (ELF) 格式。本章会基于 ELF-64。\n\n## Relocatable Object Files\n\nELF relocatable object file 通常包含以下 section：\n\n1.  `.text`: 程序的机器码\n2.  `.rodata`: 只读的数据\n3.  `.data`: 需要初始化的全局变量和静态变量\n4.  `.bss`: 未初始化或初始化为零的全局变量和静态变量，它们在运行时会以零为初值，从而在 object file 中不占据文件大小\n5.  `.symtab`: symbol table，存储 symbol（函数、全局变量）的信息，不需要 `-g` 编译选项，但不含局部变量的信息\n6.  `.rel.text`: 列出了 `.text` 中在链接时需要修改的地方，一般是调用外部函数或引用全局变量时需要修改，而 [调用本地函数不需要修改](/post/2022/09/csapp-3#jump-指令编码)\n7.  `.rel.data`: 列出了 `.data` 中在链接时需要修改的地方，一般是全局变量的值为其他全局变量或外部函数的地址时需要修改\n8.  `.debug`: 调试信息，包含局部变量的信息、typedef 信息、源代码等，需要 `-g` 编译选项才有\n9.  `.line`: 源代码与机器码行号间的对应关系，需要 `-g` 编译选项才有\n10. `.strtab`: 一堆字符，用于其它 section，可以指向其中一个位置来表示一个字符串（从这个位置起到 `\\0` 为止）\n\n## Symbols and Symbol Tables\n\n对 linker 来说，symbol 有三种：\n\n1.  本地定义，可以被外部访问的: C 中非 `static` 的函数和全局变量\n2.  外部定义的，例如 C 中 `extern` 的全局变量\n3.  本地定义，外部不可访问的: C 中 `static` 的函数和变量\n\n一个 ELF64 symbol 包含如下信息（CS:APP Figure 7.4）：\n\n```c\ntypedef struct\n{\n    int   name;      /* String table offset */\n    char  type:4,    /* Function or data (4 bits) */\n          binding:4; /* Local or global (4 bits) */\n    char  reserved;  /* Unused */\n    short section;   /* Section header index */\n    long  value;     /* Section offset or absolute address */\n    long  size;      /* Object size in bytes */\n} Elf64_Symbol;\n```\n\n`value` 在 relocatable object file 中是 symbol 的地址相对于 section 开头的 offset，在 executable object file 中是 symbol 的绝对地址。\n\n`section` 是 object file 的 section 之一（的 index），在 relocatable object file 中还可以是一个 pseudosection:\n\n-   ABS: 不应被 relocate 的 symbol\n-   UNDEF: 未定义（在其他 module 中定义）的 symbol\n-   COMMON: 多个 module 共用的 symbol（见 [Symbol Resolution](#symbol-resolution)），此时 `value` 的值给出 data alignment 的要求，`size` 给出的是 minimum size\n\n未初始化的静态变量以及初始化为零的全局或静态变量会放在 `.bss`。\n\n未初始化的全局变量，如果启用了 `-fcommon` 编译选项则会放在 COMMON，否则放在 `.bss`。在 gcc 9 及之前默认选项是 `-fcommon`，而自 gcc 10 起默认选项是 `-fno-common`。在 C++ 中 `-fcommon` 是无效的，未初始化的全局变量总是放在 `.bss`。\n\n可以使用 `readelf -s a.o` 来查看 `a.o` 的 `.symtab`。\n\n## Symbol Resolution\n\nSymbol resolution 即把每个 symbol reference 对应到一个 symbol definition。\n\nlocal symbol 的 resolution 是容易的，因为编译单个 module 时就保证了 local symbol 是唯一的。\n\nglobal symbol 可能遇到几种情况：\n\n-   只有一个 module 里定义了这个 global symbol，则使用这个 symbol\n-   没有任何 module 里定义了这个 global symbol，则报错 undefined reference\n-   在多个 module 里定义了这个 global symbol，则：\n    -   如果其中有多个 symbol 不在 COMMON 段，则报错 multiple definition\n    -   如果其中只有一个不在 COMMON 段，则使用这个 symbol\n    -   如果这些 symbol 都在 COMMON 段，则使用其中 `size` 最大的一个（如果 `size` 相同则使用哪个是没有区别的）；如果这些 symbol 有不一样的 `size`，linker 还会给出警告\n\n也就是说，若编译选项为 `-fcommon`，如果在多个 module 中定义了同一个全局变量且其中最多有一个初始化了，则可能导致意外的结果。可以理解为，multiple definition 在本质上是 multiple initialization。\n\n在 C++ 中，函数重载、类方法会通过 *mangling* 来使得函数的每种重载有独特的 symbol name。\n\n## Static Libraries\n\nStatic library 其实就是一堆 object file 包装在一起，它的好处是：\n\n1.  不用每次重新编译（比起提供源码）\n2.  使得库和编译器解耦（比起将库函数内置到编译器中）\n3.  只需将用到的 object file 复制到最终的可执行文件中，避免空间浪费（比起提供单个 object file）\n4.  可以自动选择用到的 object file，在编译命令中只需指定少量库的名称（比起提供一堆 object file）\n\n可以使用类似 `ar rcs libabc.a a.o b.o c.o` 的命令来创建一个 static library。\n\n在编译时，有两种使用 static library 的方式：\n\n-   直接将 static library 的路径作为参数: `libabc.a`\n-   使用 `-lname` 来使用 `libname.a`，但需要使用 `-Ldir` 来将 `dir` 加入到 `-l` 的搜索路径之中: `-L. -labc`\n\n特别地，编译器会自动将 `libc.a` 提供给 linker，不需要手动指定。\n\n在链接时，linker 会依次处理每个参数：\n\n-   如果一个参数是 object file 就一定会使用\n-   如果是 static library，则会依次查看其中包含的每一个 object file，如果一个 object file 中定义了某个当前引用了但仍未定义的 symbol，则会使用这个 object file，而这样的过程会反复迭代进行直到没有新的 object file 被使用为止（例如 `main.c` 引用了 `b.o` 而没有引用 `a.o`，而 `b.o` 中引用了 `a.o`，且在 `libabc.a` 中 `a.o` 位于 `b.o` 之前，那么第一次迭代中只会使用 `b.o`，第二次迭代才会使用 `a.o`，而 `c.o` 不会被使用）\n\n这样的过程使得编译命令中参数的顺序以及 static library 中 object file 的顺序可能影响编译结果：\n\n-   一般来说需要将 library 放在编译命令的末尾，否则处理一个 library 时还没有引用其中的 symbol，就不会使用相应的 object file，最后就会报错 undefined reference\n-   如果多个 library 之间有依赖关系，需要将被其他 library 依赖的 library 放在靠后的位置\n-   如果多个 library 之间有循环依赖，可能需要在编译命令中多次指定同一个 library（或者也可以将这两个 library 合并成一个，这样的话通过多次迭代就可以解决循环依赖）\n-   library 的设计应当避免 multiple definition，但理论上存在不同的参数顺序或 static library 中 object file 的顺序导致 multiple definition 的可能\n\n## Relocation\n\nrelocation 分为两步：\n\n1.  给 symbol definition 重新分配内存地址\n2.  相应地修改 symbol reference\n\n第一步是简单的，把各个 object file 中的各个 section 分别拼在一起即可。\n\n为了让 linker 知道如何修改 symbol reference，需要让 linker 知道：\n\n1.  需要被修改的 symbol reference 在哪\n2.  需要修改成什么\n\n在 relocatable object file 的 `.rel.text` 和 `.rel.data` 中存放了相关的信息，一条这样的信息称作一个 relocation entry，包含的内容为：\n\n-   `offset`: 这个 symbol reference 相对于其所在的 section 的偏移量。也就是说，在这个 reference 所在的 section 的地址的基础上加上 `offset` 就得到了这个 reference 的地址。\n-   `type`: 有很多种 relocation，CS:APP 中只介绍其中的 `R_X86_64_PC32` 和 `R_X86_64_32` 两种。\n-   `symbol`: 被 reference 的 symbol 在 symbol table 中的 index。\n-   `addend`: 计算 symbol 地址时加在最后的常数（见后文）。\n\n简单来说，`R_X86_64_32` 使用绝对地址进行定位，`R_X86_64_PC32` 使用相对于 PC 的地址进行定位，且这两种类型的 relocation 都只支持 32 位的地址（如果一个程序的大小超过 2GB，就需要指定编译选项 `-mcmodel=medium/large`）。\n\n-   `R_X86_64_32`: 修改后的 reference 为 symbol 的地址加上 `addend`\n-   `R_X86_64_PC32`: 修改后的 reference 为 symbol 的地址与 reference 的地址之差加上 `addend`；需要注意的是，是与 reference 的地址之差，而不是与执行到 reference 所在语句时的 PC 之差，所以通常会需要通过 `addend` 来修正\n\n可以使用 `objdump -dx` 以在反汇编结果中显示 relocation entry，或者使用 `readelf -r` 显示所有 relocation entry。\n\n例如，使用 GCC 8.5 编译\n\n```c\nint foo(int *arr);\n\nint a[3] = {1, 2, 3};\nint *b = &a[2];\n\nint bar()\n{\n    return foo(&a[1]);\n}\n```\n\n`readelf -r`:\n\n```\nRelocation section '.rela.text' at offset 0x250 contains 2 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000001  000a0000000a R_X86_64_32       0000000000000008 a + 4\n000000000006  000b00000002 R_X86_64_PC32     0000000000000000 foo - 4\n\nRelocation section '.rela.data' at offset 0x280 contains 1 entry:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000000  000a00000001 R_X86_64_64       0000000000000008 a + 8\n```\n\n在 `.rela.text` 中，`a` 的 `addend` 是 `4`，是直接得到 `a[1]` 而非 `a[0]` 的地址；`foo` 的 `addend` 是 `-4`，是因为 reference 的地址是 reference 所在的 `jmp` 指令的下一条指令的地址减 4，导致 PC 的地址加上 `foo` 的地址减去 reference 的地址得到的是 `foo` 的地址加 4，需要 `addend` 来修正。\n\n## Executable Object Files\n\n可执行文件的内容大体上和 relocatable object file 类似，主要的区别是：\n\n-   在 ELF header 中指定了程序的 entry point\n-   有一个 `.init` section，定义了一个简单的函数，用来初始化程序\n-   有一个 program header table，描述了程序文件与内存的对应关系，即要把文件的哪一段映射到内存的哪一段，地址如何对齐，以及每一段的权限（`.init`、`.text`、`.rodata` 的权限为 `r-x`，`.data` 和 `.bss` 的权限为 `rw-`）\n-   `.symtab`、`.debug`、`.line`、`.strtab` 在执行时不会加载到内存中\n-   如果 fully linked，则没有 `.rel` section\n\n## Loading Executable Object Files\n\n在程序运行时，run-time memory image 大致如下图（CS:APP Figure 7.15）所示：\n\n![Linux x86-64 run-time memory image](csapp-fig7.15.png)\n\n（[errata](https://csapp.cs.cmu.edu/3e/errata.html) 中指出，栈的起始地址并不是 $2^{48}-1$。）\n\n因为地址对齐、address-space layout randomization 等原因，实际上的内存结构会与上图有一定的差异，但每一段的相对位置是和图中一致的。\n\nloader 加载可执行文件时，首先创建 memory image，然后根据 program header table 将可执行文件的内容映射到内存中，最后跳转到程序的 entry point。C 语言程序的 entry point 是 `_start` 函数（在 `crt1.o` 中定义）的地址，`_start` 又会调用 `__libc_start_main` 函数（在 `libc.so` 中定义），进行运行环境的初始化，然后调用 `main` 函数，最后对返回值进行处理。\n\n## Dynamic Linking with Shared Libraries\n\n静态库有一些问题：\n\n1.  更新静态库需要重新链接\n2.  每个程序都有一份库的拷贝，会造成空间的浪费\n\n共享库 (shared library) 可以解决这些问题。共享库可以在 run time 或者 load time 被动态链接。动态链接由 dynamic linker 完成。共享库也被称作 shared object，在 Linux 中后缀名为 `.so`，在 Windows 中被叫做 DLL。\n\n共享库在两个层面上被共享：\n\n1.  在文件系统上只有一份 `.so` 文件，而在可执行文件中没有库的拷贝\n2.  在内存中共享库的 `.text` section 的单份拷贝可以被多个进程同时使用\n\n可以用类似于 `gcc -shared -fpic a.c b.c c.c -o libabc.so` 的命令构建共享库。编译选项中 `-shared` 告诉编译器要生成 shared object，`-fpic` 用来生成 [position-independent code](#position-independent-code-pic)。\n\n可以用类似 `gcc main.c ./libabc.so -o main` 的命令来使用共享库。\n\n运行 `main` 时，loader 会在进入 entry point 前在 `.interp` section 中发现 dynamic linker `ld-linux.so`，于是让 dynamic linker 完成共享库的 relocation 并修改程序中的 symbol reference，最后将控制权交还给程序。\n\n## Loading and Linking Shared Libraries from Applications\n\n除了在编译时指定要链接到的共享库并在 load time 链接，也可以在 run time 加载并使用共享库。\n\nC 语言中的相关函数放在 `dlfcn.h` 头文件中，编译时需要 `-ldl` 来使用这些函数：\n\n-   `void *dlopen(const char *filename, int flag)`: 加载共享库\n\n    -   返回值: 成功加载则返回 handle，否则返回 `NULL`\n\n    -   `filename`: 共享库文件名\n\n    -   `flag`: 影响如何处理共享库中引用的 external symbol，必须包含 `RTLD_NOW` 和 `RTLD_LAZY` 两者之一\n\n        -   `RTLD_NOW`: 立即 resolve 所有 external symbol\n        -   `RTLD_LAZY`: 等到运行共享库中的代码时再 resolve external symbol\n        -   `RTLD_GLOBAL`: 之后给其他共享库 resolve external symbol 时可以使用当前这个共享库\n\n        如果编译程序时启用了 `-rdynamic` 选项，在 resolve external symbol 时，除了使用其他加载时启用了 `RTLD_GLOBAL` 选项的共享库，也可以使用程序自身的 global symbol。\n\n-   `void *dlsym(void *handle, char *symbol)`: 获得共享库中某个 symbol 的地址\n\n    -   `symbol`: symbol 名称\n\n    -   返回值: 成功获取则返回 symbol 地址，否则返回 `NULL`\n\n-   `int dlclose(void *handle)`: 关闭共享库\n\n    -   返回值: 成功关闭则返回 `0`，出错则返回 `-1`\n\n-   `const char *dlerror(void)`: 获取最后一次调用 `dlopen` / `dlsym` / `dlclose` 的报错信息，如果最后一次调用没有出错则返回 `NULL`\n\nCS:APP 给出了一份参考代码 [code/link/dll.c](https://csapp.cs.cmu.edu/3e/ics3/code/link/dll.c)。\n\n## Position-Independent Code (PIC)\n\n共享库的一条重要性质是它的代码段在内存中只有一份，而可以被多个进程共享，这就使得它的代码中的 symbol reference 不能在动态链接时被修改，适用于静态链接的 relocation 无法完成，所以共享库的代码需要是 position-independent 的。\n\nPIC 的主要思路基于以下两点：\n\n1.  虽然共享库的代码段是共享的，但数据段是每个进程各有一份的\n2.  无论整个共享库被放到内存的哪个位置，代码段和数据段地址的距离是固定的（这与上一条不矛盾，应该是因为虚存）\n\n因此，可以在数据段中存放效果相当于 relocation 的信息，来间接达到 relocation 的效果。说白了就是，因为没法修改代码段，所以把 symbol 的地址放到数据段里。具体实现中，数据段的开头有一个 *global offset table* (GOT)，表中每一项都是一个地址，可以由 dynamic linker 进行修改，而由于代码段和数据段的地址距离固定，就可以用 PC-relative 的方式寻址到表中的项。\n\nPIC data reference 是简单的，只要在 GOT 中为每个 data symbol (全局或 static 变量) 创建一个表项，在动态链接时由 dynamic linker 修改这些项，而在代码中通过这个表项来间接地进行 data reference，例如 (CS:APP Figure 7.18，`GOT[3]` 中存放了全局变量 `x` 的地址)：\n\n```asm\n    movq Ox2OO8b9(%rip), %rax   # %rax = *GOT[3] = &x\n    addl $0x1, (%rax)           # ++x\n```\n\n如果是本地定义的变量，也可以使用 PC-relative 的定位方式直接引用，而只对外部定义的变量使用 GOT，但编译器也可能选择不做这样的区分而是使用统一的方法来处理。\n\nPIC procedure call 也可以和 data reference 一样处理（可以用 `-fno-plt` 编译选项来这样做），但实际上会使用名为 *lazy binding* 的技术进行优化。\n\n这是因为，链接到一个共享库时，往往最终会调用的只是它提供的大量函数中的一小部分，如果对整个共享库用到的外部函数都在动态链接时计算出相应的 offset，就可能造成浪费。而 lazy binding 则是在第一次调用某个外部函数时绑定这个函数的地址。\n\nlazy binding 基于一个名为 *procedure linkage table* (PLT) 的结构。PLT 位于代码段中，表中的每一项其实是三条指令，如 CS:APP Figure 7.19 所示：\n\n![PLT 原理示意图](csapp-fig7.19.png)\n\n整个流程就是：\n\n1.  调用 `addvec` 时，实际上调用的是 `PLT[2]` 的地址\n2.  `PLT[2]` 的第一条指令会跳转到 `GOT[4]`，`GOT[4]` 里一开始放的是 `PLT[2]` 的第二条指令，所以首次调用 `PLT[2]` 时就从第一条指令跳到第二条指令\n3.  第二条指令是往栈里压入 `addvec` 的 ID，是用来告诉 dynamic linker 这是哪个函数\n4.  第三条指令会跳转到 `PLT[0]` \n5.  `PLT[0]` 的第一条指令是往栈里压入 relocation entries 的地址，第二条指令是跳转到 dynamic linker\n6.  dynamic linker 通过放在栈中的函数的 ID 以及 relocation entries 计算出 `addvec` 的地址，放在 `GOT[4]`，然后跳转到 `addvec`\n7.  因为一路上都是 `jmp`，跳转到 `addvec` 后可以正常返回到调用 `PLT[2]` 的位置\n8.  第二次调用 `PLT[2]` 时，`GOT[4]` 里已经是 `addvec` 的地址，所以就在 `PLT[2]` 的第一条指令处跳转到了 `addvec`\n\n## Library Interpositioning\n\nLinux 的链接器支持一个名为 *library interpositioning* 的技术，可以用来把共享库的函数替换掉，一般会换成一个 wrapper function 用来 trace，但也可以换成完全不同的东西。\n\n看了下中文版 CS:APP，这个东西竟然叫“库打桩”（\n\n编译时的 library interpositioning 就是用 `#define` 换掉某个函数 ~~，在机房里被 `#define sort random_shuffle` 过的大家想必对此非常熟悉~~。\n\n链接时的 library interpositioning 是给 linker 传参 `--wrap foo`，然后调用 `foo` 就会实际上调用 `__wrap_foo`，而调用 `__real_foo` 则会调用原本的 `foo`。一般会给 `gcc` 而非 `ld` 传参，就是用 `gcc -Wl,--wrap,foo` 代替 `ld --wrap foo`，其中 `-Wl` 表示给 linker 传参，后面的逗号会被换成空格。\n\n运行时的 library interpositioning 是在运行程序时设置环境变量 `LD_PRELOAD=\"/path/to/wrapper.so /path/to/anotherwrapper.so\"`，然后在使用任意共享库中的函数之前就会优先尝试使用 `wrapper.so` 和 `anotherwrapper.so`。这时，为了能在 wrapper function 中调用原本的函数，就需要 [在运行时加载共享库](#loading-and-linking-shared-libraries-from-applications)。\n\n如果想看具体实现，可以参考 CS:APP。\n\n编译时的 library interpositioning 需要修改源代码，链接时的 library interpositioning 需要获取到 object file 并重新链接得到可执行文件，而运行时 library interpositioning 只需要设置环境变量，不需要对可执行文件进行任何修改，可以方便地对很多不同程序的某个函数调用进行跟踪。\n"},{title:y,tags:"gcc 性能优化 问题解决记录",content:`在学习 [浮点数精度转换指令](/post/2022/09/csapp-3#浮点数精度转换) 时，CS:APP 里提到 gcc 并不使用 \`vcvtss2sd\`/\`vcvtsd2ss\`，而是使用 \`vunpcklps\` & \`vcvtps2pd\` / \`vmovddup\` & \`vcvtpd2psx\`，但是我使用 gcc 12.2.0 编译得到的结果就是 \`vcvtss2sd\`/\`vcvtsd2ss\`。对此，CS:APP 没有深究：

> It is unclear why GCC generates this code. There is neither benefit nor need to have the value duplicated within the XMM register.

但是 CS:APP 选择放弃反而会激发读者的斗志啊（

虽然但是，我确实没想到这玩意会让我断断续续搞了三天，ddl 又要寄了 🌚



## 问题描述

这一问题可以由下面的代码所展示：

\`\`\`c
double f2d(float x)
{
    return x;
}

float d2f(double x)
{
    return x;
}

double fp2d(float *x)
{
    return *x;
}

float dp2f(double *x)
{
    return *x;
}
\`\`\`

它编译成汇编的结果有如下几种：

<Card title="编译结果" fold>

汇编中不重要的部分已省去。

A:

\`\`\`asm
f2d:
    cvtss2sd    %xmm0, %xmm0
    ret
d2f:
    cvtsd2ss    %xmm0, %xmm0
    ret
fp2d:
    pxor        %xmm0, %xmm0
    cvtss2sd    (%rdi), %xmm0
    ret
dp2f:
    pxor        %xmm0, %xmm0
    cvtsd2ss    (%rdi), %xmm0
    ret
\`\`\`

B：

\`\`\`asm
f2d:
    unpcklps    %xmm0, %xmm0
    cvtps2pd    %xmm0, %xmm0
    ret
d2f:
    unpcklpd    %xmm0, %xmm0
    cvtpd2ps    %xmm0, %xmm0
    ret
fp2d:
    movss       (%rdi), %xmm0
    cvtps2pd    %xmm0, %xmm0
    ret
dp2f:
    movq        (%rdi), %xmm0
    cvtpd2ps    %xmm0, %xmm0
    ret
\`\`\`

A with AVX2：

\`\`\`asm
f2d:
    vcvtss2sd   %xmm0, %xmm0, %xmm0
    ret
d2f:
    vcvtsd2ss   %xmm0, %xmm0, %xmm0
    ret
fp2d:
    vxorps      %xmm0, %xmm0, %xmm0
    vcvtss2sd   (%rdi), %xmm0, %xmm0
    ret
dp2f:
    vxorps      %xmm0, %xmm0, %xmm0
    vcvtsd2ss   (%rdi), %xmm0, %xmm0
    ret
\`\`\`

B with AVX2：

\`\`\`asm
f2d:
    vunpcklps   %xmm0, %xmm0, %xmm0
    vcvtps2pd   %xmm0, %xmm0
    ret
d2f:
    vmovddup    %xmm0, %xmm0
    vcvtpd2psx  %xmm0, %xmm0
    ret
fp2d:
    vmovss      (%rdi), %xmm0
    vcvtps2pd   %xmm0, %xmm0
    ret
dp2f:
    vmovq       (%rdi), %xmm0
    vcvtpd2psx  %xmm0, %xmm0
    ret
\`\`\`

</Card>

| 函数 |          A          |            B            |      A with AVX2       |        B with AVX2        |
| :--: | :-----------------: | :---------------------: | :--------------------: | :-----------------------: |
| f2d  |     \`cvtss2sd\`      | \`unpcklps\` & \`cvtps2pd\` |      \`vcvtss2sd\`       | \`vunpcklps\` & \`vcvtps2pd\` |
| d2f  |     \`cvtsd2ss\`      | \`unpcklpd\` & \`cvtpd2ps\` |      \`vcvtsd2ss\`       | \`vmovddup\` & \`vcvtpd2psx\` |
| fp2d | \`pxor\` & \`cvtss2sd\` |  \`movss\` & \`cvtps2pd\`   | \`vxorps\` & \`vcvtss2sd\` |  \`vmovss\` & \`vcvtps2pd\`   |
| dp2f | \`pxor\` & \`cvtsd2ss\` |   \`movq\` & \`cvtpd2ps\`   | \`vxorps\` & \`vcvtsd2ss\` |  \`vmovq\` & \`vcvtpd2psx\`   |

问题在于，gcc 为什么/在什么情况下会生成如 B 所示的指令。其中，使用两条理解起来都不太容易的指令（\`unpcklps\`、\`cvtps2pd\`）来代替指令集中自带的 \`cvtss2sd\`/\`cvtsd2ss\` 最令人费解。而 source 为指针的另外两个函数是受 [performance - Why don't GCC and Clang use cvtss2sd \\[memory\\]? - Stack Overflow](https://stackoverflow.com/questions/16597587/why-dont-gcc-and-clang-use-cvtss2sd-memory) 启发。

我先尝试了各种关键词用搜索引擎进行搜索，均未找到答案。

## gcc 版本的定位

使用 [Compiler Explorer](https://gcc.godbolt.org/) 进行尝试，很快就能确认，是在 gcc 4.8.5 / 4.9.0 之间行为出现了变化。

于是，我先看了 [gcc 4.9 changes](https://gcc.gnu.org/gcc-4.9/changes.html)，又在 commit log 里大力搜索 “\`cvtss2sd\`” “\`cvtsd2ss\`” “\`unpcklp\`” “floating point” “convert”……都没找到相关内容。

## 具体 commit 的定位：git bisect / 编译 gcc

在各种搜索都失败后，我决定使用 \`git bisect\` 找到行为出现变化的 commit。

要 bisect，就得编译 gcc 4.8.5 ~ 4.9.0，步骤大致如下：

1.  将 gcc 代码 clone 下来: \`git clone https://github.com/gcc-mirror/gcc --branch releases/gcc-4.9 --depth 50000\`
2.  创建 \`build\` 目录
3.  在 \`build\` 目录下运行 \`gcc\` 仓库根目录的 \`configure\` 脚本
4.  在 \`build\` 目录下运行 \`make\`

其中，\`configure\` 的配置可以参考 [Installing GCC: Configuration - GNU Project](https://gcc.gnu.org/install/configure.html)，但我只是 bisect 一下，就没仔细研究。

过程中走的弯路就不一一细说了，只说一下最终的解决方案中遇到的几个主要问题。

最终的编译命令为:

\`\`\`sh
CC=gcc-4.8
CXX=g++-4.8
make distclean
../gcc/configure --enable-languages=c --disable-multilib --disable-libsanitizer
make -j$(nproc)
\`\`\`

### 语言标准问题

因为编译的是多年前的 gcc 4.8~4.9，用现在的编译器会遇到一些语言标准不同的问题。修改编译选项大概能解决问题，但改起来麻烦，也不见得能解决所有问题，不如直接用旧版 gcc 来编译。

~~但是现在目标就是编译旧版 gcc，你哪来的旧版 gcc 用来编译？~~

用旧版 gcc 解决编译旧版 gcc 遇到的问题看起来很矛盾，但我们要解决的是编译两个版本之间的一堆 commit，而获得一个用来编译的旧版 gcc 只需要一个 gcc release 的可执行文件。这个用来编译的旧版 gcc 可以用各种方式下载一个，而我用的是 Arch Linux，就装了 [AUR 里的 gcc48](https://aur.archlinux.org/packages/gcc48)。

获得了一个旧版 gcc 后，运行 \`configure\` 时修改环境变量 \`CC\` 和 \`CXX\` 即可使用。

P.S. 我本来想用 AUR 的 PKGBUILD 来编译，但能编译 release 不代表能编译各个 commit，然后踩各种坑踩了半天..

### struct ucontext

还会遇到一个编译错误: \`md-unwind-support.h:65:47: error: dereferencing pointer to incomplete type 'struct ucontext'\`

将相应代码中的 \`ucontext\` 修改为 \`ucontext_t\` 即可。

reference: [How to compile gcc 6.4.0 with gcc 7.2 in Archlinux - Stack Overflow](https://stackoverflow.com/questions/46999900/how-to-compile-gcc-6-4-0-with-gcc-7-2-in-archlinux)

### libsanitizer

还会遇到一些编译错误，在搜索其中一个的解决方案时，我找到了 [一次令人吐血的 ubuntu 源码安装 gcc-5.4.0 经历\\_亿零贰肆的博客-CSDN 博客\\_ubuntu 安装 gcc5.4.0](https://blog.csdn.net/tuibianhuaisheng/article/details/115399019)。

这篇博客也提到了上面说的 \`struct ucontext\` 的问题，而仔细一看就会发现，剩下其他问题全都是 \`libsanitizer\` 里的，而我研究这个问题不需要 \`libsanitizer\`，直接 \`--disable-libsanitizer\` 就能解决这一堆编译错误还能缩短编译用时。

### make distclean

修改各种选项或者更换 commit 后，如果直接 \`make\` 容易出问题，可以先 \`make distclean\` 来重置。

### git bisect

在处理完上面几个问题之后，编译就很顺利了。在我 8C16T 的 AMD Ryzen 7 4800H 上，编译一次大约需要 9min。

需要注意的是，因为原问题可以看成是在更老的版本出现，即新版本 good 老版本 bad，但 \`git bisect\` 默认是老版本 good 新版本 bad，这里容易搞反，需要注意。（\`git bisect\` 可以把 good/bad 改成 old/new，但我懒得（研究怎么）改了。）

bisect 找到的 commit 是 [915e8e6e](https://github.com/gcc-mirror/gcc/commit/915e8e6eec05fb595d445cb738e4875d607ce126)。

从这个 commit 的内容可以得知，那些看起来有些奇怪的编译结果是一个叫做 \`use_vector_fp_converts\` 的优化的结果。这个 commit 使得这个优化只对 amdfam10 架构生效，在新版 gcc 中仍可使用 \`-mtune=amdfam10\` 选项观察到这一行为（也可以使用 \`-mtune-ctrl=use_vector_fp_converts\` 来启用这个优化）。代码中对这一优化给出的理由是 “avoids partial write to the destination”，也就是说 \`cvtss2sd\`/\`cvtsd2ss\` 只修改目标寄存器的低位，可能导致效率低。

## 优化最终被关闭的原因

锁定了问题出现的 commit，接下来就是搜索这个 commit 修改的原因了。

[在 \`gcc-patches\` 里搜索 \`use_vector_fp_converts\`](https://www.mail-archive.com/search?l=gcc-patches%40gcc.gnu.org&q=use_vector_fp_converts)，然后再顺着邮件内容找，就可以找到相关邮件：

-   [\\[Google\\] X86_TUNE_USE_VECTOR_CONVERTS adjustment](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg59433.html)
-   [\\[PATCH\\] disable use_vector_fp_converts for m_CORE_ALL](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg61372.html) ([157ca3e9](https://github.com/gcc-mirror/gcc/commit/157ca3e989605194001568cc1864603b32fbd025))
-   [Revisit Core tunning flags](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg62058.html)
-   [Re: \\[PATCH i386\\]: Enable push/pop in pro/epilogue for modern CPUs](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg46926.html)

令我自闭的是..直接搜索 \`cvtss2sd\`/\`cvtsd2ss\` 就能搜到这些邮件 😵 为什么 bisect 出来才想着在邮件列表里搜呢...（低情商：wssb；高情商：还是 mailing list 使用经验不足 😢）

总结一下这些邮件的内容，就是：

1.  在一些 Intel CPU 上，某些 test case 上启用 \`use_vector_fp_converts\` 更快，另一些 test case 上不启用更快。
2.  在启用 \`use_vector_fp_converts\` 更快的 test case 上，可以通过在 \`cvtss2sd\`/\`cvtsd2ss\` 之前将 XMM 寄存器清空（\`pxor %xmm0, %xmm0\`）以避免只更新低位带来的性能损失，从而达到和启用 \`use_vector_fp_converts\` 差不多的性能。所以 [157ca3e9](https://github.com/gcc-mirror/gcc/commit/157ca3e989605194001568cc1864603b32fbd025) 就对 \`m_CORE_ALL\` 关闭了这个优化并且在需要时先将 XMM 寄存器清空。
3.  在 [Re: \\[PATCH\\] disable use_vector_fp_converts for m_CORE_ALL](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg62712.html) 中，Honza 表示可以先把上面那个 patch commit 了，他测试一下再决定是否对 \`m_GENERIC\` 也关闭这个优化，所以 157ca3e9（对 \`m_CORE_ALL\` 关闭优化并在需要时清空 XMM）和 915e8e6e（对 \`m_GENERIC\` 关闭优化）分成了两个 commit。

## 优化最初被添加的原因

继续追根溯源下去，通过 \`git blame\` 来找到一开始添加这个优化的原因。

首先找到 [54723b46](https://github.com/gcc-mirror/gcc/commit/54723b46231868447f68ed5322d916bd05bffae3)，这个 commit 将 \`TARGET_USE_VECTOR_FP_CONVERTS\` 从 \`TARGET_USE_VECTOR_CONVERTS\` 中抽离出来成为单独的优化开关。

然后找到 [4845dbb5](https://github.com/gcc-mirror/gcc/commit/4845dbb50ed31ad03c579364e4b70bbe90e7af99)，这个 commit 添加了 \`X86_USE_VECTOR_CONVERTS\`，即 \`X86_TUNE_USE_VECTOR_FP_CONVERTS\` 的前身。

4845dbb5 的邮件是 [SSE conversion optimization](https://gcc.gnu.org/pipermail/gcc-patches/2007-September/225078.html)，里面写的很简略，就是 “Amdfam10 preffers doing packed conversions destinating SSE register rather than scalar”。

只不过 [performance - Why don't GCC and Clang use cvtss2sd \\[memory\\]? - Stack Overflow](https://stackoverflow.com/questions/16597587/why-dont-gcc-and-clang-use-cvtss2sd-memory) 里还是有一些解释的，反正简单来说就是 partial regisiter update 会有性能损失。

## 对 m_CORE_ALL、m_GENERIC 启用优化的原因

可以发现，一开始有这个优化时，是只对 \`m_AMDFAM10\` 启用的，这和现在是一样的，为什么中间绕了一圈又回到最开始的选择呢？继续寻找对 \`m_CORE_ALL\` 和 \`m_GENERIC\` 启用这个优化的原因。

首先找到 [3ad20bd4](https://github.com/gcc-mirror/gcc/commit/3ad20bd44836e57453b743466f1ca0d591bd10ac)，这个 commit 把相关代码挪了个位置。

然后找到 [3a579e09](https://github.com/gcc-mirror/gcc/commit/3a579e0930abe3ed91977a71284021399339860c)，这个 commit 把 \`m_CORE2I7\` 改成了 \`m_CORE_ALL\`。

然后找到 [3a4ffde6](https://github.com/gcc-mirror/gcc/commit/3a4ffde68cfc6fee3c20d282d6690f2569e2fffa)，这个 commit 修改了一堆处理器架构的 bitmask，然后..把 \`m_AMDFAM10\` 和 \`m_CORE2I7\` 换了个位置 🤔

然后找到 [ab247762](https://github.com/gcc-mirror/gcc/commit/ab2477624b15b5d1fe43972f8f4d6082c6893624)，这个 commit 新增了 \`m_CORE2I7\` 架构并且为它启用了 \`X86_TUNE_USE_VECTOR_FP_CONVERTS\`。这个 patch 的邮件是 [0005-Switch-Core-2-to-new-tuning](https://gcc.gnu.org/pipermail/gcc-patches/2010-November/300958.html)，给出的原因是 Core 2/i7 比较适合使用 generic tuning，而此时 \`X86_TUNE_USE_VECTOR_FP_CONVERTS\` 是对 \`m_GENERIC\` 启用的，就也对 \`m_CORE2I7\` 启用了。

这时再回头看上面找到的 [54723b46](https://github.com/gcc-mirror/gcc/commit/54723b46231868447f68ed5322d916bd05bffae3)，这个 commit 将 \`TARGET_USE_VECTOR_CONVERTS || TARGET_GENERIC\` 改成了 \`TARGET_USE_VECTOR_FP_CONVERTS\`，所以要 blame 这个 \`|| TARGET_GENERIC\`。

最后找到是 [bf019a1f](https://github.com/gcc-mirror/gcc/commit/bf019a1f7f992a1feb985c4b656e527475e73a30) 添加了 \`|| TARGET_GENERIC\`。这个 patch 的邮件是 [PR target/33396](https://gcc.gnu.org/pipermail/gcc-patches/2007-September/225425.html)，时间上紧跟着最初的 4845dbb5，而 changelog 和邮件里只提到了添加 \`TARGET_SSE_MATH\` 而没有提到添加 \`TARGET_GENERIC\` 的原因，并且这封邮件还没人回复。

至此，我已经不知道能如何继续探究下去了。我感觉可能是：

1.  [SSE conversion optimization](https://gcc.gnu.org/pipermail/gcc-patches/2007-September/225078.html) 中提到 “We are now testing if the patch is good for generic”，可能他自己测试之后因为某些原因得到了这个优化 good for generic 的结论，就 commit 了，也没再解释；
2.  或者是，[PR target/33396](https://gcc.gnu.org/pipermail/gcc-patches/2007-September/225425.html) 里提到了 “failure with 32bit generic”，可能是测试的时候加上了 \`TARGET_GENERIC\`，后来忘记删掉了 🤔
3.  或者是，有什么其他原因，但忘记写在 log / 邮件里了，或者写在某个隐秘的角落我没找到。

反正不管是什么原因，bf019a1f 都是一个 commit 做了两件事，还只写了一件事的 changelog，导致这成了一个谜。

## 与其他编译器的对比

使用 [Compiler Explorer](https://gcc.godbolt.org/) 看一下其他编译器是怎么做的。

clang: 无论是否 \`-mtune=amdfam10\` 都没有 \`use_vector_fp_converts\`。

MSVC: 无论是否 \`-mtune=amdfam10\` 都是 source in register 则 \`cvtss2sd\`/\`cvtsd2ss\`，source in memory 则表现出 \`use_vector_fp_converts\` 的行为。

但是我并不知道如何研究其他编译器为什么做出这样的选择 😢

## 性能测试

最后来实际测试一下这个优化的性能。

测试使用的代码为 [\\[PATCH\\] disable use_vector_fp_converts for m_CORE_ALL](https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg61372.html) 中的 \`1.c\` 和 \`2.c\`，但原来的 \`2.c\` 用时太短，所以把循环范围改成了 \`1ll << 32\`：

<Card fold title="测试用代码">

\`1.c\`:

\`\`\`c
float total = 0.2;
int k = 5;

int main()
{
    int i;

    for (i = 0; i < 1000000000; i++)
    {
        total += (0.5 + k);
    }

    return total == 0.3;
}
\`\`\`

\`2.c\`:

\`\`\`c
double b[1024];

float a[1024];

int main()
{
    for(long i = 0 ; i < (1ll << 32); i++)
      a[i & 1023] = a[i & 1023] * (float)b[i & 1023];
    return (int)a[512];
}
\`\`\`

</Card>

测试使用的编译选项有：

1.  \`-O2 -mtune-ctrl=^use_vector_fp_converts\`
2.  \`-O2 -mtune-ctrl=^use_vector_fp_converts -mavx2\`
3.  \`-O2 -mtune-ctrl=use_vector_fp_converts\`
4.  \`-O2 -mtune-ctrl=use_vector_fp_converts -mavx2\`

其中值得注意的是，使用 2 号编译选项编译 \`2.c\` 时会通过将 \`vcvtsd2ss\` 指令的第二个 operand 设为 \`%xmm1\` 来代替 \`pxor %xmm0, %xmm0\` 以达到清空 \`%xmm0\` 的效果。

为了测试清空 XMM 寄存器的效果，在这 4 种编译选项之外，还对 \`2.c\` 增设了手动删掉用于清空 \`%xmm0\` 的指令的两份汇编代码。

所以总共有 10 份汇编代码用于测试：

-   1-1: \`1.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts\`
-   1-2: \`1.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts -mavx2\`
-   1-3: \`1.c\`，\`-O2 -mtune-ctrl=use_vector_fp_converts\`
-   1-4: \`1.c\`，\`-O2 -mtune-ctrl=use_vector_fp_converts -mavx2\`
-   2-1: \`2.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts\`
-   2-2: \`2.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts -mavx2\`
-   2-3: \`2.c\`，\`-O2 -mtune-ctrl=use_vector_fp_converts\`
-   2-4: \`2.c\`，\`-O2 -mtune-ctrl=use_vector_fp_converts -mavx2\`
-   2-5: \`2.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts\`，然后删掉 \`pxor %xmm0, %xmm0\`
-   2-6: \`2.c\`，\`-O2 -mtune-ctrl=^use_vector_fp_converts -mavx2\`，然后将 \`vcvtsd2ss\` 的第二个 operand 改为 \`%xmm0\`。

<Card fold title="测试用汇编代码">

<Card fold title="1-1">

\`\`\`asm
	.file	"1.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pxor	%xmm1, %xmm1
	movss	total(%rip), %xmm0
	movl	$1000000000, %eax
	cvtsi2sdl	k(%rip), %xmm1
	addsd	.LC0(%rip), %xmm1
	.p2align 4,,10
	.p2align 3
.L2:
	cvtss2sd	%xmm0, %xmm0
	addsd	%xmm1, %xmm0
	cvtsd2ss	%xmm0, %xmm0
	subl	$1, %eax
	jne	.L2
	movss	%xmm0, total(%rip)
	xorl	%edx, %edx
	cvtss2sd	%xmm0, %xmm0
	ucomisd	.LC1(%rip), %xmm0
	setnp	%dl
	cmove	%edx, %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	k
	.data
	.align 4
	.type	k, @object
	.size	k, 4
k:
	.long	5
	.globl	total
	.align 4
	.type	total, @object
	.size	total, 4
total:
	.long	1045220557
	.section	.rodata.cst8,"aM",@progbits,8
	.align 8
.LC0:
	.long	0
	.long	1071644672
	.align 8
.LC1:
	.long	858993459
	.long	1070805811
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="1-2">

\`\`\`asm
	.file	"1.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	vxorps	%xmm1, %xmm1, %xmm1
	vmovss	total(%rip), %xmm0
	movl	$1000000000, %eax
	vcvtsi2sdl	k(%rip), %xmm1, %xmm1
	vaddsd	.LC0(%rip), %xmm1, %xmm1
	.p2align 4,,10
	.p2align 3
.L2:
	vcvtss2sd	%xmm0, %xmm0, %xmm0
	vaddsd	%xmm1, %xmm0, %xmm0
	vcvtsd2ss	%xmm0, %xmm0, %xmm0
	subl	$1, %eax
	jne	.L2
	vmovss	%xmm0, total(%rip)
	xorl	%edx, %edx
	vcvtss2sd	%xmm0, %xmm0, %xmm0
	vucomisd	.LC1(%rip), %xmm0
	setnp	%dl
	cmove	%edx, %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	k
	.data
	.align 4
	.type	k, @object
	.size	k, 4
k:
	.long	5
	.globl	total
	.align 4
	.type	total, @object
	.size	total, 4
total:
	.long	1045220557
	.section	.rodata.cst8,"aM",@progbits,8
	.align 8
.LC0:
	.long	0
	.long	1071644672
	.align 8
.LC1:
	.long	858993459
	.long	1070805811
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="1-3">

\`\`\`asm
	.file	"1.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pxor	%xmm1, %xmm1
	movss	total(%rip), %xmm0
	movl	$1000000000, %eax
	cvtsi2sdl	k(%rip), %xmm1
	addsd	.LC0(%rip), %xmm1
	.p2align 4,,10
	.p2align 3
.L2:
	unpcklps	%xmm0, %xmm0
	cvtps2pd	%xmm0, %xmm0
	addsd	%xmm1, %xmm0
	unpcklpd	%xmm0, %xmm0
	cvtpd2ps	%xmm0, %xmm0
	subl	$1, %eax
	jne	.L2
	movss	%xmm0, total(%rip)
	unpcklps	%xmm0, %xmm0
	xorl	%edx, %edx
	cvtps2pd	%xmm0, %xmm0
	ucomisd	.LC1(%rip), %xmm0
	setnp	%dl
	cmove	%edx, %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	k
	.data
	.align 4
	.type	k, @object
	.size	k, 4
k:
	.long	5
	.globl	total
	.align 4
	.type	total, @object
	.size	total, 4
total:
	.long	1045220557
	.section	.rodata.cst8,"aM",@progbits,8
	.align 8
.LC0:
	.long	0
	.long	1071644672
	.align 8
.LC1:
	.long	858993459
	.long	1070805811
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="1-4">

\`\`\`asm
	.file	"1.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	vxorps	%xmm1, %xmm1, %xmm1
	vmovss	total(%rip), %xmm0
	movl	$1000000000, %eax
	vcvtsi2sdl	k(%rip), %xmm1, %xmm1
	vaddsd	.LC0(%rip), %xmm1, %xmm1
	.p2align 4,,10
	.p2align 3
.L2:
	vunpcklps	%xmm0, %xmm0, %xmm0
	vcvtps2pd	%xmm0, %xmm0
	vaddsd	%xmm1, %xmm0, %xmm0
	vmovddup	%xmm0, %xmm0
	vcvtpd2psx	%xmm0, %xmm0
	subl	$1, %eax
	jne	.L2
	vmovss	%xmm0, total(%rip)
	vunpcklps	%xmm0, %xmm0, %xmm0
	xorl	%edx, %edx
	vcvtps2pd	%xmm0, %xmm0
	vucomisd	.LC1(%rip), %xmm0
	setnp	%dl
	cmove	%edx, %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	k
	.data
	.align 4
	.type	k, @object
	.size	k, 4
k:
	.long	5
	.globl	total
	.align 4
	.type	total, @object
	.size	total, 4
total:
	.long	1045220557
	.section	.rodata.cst8,"aM",@progbits,8
	.align 8
.LC0:
	.long	0
	.long	1071644672
	.align 8
.LC1:
	.long	858993459
	.long	1070805811
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-1">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	leaq	b(%rip), %rdi
	movabsq	$4294967296, %rsi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	pxor	%xmm0, %xmm0
	addq	$1, %rax
	andl	$1023, %edx
	cvtsd2ss	(%rdi,%rdx,8), %xmm0
	mulss	(%rcx,%rdx,4), %xmm0
	movss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	cvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-2">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	vxorps	%xmm1, %xmm1, %xmm1
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	movabsq	$4294967296, %rsi
	leaq	b(%rip), %rdi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	addq	$1, %rax
	andl	$1023, %edx
	vcvtsd2ss	(%rdi,%rdx,8), %xmm1, %xmm0
	vmulss	(%rcx,%rdx,4), %xmm0, %xmm0
	vmovss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	vcvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-3">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	leaq	b(%rip), %rdi
	movabsq	$4294967296, %rsi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	addq	$1, %rax
	andl	$1023, %edx
	movq	(%rdi,%rdx,8), %xmm0
	cvtpd2ps	%xmm0, %xmm0
	mulss	(%rcx,%rdx,4), %xmm0
	movss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	cvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-4">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	leaq	b(%rip), %rdi
	movabsq	$4294967296, %rsi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	addq	$1, %rax
	andl	$1023, %edx
	vmovq	(%rdi,%rdx,8), %xmm0
	vcvtpd2psx	%xmm0, %xmm0
	vmulss	(%rcx,%rdx,4), %xmm0, %xmm0
	vmovss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	vcvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-5">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	leaq	b(%rip), %rdi
	movabsq	$4294967296, %rsi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	addq	$1, %rax
	andl	$1023, %edx
	cvtsd2ss	(%rdi,%rdx,8), %xmm0
	mulss	(%rcx,%rdx,4), %xmm0
	movss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	cvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

<Card fold title="2-6">

\`\`\`asm
	.file	"2.c"
	.text
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	xorl	%eax, %eax
	leaq	a(%rip), %rcx
	movabsq	$4294967296, %rsi
	leaq	b(%rip), %rdi
	.p2align 4,,10
	.p2align 3
.L2:
	movq	%rax, %rdx
	addq	$1, %rax
	andl	$1023, %edx
	vcvtsd2ss	(%rdi,%rdx,8), %xmm0, %xmm0
	vmulss	(%rcx,%rdx,4), %xmm0, %xmm0
	vmovss	%xmm0, (%rcx,%rdx,4)
	cmpq	%rsi, %rax
	jne	.L2
	vcvttss2sil	2048+a(%rip), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.globl	a
	.bss
	.align 32
	.type	a, @object
	.size	a, 4096
a:
	.zero	4096
	.globl	b
	.align 32
	.type	b, @object
	.size	b, 8192
b:
	.zero	8192
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
\`\`\`

</Card>

</Card>

用于测试的机器有五台，CPU 型号分别为：

-   A: AMD Ryzen 7 4800H with Radeon Graphics （笔记本）
-   B: Intel(R) Xeon(R) CPU E5-2670 v2 @ 2.50GHz （Hostwinds）
-   C: Intel(R) Xeon(R) CPU E5-4610 v2 @ 2.30GHz （THU 校内服务器）
-   D: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz （腾讯云）
-   E: Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz （阿里云）

测试时，将程序运行 10 遍，记录其中第 3 短的用时。

<Card fold title="ssh 远程测试脚本">

\`\`\`bash
#!/bin/bash

eval "$(ssh-agent)"
ssh-add

dir="$(ssh "$1" mktemp -d)"
scp ./*-*.s "$1:$dir"

ssh "$1" 'grep "model name" /proc/cpuinfo | head -n1'

for i in 1-1 1-2 1-3 1-4 2-1 2-2 2-3 2-4 2-5 2-6; do
    echo "$i"
    ssh "$1" gcc "$dir/$i.s" -o "$dir/$i"
    for _ in $(seq 1 10); do
        ssh "$1" /usr/bin/time "$dir/$i"
    done
done

ssh "$1" rm -r "$dir"

ssh-agent -k
\`\`\`

</Card>

测试结果为：

| 代码/用时(s) |  A   |  B   |   C   |  D   |  E   |
| :----------: | :--: | :--: | :---: | :--: | :--: |
|     1-1      | 2.10 | 3.15 | 3.96  | 4.62 | 4.41 |
|     1-2      | 2.10 | 3.11 | 3.95  | 4.61 | 4.42 |
|     1-3      | 3.50 | 3.82 | 4.52  | 5.30 | 5.04 |
|     1-4      | 3.50 | 3.77 | 4.90  | 5.30 | 5.04 |
|     2-1      | 1.62 | 6.47 | 7.22  | 3.59 | 3.43 |
|     2-2      | 1.41 | 6.26 | 7.65  | 4.31 | 4.08 |
|     2-3      | 1.61 | 4.66 | 5.31  | 3.24 | 3.11 |
|     2-4      | 1.61 | 4.76 | 5.69  | 3.59 | 3.43 |
|     2-5      | 1.40 | 9.06 | 10.41 | 7.12 | 6.77 |
|     2-6      | 1.41 | 9.03 | 10.98 | 7.11 | 6.77 |

这数据真的非常让人怀疑是不是测错了（

只能说是大千世界无奇不有，性能优化实在是太玄学了（

但测试似乎表明，source in register 时关闭 \`use_vector_fp_converts\`、source in memory 时开启 \`use_vector_fp_converts\`，也就是 MSVC 的选择，在总体上是比较优的。
`},{title:C,tags:t,content:`[CS:APP](https://csapp.cs.cmu.edu/) 第八章 “Exceptional Control Flow” 的学习笔记。



在一般情况下，PC 会按照指令的顺序以及跳转指令来变化。但在很多时候，这样的控制流是不能满足需要的，需要 *exceptional control flow* (ECF) 作为跳转指令的补充，以处理一些“异常”的或者来自“外部”的变化。

ECF 存在于各个层次，例如：

-   硬件监测到事件发生时调用 exception handler
-   操作系统在不同进程之间进行 [context switch](#context-switch)
-   不同进程间通过发送 [signal](#signals) 来调用接收者的 signal handler
-   程序内部通过 [nonlocal jump](#nonlocal-jumps) 来实现错误处理

## Exceptions

*exception* 是由某种“状态改变”（可能是某条指令执行的结果，或者来自外部 I/O 的变化等等）导致的控制流的突变。

处理器检测到这种状态改变后，会调用 *exception handler*，然后跳转到触发前的指令或下一条指令，或者终止整个程序。

### Exception Handling

每种 exception 都会有一个 *exception number*，某些 exception 的 number 由硬件决定，另一些由操作系统决定。

内存中会有一个 *exception table*，以 exception number 为索引，每一项是对应的 exception handler。处理器中有一个 *exception table base register*，用来存 exception table 的起始地址，结合 exception number 就可以对每一项寻址。

exception 与 procedure call 的主要区别有：

-   procedure call 返回到栈顶存储的返回地址，而 exception 返回到触发时的指令或下一条指令，或终止程序。
-   调用 exception handler 时，会保存包括 condition codes 在内的一些处理器状态，在返回时恢复。
-   exception handler 在 [kernel mode](#user-kernel-mode) 下运行，使用的运行栈也是 kernel 的。

### Classes of Exceptions

exception 一般有四种：

-   interrupt: 异步触发（不是某条指令的执行导致了 exception），返回到下一条指令。一般是由外部 I/O 设备触发（设备通过 interrupt pin 告诉处理器有 interrupt，通过 system bus 发送 exception number，处理器在每执行完一条指令后检查 interrupt pin），触发后调用 interrupt handler，再回到原来的位置继续执行下一条指令。
-   trap: 同步触发，返回到下一条指令。比如 [system call](#linux-中的-system-call) 是一种常见的 trap，通过 \`syscall\` 指令主动触发 exception，看上去和函数调用类似，但可以在 kernel mode 下运行。
-   fault: 同步触发，返回到触发 exception 的指令或退出。一般来说，fault handler 会尝试解决导致 fault 发生的问题，如果成功解决则返回到触发 exception 的指令，并且能够不再次触发 exception 而继续执行下去；如果没能成功解决，则 abort。
-   abort: 同步触发，一定退出。一般代表严重的不可恢复的错误。

### Exceptions in Linux/x86-64 Systems

#### x86-64 中的 fault / abort

-   Divide Error Exception (Interrupt 0): 除以零。它是 fault，但实际上 Linux 不会尝试从 divide error 中恢复，而是会直接 abort，一般会显示为 “floating point exception”。
-   General Protection Exception (Interrupt 13): 有多种触发原因，例如访问未定义的内存，尝试写入只读的内存段。Linux 也不会尝试从中恢复，而是会直接 abort，一般会显示为 “segmentation fault”。
-   Page-Fault Exception (Interrupt 14): page fault 是一个名副其实的 fault，会尝试恢复，详见[第九章](/post/2022/11/csapp-9)。
-   Machine-Check Exception (Interrupt 18): 严重的硬件错误，是 abort。

（完整列表参见 [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html) Volume 3A 的 “6.15 EXCEPTION AND INTERRUPT REFERENCE” 一节。）

#### Linux 中的 system call

Linux 中常用的一些 system call 如 CS:APP Figure 8.10 所示：

![Linux 中常用的一些 system call](csapp-fig8.10.png)

（更多 system call 参见 \`man syscalls\`）

在 C 语言中，可以使用 \`syscall\` 函数来调用 system call，但一般不这样做，而是使用每个 system call 对应的 wrapper function。\`syscall\` 和 wrapper function 统称为 *system-level function*。

## Processes

一个系统中会有很多进程同时运行，但营造出了每个进程都独占了处理器和内存的假象。

进程独占内存的假象是通过每个进程的 private address space 实现的，详见[第九章](/post/2022/11/csapp-9)。

### Logical / Concurrent Flow

根据一个程序的指令得到的 control flow 称作 *logical (control) flow*。系统会在不同的进程间来回切换，从一个进程切换出去称作将这个进程 *preempt*。

如果两个 control flow 的存活时间有重叠，则称它们是 *concurrent flow* 或它们 *run concurrently*。这种现象被称作 *concurrency*，也被称作 *multitasking*。每次连续执行的同一个 logical flow 中的一段称作一个 *time slice*，所以 multitasking 也被称作 *time slicing*。如果两个 logical flow 在不同的 processor core 上运行，则称它们是 *parallel flow*，*run in parallel*。

### User / Kernel Mode

在处理器中存有一个 *mode bit*，表示当前是 user mode 还是 kernel mode。只有在 kernel mode 下才能执行某些 *privileged instruction*、修改 mode bit、访问地址空间中属于 kernel 的区域。

user mode 的程序只能通过 exception 来进入 kernel mode，以执行 privileged instruction 或者访问 kernel 的数据。在 Linux 中，也可以在 user mode 下访问 \`/proc\`、\`/sys\` 来获得一些 kernel 的数据。

### Context Switch

每个进程都有一个 *context*，包括寄存器内容、PC、user stack、kernel stack、condition codes、page table、process table、file table 等等。

操作系统通过 *context switch* 来在不同进程间切换，即保存当前进程的 context，恢复要切换到的进程的 context，最后切换过去。context switch 在 exception 中发生，处理 exception 时操作系统中的 *scheduler* 会决定是否进行 context switch，schedule 到哪个进程。例如：

-   在通过 system call 读取文件时进行 context switch，以在等待读取文件时先执行其他进程；读取到文件后在 interrupt 中再 context switch 回来。
-   系统会周期性地（例如每 1ms）触发 interrupt，从而可以在一个进程执行了一段时间后进行 context switch。

因为程序不知道操作系统会如何 schedule，一般来说，不同进程的执行顺序是没有保证的。

## System Call Error Handling

system-level function 一般以返回 -1 代表出错，而将具体的错误记录在全局整型变量 \`errno\` (\`#include <errno.h>\`)，函数 \`strerror\` 可以用来根据 \`errno\` 得到文字错误信息。

调用 system-level function 时应当检查错误。为了使错误处理更加简便，可以使用类似下面的 wrapper function：

\`\`\`c
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void unix_error(char *msg)
{
    fprintf(stderr, "%s: %s\\n", msg, strerror(errno));
    exit(errno);
}

pid_t Fork(void)
{
    pid_t pid = fork();

    if (pid < 0)
        unix_error("Fork error");

    return pid;
}
\`\`\`

## Process Control

C 语言中有很多用来控制 Unix 进程的函数。

### 获取 PID

每个进程都有一个 PID。

-   \`pid_t getpid(void)\`: 返回当前进程的 PID
-   \`pid_t getppid(void)\`: 返回当前进程的 parent 的 PID

### 进程的状态

每个进程可能处于三种状态之一：

1.  Running: 正在运行中，会被 schedule。
2.  Stopped: 被 suspend 了，不会被 schedule。Stopped 可能是 SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU 导致的，可以由 SIGCONT 恢复运行。
3.  Terminated: 进程永久地结束了，可能是从 \`main\` 函数返回、调用了 \`exit\` 函数或者收到了某些 signal。

-   \`void exit(int status)\`: 以某个 exit status 将当前进程 terminate

### fork

-   \`pid_t fork(void)\`: 创建子进程

fork 会将当前进程的所有状态复制一份创建一个新的进程，新的进程有着和原来相同的代码、数据、文件（例如 \`stdout\`），但 PID 不同，并且后续对数据的修改是和原进程独立的。

fork 会调用一次，返回两次，分别在两个进程中返回，在 parent 中返回 child 的 PID，在 child 中返回 0，出错则返回 -1。

fork 出的进程和原进程在接下来会执行同一份代码，所以一般会判断 \`fork\` 的返回值是否为 0 来让两个进程执行不同的分支。

### process group

每个进程会属于一个 process group，每个 process group 有一个 ID。

创建子进程时，子进程会默认处于 parent 的 process group。

-   \`pid_t getpgrp(void)\`: 返回当前进程的 process group ID
-   \`int setpgid(pid_t pid, pid_t pgid)\`: 将 \`pid\` 对应的进程的 progress group ID 修改为 \`pgid\`，\`pid\` 为 0 表示当前进程，\`pgid\` 为 0 表示修改为 \`pid\` 对应的进程的 PID

### wait

-   \`pid_t waitpid(pid_t pid, int *statusp, int options)\`: 等待子进程结束
-   \`pid_t wait(int *statusp)\`: \`waitpid(-1, statusp, 0)\`

#### waitpid 的 pid 参数

参数 \`pid\` 决定了要等待的是哪些子进程：

-   -1: 所有子进程
-   \\> 0: PID 为 \`pid\` 的子进程
-   0: process group 与当前进程相同的子进程
-   \\< -1: process group ID 为 \`-pid\` 的子进程

#### waitpid 的行为 (options)

默认情况下，\`waitpid\` 会等待到有某个被等待的子进程 terminate 再返回，\`options\` 可以改变这一行为，其值可以包含下列 flag：

-   \`WNOHANG\`: 立即返回，如果没有符合条件的子进程则返回 0
-   \`WUNTRACED\`: 除了 terminate，子进程 stop 也可以结束等待
-   \`WCONTINUED\`: 除了 terminate，子进程从 stopped 中 continue 也可以结束等待

#### reap

除了等待，wait 还会将 terminated 的子进程 *reap*，即彻底清除掉。没有被 reap 但 terminated 的进程被称作 *zombie*，会占用一定的系统资源。在 \`ps\` 中，zombie 显示为 \`[defunct]\`。

如果 parent terminate 了，没有 terminate 的子进程会被设置为 PID 为 1 的 \`init\` 进程的子进程，而 zombie 子进程则会被 \`init\` reap。

#### wait 获取子进程的 status

如果 \`statusp\` 参数不是 \`NULL\`，在 \`waitpid\` 返回时 \`*statusp\` 内就会存有引起等待结束的那个子进程的信息。

有一系列 macro 可以用来提取 status 中的信息（参数是 \`*statusp\`，不是指针）：

-   \`WIFEXITED(status)\`: 是否正常退出 (从 \`main\` 函数返回或调用了 \`exit\` 函数)
-   \`WEXITSTATUS(status)\`: 如果正常退出，则返回 exit status (\`main\` 函数返回值 / \`exit\` 函数参数)
-   \`WIFSIGNALED(status)\`: 是否由某个 signal terminate
-   \`WTERMSIG(status)\`: 如果是由某个 signal terminate，返回这个 signal
-   \`WIFSTOPPED(status)\`: 是否被 stop
-   \`WSTOPSIG(status)\`: 如果被 stop，返回使其 stop 的 signal
-   \`WIFCONTINUED(status)\`: 是否被 continue

#### wait 的报错

出错时 wait 会返回 -1，\`errno\` 可能是 \`ECHILD\` 表示被等待的子进程集合为空，可能是 \`EINTR\` 表示 wait 函数被某个 signal 中断了。

wait 会在每有一个子进程结束时返回，但子进程全部结束时会报错 \`ECHILD\`，可以利用这一点通过 \`while\` 循环来等待所有子进程全部结束。

### sleep

-   \`unsigned int sleep(unsigned int secs)\`: sleep 若干秒，返回剩余应当 sleep 的秒数（正常情况下没被 interrupt 就是 0）
-   \`int pause(void)\`: 一直 sleep，直到被 signal interrupt，总是返回 -1

### execve

-   \`int execve(const char *filename, char *const argv[], char *const envp[])\`

\`execve\` 会以 \`argv\` 作为参数、\`envp\` 作为环境变量，在当前进程内执行 executable object file \`filename\`。可以和 \`fork\` 配合来在子进程内执行其他程序。

\`argv\` 是一个以 \`NULL\` 为结尾的字符串数组，表示各个参数，其中第一个一般是程序的名称。

\`envp\` 也是以 \`NULL\` 为结尾的字符串数组，每个字符串形如 \`name=value\`。

有一些函数可以用来获取、设置环境变量：

-   \`char *getenv(const char *name)\`: 返回 \`NULL\` 或环境变量的值
-   \`int setenv(const char *name, const char *newvalue, int overwrite)\`: 成功则返回 0，失败（\`overwrite\` 为 0 而 \`name\` 已存在）则返回 -1
-   \`void unsetenv(const char *name)\`

## Signals

### signal 的种类

可以用 \`man signal.7\` 查看 signal 的列表（名称、语义、编号、默认行为）。

特别地：

-   除以零时会被发送 SIGFPE
-   执行非法指令时会被发送 SIGILL
-   非法访问内存时会被发送 SIGSEGV
-   按 Ctrl+C 时 foreground process group 会被发送 SIGINT
-   子进程 terminate 时会向 parent 发送 SIGCHLD
-   可以通过 SIGKILL 来强行 terminate 一个进程

### signal 的工作流程

-   每个进程会记录每个 signal 是否 *pending*、是否 *blocked*
-   发送 signal 会使接收者的这个 signal 变为 pending
-   进程可以改变每个 signal 的 blocked 状态
-   在切换到 user mode 执行进程时，如果一个 signal 处于 pending 状态且没有被 blocked，就会接收这个 signal，并设为没有在 pending

这意味着：

-   signal 只记录是否 pending，不会记录发送了几次，在被接收前多次发送只会被接收一次
-   在 blocked 状态下被发送 signal，会在 unblock 时收到

### 发送 signal

#### kill 命令

可以用 \`kill\` 命令在 shell 中向指定的进程发送信号。一般 shell 会有 builtin 的 \`kill\`，也有位于 \`/usr/bin/kill\` 的 \`kill\`，可能有一定的区别。

基础的 \`kill\` 命令形如 \`kill -sig pid\`，其中 \`-sig\` 可以形如 \`-INT\`/\`-SIGINT\`/\`-2\`，而 \`pid\` 表示要把信号发送给：

-   \\> 0: PID 为 \`pid\` 的进程
-   0: process group 和当前进程相同的进程
-   -1: 除 PID 为 1 的 \`init\` 外的所有进程
-   \\< 0: process group ID 为 \`-pid\` 的进程

这与 [waitpid 的 pid 参数](#waitpid-的-pid-参数) 是类似的。

#### 在 shell 中使用键盘发送 SIGINT / SIGTSTP

shell 中会有至多一个 foreground job 和零个或若干个 background job。shell 会给每个 job 中的所有进程指定同样的 process group。

Ctrl+C 会向 foreground group 发送 SIGINT，Ctrl+Z 会向 foreground group 发送 SIGTSTP。

#### 使用函数发送 signal

-   \`int kill(pid_t pid, int sig)\`: 与 [kill 命令](#kill-命令)类似
-   \`unsigned int alarm(unsigned int secs)\`: 让 kernel 在 \`secs\` 秒后向当前进程发送 SIGALRM；如果有尚未发送的 alarm 则取消掉，如果 \`secs\` 为 0 则取消后不会发送新的 SIGALRM；没有尚未发送的 alarm 则返回值是 0，否则是被取消的 alarm 还剩的秒数

### 设置 signal handler

除了 SIGKILL 和 SIGSTOP，其他 signal 的行为可以被改变。

\`\`\`c
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
\`\`\`

函数 \`signal\` 用来改变处理 signal \`signum\` 的方式。\`handler\` 可以是一个函数指针，也可以是 \`SIG_IGN\` 表示无视这个 signal，或者 \`SIG_DFL\` 表示使用这个 signal 的默认行为。

有 handler 时，接收到一个 signal 就会触发 exception 来执行 handler，在 handler 结束时一般会返回到原来的指令。

在执行 handler 的过程中，相应的 signal 会被 block，但 handler 可以被其他类型的 signal interrupt，在处理完这另一个 signal 后返回到一开始的 handler。

### block / unblock signal

进程可以主动 block / unblock 指定的 signal：

-   \`int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)\`

其中 \`how\` 是 \`SIG_BLOCK\` / \`SIG_UNBLOCK\` / \`SIG_SETMASK\`，分别表示 block \`set\` 里的 signal / unblock \`set\` 里的 signal / 将 blocked set 设为 \`set\`。

若 \`oldset\` 不是 \`NULL\`，则会将修改前的 blocked set 存下来。

还有一些用来设置 \`sigset_t\` 的函数：

-   \`int sigemptyset(sigset_t *set)\`: 将 \`set\` 设为空
-   \`int sigfillset(sigset_t *set)\`: 将 \`set\` 设为所有 signal
-   \`int sigaddset(sigset_t *set, int signum)\`: 将 \`signum\` 加入 \`set\`
-   \`int sigdelset(sigset_t *set, int signum)\`: 将 \`signum\` 从 \`set\` 中删去
-   \`int sigismember(const sigset_t *set, int signum)\`: 检查 \`signum\` 是否在 \`set\` 中，返回 0/1 或出错返回 -1

### 编写、使用 signal handler

#### 编写安全的 signal handler

由于 signal handler 和主程序并行运行、共享数据，并且主程序可能在意想不到的地方接收到 signal 而被 interrupt，编写安全的 signal handler 是困难的，一般要遵循下面的守则：

0.  handler 应当尽量简单，例如可以设置一个 flag 而在主程序中检查 flag 并进行处理，而非直接在 handler 中处理
1.  在 handler 中只调用 async-signal-safe 的函数（函数列表参见 \`man signal-safety\`），常用的 \`printf\`、\`sprintf\`、\`malloc\`、\`exit\` 都不是 async-signal-safe 的
2.  存储并恢复 \`errno\`，保证调用 handler 前后 \`errno\` 不变
3.  访问 handler 与主程序共享的数据时，block signal 以防止在访问的中途被 interrupt
4.  把在 handler 中修改而在主程序中访问的的全局变量声明为 \`volatile\` 的，防止编译器误认为变量没有被修改而错误地进行优化
5.  将 flag 声明为 \`sig_atomic_t\` 类型，它的单次访问是 atomic 的，不会被 interrupt（但先读后写是两次访问，可能被 interrupt）

<Card title="为什么函数会不 async-signal-safe">
以 \`printf\` 为例，\`printf\` 会使用一个 statically allocated buffer，如果在中途被 interrupt，而在返回到被 interrupt 的位置前的这段时间里，\`printf\` 再次被调用，那么这个 buffer 就会处于一个 inconsistent 的中间态，导致 UB。

也就是说，一个函数不 async-signal-safe 一般是因为使用了一些全局变量并且可能在执行过程中被 interrupt。要安全地调用这样的函数，在其被 interrupt 后，下次执行必须要是从被 interrupt 的地方继续，而不能从头开始。

除了在 handler 中只调用 async-signal-safe 的函数，也可以选择在主程序中调用非 async-signal-safe 函数时 block 掉 handler 使用了这一函数的 signal，但这很难做到。
</Card>

#### 正确处理多次发送的 signal

多次发送 signal 可能只会收到一次，所以处理 signal 时不能误以为收到的次数与发送的次数相同。

例如，接收 SIGCHLD 来 reap child 时，应当在 handler 中 reap 掉所有已 terminate 的子进程，而非只 reap 一个子进程。

#### 不同系统上 signal handling 的差异

在一些系统上，signal handling 的语义会有区别：

-   在一些系统上，调用了 handler 后这个 signal 就会恢复默认行为，需要在 handler 中重新调用 \`signal\` 才能一直使用这个 handler。

-   在一些系统上，需要执行较长时间的 system call 会在被 interrupt 后报错 EINTR，而在现代系统上会尽可能地自动重新执行这个 system call，详见 \`man signal.7\` 的 “Interruption of system calls and library functions by signal handlers” 一节。

    （P.S. 这就是 [Rise of Worse Is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html) 中用来举例的 “PC loser-ing problem”，原本采用 worse-is-better 的 Unix 现在也进化成了 the right thing）
    （P.P.S. 当时读这篇的时候我完全没看懂这一段，没想到现在竟然还能记起来）

可以通过 \`sigaction\` 函数来设置想要的 signal handling 语义。

#### 注意 handler 被调用的时机

handler 可能会在意想不到的时机被调用，为了避免出错（race），可能会需要暂时 block signal 来确保 handler 在正确的时机被调用。详见 CS:APP 上的例子。

### 等待 signal

-   \`int sigsuspend(const sigset_t *mask)\`: 将 blocked set 设为 \`mask\`，在接收到任何 signal 后返回

可以在程序的其他部分 block 掉某个 signal，然后在 \`sigsuspend\` 的参数中将其 unblock，以达到等待该 signal 的目的。因为 \`sigsuspend\` 等待的不是某个特定的 signal，可以配合 \`while\` 循环来检查由 handler 设置的某个 flag。

\`sigsuspend\` 的效果类似于下面的这段代码：

\`\`\`c
sigprocmask(SIG_SETMASK, &mask, &prev);
pause();
sigprocmask(SIG_SETMASK, &prev, NULL);
\`\`\`

不同的是，上面这段代码有可能会恰好在 \`sigprocmask\` 之后、\`pause\` 之前接收到 signal，导致这个 signal 没有将 \`pause\` interrupt 而一直 sleep 下去。\`sigsuspend\` 是 atomic 的，就不存在这样的问题。

## Nonlocal Jumps

-   \`int setjmp(jmp_buf env)\`
-   \`void longjmp(jmp_buf env, int val)\`

\`setjmp\` 会将当前的 PC 和寄存器等信息存在 \`env\` 中，而 \`longjmp\` 会恢复 \`env\` 中保存的信息，跳转到 \`setjmp\` 的位置。

这意味着 \`setjmp\` 可能返回多次，而 \`longjmp\` 不会返回。第一次调用 \`setjmp\` 会返回 0，而之后调用 \`longjmp\` 时会在 \`setjmp\` 的位置返回参数 \`val\` 的值（特别地，如果 \`val\` 的值是 0，会返回 1，强制和首次返回区分开）。

因为 \`setjmp\` / \`longjmp\` 只是恢复 PC 和寄存器（包括 \`%rsp\`）：

-   调用 \`longjmp\` 时 \`setjmp\` 所在的函数必须还没有返回，否则 \`setjmp\` 所在的 stack frame 就失效了。
-   \`setjmp\` 的返回值只应出现在[一些简单的表达式中](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setjmp.html)，否则是 UB。特别地，不应将 \`setjmp\` 的返回值赋给一个变量，但可以放在 \`if\` 或 \`switch\` 里。这是考虑到，计算一个复杂的表达式可能会有一些中间量以及 dynamic stack allocation，而 \`longjmp\` 回来时这些中间量、dynamic stack allocation 不一定能被正确恢复，导致表达式不一定能被正确计算。
-   如果修改了存放在内存中的局部变量，跳转后会是被修改过的值而不是原来的值，而存放在寄存器中的值则会被恢复。要确保变量不被存在寄存器中，必须使用 \`volatile\` 声明变量，否则（即便使用了 \`register\` 或 \`auto\` 来声明变量）编译器可能任意地把变量放在内存或寄存器中，造成跳转后变量的值不确定。

<Card type="question" title="volatile vs 取地址">
C99 rationale 和 \`man setjmp\` 都说要用 \`volatile\` 才能确保局部变量存在栈上，那如果一个局部变量被取了地址，还有可能存在寄存器中吗？如果有可能的话，是标准允许这样但事实上不会，还是真的可以在 gcc 中做到？
</Card>

-   \`int sigsetjmp(sigjmp_buf env, int savesigs)\`
-   \`void siglongjmp(sigjmp_buf env, int val)\`

\`sigsetjmp\` / \`siglongjmp\` 会额外存储、恢复 pending / blocked signal 的信息（需要以非 0 \`savesigs\` 调用 \`sigsetjmp\`），可以用于 signal handler。

nonlocal jump 主要有两种用途：

-   出错时直接跳转到一个集中的位置来处理错误，而不用一层层往上返回
-   处理 signal 时不返回到被 interrupt 的位置，而跳转到指定的位置

在 signal handler 中使用 nonlocal jump 时需要注意：

-   先 \`sigsetjmp\` 再 install signal handler，否则可能 race
-   \`siglongjmp\` 跳转到的后续代码中只能调用 async-signal-safe 的函数

nonlocal jump 可能造成可读性的问题，也可能因为跳过了中间很多函数的返回，造成内存泄露等后果，要谨慎使用。

## Tools for Manipulating Processes

-   \`strace\`: 显示程序调用的所有 system call，可以静态链接来避免看到大量共享库相关的输出
-   \`ps\`: 列出进程信息
-   \`top\`: 列出进程的资源使用（可以用 \`htop\`）
-   \`pmap\`: 查看进程的 memory map
-   \`/proc\`: 查看各种进程相关的信息 (\`man proc.5\`)
`},{title:w,tags:t,content:`[CS:APP](https://csapp.cs.cmu.edu/) 第九章 “Virtual Memory” 的学习笔记。



虚存是对 main memory 的抽象，它的主要作用有：

-   将 main memory 用作 disk 的 cache，只将 active 的部分放在 main memory，在需要时在 disk 和 memory 之间传递数据
-   通过给应用程序提供统一的地址空间，简化内存管理
-   通过给不同进程提供独立的地址空间，防止一个进程的数据被其他进程破坏

虚存在系统中起着非常重要的作用，学习虚存一方面可以学会使用它的一些强大功能（例如将文件映射到内存中），另一方面可以避免一些内存管理相关的错误。

## Physical and Virtual Addressing

内存有两种寻址方式：物理寻址和虚拟寻址。

main memory 可以看作 $M$ 个 byte 排列在一起，地址分别为 $0 \\sim M-1$，物理寻址就是 CPU 直接将需要的地址传给 main memory，获取到数据后传回 CPU。

虚拟寻址需要硬件和操作系统配合，CPU 将虚拟地址传给 *memory management unit* (MMU)，MMU 将虚拟地址翻译成物理地址传给 main memory，而这个过程又和操作系统相关。

## Address Spaces

（线性）地址空间是连续的非负整数构成的集合，一个系统有一个物理地址空间 $[0, M-1]$，还有若干个虚拟地址空间 $[0, N-1]$，其中 $N = 2^n$，称作 $n$-bit 地址空间，一般是 32-bit 或者 64-bit。

同一份数据可以在不同的地址空间有不同的地址，是虚存的一个基本思想。

## VM as a Tool for Caching

可以说，虚存是存储在磁盘上的，而物理内存是虚存的 cache。（但实际上虚存在很多时候会只出现在这个 cache 里而只在必要时被写入到磁盘上。）

### page

虚存被分成了很多固定大小的块，每一块称作一个 *virtual page*，而物理内存被分为同样大小的块，每一块被称作一个 *physical page*。在 cache 中，这样的一块一般被称作一个 block，但在虚存中被称作一个 page。

因为 DRAM 比磁盘快很多，并且磁盘的连续访问比随机访问快很多：

-   虚存的一个 page 会比较大，一般有 4KB ~ 2MB
-   虚存是 [fully associative cache](/post/2022/12/csapp-6#cache-的分类)
-   操作系统会使用一些比 SRAM cache 更加复杂的算法作为 replacement policy 来管理虚存

一个 virtual page 可能处于三种状态之一: unallocated、cached、uncached。

### page table

在物理内存中存放着一张 *page table*，虚拟地址空间中的每个 page 都对应 page table 中的一项 (*page table entry*, PTE)。每一项包含一个 valid bit 和一个地址：

-   cached: valid bit set，地址为该 page 的缓存的物理地址
-   uncached: valid bit not set，地址指向磁盘上的 virtual page
-   unallocated: valid bit not set，地址为 null

### page fault

在地址翻译时，MMU 会查看传入的虚拟地址对应的 PTE，若 cached，则称作 *page hit*，就会将 PTE 存储的物理地址传给 main memory；否则，就是 cache miss，在虚存中被称作 *page fault*。

page fault 是一个 exception，会触发 kernel 中的 page fault handler。page fault handler 会在 physical memory 中选择一个 physical page（victim page）用来存这个触发 page fault 的 page，先将 victim page 原有的数据在必要时放回磁盘，然后将新的数据存入 victim page，再相应地修改 page table 中的这两个 PTE，使得 victim page 原来存的那个 virtual page 变为 uncached，而新存入的 virtual page 变为 cached 并且地址指向 victim page。page fault handler 的最终效果就是，一开始想要的 virtual page 已经 cached，于是在返回到 exception 触发的位置时就可以 page hit 而正常读取数据了。

在磁盘和内存间传递数据在虚存中被称作 *swapping* 或 *paging*：

> Pages are *swapped in* (*paged in*) from disk to DRAM, and *swapped out* (*paged out*) from DRAM to disk.

虚存的 cache miss 是非常昂贵的，但由于程序访问内存的 locality，一般来说 page fault 很少触发，效率就不会太差。不断触发 page fault 的情况称作 *thrashing*，会大大影响程序的效率。

## VM as a Tool for Memory Management

实际上，page table 在一个系统中并非只有一份，而是每个进程都有一份，并且可以把同一个 physical page 映射到不同进程中的多个 virtual page。

虚存为内存管理提供了如下的便利：

-   简化了 linking，使得链接时无需考虑具体的物理地址，不同程序可以使用同样的虚拟地址分配方案。
-   简化了 loading，使得加载程序时只需将可执行文件的段落映射到虚存中，不用拷贝数据，等访问到某个 page 时才会 page in。这样的将文件内容映射到虚存中的操作称作 [memory mapping](#memory-mapping)，Linux 提供了 \`mmap\` system call 来进行 memory mapping。
-   简化了内存共享，操作系统可以将进程私有的数据映射到不同的 physical page，而将共享的数据映射到相同的 physical page。
-   简化了内存分配，因为应用请求一段连续的 virtual pages 时，操作系统可以将其映射到不连续的 physical pages。

## VM as a Tool for Memory Protection

-   虚存可以轻松地给不同的进程提供不同的私有内存空间。
-   通过给 PTE 添加 permission bit \`SUP\`、\`READ\`、\`WRITE\`，就可以使某个 page 只读或者只能在 kernel mode 下被访问。如果试图访问一个 page 时权限出错，则会触发 CPU 的 general protection exception，进而由 exception handler 向进程发送 SIGSEGV。

## Address Translation

一个内存地址可以被分为两部分，虚拟地址被分为高位的 *virtual page number* (VPN) 和低位的 *virtual page offset* (VPO)，物理地址被分为 PPN 和 PPO。

CPU 中有一个 *page table base register* (PTBR)，指向 page table 的起始地址。地址翻译时，MMU 通过 PTBR 和 VPN 得到 PTE 的地址，从 main memory 获取 PTE，根据 valid bit，要么触发 page fault，要么获取到 PPN，而 PPO = VPO，就得到了物理地址。

SRAM cache 一般会以物理地址来 cache main memory，也就是说，通过 PTE 的地址访问 PTE、通过物理地址访问 main memory 时会首先尝试通过 SRAM cache 来访问。

如果每次都从 main memory 获取 PTE，即使在 L1 cache hit 了效率也不够高，所以 MMU 中还有一个小的 page table cache，叫做 *translation lookaside buffer* (TLB)。VPN 被分为两部分：低位的 TLBI (index) 和高位的 TLBT (tag)，其中 TLBI 用来选择 cache set，TLBT 用来进行 cache line matching。在地址翻译时，会优先查询 TLB，若 miss 再查询 page table。

地址空间往往很大，如果只用一张 page table，那么 page table 本身就会占用大量的空间，所以可以将 page table 分层，每层 page table 指向下一层 page table，直到最后一层指向 VP / PP。

## Case Study: Core i7 Address Translation

Core i7 memory system 如 CS:APP Figure 9.21 所示：

![The Core i7 memory system](csapp-fig9.21.png)

Core i7 使用 48-bit 的虚拟地址空间和 52-bit 的物理地址空间，page size 可以设置为 4KB 或 4MB，有四级 page table。

每个 PTE 有以下内容：（还有一些其他内容）

-   P: valid bit
-   R/W: 是否只读
-   U/S: 是否需要在 kernel mode 下访问
-   XD: 是否可以被读取指令（是否可执行）
-   A: reference bit，访问到时由 MMU 设置，而由软件清除（可以用于 replacement algorithm）
-   Base addr: child page table / physical page 的地址的高位 40 bits（剩下 12 bits 即 4KB，这要求地址以 4KB 对齐，而 page size 一般就是 4KB）

L1 page table 还有一项 PS 用来指定 page size。

L4 page table 还有 dirty bit D 用来表示 page 被写入过需要被 swap out (write back)，以及 G 表示 global page 即切换进程时不从 TLB 中 evict 掉。

VPN 有 36 bits，每 9 bits 用来访问一级 page table。

因为 L1 cache 是 8-way 32KB 的，正好有 12 bits 用来选择 cache set，所以在获取 PPN 的同时就可以把 VPO 发送给 L1 cache 来提前选择好 cache set。

## Linux Virtual Memory System

kernel 的虚存中包含：

-   kernel 的代码以及全局的数据结构

-   将整个物理内存连续地映射到虚存中，这样就可以方便地访问特定的物理地址

-   和每个进程相关的数据结构，例如 page table、kernel stack、\`task_struct\` 等

    （P.S. 这部分虽然是和每个进程相关，但并不会在每个进程中有所不同，CS:APP 中这里写错了，在 errata 中指出了）

Linux 将虚存划分为若干 *area*（也称 *segment*）来管理，例如 code segment、data segment、heap、shared library segment，每个 area 是虚存中连续的一段。

kernel 为每个进程维护了一个 \`task_struct\`，其中的 \`mm\` 一项是一个 \`mm_struct\`。\`mm_struct\` 的 \`pgd\` 一项是 L1 page table 的地址，而 \`mmap\` 指向一个 \`vm_area_struct\`。每个 \`vm_area_struct\` 表示一个 area，有以下几项（还有一些其他项）：

-   \`vm_start\` / \`vm_end\`: 指向 area 的开头 / 结尾
-   \`vm_page_prot\`: area 中所有 page 的 access permission
-   \`vm_flags\`: 一些 flag，例如这个 area 中的 page 是否被所有进程共享
-   \`vm_prev\` / \`vm_next\`: 指向相邻的 \`vm_area_struct\`，构成一个链表

在处理 page fault 时，page fault handler 首先会检查地址是否在某个 area 内（不在则触发 segmentation fault），然后会检查是否有访问权限（没有则触发 protection exception），如果一切 ok 就会根据 replacement algorithm 选择 victim page，若其 dirty 则将其 swap out，然后将新的 page swap in，最后更新 page table 并返回。

<Card type="question" title="segmentation fault vs protection exception">
segmentation fault 和 protection exception 有区别吗？general protection exception 不应该是 CPU 触发的吗，怎么是 page fault handler 触发？segmentation fault 和 SIGSEGV 是什么关系？

我的理解是 kernel 收到 CPU 的 general protection exception 会向进程发送 SIGSEGV，但 CS:APP 这里在相邻的两段分别用了 “segmentation fault” 和 “protection exception”。
</Card>

## Memory Mapping

将一个 *object* 的内容设为一段虚存的初始值称作 *memory mapping*。这个 object 可以是文件系统中一个文件的一段 (*file-backed*)，也可以是一个初始为空的 *anonymous file* (*demand-zero*)。

在 map 时并不会立即将数据放到物理内存中，而是等到访问到某个 page 时再 swap in，这称作 *demand paging*。操作系统会使用 *swap file* 来进行 swapping，但只有进行了修改才会需要 swap out，否则可以直接从 map 到的文件 swap in。

如果不同的进程映射到了同一个文件的同一段，在物理内存中会只有一份数据。

memory mapping 有 shared 和 private 两种：

-   map as shared objects: 修改对其他进程可见，如果是 file-backed 还会将内存修改同步到磁盘上的文件。
-   map as private objects: 修改对其他进程不可见，也不会同步到磁盘上，并且是 copy-on-write 的：一开始将 PTE 设为只读，在触发 protection exception 后，exception handler 发现这个 area 是可以写入但 private 的，就创建一个新的 page，将原来的 page 复制过去，将 PTE 设为可以写入。

### fork 的原理

fork 时会将原来的 \`mm_struct\` 以及 page table 复制一份，但是将原来的 private area 中的 PTE 可以写入的重新变为只读，从而在之后再写入时重新触发 copy-on-write，就做到了 parent 和 child 一开始有一样的数据但后续写入独立。在 fork 前就创建了的 shared area 会由两个进程共享，可以利用这一点在 parent 和 child 之间通信。

### execve 的原理

1.  删除当前进程的所有 area (\`vm_area_struct\`)
2.  根据 program header table 进行 memory mapping：
    -   \`.init\`、\`.text\`、\`.rodata\`: private, file-backed, read-only
    -   \`.data\`: private, file-backed, read/write
    -   \`.bss\`、heap、stack: private, demand-zero, read/write
3.  如果有 link 到共享库，会进行动态链接，将共享库 private, file-backed map
4.  修改 program counter

### mmap

\`void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)\`

-   \`addr\`: area 的起始地址，仅作提示作用，一般 \`NULL\` 就行
-   \`length\`: area 的长度
-   \`prot\`: \`PROT_EXEC\`、\`PROT_READ\`、\`PROT_WRITE\`、\`PROT_NONE\`
-   \`flags\`: 有很多，常用的有 \`MAP_SHARED\`、\`MAP_PRIVATE\`、\`MAP_ANONYMOUS\`
-   \`fd\`: map 到的 file descriptor
-   \`offset\`: map 到的文件内容的 offset，必须是 page size 的倍数

在 \`MAP_ANONYMOUS\` 时，最好将 \`fd\` 设为 -1、\`offset\` 设为 0（在有的实现中这是必须的）。

失败时 \`mmap\` 会返回 \`MAP_FAILED\`。

\`int munmap(void *addr, size_t length)\`: 将自 \`addr\` 起 \`length\` 长的范围内的 mapping 删除，以后再访问就会 segmentation fault。\`addr\` 必须是 page size 的倍数。

## Dynamic Memory Allocation

### 动态分配的相关函数

在 C 语言中，可以用 \`malloc\` 和 \`free\` 来获取 / 释放动态分配的内存。可以使用 \`calloc\` 来初始化分配到的内存并在使用乘法计算内存大小时检测是否发生溢出。可以使用 \`realloc\` 来给一块动态分配的内存调整大小。详见 \`man malloc\`。

为了让动态分配得到的内存可以用于任何数据类型，地址会以 double word 对齐，即 32 位系统对齐到 8 的倍数，64 位系统对齐到 16 的倍数。

操作系统使用 \`brk\` 指针来指向 heap 的结尾，可以通过 \`sbrk\` 函数来增大 heap。

### allocator 的要求和目标

Dynamic memory allocator 会将 heap 划分为若干大小不等的 block，每个 block 要么 allocated 要么 free。

allocator 需要做到：

-   能够处理以任意顺序发送的 allocate 和 free 请求（不能对顺序做任何假定）
-   立即对请求做出响应（不能离线）
-   只使用 heap 存储数据（不能将数据存储在虚存的其他位置）
-   满足对齐要求（能够存储任何类型的数据）
-   不能修改或移动 allocated block（可以修改 free block 或者 heap 中不是 block 的区域）

而 allocator 有两个性能方面的目标：

1.  更快地响应请求（更大的吞吐量）
2.  更高效地利用内存

其中，导致内存利用率低的主要原因是 *fragmentation*：

-   internal fragmentation: 实际分配的 allocated block 比 alloc 请求中申请的大
-   external fragmentation: 所有 free block 加起来大小足够，但每单个 free block 都不够大，导致需要使用更多 heap 空间

### 一种简单的 allocator 实现方式

#### block header

allocator 需要记录 block 的信息，而只能使用 heap 空间，所以直接在 block 的开头记录 block header，即 block size 以及是否 allocated。

因为地址有对齐要求，block size 的最低几位一定是 0，就可以用最低位来存 allocated bit。

block size 充当了单向链表的作用。如果想访问 free block，就得访问每个 block 再看是否 free，所以这样的结构被称作 *implicit free list*。

#### placement policy

allocate 时需要找到一个足够大的 free block，allocator 进行这样的搜索的方式称作 *placement policy*：

-   first fit：从头开始找，直到找到足够大的 free block
-   next fit：从上次搜索结束的地方开始找，直到找到足够大的 free block
-   best fit：遍历所有 free block，使用足够大的 free block 中最小的

使用 implicit free list 时，next fit 比 first fit 吞吐量更大但内存利用率更低，best fit 内存利用率最好但吞吐量最差。

#### 分割 free block

如果 allocate 时 free block 的剩余空间比需要的空间大，且大的超过一个 block 的 minimum size (double word)，就可以将这个 block 分为两半，一半用作 allocated block，另一半为 free block。

#### 获取更多的 heap 空间

如果已有的 heap 空间无法满足 allocate 请求，可以使用 \`sbrk\` 来获取更多的 heap 空间，并将新得到的空间设为 free block。

#### 合并 free block

如果很多 free block 相邻地放在一起，可能会造成 *false fragmentation*，即合并后能放下但每个单独无法放下，所以需要对相邻的 free block 进行合并 (coalesce)。

合并有两种策略：

-   immediate coalescing：每次 free 时都将新得到的 free block 与相邻的 free block 合并，这样的话每时每刻都不会有相邻的 free block
-   deferred coalescing：等到某个时候再合并，例如在未能找到足够大的 free block 时

immediate coalescing 的实现较为简单，可以在常数时间内完成，但可能会导致反复的合并和分割，带来不必要的性能损失。

合并时需要知道上一个 block 的信息，这可以通过在 block 尾部添加一个与 header 内容相同的 footer 来实现，这被称作使用 *boundary tags*。由于只有 free block 需要 footer，可以省去 allocated block 的 footer，而在 header 中存储上一块的 allocated bit，来节省空间。

### explicit free list

可以在 free block 中存储指向前驱后继的指针来维护一个 free block 的链表，称作 *explicit free list*。

这个 list 可以是 LIFO 的或者按地址顺序的。LIFO 的 list 可以在常数时间内完成 free 操作，而按地址顺序的 list 需要使用线性时间来找到一个 block 在 list 中的位置，但内存利用率更高。

由于需要足够大的空间来存储前驱后继的指针，explicit free list 的 minimum block size 更大，可能会出现更严重的 internal fragmentation 导致内存利用率下降。

### segregated free lists

可以将 block 按 size 分类，例如按 2 的次幂分类，每一类维护一个 list。具体实现方式有很多，例如 simple segregated storage 和 segregated fits。

#### simple segregated storage

每一类的所有 block 都是这一类的最大 size，如果一类 block 用光了就申请新的 heap 空间，free 时直接放回相应的 list，不合并也不分割。

这样的话，header 和 footer 都不需要了，只需在 free block 里存放一个后继指针即可，但 internal fragmentation 和 external fragmentation 都很严重。

#### segregated fit

每一类中有不同大小的 block，有分割和合并。allocate 时从相应的类别开始找，在一类中找不到就继续找下一类，这样近似于 best-fit search，但速度很快。

segregated fit 的综合性能较好，所以包括 libc 中的 \`malloc\` 函数在内的 allocator 往往选择使用 segregated fit。

#### buddy system

所有 block size 都是 2 的次幂，分割时每次分成两半直到大小合适，合并时只和 “buddy” 合并。

这里描述清楚可能比较复杂，就感性理解一下，所有的 block 会形成一个如下图所示树状的样子（有点树状数组的感觉），parent 相同的 block 就是 buddy。

![buddy system](buddy-system.png)

这样的话，搜索和合并会比较快速，但由于 block size 都是 2 的次幂，可能出现严重的 internal fragmentation。

### 平衡树维护 free block

CS:APP 中没有提到这种方式，但只要理解了上面这几种 free list，就很好理解，free block 不一定要用链表维护，也可以用平衡树维护：在 free block 中存放树的节点所需的 children、parent 等信息，就可以高效实现严格的 best fit，复杂度也不会像 segregated fit 一样在极端情况下发生退化。但是树的节点需要的信息往往比链表多，可能会让 minimum block size 增大到 6 个 word。

我自己写 malloc lab 的时候试着写了个 Splay，发现一般情况下还是比 segregated fit 慢不少，内存利用率也不一定有明显提升，不知道其他平衡树 / 特殊场景下性能如何。倒是在网上看到有说红黑树可以在 malloc lab 拿高分（~~谁用好的算法拿高分啊，不是考验对着数据调参的能力吗，我觉得我对数据过拟合的 segregated fit 分已经够高了~~）（~~虚假的 segregated fit：按 block size segregate 来寻找 fit；真正的 segregated fit：按测试数据 segregate 分别进行 fit~~）。

## Garbage Collection

可以通过 block 之间以及 stack、register、global 变量对 block 的引用关系找到不可达的 block 而进行 garbage collection。

在 C 中，由于没有类型信息，可能会将非指针类型的数据视作对 block 的引用，导致不可达的 block 被视作可达，所以 C 语言的 garbage collection 只能是 conservative 的。
`},{title:E,tags:"游泳 经验分享",content:`这学期选了游泳零基础班作为体育课。一开始的时候只是略低于平均水平，但到后来学习换气的时候，在 20~40m 左右卡了很久，最后能连续游 50m 比班上倒数第二晚了三节课。

在体育方面会垫底是我预料之中的，但比倒数第二差太多，长期和班上同学分开上课，还是挺难受的。但是，这段经历也让我有了丰富的失败经验（，可以水一篇踩坑记录，幸运的话可能还能在未来帮到某人。



在过程中，老师不断和我说“太紧张了”“要坚持下来”“呛到水、换气不充分要学会调整，不要总是停下来”“为什么停下来呢”（也有动作纠正，只不过在这之前有很多 PUA），但在最后学会之后，我还是觉得，正确的动作远胜于盲目的练习，更别提玄学的《心态》了。比起出问题后学会调整，不出问题才是最重要的。

不知道心态、毅力在游几百米时有多重要，但如果几节课都没什么进步、50m 都游不下来，很可能还是动作有问题。

虽然整个过程很艰辛，但总结起来也没多少东西，就是下面这几点：

1.  在抬头换气前，要先在水下把气吐干净。开始吐气的时机大概是换气前最后一次蹬腿时。
2.  如果蹬太多次腿再换气，可能会气不够，可以只蹬 1~2 次腿就换气。
3.  换气后下沉是正常的，换气后立即蹬一次腿可以缓解下沉。
4.  划手时，要以合适的角度往下撑，凭借下撑的反作用力让头抬起来。否则，如果单靠下巴和腰，头就很难抬高，从而没有充分的时间换气。
5.  虽然吸气只用嘴，但吐气时可以适当用鼻子辅助，也可以一定程度上防止鼻子进水。
6.  嘴巴要张大，类似于打哈欠的程度，以至于吸气时感受不到气流。如果嘴张的小，就容易换气不充分或者呛到水，时间久了也容易累、不适。一开始老师跟我说要张大的时候我还以为是从 wo 张大到 o，后来才知道要到打哈欠的程度。

不知道最后老师说“比上周好多了”“这不是 100m 就游下来了吗”的时候，是否觉得我“不紧张了”“能坚持下来了”。反正，我心里想的是：“原来嘴 tmd 要张这么大，嘴一张大立刻轻松一万倍。”

P.S. 这篇的 [og](https://ogp.me/) image 是 [【中字】打铁自述励志学游泳经历](https://www.bilibili.com/video/av556552520) 的 [封面](/images/2022/11/swim.jpg)，因为很草所以想起来就用作 og image 了（，然后重新看了一遍这个切片，当时看的时候还体会不到按距离分组、自己垫底的感觉，现在也能对 kanon（~~考哥震怒~~）的苦呀西感同身受了。
`},{title:k,tags:t,content:`[CS:APP](https://csapp.cs.cmu.edu/) 第六章 “The Memory Hierarchy” 的学习笔记。

这章的主要内容有：各种存储设备（RAM、ROM、HDD、SSD）的特点、程序的局部性、缓存的结构以及原理、缓存对程序性能的影响。



因为时间不太够，本来我想先跳过这章以后再补的，但学第九章的时候感觉还是跳不得，否则第九章有些东西感觉学了个半懂。~~虽然只用学一小部分就足以满足第九章的需求，但我打算摆烂了，该学的东西学不完就学不完，我想学啥就学啥。~~

## Storage Technologies

### RAM

*Random access memory* 分为 SRAM 和 DRAM 两种，SRAM 有更快的访问速度但更加昂贵。

#### SRAM

SRAM (Static RAM) 将每个 bit 存储在一个 *bistable* 的 memory cell 中，每个 cell 由 6 个晶体管组成，有两种可能的稳定态，遇到微小的扰动也会迅速恢复到这两种状态之一。

#### DRAM

DRAM (Dynamic RAM) 将每个 bit 存储在一个很小的电容中，容易受到外界干扰，所以需要周期性地将数据复制出去再复制回来以进行刷新，可能还会配合纠错码来保证数据正确。

DRAM 的设计使其存储密度更高，但访问速度更慢；SRAM 则更快，但密度更低，更贵，更费电。访问 DRAM 的用时大约是 SRAM 的 10 倍，而 SRAM 的造价大约是 DRAM 的 1000 倍。

#### Conventional DRAM

DRAM 芯片被分为若干 *supercell*，每个 supercell 存储一个 word，一般是 1 byte。supercell 排列为二维阵列，可以用二维坐标 $(i, j)$ 定位。

DRAM 通过 *pin* 连接到 *memory controller* 来和外界通信。读取位于 $(i, j)$ 的 supercell 时，memory controller 会依次发送 *row access strobe* (RAS) $i$ 和 *column access strobe* (CAS) $j$，在收到 RAS 后 DRAM 会将第 $i$ 行复制到一个内部的 row buffer，收到 CAS 后再从 row buffer 里将第 $j$ 列发送给 memory controller。

#### Memory Module

DRAM 芯片会被组装为 *memory module* 来插到主板上。

DIMM 是一种 memory module。例如，一个 DIMM 可以包含 8 个 DRAM 芯片，每个 64-bit 的 word 在每个 DRAM 芯片的同一个地址上分别存一个 byte，从而整个 DIMM 可以以 64-bit 为单位与外界通信。

#### Enhanced DRAM

朴素的 DRAM 是比较慢的，历史上曾经有过若干对 conventional DRAM 的优化：

1.  FPM (fast page mode) DRAM: 如果连续两次 RAS 是一样的，可以省略掉后续相同的 RAS，直接发送 CAS
2.  EDO (extended data out) DRAM: 延长了数据输出的时间，对 pipelining 有帮助
3.  SDRAM (synchronous): 通过时钟信号的 rising edge 同步地通信，而非通过发送 RAS/CAS 异步通信
4.  DDR (double data-rate) SDRAM: 通过同时使用时钟信号的 rising edge 和 falling edge 达到 double data-rate，分为 DDR、DDR2、DDR3、DDR4、DDR5 等
5.  VRAM (video): 一般用于显卡、frame buffer 等，它的输出是直接输出整个 buffer，并且可以并行地同时读和写

### ROM

RAM 会在断电后丢失数据，所以是 *volatile* 的。与之相对，还有 nonvolatile 的存储器，统称为 *read-only memory* (ROM)，尽管有的 ROM 是可以写入的。ROM 的写入称作 *reprogram*。

-   PROM (programmable ROM) 只能被写入一次。
-   EPROM (erasable PROM) 需要用特殊设备写入，可以写入大约 1000 次。
-   EEPROM (electrically EPROM) 不需要用特殊设备就可以写入，可以写入大约 $10^5$ 次。
-   flash memory 是一种基于 EEPROM 的 nonvolatile 存储器，被广泛使用，包括用于 [SSD](#ssd)。
-   固件 (firmware) 往往存储于 ROM 中。

### 访问 main memory

一个 *bus* 是一组用来通信的导线，可以传输地址、数据、控制信号等。CPU 和 main memory 之间的通信通过 *bus transaction* 进行。

CPU 通过 system bus 连接 I/O bridge，I/O bridge 通过 memory bus 连接 main memory。I/O bridge 负责 system bus signal 和 memory bus signal 之间的转换。

### HDD

#### 磁盘的结构

磁盘由若干 *platter*（盘片）组成。每个 platter 有两个 *surface*（表面），每个 surface 上覆盖着磁性记录材料。platter 由位于中心的 *spindle*（主轴）带动，以某个一般是 5400~15000 RPM 的速度转动。

每个 surface 被分成若干个称作 *track*（磁道）的同心圆环，每个 track 被分为若干 *sector*（扇区）。每个 sector 存有相同大小的数据（一般是 512 bytes），相邻的 sector 之间由 *gap*（间隙）隔开，gap 不存储数据，而是用来识别 sector。

一个磁盘通常由多个堆叠在一起的 platter 构成，这些 platter 共享一个 spindle。对于某个距离 $k$，一个磁盘内所有 surface 上离转轴距离为 $k$ 的 track 的集合称作一个 *cylinder*（柱面）。

整体结构如 CS:APP Figure 6.9 所示：

![磁盘结构示意图](csapp-fig6.9.png)

#### 磁盘的容量

磁盘的容量有三个衡量指标：

-   recording density: 单位长度的 track 存储的 bit 数量
-   track density: 单位长度的半径上的 track 个数
-   areal density: 单位面积上存储的 bit 数量

早期的磁盘的所有 track 都有相同数量的 sector，这样的话位于外部的 track 的 sector 就会更加稀疏。后来为了提高容量，将 cylinder 划分成了若干个 *recording zone*，每个 recording zone 由若干相邻的 cylinder 组成，同一个 recording zone 内的所有 track 有相同数量的 sector。

#### 磁盘的读写

磁盘通过连在传动臂上的读写头进行读写，每次读写前需要先将读写头移动到相应的位置（寻道），并等待目标 sector 转动到读写头下，再开始读写。

寻道用时与读写头原本的位置到目标位置的距离有关，等待转动的用时则看运气。在 CS:APP 举的例子中，寻道平均用时为 9 ms，等待旋转平均用时为 4 ms，读写一个 sector 用时 20 μs。

也就是说，磁盘读写的主要用时是寻道以及等待旋转用时，也就是初次访问一段连续的 sector 的用时，而与访问多少个连续的 sector 关系不大。对于单个 sector，磁盘访问的用时可以达到 SRAM 的 $10^4$ 倍，DRAM 的 $10^3$ 倍，但连续 sector 的读写用时仅为 DRAM 的不到十倍。

#### Logical Disk Blocks

磁盘对外提供了 *logical block* 作为 sector 的抽象，每个 logical block 的大小和一个 sector 相同，由连续的非负整数索引，通过 *disk controller* 翻译成形如 *(surface, track, sector)* 的坐标。

<Card title="磁盘格式化">
磁盘在使用前需要进行格式化：在 gap 中写入 sector 的标识信息，识别出有故障的 cylinder，将一些 cylinder 设为备用以防其他 cylinder 损坏。由于备用 cylinder 的存在，formatted capacity 会小于 maximum capacity。
</Card>

### I/O bus

不同的 I/O 设备通过 I/O bus 与 I/O bridge 连接。例如显卡、连接各种设备的 USB controller、通过 SCSI/SATA 等接口连接磁盘的 host bus adapter 等都会连接到 I/O bus。

### 访问磁盘

访问磁盘需要向磁盘发送三条指令：

1.  向磁盘发送一个信号，告诉磁盘要读取数据
2.  将要读取的 logical block number 发送给磁盘
3.  告诉磁盘读取到的数据要放在 main memory 的哪个地址

发送完这些指令后，CPU 会继续干其他事情。磁盘读取到数据后，会通过 I/O bus 直接将数据存放到 main memory 中而不经过 CPU，这被称作 *direct memory access* (DMA)。存放好数据后，磁盘向 CPU 发送 interrupt signal 来跳转到处理磁盘读取完成的 signal handler。

### SSD

SSD 将一个或多个 flash memory 包装起来，并且有一个 *flash translation layer* 来将输入的 logical block number 转换为对 flash memory 的访问，对外表现出与 HDD 类似的接口。

flash memory 由若干 block 组成，每个 block 又由若干（32-128 个）page 组成，每个 page 一般是 512B-4KB 大，数据传输的最小单位是 page。

SSD 的写入比较特殊：一个 page 需要在所属的整个 block 都被擦除（改为全 1）后才能写入一次，如果要写入第二次就得再把整个 block 擦除一遍。在写入时，为了擦除某个 block，可能会需要把这个 block 存储的数据复制到其他 block。擦除是一个耗时相对较长的操作，需要约 1 ms，并且每个 block 在擦除约 $10^5$ 次后就会损坏。

这使得 SSD 的写入比读取略慢，并且写入很多次后可能损坏。flash translation layer 会通过 *wear-leveling logic* 来尽可能使得每个 block 的擦除次数相同，以延长 SSD 的使用寿命。

disk、RAM、CPU 速度差异的历史变化如 CS:APP Figure 6.16 所示，其中 CPU cycle time 是单核的，effective CPU cycle time 是多核的：

![disk、RAM、CPU 速度差异的历史变化](csapp-fig6.16.png)

## Locality

好的程序具有良好的 *locality*。locality 有两种表现形式，*temporal locality* 指的是最近访问过的数据更有可能在不久的将来再次被访问，*spatial locality* 指的是访问过一处的数据后更有可能在不久的将来访问邻近的其他数据。

具有良好 locality 的程序跑得更快，因为计算机系统设计的各个层面都利用 locality 做了优化。

一些 locality 的例子：

-   重复引用同一个变量的程序有良好的 locality。
-   在一段连续内存（数组）中依次访问每个元素称作 *stride-1 reference pattern*，每次间隔 $k-1$ 个元素进行访问称作 *stride-k reference pattern*，$k$ 越小 locality 越好。遍历高维数组时尤其要注意访问的顺序。
-   由于循环会重复访问同一段指令，循环的指令读取局部性良好

## The Memory Hierarchy

在硬件上，不同存储技术之间存在性能、价格、容量的 trade-off；在软件上，程序具有 locality。硬件和软件的这两条性质正好可以搭配在一起，促使 memory system 采用了如 CS:APP Figure 6.21 所示的称作 *memory hierarchy* 的组织方式：

![The memory hierarchy](csapp-fig6.21.png)

memory hierarchy 的构成并不一定和上图完全一致，例如 SRAM 的级数可能不是三级、DRAM 和 HDD 间可能还有 SSD、磁带也可以作为 memory hierarchy 中比 HDD 更低的一级。

### Cache

caching 指的是用一个相对小而快的存储设备来存储一个相对大而慢的存储设备中最为活跃的部分，这个小的存储设备称作大的存储设备的 cache。

在 memory hierarchy 中，每一级都是下一级的 cache。数据会在各个相邻层级间不断地传输，不同层级之间会以不同的 block size 作为数据传输的基本单位。

### 从 cache 获取数据

想要从 memory hierarchy 的某一级获取数据时，首先会尝试从它的 cache 获取数据，如果成功获取则称作 *cache hit*，否则称作 *cache miss*。

发生 cache miss 时，一般会先将数据从下一级复制到上一级，从而最终还是表现为从 cache 中获取数据。如果 cache 满了，在从下一级获取数据时，就需要删除 cache 中的一些数据来腾出空间，这时需要在 cache 中选择被删除的数据，被删除的 block 称作 *victim block*，这个行为称作将 victim block *evict*，而选择 victim block 是根据 *replacement policy* 进行的，例如 random replacement policy、least recently used (LRU) replacement policy 等。

### Cache 的管理

cache 可能由硬件、OS、软件以及它们之间的相互配合来进行管理，而这在大部分时候都是自动完成的，无需应用程序的程序员操心。

各级 cache 如 CS:APP Figure 6.23 所示：

![无处不在的各式各样的 cache](csapp-fig6.23.png)

### Cache 对 locality 的利用

temporal locality 使得重复使用的数据留存在 cache 中从而更容易 cache hit；cache 中的数据按 block 存储则利用了 spatial locality，使得一个数据被 cache 时与其邻近的处于同一个 block 的数据也被 cache。

## Cache Memories

随着 CPU 和 DRAM 的速度差异越来越大，SRAM 被用来填充它们之间的 gap。

在下面的讨论中，为了简便，假设只有 L1 cache，没有 L2、L3 cache。（或者也可以看成是在介绍 L3 cache 是如何工作的。）

### Cache 的结构与读取

设 main memory 有 $2^m$ 个地址，每个地址存放一个 byte。它的 cache 会分成 $2^s$ 个 *cache set*，每个 cache set 包含 $E$ 个 *cache line*，每个 cache line 存放一个大小为 $2^b$ byte 的 data block、一个 *valid bit*、以及长度为 $t = m-b-s$ 的 *tag bits*。

每个地址会被分成三部分，高位的 $t$ 位是 tag，中间 $s$ 位是 set index，低位 $b$ 位是 block offset。获取存放在某个地址的数据时，先根据其 set index 找到对应的 cache set，再在 cache set 中找到 valid bit 为 1 且 tag 相符的 cache line，最后通过 block offset 来从 block 中提取出单个 byte。

在 cache miss 时，需要从下一级获取数据，存放到 cache 中。如果对应的 cache set 所有 cache line 都满了，就需要 evict 某个已有的 cache line。

### Conflict Miss

cache set 的设计基于一个假设，即在局部内访问的数据地址的低位往往是不同的，但实际上可能并非如此。如果以 $2^{s+b}$ 的倍数为地址间隔访问数据，就可能连续访问同一个 cache set 内的数据，导致 cache miss（$E$ 较小，尤其是 $E=1$ 时，这种情况更可能触发）。例如，数组的大小是 $2$ 的次幂而交替访问相邻数组的同一个下标时就可能这样。（这大概在 APIO2019 讲过，当时我自然是啥都没听懂，就只记得数组不要开 $2$ 的次幂。）

### Cache 的分类

$E=1$ 的 cache 称作 *direct-mapped cache*。（~~书上在这仔细解释了半天，感觉废话好多啊。~~）

$E > 1$ 的 cache 称作 *set associative cache*。其中，$s > 0$ 的称作 E-way set associative cache，而 $s = 0$ 的称作 fully associative cache。

### Cache 的写入

在 cache hit 时，有两种处理方式：

-   *write-through*: 既修改 cache，又修改下一级
-   *write-back*: 只修改 cache，并且在每个 cache line 中添加一个 *dirty bit*，用来记录是否被修改过，在被 evict 时若 dirty 则写入下一级

在 cache miss 时，也有两种处理方式：

-   *write-allocate*: 先从下一级获取数据，然后用与 cache hit 相同的处理方式
-   *no-write-allocate*: 直接写入下一级，不获取到 cache 中

一般 write-through 和 no-write-allocate 搭配，write-back 和 write-allocate 搭配。

实际上，cache 写入的优化是非常复杂的问题，这里只是简单介绍了一下。作为程序员，可以把 cache 写入当成是 write-back、write-allocate 的。

### i-cache 和 d-cache

只存放指令的 cache 称作 *i-cache*，只存放数据的 cache 称作 *d-cache*，都存放的 cache 称作 *unified cache*。

将 i-cache 和 d-cache 分开，就可以对它们分别进行优化，例如 i-cache 是只读的，二者可以有不一样的大小、不一样的 cache set 设置。将两者分开还可以一定程度上避免 conflict miss。

在 Core i7 处理器中，每个核有自己的 L1 i-cache、L1 d-cache、L2 unified cache，所有核共享一个 L3 unified cache。

### Cache 的性能

cache 性能的衡量指标有：

-   miss rate
-   hit rate
-   hit time: cache hit 时的访问用时
-   miss penalty: cache miss 时的访问用时，与最终从哪一级获取到数据有关

一般来说，cache 的参数对性能的影响是：

-   cache size 越大，hit rate 就越高，但速度会慢。
-   增大 block size 可以更好地利用 spatial locality，但也有可能因 cache line 数量减少而降低 hit rate，并且会因为每次需要传递的数据变多而增大 miss penalty。
-   更大的 $E$ 可以降低 conflict miss 的可能性，但也会使得 tag 匹配以及 victim line 的选择更加复杂，从而增大 hit time 和 miss penalty。在 Core i7 处理器中，L1、L2 cache 是 8-way 的，L3 cache 是 16-way 的。
-   write-through 实现起来更加容易，并且在 read miss 时不会触发写入。而 write-back 可以减少数据传递的总量，降低 I/O bus 带宽的占用，也可能降低数据传递的用时。一般来说，memory hierarchy 中较低的层级更倾向于使用 write-back。

## The Impact of Caches on Program Performance

### The Memory Mountain

对一定 size 的数据按照一定的 stride 进行访问，将 size、stride 与数据吞吐量的关系画成三维图像，就得到了 *memory mountain*。

CS:APP Figure 6.41 展示了一座 Core i7 的 memory mountain:（这也是 CS:APP 的封面）

![Core i7 的 memory mountain](csapp-fig6.41.png)

Memory mountain 较为完整地呈现了一个 memory system 的性能，以及 temporal locality 和 spatial locality 对性能的影响。

在每级 cache 的容量处，吞吐量会发生明显的突变。

在 size 相同时，stride 越小吞吐量越高。在 stride 接近 1 时变化尤其明显，这和 Core i7 系统的 prefetching 技术息息相关，处理器能够识别出 stride-1 reference pattern 并在实际访问到数据之前就进行 prefetch。

### 矩阵乘法的循环顺序

（书上在这讲了半天，~~感觉废话好多~~，我就放个测试结果上来吧。）（CS:APP Figure 6.46）

![Core i7 矩阵乘法性能](csapp-fig6.46.png)
`},{title:S,tags:i,content:`[DDPP5](https://wakerly.org/DDPP/) 第二章 “Number Systems and Codes” 的学习笔记。



开头整数编码的内容很多是 [CS:APP 第二章](/post/2022/09/csapp-2) 讲过的，也有一些新内容，但基本上都是标星的可选内容，我看是看了但懒得写笔记了（

一套编码被称作一个 *code*，一个 code 中的单个合法编码（二进制串）被称作一个 *code word*。

## Gray Code

Gray code 的性质：相邻两个数的 code word 只有一位不同，且 $2^n-1$ 的 code word 中只有一个 1（也就是说 $n$-bit Gray code 的首尾也只有一位不同）。

<Card title="4-bit Gray code" fold>

\`\`\`
 0: 0000
 1: 0001
 2: 0011
 3: 0010
 4: 0110
 5: 0111
 6: 0101
 7: 0100
 8: 1100
 9: 1101
10: 1111
11: 1110
12: 1010
13: 1011
14: 1001
15: 1000
\`\`\`

</Card>

递归构造：

1.  $1$-bit Gray code: 0 是 0，1 是 1
2.  $(n+1)$-bit Gray code:
    -   前 $2^n$ 个数和 $n$-bit Gray code 相同（开头加上 0）
    -   后 $2^n$ 个数是把 $2^n$ 个 $n$-bit Gray code 逆序排列再在开头加上 1

直接计算单个数的 Gray code：

-   递归就能直接计算，~~相信大家都会做 [NOIPD1T1](https://uoj.ac/problem/488) 吧，记得开 \`unsigned long long\`~~（
-   也可以这么算：$n$ 的 Gray code 第 $i$ 位为 1 当且仅当 $n$ 的二进制中第 $i$ 位和第 $i+1$ 位不同

书中描述了一个使用场景：一个磁盘的每个扇区需要编码，从扇区上读取若干 bits 来识别当前处于哪个扇区，在两个相邻扇区的交界处可能有部分 bits 来自其中一个扇区，另外的 bits 来自另一个扇区，Gray code 可以使最终读取到的结果一定是这两个扇区之一。

## Codes for Actions, Conditions, and States

说白了就是如何编码一个 enum。不同的编码方式有各自的特点，可以从编码长度、电路开销、设计难度、可纠错性等角度考虑，选择最合适的编码方式，或者组合使用多种编码方式。

-   顺着编码为二进制可以使编码长度最短（$\\lceil \\log_2 n \\rceil$）。
-   *1-out-of-n-code*：合法的 code word 只有一位是 1，每个 enum 对应某一位为 1。例如，控制哪个灯开时，这种编码方式无需再有电路来选择要开的灯，直接将编码的每一位连到一盏灯就可以了。
-   *m-out-of-n-code*：合法的 code word 恰有 $m$ 位是 1。要检测一个 code word，只需使用一个 $m$-input AND gate，电路较为简单。而 code word 总数有 $\\binom nm$，也很多。

## n-Cubes and Distance

以 $2^n$ 个 $n$-bit 二进制串作为顶点，在只有一个 bit 不同的串之间连边，得到的图被称作 *$n$-cube*，可以画成一个（超）立方体：（DDPP5 Figure 2-8）

![n-cubes for n = 1, 2, 3, and 4.](ddpp-fig-2-8.png)

图上两个二进制串之间的距离被称作 *Hamming distance*，表示两个串中不相同的位数。

## Codes for Detecting and Correcting Errors

实际存储、传输编码时，可能会发生错误。错误的具体行为可以由 *error model* 刻画。最简单的 error model 是 *independent error model*，即每个错误只独立地改变编码中的一位，多位同时发生错误的概率比一位发生错误的概率小得多。

### Error-Detecting Codes

对于一个 code，不是 code word 的二进制串称作 *noncode word*。

*error-detecting code* 具有这样的性质：任何一个 code word 在任意修改一位后都会得到一个 noncode word。

使用 error-detecting code 时，可以认为只要是 code word 都没有发生错误，noncode word 则一定发生了错误。

一个 $n$-bit error-detecting code 是 $n$-cube 的一个点独立集，也就是说任意两个 code word 的 Hamming distance 都至少为 2。

奇偶性可以用来设计 error-detecting code：任给一个 $n$-bit code，将第 $n+1$ 位设为前 $n$ 位中 1 的个数的奇偶性（称作 *parity bit*），则可以得到一个 $(n+1)$-bit error-detecting code。这样的编码称作 *1-bit parity code*，若 code word 都有偶数个 1 则称作 *even-parity code*，有奇数个 1 则称作 *odd-parity code*。

### Error-Correcting and Multiple-Error-Detecting Codes

如果一个 code 中两个 code word 的最小 Hamming distance 有 $2c+d+1$，则可以对最多 $c$ 位的错误进行纠正，并且检测到最多 $c+d$ 位的错误（一个 $c+d+1 \\sim 2c+d$ 位的错误会被认为是来自另一个方向的错误而被错误地纠正，从而不能被检测到；可以选择少纠错几位来检测到更多位的错误）。

纠错就是找到和一个 noncode word 的 Hamming distance 最小的唯一一个 code word，进行纠错的硬件被称作 error-correcting decoder。

### Hamming Codes

*Hamming code* 是一种通用的最小距离为 3 的编码。一个有 $n$ 个 check bit 的 Hamming code 最多可以存储 $2^n-n-1$ 个 information bit，从而总共有 $2^n-1$ 个 bit。

一个 $(2^n-1)$-bit Hamming code 的 bit 依次编号为 $1 \\sim 2^n-1$，编号为 $1, 2, 4, \\ldots, 2^{n-1}$ 的 bit 是 check bit。每个 check bit 代表一个 group，编号为 $2^i$ 的 check bit 所代表的 group 包含的是编号的二进制中包含 $2^i$ 的所有 bit。check bit 的取值使得每个 group 都含偶数个 1。

实际使用的 Hamming code 往往会将 check bit 移到末尾，例如一个 $15$-bit Hamming code 中 bit 的编号依次为 15, 14, 13, 12, 11, 10, 9, 7, 6, 5, 3, 8, 4, 2, 1。

因为每个 bit 都至少属于一个 group，改变一个 bit 会得到 noncode word。改变编号为 $i$ 和 $j$ 的两个 bit 时，会改变 $i$ 异或 $j$ 对应的 group，所以改变两个 bit 会得到 noncode word。所以 Hamming code 中两个 code word 的 Hamming distance 至少为 3。

纠错时，只要将错误的 check bit 的编号或起来就可以得到错误的 bit 的编号。

可以通过增加一个 parity bit 来得到一个最小距离为 4 的 $2^n$-bit extended Hamming code。

### CRC Codes

*cyclic-redundancy-check (CRC) codes* 是一种得到广泛应用的 error-correcting code，例如被用在文件系统和网络通信中，它可以检测到成团出现的多位错误，在一些场景中这种错误比随机出现的错误概率更高。

### Two-Dimensional Codes

如 DDPP5 Figure 2-14 (a) 所示：

![所有 bits 排列成一个矩阵，矩阵被划分为四个部分: information bits, checks on rows, checks on columns, checks on checks.](ddpp-fig-2-14-a.png)

选择 $C_{\\mathrm{row}}$ 和 $C_{\\mathrm{col}}$ 两种编码方式，设置 checks on rows 使得 information bits 所在的每一行都是一个 $C_{\\mathrm{row}}$ 的 code word，设置 checks on columns 使得 information bits 所在的每一列都是一个 $C_{\\mathrm{col}}$ 的 code word，而 checks on checks 则可以选择，要么每一行都是一个 $C_{\\mathrm{row}}$ 的 code word，要么每一列都是一个 $C_{\\mathrm{col}}$ 的 code word。

这样得到的 *two-dimensional code* 的最小距离是 $C_{\\mathrm{row}}$ 和 $C_{\\mathrm{col}}$ 的乘积，所以 two-dimensional code 也被叫做 *product code*。

RAID 就可以看作使用了 two-dimensional code：每块数据盘内的每个 block 都有 CRC code，还有一块硬盘用来存所有数据盘的 parity bits。

### Checksum Codes

parity bit 可以看作是 bits 在模 2 意义下的和，可以推广为 *checksum*。

例如，模 256 意义下，可以计算 bytes 的和，来检测 bytes 的错误。

除了改变模数，还可以改变计算方式，例如使用 ones’ complement 加法来计算模 255 或 65535 意义下的 checksum。

### m-out-of-n Codes

[m-out-of-n code](#codes-for-actions-conditions-and-states) 的最小距离为 2，并且能够检测到 *unidirectional multiple errors*，即所有错误都是 0 变 1 或 1 变 0 的改变多位的错误。

## Codes for Transmitting and Storing Serial Data

-   parallel data transmission: 一个 data word 的所有 bit 同时传输
-   serial data transmission: 一个 bit 一个 bit 传输

在某些场景下，serial data transmission 可以减少线路开销，或者减少一些设计上的困难。

最基本的 serial data transmission 需要三个信号：

-   CLOCK: 将时间划分为一个个 *bit cell*，标识出每个 bit 所处的时间范围
-   SERDATA: 实际传输的数据，具体内容依 *line code* 而定
-   SYNC: 用来标识 bit 的 significance，例如传输 bytes 时用来标记每个 byte 的开头

实际上，也可以选择合适的 line code 从而只需传输一个信号，从数据信号中读取出 CLOCK 和 SYNC 的信息。

<Card title="Serial Line Codes" type="wip">
Serial Line Codes 这一节我感觉有些地方没完全理解，也有和 Wikipedia 有出入的地方，也标星了，感觉后面不一定用得上，就先咕了。
</Card>
`},{title:A,tags:i,content:`[DDPP5](https://wakerly.org/DDPP/) 第三章 “Switching Algebra and Combinational Logic” 的学习笔记。



## Switching Algebra

这一节基本上就是离散数学 (1) 开头两章的内容，术语和记号有很多不同，~~幸好忘的差不多了，不然都要搞混了~~。

### 记号

-   AND：$X\\ \\cdot\\ Y$
-   <span class="inline-block w-3"/>OR：$X + Y$
-   NOT：$X'$
-   AND 的优先级高于 OR

（yysy 我还是更喜欢 $\\lor, \\land$，$\\cdot$ 也还行，$+$ 真的有点难以接受。）（~~它们明明是对偶的怎么搞得像个环一样。~~）（主要还是下面这些定理用加号看起来真的好怪。）（异或不是还号称二进制加法吗。）

### 公理

$$
\\begin{array}{rl}
\\text{(A1)} & X \\ne 1 \\implies X = 0 \\\\
\\text{(A1D)} & X \\ne 0 \\implies X = 1 \\\\\\\\
\\text{(A2)} & X = 0 \\implies X' = 1 \\\\
\\text{(A2D)} & X = 1 \\implies X' = 0 \\\\\\\\
\\text{(A3)} & 0 \\ \\cdot\\  0 = 0 \\\\
\\text{(A3D)} & 1 + 1 = 1 \\\\\\\\
\\text{(A4)} & 1 \\ \\cdot\\  1 = 1 \\\\
\\text{(A4D)} & 0 + 0 = 0 \\\\\\\\
\\text{(A5)} & 0 \\ \\cdot\\  1 = 1 \\ \\cdot\\  0 = 0 \\\\
\\text{(A5D)} & 1 + 0 = 0 + 1 = 1
\\end{array}
$$

### 定理

中文名来自《数理逻辑与集合论（第二版）》2.2 节“等值公式”。

$$
\\begin{array}{ll}

\\begin{array}{rl}
\\enspace\\text{(T1)} & X + 0 = X \\\\
\\enspace\\text{(T1D)} & X \\ \\cdot\\  1 = X
\\end{array}
& \\text{Identities（同一律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T2)} & X + 1 = 1 \\\\
\\enspace\\text{(T2D)} & X \\ \\cdot\\  0 = 0
\\end{array}
& \\text{Null elements（零律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T3)} & X + X = X \\\\
\\enspace\\text{(T3D)} & X \\ \\cdot\\  X = X
\\end{array}
& \\text{Idempotency（幂等律）}
\\\\\\\\

\\begin{array}{rl}
\\quad\\ \\text{(T4)} & (X')' = X
\\end{array}
& \\text{Involution（双重否定律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T5)} & X + X' = 1 \\\\
\\enspace\\text{(T5D)} & X \\ \\cdot\\  X' = 0
\\end{array}
& \\text{Complements（补余律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T6)} & X + Y = Y + X \\\\
\\enspace\\text{(T6D)} & X \\ \\cdot\\  Y = Y \\ \\cdot\\  X
\\end{array}
& \\text{Commutativity（交换律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T7)} & (X + Y) + Z = X + (Y + Z) \\\\
\\enspace\\text{(T7D)} & (X \\ \\cdot\\  Y) \\ \\cdot\\  Z = X \\ \\cdot\\  (Y \\ \\cdot\\  Z)
\\end{array}
& \\text{Associativity（结合律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T8)} & X \\ \\cdot\\  (Y + Z) = \\,\\: X \\ \\cdot\\  Y \\,\\: + \\,\\: X \\ \\cdot\\  Z \\,\\: \\\\
\\enspace\\text{(T8D)} & X + \\,\\: Y \\ \\cdot\\  Z \\,\\: = (X + Y) \\ \\cdot\\  (X + Z)
\\end{array}
& \\text{Distributivity（分配律）}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\text{(T9)} & X + \\,\\: X \\ \\cdot\\  Y \\,\\: = X \\\\
\\enspace\\text{(T9D)} & X \\ \\cdot\\  (X + Y) = X
\\end{array}
& \\text{Covering（吸收律）}
\\\\\\\\

\\begin{array}{rl}
\\text{(T10)} & \\,\\: X \\ \\cdot\\  Y \\,\\: + \\,\\: X \\ \\cdot\\  Y' \\,\\: = X \\\\
\\text{(T10D)} & (X + Y) \\ \\cdot\\  (X + Y') = X
\\end{array}
& \\text{Combining}
\\\\\\\\

\\begin{array}{rl}
\\text{(T11)} & \\begin{aligned} & X \\cdot Y + X' \\cdot Z + Y \\cdot Z \\\\[-0.2em] =\\ & X \\cdot Y + X' \\cdot Z \\end{aligned} \\\\
\\text{(T11D)} & \\begin{aligned} & (X + Y) \\cdot (X' + Z) \\cdot (Y + Z) \\\\[-0.2em] =\\ & (X + Y) \\cdot (X' + Z) \\end{aligned}
\\end{array}
& \\text{Consensus}
\\\\\\\\

\\begin{array}{rl}
\\text{(T12)}  & X + X + \\cdots + X = X \\\\
\\text{(T12D)} & X \\ \\cdot\\  X \\ \\cdot\\ \\cdots\\ \\cdot\\  X = X
\\end{array}
& \\text{Generalized idempotency}
\\\\\\\\

\\begin{array}{rl}
\\text{(T13)} &
\\begin{aligned}
& (X \\ \\ \\cdot\\  X \\ \\ \\cdot\\ \\cdots\\ \\cdot\\  X)' \\\\[-0.2em]
= & \\,\\: X' + X' + \\cdots + X'
\\end{aligned}
\\\\
\\text{(T13D)} &
\\begin{aligned}
& (X + X + \\cdots + X)' \\\\[-0.2em]
= & \\,\\: X' \\cdot\\  X' \\cdot\\  \\cdots \\ \\cdot\\  X'
\\end{aligned}
\\end{array}
& \\begin{array}{c} \\text{DeMorgan’s theorem} \\\\ \\text{（摩根律）} \\end{array}
\\\\\\\\

\\begin{array}{rl}
\\enspace\\ \\text{(T14)} &
\\begin{aligned}
 & [F(X_1, X_2, \\ldots, X_n, +, \\ \\cdot\\ )]' \\\\[-0.2em]
=&\\ F(X_1', X_2', \\ldots, X_n', \\ \\cdot\\ , +)
\\end{aligned}
\\end{array}
& \\begin{array}{c} \\text{Generalized} \\\\ \\text{DeMorgan’s theorem} \\end{array}
\\end{array}
$$

$$
\\begin{array}{rl}
& \\text{Shannon’s expansion theorems} \\\\[0.3em]
\\text{(T15)} & F(X_1, X_2, \\ldots, X_n) = \\ X_1 \\ \\cdot\\  F(1, X_2, \\ldots, X_n) + X_1' \\ \\cdot\\  F(0, X_2, \\ldots, X_n) \\\\
\\text{(T15D)} & F(X_1, X_2, \\ldots, X_n) = [X_1 + F(1, X_2, \\ldots, X_n)] \\cdot [X_1' + F(0, X_2, \\ldots, X_n)]
\\end{array}
$$

（~~草，对齐好累，我为什么要浪费这个时间。~~）

### Duality

将一个等式中所有的 $0$ 换成 $1$、$1$ 换成 $0$、$+$ 换成 $\\cdot$、$\\cdot$ 换成 $+$，等式依然成立。

上面的定理中带 “D” 的都是上一条的对偶。

### Standard Representations of Logic Functions

这里需要翻出来我离散 (1) 写的 [真值表生成器](https://ouuan.github.io/truth-table-generator/)（其实可以去加上 $+$ 和 $\\cdot$ 作为 alias，但如果要加 $'$ 的话会很麻烦所以干脆不加了吧（

logic function 有若干精确的标准表示方法：

-   真值表
-   canonical sum: 主析取范式，极小项 (minterm) 的和
-   使用 $\\sum$ 表示的 minterm list
-   canonical product: 主合取范式，极大项 (maxterm) 的和
-   使用 $\\prod$ 表示的 maxterm list
-   Verilog \`case\` 语句

这里用 $\\prod$ 表示 maxterm list 的下标比离散 (1) 讲的舒服多了：minterm 的 index 就是哪组变量取值下表达式值为 1，maxterm 的 index 就是哪组变量取值下表达式为 0，所以两种范式的下标刚好是补集。例如，有 $X, Y, Z$ 三个变量，$X' \\cdot Y \\cdot Z'$ 的下标是 $2$，$X' + Y + Z'$ 的下标是 $5$；$\\sum_{X,Y,Z}(1,2,6) = X' \\cdot Y' \\cdot Z + X' \\cdot Y \\cdot Z' + X \\cdot Y \\cdot Z' = \\prod_{X,Y,Z}(0,3,4,5,7)$。

Verilog 的 \`case\` 语句大概是这个样子：（虽然还完全没学 Verilog，但我感觉 Shiki 自带的 system-verilog 高亮看起来就比 verilog 正确许多，以后可能也用 system-verilog 的高亮了）

\`\`\`system-verilog
case ({X,Y,Z})
  1,2,6:    F = 1;
  default:  F = 0;
endcase
\`\`\`

## Combinational-Circuit Analysis

这一节就是说给你一个电路图怎么搞出它的 logic function。其实没啥好说的，就（按拓扑序）一个一个 gate 递推就行，可以用真值表也可以用逻辑表达式。

有一个小 trick：DeMorgan’s theorem 在电路图中表现为，将 inversion bubble 换到另一侧（输入 / 输出），并且改变 gate 的类型（AND / OR），这样的话，如果两个 inversion bubble 在一条 wire 上就可以消掉。

## Combinational-Circuit Synthesis

在 digital design 中，“Synthesis” 有若干种含义（例如从 HDL 到 FPGA），而在这一节只是指从 formal description 到 gate-level circuit。

### Circuit Descriptions and Designs

自然语言描述 → 逻辑表达式 / 真值表（canonical sum / product） → 电路

很多时候写出逻辑表达式会比列出真值表简单一些，但在面对较为复杂的逻辑关系时，列出真值表可以强制设计师考虑到每种情况，从而避免漏掉 corner case。

一个输出是某个逻辑表达式的电路被称作 *realize* 了这个表达式，是这个表达式的 *realization* 或者 *implementation*。

### Circuit Manipulations

在多数电路技术（包括 CMOS）中，NAND / NOR 比 AND / OR 效率更高，所以一般会修改电路来尽量使用 inverting gate 而非 noninverting gate：

-   在 wire 上移动 inversion bubble（从上一个输出移到下一个输入）
-   在 wire 的两侧同时加上 inversion bubble（或者 NOT gate）
-   消除同一根 wire 上的两个 inversion bubble
-   将 inversion bubble 换到另一侧（输入 / 输出），并且改变 gate 的类型（AND / OR）

### Combinational-Circuit Minimization

一般情况下，逻辑表达式的化简主要用的是定理 T10（Combining），就是在 sum of products 中找到仅有一项相反的两个 product 将它们合并，最终得到的也是一个 sum of products，实现为 2-level（first-level 计算 product，second-level 计算 sum）的电路。

product of sums 电路是对偶的，就不重复了，下文也是一样。

### Karnaugh Maps

如 DDPP5 Figure 3-23 所示：

![2-variable, 3-variable, and 4-variable Karnaugh maps](ddpp-fig-3-23.png)

在 Karnaugh map 中，每一个表示一个 minterm，相邻（包括跨过边界到另一侧的相邻）的格子仅有一位相反，所以边长为 1 / 2 / 4 的矩形可以合并。

选出若干矩形，恰好覆盖所有输出为 1 的格子，就可以化简逻辑表达式。

如果一个矩形覆盖的全是 1，并且是极大的（在其对应的 product 中减少任何一个输入都会使其覆盖到 0），就称作一个 *prime implicant*。最简的逻辑表达式是若干 prime implicant 的 sum。

有的函数的 Karnaugh map 非常分散（例如 parity function），没有连成一块的 1，就需要多级而非 2-level 的电路来进行化简。

在 FPGA 中，输入数量较少的电路都是通过 lookup table (LUT) 而非 gate-level circuit 来实现，只需真值表就可以。但复杂的电路需要由多个 LUT 组合起来，此时逻辑表达式的化简依然有用。

## Timing Hazards

真实的电路中会有 delay，而上面研究的都是 combinational logic circuit 的 *steady-state behavior*，没有考虑到 *transient behavior*。

因为 delay 的存在，可能会发生这样的情况：输入发生了改变，稳态下的输出不变，但在一瞬间内输出发生了变化（产生了一个 short pulse）。这样的 pulse 被称作 *glitch*。

如果一个电路有产生 glitch 的可能性，则称这个电路存在 *hazard*。实际物理电路的 delay 大小等因素难以控制，所以这里只是考虑产生 glitch 的可能性，而非实际是否有 glitch 产生（有点类似于并发编程中要保证所有可能的执行顺序下都不出错）。

### Static Hazards

*static-1 hazard*：稳态输出是 1，改变某一个输入后稳态输出还是 1，但这一个输入改变时可能会短暂地输出 0。static-0 hazard 是类似的。

书上给了个例子，但这个其实很好理解，就是电路的一个输入作为多个 gate 的输入，而这些 gate 的输出变化得有快有慢。

### Finding Static Hazards Using Maps

正常的 sum of products 电路中不会有 static-0 hazard，可能有 static-1 hazard。

可以用 Karnaugh map 来找到 hazard：如果两个相邻的 1 没有被同一个 gate 覆盖，从其中一个变为另一个时就可能产生 glitch。（因为极端情况下可能所有覆盖原来那一格的 gate 先全部变为 0，覆盖后来那一格的 gate 才变为 1。）

消除 hazard 就是用冗余的 gate 来覆盖这样的相邻的 1，类似于定理 T11（Consensus）。

### Dynamic Hazards

如果变化一个输入时可能产生不止一次 glitch，就称作 *dynamic hazard*。

一个正常的 2-level sum of products / product of sums 电路中不会有 dynamic hazard。

### Designing Hazard-Free Circuits

在多数电路中（尤其是 synchronous digital system 中），hazard 不会造成什么影响。但在某些电路（asynchronous sequential circuits）中，需要避免 hazard 的存在。

在一般的电路中消除 hazard 是复杂的，而在 sum of products 中，可以用 Karnaugh map 或者取遍所有 prime implicant（称作 *complete sum*）来消除 hazard。
`},{title:P,tags:i,content:`[DDPP5](https://wakerly.org/DDPP/) 第四章 “Digital Design Practices” 的学习笔记。



## Documentation Standards

一个 <dfn>document package</dfn> 通常至少包含以下内容：

specification (*spec*)
:   准确地描述系统的所有输入和输出以及功能。

block diagram
:   大致描述系统的主要模块之间的连接。

logic-device description
:   分别描述每个 “custom” logic device 的功能，这里 “custom” 是与现成的、由其他制造商生产的相对，例如 ASIC、FPGA、CPLD 等都是 custom 的。

schematic diagram
:   对每个模块的细节描述，比 *logic diagram* 更加细致，在 board-level design 中是包括 IC type、reference designator、signal name、pin number 等细节信息的电路图，在 FPGA、CPLD 中则由 HDL model 来充当这一角色。

timing diagram
:   展示各个信号随时间的变化情况。

circuit description
:   解释电路的工作原理以及注意事项。

test plan
:   如何对系统进行测试。

感觉大致上来说，与软件进行类比的话，logic-device description 像是组件的 API 文档，circuit description 像是代码内的注释，block diagram 像是整个程序的结构图，schematic 则是“代码”。总之，这个 document package 和软件的文档不一样，还包含 schematic 这种具体实现。

### Block Diagrams

大概就是 DDPP5 Fig.4-1 这种感觉：

![block diagram for a shift-and-add multiplier](ddpp-fig-4-1.png)

整个系统被划分为若干 component，block diagram 展示它们之间最主要的一些连线而略去细节。

在 block diagram 中，信号的流动可以是任意方向的，不需要都沿一个方向。

### Gate Symbols

根据 generalized DeMorgan’s theorem，AND、OR、NAND、NOR、NOT (inverter)、BUFFER (non-inverting buffer) 各自都有两种不同的画法，如 DDPP5 Fig.4-4 所示：

![在 generalized DeMorgan's theorem 下等价的 gate symbols](ddpp-fig-4-4.png)

### Signal Names and Active Levels

为了兼容更多的 HDL 和 EDA，signal name 最好不要有特殊字符，而是只使用字母、数字、下划线，以字母开头。

signal name 往往代表某种状态或某种操作，但并不总是在位于 HIGH 时表示相应的意思。每个 signal name 会有一个 <dfn>active level</dfn>，<dfn>active-high</dfn> 意味着这个 signal 位于 HIGH 时（在 positive-logic 中即为 1 时）表示这某种状态或某种操作，<dfn>active-low</dfn> 则与之相反。一个 signal 位于其 active level 时，我们说它 is <dfn>asserted</dfn>，反之则说它 is <dfn>negated</dfn> (*deasserted*)。

signal name 会以某种 naming convention 来表示其 active level，DDPP5 采用的 convention 是 active-high 保持不变，而 active-low 加上 \`_L\` 后缀。例如，\`READY\` 为 1 / \`READY_L\` 为 0 表示 ready，\`READY\` 为 0 / \`READY_L\` 为 1 表示没有 ready。

一般来说 active-high 理解起来相对容易，但由于性能、兼容性等原因也经常会需要 active-low。

### Active Levels for Pins

gate 或其他 logic element 的 pin 上有 inversion bubble 时，除了理解成不同的逻辑函数，也可以理解成 active-low 的输入/输出。

例如，AND、NAND、NOR、OR 可以表示四种不同 active level 的 AND：（DDPP5 Fig.4-6）

![四种不同 active level 的 AND: AND, NAND, NOR, OR](ddpp-fig-4-6.png)

因为 inverting gate 往往性能更好，可以将 noninverting gate 替换为 inverting gate，而理解成输入输出的 active level 相反的 noninverting gate。

### Bubble-to-Bubble Logic Design

在画电路图时，尽量将 active-low 的信号连接到 inversion bubble 上，在理解电路时就可以少一些 logical negation（本质上是因为 active-low 信号的两侧都有 inversion bubble，从而能够消去），使电路更好理解。

### Constant Logic Signals

电路设计中偶尔会用到 constant 0 （*ground*） 和 constant 1 （*power-supply voltage*），在电路图中它们的记号如下图所示：（DDPP5 Fig.4-9 (b))

![constant 0 and 1 inputs with individual gates](ddpp-fig-4-9-b.png)

### Drawing Layout

logic diagram 和 schematic 一般要从左到右画，所有输入都在最左侧，所有输出都在最右侧。

在线路发生交叉时，有两种区分重叠和连接的方法：

-   连接处打点，重叠不打点
-   连接都形如 ⟂ / ⊤，重叠则形如 +

由于 schematic 需要很多细节，一张图可能画不下，有两种处理方式：

-   分为多张并列的图，标注出跨越两张图的连线。
-   将图组织为树状（与 Web 前端的 component 类似），树根与 block diagram 类似。图中的 component 可以是另一张 schematic，也可以是 standard logic device 或者 HDL model。

### Buses

为了方便画图，多个并列的信号可以画成一个 <dfn>bus</dfn>。

bus 的名字一般形如 \`ADDR[15:0]\`，表示 \`ADDR15\`、\`ADDR14\`、……、\`ADDR1\`、\`ADDR0\`。

在图上 bus 用一条较粗的线表示，从这条粗线上连出一条细线表示从中 “pull” 出单独一个信号。

### Additional Schematic Information

在 board-level design 中，一个 schematic 在电路图的基础上还需要标明 IC type、reference designator、pin number 等信息，用来精确地描述电路。

其中，IC type 描述了 IC 的功能，<dfn>reference designator</dfn> 用来在一类 IC 中指定特定的一个实例，<dfn>pin number</dfn> 用来指定从哪连到哪。

全都标上长这样：（DDPP5 Fig.4-18）

![schematic diagram for a circuit using several SSI parts](ddpp-fig-4-18.png)

## Circuit Timing

在时序电路中，电路由一个 clock 控制，而 clock 的频率会根据完成一步操作在最坏情况下的用时来制订，所以计算、优化电路的 timing 对电路的性能和正确性都非常重要。

### Timing Diagrams

*timing diagram* 用来展示电路里各个信号随时间变化的情况，如 DDPP5 Fig.4-19 (b)(c) 所示：

![(b) 展示 causality 和 propagation delay 的 timing diagram (c) 展示 minimum / maximum delay 的 timing diagram](ddpp-fig-4-19-bc.png)

信号的转变不是瞬间发生的，从一个状态到另一个状态的用时称作 <dfn>transition time</dfn>，从 LOW 到 HIGH 的用时叫做 <dfn>rise time</dfn>，从 HIGH 到 LOW 的用时叫做 <dfn>fall time</dfn>。

在图 (b) 中，不同的箭头用来表示 transition 之间的 causality （因果关系）。

有因果关系的 transition 并不是立刻一个接着一个发生，而是会有 *delay*，不同的信号、路径会有不同的 delay。delay 一般是指两个 transition 各自中点的距离。

很多因素都会对 delay 造成影响，所以 delay 一般不是单个数字，而是一个区间。图 (c) 中标明了 minimum delay 和 maximum delay。

有时候 timing diagram 不需要区分 rise 和 fall，例如用来存储数据的信号，就可以如 DDPP5 Fig.4-20 (a) 这样画：

![不区分 rise 和 fall 的 timing diagram](ddpp-fig-4-20-a.png)

可以将一个 bus 画在一起，也可以用数字标注 bus 的取值，如 DDPP5 Fig.4-20 (b) 所示：

![将 bus 画在一起的 timing diagram](ddpp-fig-4-20-b.png)

### Propagation Delay

<dfn>propagation delay</dfn> 指的是电路的某个输入发生改变后沿着某个路径产生某个输出的 delay，一般记作 $t_{\\mathrm{pX}}$，其中 $\\mathrm{X}$ 用来标识这个路径。

影响 propagation delay 的因素有很多，例如：

-   Power-supply voltage: 包括标定的电压，以及小的电压波动
-   Temperature: 包括环境温度和电路工作产生的热量
-   Output loading: 电路的输出可能与后续电路的很多个输入相连，连接到的输入越多，将信号传递过去就用时越长
-   Input rise and fall times: 如果输入的 transition 慢，也会计入 propagation delay
-   Transition direction: 有时 rise 和 fall 的用时会不同
-   Speed-of-light delays: 如果电路的物理尺寸大，或者电路速度非常快，光速的限制就不能忽略
-   Noise and crosstalk: 环境中的各种干扰，以及相邻线路之间的干扰
-   Manufacturing tolerances: 元件被制造出来的时候可能有细微的差异

一般来说，计算 propagation delay 可以不考虑这么多因素，而只需根据生产商提供的元件的 “maximum” “typical” “minimum” propagation delay 来进行计算。

如果电路有多个输入输出，就会有很多条路径需要计算 delay。

<Card title="glitch 与 delay">

第三章中提到的 [glitch](/post/2023/01/ddpp-3#timing-hazards) 是否实际发生，与电路的 delay 密切相关。

</Card>

### Timing Specifications

生产商一般会提供元件在某种条件下每个路径、每种 transition 方向的 propagation delay 的范围，一般会提供 maximum delay 和 minimum delay，也可能提供一个 “typical” delay。

一般情况下，maximum delay 是最重要的，minimum delay 只在少数情况下需要考虑，而依赖于 typical delay 是不靠谱的。

### Timing Analysis Tools

在复杂的电路中，往往需要借助 EDA tool 来计算 timing。比起手动计算，EDA 可能会利用元件附带的比 min/max delay 更加详细的信息来更加精确地计算 delay。可以使用模拟器，手动设计输入，来计算 delay。也可以使用 timing analysis program，来自动计算出所有可能的 delay。

在设计的不同阶段可能会对 timing 进行多次估计和计算，在设计基本完成时如果发现 propagation delay 不符合设计要求，可能需要进行调整，例如针对 critical path 进行线路优化，将 critical path 上的元件尽量放在相邻的位置，将 high-fanout 的信号复制几分来减轻 output load……这样对 timing 进行调整的过程可能会反复进行很多遍，被称作 <dfn>timing closure</dfn>。

## HDL-Based Digital Design

### EDA Tool Suites for HDLs

text editor
:   包含代码高亮等功能的 HDL source file 编辑器。

compiler
:   检查代码中的语法错误，将 HDL 编译为 RTL （register-transfer language）。

synthesizer (synthesis tool)
:   将 RTL design synthesis 到某个具体的 hardware technology 上，通常分为若干步骤：
    1.  mapping: 将 RTL design 对应到具体的 hardware element
    2.  placement: 在 FPGA / CPLD 设计中，为每个 element 选择具体的 programmable resource instance；在 ASIC 设计中，为各种 basic building block 安排位置
    3.  routing: 在 FPGA / ASIC 设计中，在 element 之间连线（CPLD 中连线是固定的，要根据连线选择 programmable resource）

simulator
:   对给定的 HDL model 和随时间变化的输入，计算出随时间变化的输出。输入可以是手动编辑的，由 *test bench* 生成的，或者通过 *waveform editor* 编辑的。输出可以是波形图或者列表，还可能包含警告。

template generator
:   生成常用的代码模板。

schematic viewer
:   由 HDL model （RTL） 或 synthesized result 生成 schematic diagram，synthesis 前后的 schematic diagram 可能会有很大的不同，但功能是一致的。

chip viewer
:   查看 synthesized result 中的物理布局和连线。

constraints editor
:   给 synthesizer 调参，例如设置 timing 要求，调整优化目标。

timing analyzer
:   计算某些或全部路径的 delay。

back annotator
:   将 timing analyzer 的计算结果插入到 HDL model 中，以在 simulation 中展现出 timing。

### HDL-Based Design Flow

1.  specification / hierarchy / block diagram
2.  coding
3.  compilation
4.  simulation / functional verification / pre-fitting timing verification
5.  mapping
6.  fitting / place & route
7.  post-fitting timing verification

其中，前四步被称作 <dfn>front-end steps</dfn>，后三步被称作 <dfn>back-end steps</dfn>。

设计过程一般不会是一步一步顺着来的，而是会不断反复。为了少折腾，第一步中总体设计的合理性，以及第四步中进入 back-end steps 前的测试，都非常重要。由于精确的 timing 计算依赖于具体的 fitting，在第七步发现 timing 不符合要求而推倒重来也是很有可能的。
`},{title:$,tags:i,content:`[Digital Design Principles and Practices](https://wakerly.org/DDPP/) 5th edition 的学习笔记。



---

下学期要选数电或数设，听说数电是纯考试，数设是考试 + 大作业，又听说数设助教全是 tuna 群友，就选了数设，还好没掉课（

虽然不知道讲课内容和 DDPP 有多少是正交的，但看一看 ~~除了没时间学缓考的课有挂科风险~~ 也没啥坏处。

上学期 [在上课期间学 CS:APP](/post/2022/09/csapp) 还是挺痛苦的，希望这次寒假能多学一点。本来想寒假补完一下 CS:APP，但大概是没时间了。先学 DDPP 可能对 CS:APP 的第四章也会有些帮助 (?)。

看了下 preface 和 chapter 1 开头，感觉这个作者说话挺有意思的，joke 含量很高。下面这句摘自 chapter 1 开头，两词三义，~~[<span class="text-aisan">爱姐</span>](https://zh.moegirl.org.cn/宫下爱)[<span class="text-mia">秀酱</span>](https://zh.moegirl.org.cn/内田秀)狂喜~~，~~又多了一个不读中文翻译的理由~~，~~让技术书籍的翻译也来体验一下<span class="text-nijigasaki">虹咲</span>烤肉 man 的痛苦吧~~。

> Or perhaps you’re an electrical engineering student who already knows something about analog electronics and circuit design, but you wouldn’t know a bit if it bit you.

P.S. 为什么不是 “DD:PP” 呢 🤔 ~~是不是作者学 CS:APP 的时候觉得冒号打起来太麻烦了，就想着一定要为自己的读者省去这个麻烦~~。

UPD: 终于读完第一章了。drill problem 第一题是，“Give three different definitions for the word ‘bit’ as used in this chapter”（
`},{title:D,tags:"blog Web 项目开发",content:`当你看到 [一种很新的中文字体网页嵌入方案](https://ayu.land/webfont)，但是懒得优化 DP，也不会进化算法，你可以……

整一个[<em>另</em>一种很新的中文字体网页嵌入方案](https://github.com/ouuan/glyph-segregator)（



~~这就是你 [开坑 DDPP](/post/2023/01/ddpp) 不填的理由吗~~

## 背景

前不久看到 [一种很新的中文字体网页嵌入方案](https://ayu.land/webfont)，还想着没必要做这种优化，毕竟按 Google Fonts 进行子集化就可以做到每页 1MB 左右，按现代的网速不会有太大问题，用 devtools 开节流试了下看起来也还行。

然后我回家了，离开了校园网。虽然自定义域名的 Cloudflare Pages 还能访问，但速度暂且不论，丢包率就很有点恐怖，经常页面加载一半就卡住了。

再然后，Google Fonts 里 Noto Serif SC 的 unicode range 不含单引号（和撇号是同一个字符），导致 [DDPP 序](/post/2023/01/ddpp) 里引用的那段话的撇号在我的手机上显示成了很宽的另一种字体，才让我[发现这个问题](https://github.com/ouuan/iles-blog/commit/080bd7112f88d2eae1e86594f8820c0c517e37ce)。为了以后能及时发现这种问题，我就设置了不使用本地字体直接使用 web font 的 Stylus。

恐怖的丢包率，加上自己亲身体验 web font 加载，让我意识到了，在国内普通网络环境下，如果你的设备没有安装思源宋体，访问我的博客会是多么难受（

## 主体思路

“另一种”的主体思路[和“一种”是一样的](https://ayu.land/webfont#principle)，就是把字体划分成常用字和非常用字。但是“一种”在这之后选择了使用动态规划 + 进化算法来对常用字进行进一步的拆分，“另一种”所做的优化则基于这样一个观察：虽然一个博客有一堆页面，但 80% 的人只会访问 20% 的页面（，一个字体是否常用，不仅要看出现在几个页面，还要看出现在哪些页面。

这时候，~~一直充当[不蒜子](https://busuanzi.ibruce.info/)平替（哪平价了啊）的~~ Plausible Analytics 就发挥作用了：近段时间的页面访问量可以用来估计每个页面被访问的概率，为常用字的划分提供可靠的数据支撑。

一旦估计出了每个页面的被访问概率，就可以对每个 glyph 分别计算出，如果在每一个使用了它的页面上都加载一遍，期望代价是多少，也就是使用了它的所有页面的被访问概率之和。如果这个数大于 1，就设为常用，否则设为不常用。

这个思路还是非常简单的，可以说只是“结合实际，采取启发式方法”，也称不上是一种新的方案（

## 具体实现

虽然思路简单，但实现起来还是有点复杂的，坑有点多。

### 获取页面使用的字体

如果整个页面都使用一种字体，直接看 HTML 里有哪些中文就差不多了，但我不仅<span class="font-sans">非正文用的是黑体</span>，<span class="font-kai">引用块还是楷体</span>，说不定在哪冒出来个\`等宽\`或者 $\\LaTeX\\text{公式}$，有时候还会**加粗**，更别提心情好的时候会像这段一样直接塞 \`<span class="">\` 来修改样式。

一开始我通过 [subfont](https://github.com/Munter/subfont) 找到了 [assetgraph/font-tracer](https://github.com/assetgraph/font-tracer)，但这个 font-tracer 就两个 star，没有文档，[AssetGraph](https://github.com/assetgraph/assetgraph) 又是一个 12 年前的老项目，连 Definitely Typed 都没有，试了一下完全用不会。

想了想，最靠谱的还是直接交给浏览器来处理，所以就用 [puppeteer](https://github.com/puppeteer/puppeteer) 了。目前采用的算法是：遍历 \`<body>\`，跳过 \`<script>\` 和 \`<style>\` 子树，找到所有 [Text 节点](https://developer.mozilla.org/docs/Web/API/Text)，再加上所有 \`<img>\` 的 \`alt\` 属性。找到节点后，可以用 [\`getComputedStyle\`](https://developer.mozilla.org/docs/Web/API/Window/getComputedStyle) 获取 \`font-family\` 和 \`font-weight\` 等信息。

因为要处理很多页面，也要花一点时间，所以用了 [puppeteer-cluster](https://github.com/thomasdondorf/puppeteer-cluster) 来并行处理。（不知道为什么，在 vitest 和 iles 中运行时，不加参数会报错，而加了 \`--no-sandbox --no-zygote\` 之后并行的优化效果就差一些。）

代码：[\`getPagesFontInfo.ts\`](https://github.com/ouuan/glyph-segregator/blob/master/src/getPagesFontInfo.ts)

### 字体匹配

[完整的字体匹配](https://www.w3.org/TR/css-fonts-4/#font-style-matching)是非常复杂的，我也没找到相关的库，就自己写了一个简陋的只匹配完整 \`font-family\` 和 \`font-weight\` 的算法。

其实一般 \`font-weight\` 也就 400 和 700，但我还是实现了一个 [完整的 \`font-weight\` fallback](https://developer.mozilla.org/docs/Web/CSS/font-weight#fallback_weights)。

代码：[\`matchFonts.ts\`](https://github.com/ouuan/glyph-segregator/blob/master/src/matchFonts.ts)

### 常用字体划分

最关键的这一步实现起来是最简单的，因为是纯算法的，不涉及到可怕的 Web（

代码：[\`getCommonGlyphs.ts\`](https://github.com/ouuan/glyph-segregator/blob/master/src/getCommonGlyphs.ts)

### 生成字体文件和 @font-face

我使用的是 [subset-font](https://github.com/papandreou/subset-font) 来生成字体子集文件。

这一步最大的困难，是正确地写出 \`@font-face\`。

一开始我是给常用字 (common) 和非常用字 (unique) 不同的 \`font-family\`，然后发现，在特殊情况下（幸好我的博客文章列表就触发了这个问题，不然真没想到），某个字的常规样式属于 common 而粗体属于 unique，由于 \`font-family\` 里 common 排在 unique 前面，就会匹配到常规样式，而加载不出粗体。

为了解决这个问题，common 和 unique 需要使用同一个 \`font-family\`。因为用过 Google Fonts 子集划分方案，我知道有不同 \`unicode-range\` 的 \`@font-face\` 是可以组合在一起的，难道我需要计算出精确的 \`unicode-range\` 写在 CSS 里？

为此，我粗略地读了半天（~~这两个词不冲突~~）[CSS Fonts Module Level 4 W3C Working Draft](https://www.w3.org/TR/css-fonts-4/)，发现它说，\`unicode-range\` 可以比真实的 character map 大很多，若干 \`@font-face\` 的 \`unicode-range\` 也可以相交。但是，它没说两个 \`@font-face\` 能不能除了 \`src\` 啥都一样，[而只说了](https://www.w3.org/TR/css-fonts-4/#composite-fonts)：

> Multiple @font-face rules with different unicode ranges for the same family and style descriptor values can be used to create composite fonts that mix the glyphs from different fonts for different scripts.

我也不敢依赖于实验结果，就没做实验，直接加上了粗略但是保证 common 和 unique 不相同的 \`unicode-range\`，具体来说就是 0 到最大的 code point。

这里从 0 开始也是有一定原因的：我在看 specification 的时候注意到一个奇怪的东西叫 [_first available font_](https://www.w3.org/TR/css-fonts-4/#first-available-font)，虽然没太看懂具体是什么意思，但大致上感觉最好是让 \`unicode-range\` 包含空格，为了保险就从 0 开始了。

最后还有一个坑：如果 composite font 中两个 \`@font-face\` 的 \`unicode-range\` 相交，给交集内的字符匹配字体时，会按出现位置的逆序进行匹配。

这能有什么坑呢（，如果不动手试一试真的很难想到.. 按照整体的设计，访问一个页面时很有可能是 common 字体已经缓存好了，需要下载 unique 字体，如果 unique 的 \`@font-face\` 放在 common 的后面，就会优先匹配，从而阻塞住已经缓存的 common 字体，整个页面都要等 unique 下载好才切换字体，而不是先显示 common 再显示剩下的 unique。当然，反过来的话，unique 也会等 common，但这样一般来说是更好的。

还有一些细节优化：

-   生成 unique 字体文件时，文件名里有 hash 就够了，不要再添加和页面有关的信息，这样的话如果两个页面刚好 unique glyph 集合相同就可以共用一个字体文件。
-   如果一个页面一个 common glyph 都没用，就可以不添加 common font 的 \`@font-face\`。

代码：[\`generateFontFiles.ts\`](https://github.com/ouuan/glyph-segregator/blob/master/src/generateFontFiles.ts)

### 将 CSS 写入 HTML 文件

虽然也有想过直接找到 \`</head>\` 文本替换，但为了靠谱还是用的 [\`jsdom\`](https://github.com/jsdom/jsdom)。

这部分的代码是最短的：[\`injectCSS.ts\`](https://github.com/ouuan/glyph-segregator/blob/master/src/injectCSS.ts)

### 给项目起名

主体思路是把 glyph 分成两类分别对待，就很有 segregate 的感觉（

主要还是因为刚写了一个 [segregated fit](/post/2022/11/csapp-9#segregated-fit) 印象比较深刻，所以就取了这么个名字。

### 在博客中使用

就是 [从 iles 获取页面信息](https://iles-docs.netlify.app/config#ssg-onsiterendered)，从 [Plausible Stats API](https://plausible.io/docs/stats-api#get-apiv1statsbreakdown) 获取访问量，调用 [Vite API](https://vitejs.dev/guide/api-javascript.html#preview) 跑一个 preview server，然后调用 \`glyph-segregator\`。直接看[代码](https://github.com/ouuan/iles-blog/commit/695f8b22ca3a791ceeb5440e81a6fa377b50bb3b#diff-ca899b3bf20a893bb3dfb058072a2b279953ce008f562727ad74a76d520be662)吧。

访问概率的计算方式是，看每个页面近 90 天的访客数，加一后除以其中最高的加二（其实这个加一加二基本没啥用）。用最高页面访客数而非实际总访客数作分母，是想在算法的基础上更加偏向于划分到常用字一些，稍微优化一点访问页面较多的访客的体验，也可以少一次 API 查询。

更新常用字集合用的是 [scheduled GitHub Actions](https://github.com/ouuan/iles-blog/blob/master/.github/workflows/update-fonts.yml)，在 Docker 里跑是因为 [Connection refused for local server in github actions workflow](https://stackoverflow.com/questions/74332455/connection-refused-for-local-server-in-github-actions-workflow/74341376)。

## 实际效果

整个 \`glyphSegregator\` 用时 40s 左右，glyph 数量和 common font file size (woff2) 如表所示：

|                                               | Noto Serif SC Regular | Noto Serif SC Bold | LXGW WenKai Regular | LXGW WenKai Bold |
| :-------------------------------------------: | :-------------------: | :----------------: | :-----------------: | :--------------: |
| <span class="whitespace-nowrap">common</span> |    575 (162.7KiB)     |    25 (8.5KiB)     |     37 (5.2KiB)     |        0         |
|                    unique                     |         2311          |        1536        |         161         |        0         |

首页只需加载两个 Regular 的 common font，每个页面需要加载的字体文件总大小缩减到了原来使用子集化的 1/4 左右，并且加载的字体文件数量从 10\\~30 个缩减到了 2\\~6 个。

作为对比，如果出现在两个页面就设为常用字，Noto Serif SC Regular 的 common 有 299KiB，出现在三个页面则是 227KiB。

## 后记：font subsetting 与 kerning

因为通过 Stylus 设置了不使用本地字体，我可以轻松地在本地字体和 web font 之间切换。然后我就偶然发现，切换时一些标题发生了字符的偏移。原因也很简单，就是相邻的两个字符本来有 kerning (字距调整)，但它们被划分到了不同的子集中，生成字体子集时就丢失了 kerning 信息。

我在 glyph-segregator 中 [添加了 \`alwaysCommonGlyphs\` 选项](https://github.com/ouuan/glyph-segregator/commit/ae3ddd5cbb91f0eb6bbfec7071ee408c28b36dec)（ASCII 字符总是设为 common，如果需要处理非 ASCII 字符的 kerning 也可以修改设置，但我的博客就假设只有 ASCII 字符会遇到这个问题）来解决这一问题。最好的解决方案是真的去看一下字体里有哪些 kerning 信息然后相应地处理，但是差不多得了（

<Card title="font kerning 示例">

-   有 kerning: <span style="font-kerning: normal; font-size: 2rem;">TAVeYoW</span>
-   没 kerning: <span style="font-kerning: none; font-size: 2rem;">TAVeYoW</span>

</Card>

后记的后记：还是改成了[即使未被使用也添加进 common glyph set](https://github.com/ouuan/glyph-segregator/commit/e955eb1c935d77adf0e4bcb5c870fee0614801b6)，否则如果新加一个 always common 的 glyph，为了让它 common，就会改变 common glyph set，导致 cache 失效。这里有一定的 trade-off，要在 cache 失效 / 多塞一些未被使用的 glyph / kerning 挂掉之间进行选择，我还是选择了多塞一些未被使用的 glyph，毕竟整个 ASCII 也没多大。最好是借助人类智慧来预测一下哪些 glyph 更有可能在未来被添加而放进 common glyph set 里，其他 glyph 就只有使用了才放，但是差不多得了（
`},{title:L,tags:"JavaScript 问题解决记录",content:`tl;dr: \`replace\` 的第二个参数应当使用字面量或函数，不应使用带变量的字符串表达式。



## String.prototype.replace 的第二个参数

(reference: [\`String.prototype.replace()\` - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_the_replacement))

\`\`\`javascript
replace(pattern, replacement);
\`\`\`

第二个参数 \`replacement\` 可以是字符串或函数，如果是函数，则由匹配信息作为参数计算出 replacement，如果是字符串，则可以使用一些 special replacement pattern：

|                          Pattern                           |                                           Inserts                                            |
| :--------------------------------------------------------: | :------------------------------------------------------------------------------------------: |
|                            \`$$\`                            |                                       Inserts a \`"$"\`.                                       |
|                            \`$&\`                            |                                Inserts the matched substring.                                |
|                          \`\` $\` \`\`                          |            Inserts the portion of the string that precedes the matched substring.            |
|                            \`$'\`                            |            Inserts the portion of the string that follows the matched substring.             |
|                            \`$n\`                            | Inserts the \`n\`th (1-indexed) capturing group where \`n\` is a positive integer less than 100. |
| <code class="important-whitespace-nowrap">$\\<Name\\></code> |              Inserts the named capturing group where \`Name\` is the group name.               |

## 使用变量作为 replacement 带来的问题

我实际遇到的问题是 [iles#224](https://github.com/ElMassimo/iles/issues/224)，由于使用了模板字符串作为 replacement，在变量中包含上面这些 special replacement pattern 时，就会错误地替换。

解决方法也很简单，将含变量的表达式改成函数（前面加上 \`() => \`）就可以了：[regex - javascript - Better Way to Escape Dollar Signs in the String Used By \`String.prototype.replace\` - Stack Overflow](https://stackoverflow.com/questions/28102491/javascript-better-way-to-escape-dollar-signs-in-the-string-used-by-string-prot)。

因为解决的代价非常小，虽然有的时候根据代码逻辑可以推断出 replacement 不含 \`$\`，依然可以认为，凡是 replacement 需要用到变量的，都应当替换成函数。

## 使用 ESLint 检测这一问题

[写了个](https://github.com/ouuan/eslint-config/commit/166e332dbdf8dc2ab9ff918302ada13fbd487ead) [\`no-restricted-syntax\`](https://eslint.org/docs/latest/rules/no-restricted-syntax) 的配置：

\`\`\`javascript
{
  rules: {
    'no-restricted-syntax': [
      'error',
      {
        selector: "CallExpression[callee.property.name='replace'] > .arguments:nth-child(2):not(Literal):not(ArrowFunctionExpression):not(FunctionExpression)",
        message: 'Only literals and functions are permitted as the 2nd argument of String.prototype.replace. Use a function that returns the expression instead.',
      },
    ],
  },
}
\`\`\`

因为只是分析 AST，有很多情况会误报，例如 replacement 是一个函数名，但实际代码应该很少出现这样的情况，真遇到了的话再套一层函数就 ok 了，实在不行还能用注释 disable 掉 lint。

没研究过，不知道写 ESLint plugin 能不能更加准确地检测，~~但是差不多得了~~（
`},{title:_,tags:"blog CSS Web 经验分享",content:`我的博客好像还用了不少奇怪的小 trick 来优化 （~~hopefully~~） 排版，在这整理一下，分享出来，也是怕几年（~~几天~~）后想不起来这些奇怪的东西是在干什么。

主要是 text justify 相关和标点挤压相关。



我博客的 Markdown 渲染基于 [unified](https://github.com/unifiedjs/unified)，所以下面的一些优化是以 unified 插件（remark / remark-rehype / rehype 插件）的形式实现的。

<Card type="warn">
为了直观地进行演示，本文可能会在提到一个问题的段落通过设置文本和 CSS 特意制造出相应的问题，并禁用对这个问题的处理措施以将问题展示出来。
</Card>

## text justify 相关

在每行的宽度略有差异时，[使用两端对齐会让中文排版更加美观](https://www.w3.org/TR/2022/DNOTE-clreq-20221009/#line_adjustment)，这一般通过 [\`text-align\` CSS 属性](https://developer.mozilla.org/docs/Web/CSS/text-align) 的 \`justify\` 选项实现。但由于网页排版的不确定性，每行的宽度可能不是略有差异而是有很大差异，这时使用 text justify 就会造成过大的空隙，所以需要避免出现过短的行，或者在有必要时禁用 text justify。

### lang="zh-CN" 对 text justify 的影响

这个并不是 trick，是基操，但挺重要的，还是写在这。

如果没有将 HTML 的 [\`lang\` 属性](https://developer.mozilla.org/docs/Web/HTML/Global_attributes/lang) 设为中文，在 Firefox 109（以及其他版本 / 其他浏览器，但不包括 Chrome 109）中就会按照英文的规则，将连续的汉字视作一个单词，而只在词与词之间增大间距，不改变汉字之间的间距，如下所示：

<p lang="en" style="margin: auto; width: 12em; border: gray solid 1px;">这是一个设置了 \`lang="en"\` 和固定宽度的段落，这是一个 loooooooooooooooong word。</p>

![上面的 lang 设为 en 的段落在 Firefox 109 中的渲染效果](firefox-text-justify-en.png)

其中，第一行没有两端对齐，而第三行只在逗号后面增加了间距。

如果设置了 \`lang="zh-CN"\` 则会在汉字间添加间距：

<p lang="zh-CN" style="margin: auto; width: 12em; border: gray solid 1px;">这是一个设置了 \`lang="zh-CN"\` 和固定宽度的段落，这是一个 loooooooooooooooong word。</p>

![上面的 lang 设为 zh-CN 的段落在 Firefox 109 中的渲染效果](firefox-text-justify-zh-CN.png)

当然，设置 HTML 的 \`lang\` 属性还有其他作用，不管怎么样总是得设一个的。

### 断开过长的行内代码

有时候会遇到一些 <code style="word-break: normal;">veryLoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooongInlineCode</code>，为了让它不断开，前面的一行就会非常短，justify 后间隙就非常大。当然，这样的问题不局限于行内代码，但正常的英文很少会遇到特别长的单词，代码则经常遇到，所以我选择对代码进行处理（主要是因为不需要分词套 \`<span>\`）。

思路很简单，就是把过长的 \`:not(pre) > code\` 通过 [\`<wbr>\`](https://developer.mozilla.org/docs/Web/HTML/Element/wbr) 或者 [\`word-break: break-all\`](https://developer.mozilla.org/docs/Web/CSS/word-break) 断开，让它不可断开的部分没那么长。例如：\`<code>word<wbr>-<wbr>break<wbr>: <wbr>break<wbr>-<wbr>all</code>\`、\`<code>&lt;<wbr>code<wbr>&gt;<wbr>word<wbr>&lt;<wbr>wbr<wbr>&gt;-&lt;<wbr>wbr<wbr>&gt;<wbr>break<wbr>&lt;<wbr>wbr<wbr>&gt;: &lt;<wbr>wbr<wbr>&gt;<wbr>break<wbr>&lt;<wbr>wbr<wbr>&gt;-&lt;<wbr>wbr<wbr>&gt;<wbr>all<wbr>&lt;/<wbr>code<wbr>&gt;</code>\`……（~~禁止禁止套娃~~）。

具体实现：[\`breakLongCode.ts\`](https://github.com/ouuan/iles-blog/blob/master/src/rehype/breakLongCode.ts)

1.  如果按空格分开没有超过 10 个字符的部分，不进行处理；
2.  如果按正则表达式的 \`\\b\` 分开没有超过 12 个字符的部分，则在 \`\\b\` 处插入 \`<wbr>\`；
3.  如果按 \`\\b\` 以及下划线分开没有超过 15 个字符的部分，则在相应位置插入 \`<wbr>\`；
4.  否则，没救了，直接 \`word-break: break-all\`。

当然这个粗糙的处理方式还是有一些问题，比如从上面的示例就可以看出来，期望结果可能是 \`<wbr>\` / \`<code>\` 不被断开，但实际上会在 \`<\` 后 / \`>\` 前断开。

### 在小屏幕上对窄的元素禁用 text justify

<p style="margin: auto; width: 7em; border: gray solid 1px;">有的时候容器宽度太小，即使是正常的普通文本也不适合进行 text justify。</p>

我选择了一个非常简单粗暴的处理方法：认为窄的元素 = 小屏幕上嵌套了多级的元素。

\`\`\`css
.article-style {
  text-align: justify;
}
.article-style > * > * {
  text-align: initial;
}
@media (min-width: 40em) {
  .article-style > * > * {
    text-align: inherit;
  }
}
\`\`\`

（上面放的是编译出来的 CSS，[源码](https://github.com/ouuan/iles-blog/blob/master/src/styles/article.scss)是使用 UnoCSS 的 SCSS。）

一些细节：

-   使用 \`*\` 选择器，[specificity](https://developer.mozilla.org/docs/Web/CSS/Specificity) 很低，便于 override。
-   只选择 \`> * > *\` 而非 \` * *\`，这样的话嵌套更深的元素依然从 parent 继承 \`text-align\`，就可以设置 CSS override 掉一整个子树。（之前我一度以为 katex 不自带行间公式居中，后来发现是被我的 CSS 改掉了 \`text-align\`。）
-   使用 \`inherit\` 而非 \`justify\` 进行撤销。

### 对包含过长行内公式的元素禁用 text justify

除了 \`行内代码\`，$\\text{行内公式}$ 也是常见的过长的不可断元素。这里我采用了一个本文最 dirty 的处理方式：在客户端通过 JavaScript 检测宽度过大的行内公式。

具体实现：[\`TextJustifyFix.vue\`](https://github.com/ouuan/iles-blog/blob/master/src/components/TextJustifyFix.vue)

-   只修改 \`text-align: justify\` 的元素，如果已经设置为其他对齐方式（例如表格中的居中对齐），就不应修改。
-   使用了 [\`document.fonts.ready\`](https://developer.mozilla.org/docs/Web/API/FontFaceSet/ready) 来等待字体全部加载好再检查宽度。

## 标点挤压

代码实现：[\`mojikumi.ts\`](https://github.com/ouuan/iles-blog/blob/master/src/remark/mojikumi.ts)、[\`mojikumi.scss\`](https://github.com/ouuan/iles-blog/blob/master/src/styles/mojikumi.scss)。

### 相邻标点的挤压

例如：「<span class="no-mojikumi">：“。”（。）</span>」→「<span>：“。”（。）</span>」。当然本页其他地方也有一些例子。

具体规则 [clreq](https://www.w3.org/TR/2022/DNOTE-clreq-20221009/#compression_rules_for_consecutive_punctuation_marks) 中说的比较模糊，可以参考 [jlreq](https://www.w3.org/TR/2020/NOTE-jlreq-20200811/#positioning_of_consecutive_opening_brackets_closing_brackets_comma_full_stops_and_middle_dots)。

### 使用 CSS 去除标点的一半空白

CSS 实现标点挤压有两种方式：

-   使用 [\`letter-spacing: -0.5em\`](https://developer.mozilla.org/docs/Web/CSS/letter-spacing) 去掉右侧空白，\`margin-left: -0.5em\` 去掉左侧空白。
-   使用 [\`font-feature-settings:\`](https://developer.mozilla.org/docs/Web/CSS/font-feature-settings) [\`"halt"\`](https://learn.microsoft.com/typography/opentype/spec/features_fj#halt) 将支持 halt 特性的字体变为半宽。

使用 \`letter-spacing\` 是有讲究的，比 \`margin-right\` 靠谱，因为字符真的会只占半宽，而不是占全宽但一半和下一个字符重叠，甚至造成 overflow，可能导致滚动条出现。但 \`letter-spacing\` 不能去掉左侧空白，就只能使用 \`margin-left\` 了。

通过 halt 特性变为半宽是更加靠谱的做法，但不是所有字体都支持这一特性，思源宋体是支持的，<span class="font-kai">霞鹜文楷</span> 不支持。并且，halt 只能变为半宽，不能变成其他宽度。

### 行首行尾标点的挤压

这里参考了 [Han.css](https://github.com/ethantw/Han) 的实现，就是把全宽的标点改成半宽标点和一个通过 \`::before\` 或 \`::end\` 添加的半宽的空格：

-   因为是 pseudo element，所以不影响文本内容（例如复制出来的文本）。
-   因为是空格，所以位于行首或行尾时就会发生[空格塌陷](https://www.w3.org/TR/2023/CRD-css-text-3-20230127/#white-space-phase-2)。

### 英文标点的处理

我采用了一个比较简单的判断英文标点的方法：

-   空白一侧（左括号、左引号等是左侧，其他一般是右侧）是空格时是英文标点；
-   右单引号右侧是字母时是撇号。

英文标点一般调为半宽即可，但撇号半宽还是有些太宽了，应该（根据字体而定）调成大约三分之一宽，单引号也可以调窄一点，所以可以特判一下单引号，使用 \`letter-spacing\` 和 \`margin-left\`。

### 给霞鹜文楷添加 halt 特性

因为 [添加 halt 特性的 issue](https://github.com/lxgw/LxgwWenKai/issues/104) 被拒了，我就自己改了一个 [标点字体](https://github.com/ouuan/XiaWu-Punctuations)，顺便把引号改成了和思源宋体一致的全宽以方便一起处理（也可以理解为改引号宽度顺便添加 halt 特性，毕竟没有 halt 也可以用 \`letter-spacing\` 和 \`margin-left\` 凑合一下），具体可以看仓库里的 patch 文件。

### 关于 chws 特性

[chws 特性](https://learn.microsoft.com/typography/opentype/spec/features_ae#chws) 可以根据上下文自动挤压连续标点，一眼看上去似乎比 halt 更好用。

思源宋体不支持这一特性，只不过有 [chws_tool](https://github.com/googlefonts/chws_tool) 可以用来转换。

但是，chws 不支持行首行尾标点挤压，而如果要支持行首行尾挤压，就得把支持连续标点挤压的工作做一遍（因为要知道哪些标点已经被挤成了半宽哪些只在行首行尾挤成半宽），这样一来 chws 就没多大意义了。

### Yet another mojikumi？

有一些现成的支持标点挤压的库，例如 [heti](https://github.com/sivan/heti) 和 [Han.css](https://github.com/ethantw/Han)。但是我有一些需求：

-   要能 SSG （SSR），不能在客户端运行。最好是能在 remark / rehype 中进行处理。
-   最好是尽量使用 halt 而非 \`letter-spacing\` 和 \`margin-left\`。
-   要能添加一些自定义的规则，比如对单引号特殊处理。
-   我只需要标点挤压，不想要一个 CSS 全家桶，或者带有其他功能的 JS。

现有的库难以同时满足上面这些需求，所以我就自己写了。

本来想写一个通用的库，但通用的逻辑貌似没多少代码，不值得写成一个库。而我的整个 remark 插件又有点 opinionated，可能不太适合做成库（~~懒得做成库~~），想用的话可以在遵守 [AGPL 3.0](https://github.com/ouuan/iles-blog/blob/master/LICENSE) 的前提下直接复制（本文提到的其他代码也是一样，当然，如果是两三行的代码片段就不至于 AGPL 了，简单标一下出处就 OK）。
`}],meta:[{frontmatter:{title:r,date:new Date(1543988421e3),tags:T,lastUpdated:new Date(1676204671e3),published:new Date(1658482129e3),visitor:0},href:"/about",filename:"src/pages/about.mdx"},{frontmatter:{title:c,date:new Date(1658549297e3),tags:["btrfs","Arch Linux",a],image:"/images/2022/07/btrfs-quota-timeshift-message-screenshot.png",lastUpdated:new Date(1658586466e3),published:new Date(1658552603e3),visitor:115},href:"/post/2022/07/btrfs-quota-timeshift-freeze",filename:"src/pages/post/2022/07/btrfs-quota-timeshift-freeze.mdx"},{frontmatter:{title:l,date:new Date(1658582944e3),image:"/images/2022/07/comments-loading-light.png",tags:[M,u,a],lastUpdated:new Date(1659536455e3),published:new Date(1658587665e3),visitor:66},href:"/post/2022/07/display-none-and-lazy-load",filename:"src/pages/post/2022/07/display-none-and-lazy-load.mdx"},{frontmatter:{title:m,date:new Date(1658728987e3),image:"/images/2022/07/all-in-wl.png",tags:["选课","THU",s],lastUpdated:new Date(1671169521e3),published:new Date(1658754332e3),visitor:665},href:"/post/2022/07/thu-course-selection-tips",filename:"src/pages/post/2022/07/thu-course-selection-tips.mdx"},{frontmatter:{title:d,date:new Date(1659161767e3),image:"/images/2022/07/uptime-kuma-list.png",tags:["caddy-security","uptime-kuma","caddy","server",a],lastUpdated:new Date(1659165466e3),published:new Date(1659165466e3),visitor:52},href:"/post/2022/07/uptime-monitoring-under-caddy-security",filename:"src/pages/post/2022/07/uptime-monitoring-under-caddy-security.mdx"},{frontmatter:{title:p,date:new Date(165966831e4),image:"/images/2022/08/busuanzi-and-live2d.png",tags:["busuanzi","live2d",z,u,a],lastUpdated:new Date(1659678915e3),published:new Date(1659678915e3),visitor:117},href:"/post/2022/08/busuanzi-and-live2d",filename:"src/pages/post/2022/08/busuanzi-and-live2d.mdx"},{frontmatter:{title:F,date:new Date(1660492135e3),image:"https://www.rust-lang.org/static/images/rust-social-wide.jpg",tags:["Rust","学习记录"],lastUpdated:new Date(1662783413e3),published:new Date(1660576305e3),visitor:194},href:"/post/2022/08/learn-rust",filename:"src/pages/post/2022/08/learn-rust.mdx"},{frontmatter:{title:g,date:new Date(1663478897e3),image:"/images/2022/09/csapp-2.png",tags:[e,n],lastUpdated:new Date(166399937e4),published:new Date(166351913e4),visitor:81},href:"/post/2022/09/csapp-2",filename:"src/pages/post/2022/09/csapp-2.mdx"},{frontmatter:{title:b,date:new Date(1663553588e3),image:"/images/2022/09/csapp-3.png",tags:[e,n],lastUpdated:new Date(1673269583e3),published:new Date(166399937e4),visitor:113},href:"/post/2022/09/csapp-3",filename:"src/pages/post/2022/09/csapp-3.mdx"},{frontmatter:{title:h,date:new Date(1663478888e3),image:"https://csapp.cs.cmu.edu/3e/images/csapp3e-cover.jpg",tags:[e,n],lastUpdated:new Date(1665973845e3),published:new Date(166351913e4),visitor:94},href:"/post/2022/09/csapp",filename:"src/pages/post/2022/09/csapp.mdx"},{frontmatter:{title:f,date:new Date(1667202147e3),tags:["TeX","R","物理实验",s],lastUpdated:new Date(1669709723e3),published:new Date(1667211348e3),visitor:R},href:"/post/2022/10/basic-tex-and-r-for-physics-lab",filename:"src/pages/post/2022/10/basic-tex-and-R-for-physics-lab.mdx"},{frontmatter:{title:x,date:new Date(1664805493e3),image:"/images/2022/10/csapp-4.png",copyrightNotice:"本文包含截自 CS:APP 中的图片，文章作者对其不拥有版权。",tags:[e,n,"WIP"],lastUpdated:new Date(1673710372e3),published:new Date(1665973845e3),visitor:55},href:"/post/2022/10/csapp-4",filename:"src/pages/post/2022/10/csapp-4.mdx"},{frontmatter:{title:v,date:new Date(1665975415e3),image:"/images/2022/10/csapp-7.png",copyrightNotice:"本文包含少量直接从 CS:APP 中复制的代码、图片，本文作者对其不拥有版权。",tags:[e,n],lastUpdated:new Date(1671291937e3),published:new Date(1667212746e3),visitor:64},href:"/post/2022/10/csapp-7",filename:"src/pages/post/2022/10/csapp-7.mdx"},{frontmatter:{title:y,date:new Date(1666077048e3),image:"/images/2022/10/use_vector_fp_converts-test-results.png",tags:["gcc","性能优化",a],lastUpdated:new Date(166625156e4),published:new Date(1666197777e3),visitor:85},href:"/post/2022/10/gcc-use_vector_fp_converts",filename:"src/pages/post/2022/10/gcc-use_vector_fp_converts.mdx"},{frontmatter:{title:C,date:new Date(1668736861e3),image:"/images/2022/11/csapp-8.png",tags:[e,n],lastUpdated:new Date(1671350958e3),published:new Date(1671258446e3),visitor:10},href:"/post/2022/11/csapp-8",filename:"src/pages/post/2022/11/csapp-8.mdx"},{frontmatter:{title:w,date:new Date(1669198242e3),image:"/images/2022/11/csapp-9.png",copyrightNotice:I,tags:[e,n],lastUpdated:new Date(167370575e4),published:new Date(1672037059e3),visitor:27},href:"/post/2022/11/csapp-9",filename:"src/pages/post/2022/11/csapp-9.mdx"},{frontmatter:{title:E,date:new Date(1668050758e3),image:"/images/2022/11/swim.jpg",tags:["游泳",s],lastUpdated:new Date(1668053703e3),published:new Date(1668053703e3),visitor:R},href:"/post/2022/11/pitfalls-of-breaststroke-breathing",filename:"src/pages/post/2022/11/pitfalls-of-breaststroke-breathing.mdx"},{frontmatter:{title:k,date:new Date(1670046303e3),image:"/images/2022/12/csapp-6.png",copyrightNotice:I,tags:[e,n],lastUpdated:new Date(1670226463e3),published:new Date(1670226463e3),visitor:j},href:"/post/2022/12/csapp-6",filename:"src/pages/post/2022/12/csapp-6.mdx"},{frontmatter:{title:S,date:new Date(1674304358e3),image:"/images/2023/01/ddpp-2.png",copyrightNotice:"本文包含若干截自 DDPP 的图片，本文作者对其不拥有版权。",tags:[o,n],lastUpdated:new Date(1674571032e3),published:new Date(1674571032e3),visitor:28},href:"/post/2023/01/ddpp-2",filename:"src/pages/post/2023/01/ddpp-2.mdx"},{frontmatter:{title:A,date:new Date(167461137e4),image:"/images/2023/01/ddpp-3.png",tags:[o,n],lastUpdated:new Date(1674978752e3),published:new Date(1674978752e3),visitor:31},href:"/post/2023/01/ddpp-3",filename:"src/pages/post/2023/01/ddpp-3.mdx"},{frontmatter:{title:P,date:new Date(167513277e4),copyrightNotice:"本文包含若干截自 DDPP 的图片，本文作者对它们不拥有版权。",image:"/images/2023/01/ddpp-4.png",tags:[o,n],lastUpdated:new Date(1675756712e3),published:new Date(1675756712e3),visitor:17},href:"/post/2023/01/ddpp-4",filename:"src/pages/post/2023/01/ddpp-4.mdx"},{frontmatter:{title:$,date:new Date(1673779818e3),image:"/images/2023/01/ddpp-cover.png",tags:[o,n],lastUpdated:new Date(1674297595e3),published:new Date(1673783362e3),visitor:58},href:"/post/2023/01/ddpp",filename:"src/pages/post/2023/01/ddpp.mdx"},{frontmatter:{title:D,date:new Date(1674119026e3),image:"/images/2023/01/glyph-segregator.png",tags:[N,u,"项目开发"],lastUpdated:new Date(1675319173e3),published:new Date(1674134105e3),visitor:j},href:"/post/2023/01/glyph-segregator",filename:"src/pages/post/2023/01/glyph-segregator.mdx"},{frontmatter:{title:L,date:new Date(1674981968e3),image:T,tags:[z,a],lastUpdated:new Date(1674994592e3),published:new Date(1674994592e3),visitor:32},href:"/post/2023/01/string-prototype-replace",filename:"src/pages/post/2023/01/string-prototype-replace.mdx"},{frontmatter:{title:_,date:new Date(1675942597e3),image:"/images/2023/02/css-is-awesome.jpeg",tags:[N,M,u,s],lastUpdated:new Date(1675994288e3),published:new Date(1675955985e3),visitor:18},href:"/post/2023/02/typography-tricks",filename:"src/pages/post/2023/02/typography-tricks.mdx"}]}}("学习笔记","csapp","csapp 学习笔记","问题解决记录","ddpp 学习笔记","Web","经验分享","ddpp","关于","Btrfs Quota 以及 Timeshift 导致的系统无响应问题解决过程记录",'display: none 与 loading="lazy"',"有关 THU 选课的一些常见问题与注意事项","使用 Caddy Security 时的 Uptime 监控","busuanzi 访问量统计与 live2d 插件同时使用导致 busuanzi 不显示的根本原因以及解决方法","初学 Rust","CS:APP 第二章学习笔记","CS:APP 第三章学习笔记","CS:APP 学习笔记系列 序","普物实验 TeX & R 急救指北","CS:APP 第四章学习笔记","CS:APP 第七章学习笔记","探究 gcc 浮点数精度转换所使用的指令 —— use_vector_fp_converts 优化","CS:APP 第八章学习笔记","CS:APP 第九章学习笔记","蛙泳换气踩坑记录","CS:APP 第六章学习笔记","DDPP 第二章学习笔记","DDPP 第三章学习笔记","DDPP 第四章学习笔记","DDPP 学习笔记系列 序","另一种很新的中文字体网页嵌入方案","String.prototype.replace 与隐藏的“$”","一些博客排版优化小 trick",null,"CSS","JavaScript",131,"本文包含若干截自 CS:APP 中的图片，本文作者对其不拥有版权。",84,"blog"),{});
</script></main><footer class="flex flex-col text-footer bg-card p-6 gap-1" itemprop="hasPart" itemscope="" itemtype="https://schema.org/WPFooter"><div class="flex flex-wrap justify-center gap-x-1"><span>Copyright ©</span><span title="最后更新于 2023-02-12 22:52:17 GMT+8 (f70ce56)">2022 - 2023</span><a class="flex items-center" href="/sponsor" title="赞赏支持"><span class="i-mdi-heart text-red dark:text-red-7"></span></a><span>ouuan</span></div><div class="flex flex-wrap justify-center items-center gap-x-1"><span>文章总大小 294 KiB</span><span class="i-mdi-circle-small"></span><span title="实际上，为了保护用户隐私，同一用户的多次访问只有在同一天内使用同一浏览器在同一ip下才会被算作同一人"> 共有 <ile-root id="ile-3"><span class="i-mdi-loading motion-safe:animate-spin" aria-label="加载中"></span></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.5e82acba.js";import"/assets/vendor-vue.075573a8.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.5e82acba.js").then(o=>o.v),["assets/iles.5e82acba.js","assets/vendor-vue.075573a8.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/VisitorCount.a8d4ae35.js"),["assets/VisitorCount.a8d4ae35.js","assets/VisitorCount.c343552a.js","assets/vendor-vue.075573a8.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-3",{},{})});export default E();
</script> 人到访过这里 </span></div><div class="flex justify-center items-center flex-wrap gap-x-1"> 基于 <a class="underline" href="https://github.com/ElMassimo/iles">îles</a> 及 <a class="underline" href="https://github.com/ouuan/iles-blog/blob/master/package.json">很多其他项目</a><span class="i-mdi-circle-small"></span><span>由 ouuan 设计/制作</span><span class="i-mdi-circle-small"></span><a class="underline" href="https://github.com/ouuan/iles-blog">源代码</a><span class="i-mdi-circle-small"></span><a class="underline" href="https://github.com/ouuan/iles-blog/discussions">Discussions</a></div></footer><meta itemprop="copyrightYear" content="2022 - 2023"><div class="hidden" itemscope="" itemtype="https://schema.org/Person" itemprop="copyrightHolder"><meta itemprop="additionalName" content="ouuan"><meta itemprop="givenName" content="Yufan"><meta itemprop="familyName" content="You"><meta itemprop="url" content="https://github.com/ouuan"><link itemprop="gender" href="https://schema.org/Male"><meta itemprop="image" content="/android-chrome-512x512.png"></div><ile-root id="ile-4"></ile-root><script></script><script type="module" async="">var p=(o,a)=>()=>(a||o((a={exports:{}}).exports,a),a.exports);var r=(o,a,_)=>new Promise((c,n)=>{var f=t=>{try{e(_.next(t))}catch(i){n(i)}},l=t=>{try{e(_.throw(t))}catch(i){n(i)}},e=t=>t.done?c(t.value):Promise.resolve(t.value).then(f,l);e((_=_.apply(o,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.5e82acba.js";import"/assets/vendor-vue.075573a8.js";var E=p(m=>{const u=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.5e82acba.js").then(o=>o.v),["assets/iles.5e82acba.js","assets/vendor-vue.075573a8.js","assets/vite.5ce4fca4.js"])).default}),v=()=>r(m,null,function*(){return(yield d(()=>import("/assets/BackToTop.9b4bb339.js"),["assets/BackToTop.9b4bb339.js","assets/vendor-vue.075573a8.js","assets/vite.5ce4fca4.js"])).default});s(u,v,"ile-4",{},{})});export default E();
</script><div class="hidden"></div><ile-root id="ile-5"></ile-root><script></script><script type="module" async="">import{h as o,b as r}from"/assets/iles.5e82acba.js";import{o as a}from"/assets/PlausibleTrigger.bafee336.js";import"/assets/vendor-vue.075573a8.js";import"/assets/vite.5ce4fca4.js";o(r,a,"ile-5",{},{});
</script><div></div><ile-root id="ile-6"></ile-root><script></script><script type="module" async="">var p=(t,a)=>()=>(a||t((a={exports:{}}).exports,a),a.exports);var r=(t,a,_)=>new Promise((c,n)=>{var f=o=>{try{e(_.next(o))}catch(i){n(i)}},l=o=>{try{e(_.throw(o))}catch(i){n(i)}},e=o=>o.done?c(o.value):Promise.resolve(o.value).then(f,l);e((_=_.apply(t,a)).next())});import{_ as d}from"/assets/vite.5ce4fca4.js";import{a as s}from"/assets/iles.5e82acba.js";import"/assets/vendor-vue.075573a8.js";var u=p(m=>{const E=()=>r(m,null,function*(){return(yield d(()=>import("/assets/iles.5e82acba.js").then(t=>t.e),["assets/iles.5e82acba.js","assets/vendor-vue.075573a8.js","assets/vite.5ce4fca4.js"])).default}),h=()=>r(m,null,function*(){return(yield d(()=>import("/assets/TextJustifyFix.4fa5e997.js"),[])).onLoad});s(E,h,"ile-6",{},{})});export default u();
</script><meta itemprop="inLanguage" content="zh-CN"></div>
  
</body></html>